{"version":3,"file":"static/js/410.975146e9.chunk.js","mappings":"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","sources":["math/algebra/functions/exp.js","math/algebra/functions/fraction.js","math/input-signals/signals.js","math/equation/index.js","math/algebra/functions/transfer.js","math/algebra/functions/trigonometric.js"],"sourcesContent":["import Algebra from \"math/algebra\";\nimport Complex from \"math/algebra//complex\";\nimport { Cos, Sin } from \"./trigonometric\";\n\nexport default class Exp extends Algebra {\n    constructor(a, b, symbol = \"t\", params = {}) {\n        // ae^bt\n        super(a, { symbol, type: \"exp\", b, ...params });\n    }\n\n    copy = (linkPrevious = false) =>\n        new Exp(this.a, this.b, this.symbol, {\n            dot: this.dot,\n            plus: this.plus,\n            previous: linkPrevious ? this.previous : null,\n            input: this.input\n        });\n\n    toSin = () => {\n        const exp = this.copy();\n        if (exp.type === \"exp\" && exp.b instanceof Complex) {\n            if (exp.b instanceof Complex && exp.b.real() === 0) {\n                const cos = new Cos(exp.a, exp.b.imaginary());\n                const sin = new Sin(exp.a, -exp.b.imaginary());\n                return new Complex(cos, sin);\n            }\n        }\n        return exp; // if doesnt math the condition then just return exponential function itself\n    };\n\n    valueAt = (t) => {\n        const a = Algebra.valueOf(this.a, t),\n            b = Algebra.valueOf(this.b, t);\n        return a * Math.exp(b * t);\n    }\n}\n","import Algebra from \"math/algebra\";\nimport Poly from \"./poly\";\n\nexport default class Fraction extends Algebra {\n    constructor(num, den = [1], symbol = \"t\", params = {}) {\n        // ke^ct\n        if (!(num instanceof Algebra)) {\n            if (!(num instanceof Array)) num = [num];\n            // this.a\n            else if (num.length === 0) num = [0];\n        }\n        if (!(den instanceof Algebra)) {\n            if (!(den instanceof Array)) den = [den];\n            // this.b\n            else if (den.length === 0) den = [1];\n        }\n        super(num, { symbol, type: \"frac\", b: den, ...params });\n    }\n\n    copy = (linkPrevious = false) =>\n        new Fraction(this.a, this.b, this.symbol, {\n            dot: this.dot,\n            plus: this.plus,\n            previous: linkPrevious ? this.previous : null,\n            input: this.input\n        });\n\n    lim = () => {\n        // for all fractions with all kind of numerator and denominator\n    }\n    \n    numerator = () => new Poly(this.a);\n    denominator = () => new Poly(this.b);\n\n    setNumerator = (num) => {\n        if (!(num instanceof Algebra)) {\n            if (!(num instanceof Array)) num = [num];\n            // this.a\n            else if (num.length === 0) num = [0];\n        }\n        return this.setA(num);\n    }\n\n    setDenominator = (den) => {\n        if (!(den instanceof Algebra)) {\n            if (!(den instanceof Array)) den = [den];\n            // this.b\n            else if (den.length === 0) den = [1];\n        }\n        return this.setB(den);\n    }\n    valueAt = (t) => {\n        const num = Algebra.valueOf(this.a, t);\n        const den = Algebra.valueOf(this.b, t);\n        return num / den;\n    }\n\n}\n","import StandardInputSignal from \"math/input-signals\";\nimport Poly from \"math/algebra/functions/poly\";\n\nexport class Step extends StandardInputSignal {\n    constructor(amplitude = 1, symbol = \"t\") {\n        super(amplitude, \"u\", symbol); // \\\\delta is the equivalent of small delta in mathjax\n    }\n    copy = () => new Step(this.amp, this.symbol);\n\n    $ = (t) => (t >= 0) * this.amp;\n}\n\nexport class Puls extends StandardInputSignal {\n    constructor(Delta = 1, amplitude = 1, symbol = \"t\") {\n        super(amplitude, \"\\\\sqcap\", symbol);\n        this.Delta = Delta;\n    }\n    copy = () => new Puls(this.Delta, this.amp, this.symbol);\n    $ = (t) => (t >= 0 && t <= this.Delta) * this.amp / this.Delta;\n}\n\nexport class Impact extends StandardInputSignal {\n    constructor(amplitude = 1, symbol = \"t\") {\n        super(amplitude, \"\\\\delta\", symbol); // \\\\delta is the equivalent of small delta in mathjax\n    }\n    copy = () => new Impact(this.amp, this.symbol);\n\n    $ = (t) => this.amp * (t === 0);\n}\n\nexport class Ramp extends Poly {\n    constructor(amplitude, symbol = \"t\") {\n        super([amplitude, 0], symbol);\n        this.amplitude = amplitude; // just for calculating the value of this\n        this.selfmultiply(Step());\n    }\n    copy = () => new Ramp(this.amplitude, this.symbol);\n\n    $ = (t) => (t >= 0) * t * this.amplitude;\n}\n\n\nexport class Parabolic extends Poly { //EDIT\n    constructor(amplitude, symbol = \"t\") {\n        super([amplitude, 0, 0], symbol);\n        this.amplitude = amplitude; // just for calculating the value of this\n        this.selfmultiply(Step());\n    }\n    copy = () => new Parabolic(this.amplitude, this.symbol);\n    $ = (t) => (t >= 0 ? t * this.amplitude : 0);\n}\n","import Algebra from \"../algebra/index\";\r\nimport { isDigit, precision, round } from \"math/calculus\";\r\nimport Complex from \"math/algebra/complex\";\r\nimport Poly from \"../algebra/functions/poly\";\r\nconst Algebrite = require(\"algebrite\");\r\n\r\nexport default class Equation {\r\n    static zeroPrecision = round(10 ** -precision.get());\r\n    constructor(exp, symbol = null) {\r\n        if (exp instanceof Poly) {\r\n            this.expression = exp.expression();\r\n            this.algebra = exp.copy();\r\n            this.symbol = exp.symbol;\r\n        } else if (exp instanceof Algebra) {\r\n            this.expression = exp.toString();\r\n            this.algebra = exp.copy();\r\n            this.symbol = this.exp.symbol;\r\n        } else if (typeof exp === \"string\") {\r\n            this.expression = exp;\r\n            this.algebra = null\r\n        }\r\n\r\n        this.symbol = symbol;\r\n    }\r\n\r\n    roots = () => {\r\n        // for factorable equations use: algebrite.roots\r\n        let x = Algebrite.nroots(this.expression)\r\n            .toString()\r\n            .replaceAll(\"...\", \"\");\r\n        x = x.slice(1, x.length - 1);\r\n        x = x.split(\",\").filter((xi) => xi && xi !== \"\"); // now x is converted from a string to the array of x answers (as Numbers);\r\n        // edit string to array\r\n        return x.map((xi, i) => {\r\n            // let [real, image] = xi.split(/\\+|-/).filter((xi) => xi && xi !== \"\");\r\n            let separatorIndex = 1;\r\n            for (; separatorIndex < xi.length; separatorIndex++)\r\n                if (\r\n                    (xi[separatorIndex] === \"+\" ||\r\n                        xi[separatorIndex] === \"-\") &&\r\n                    isDigit(xi[separatorIndex - 1]) &&\r\n                    isDigit(xi[separatorIndex + 1])\r\n                )\r\n                    break;\r\n\r\n            let terms = [];\r\n            terms.push(xi.slice(0, separatorIndex));\r\n            if (separatorIndex < xi.length)\r\n                terms.push(xi.slice(separatorIndex, xi.length - 2));\r\n\r\n            if (terms.length === 1) {\r\n                const magnitude = terms[0].replace(\"*i\");\r\n                return magnitude === terms[0]\r\n                    ? new Complex(Number(magnitude))\r\n                    : new Complex(0, Number(magnitude));\r\n            } else return new Complex(Number(terms[0]), Number(terms[1]));\r\n        });\r\n    };\r\n\r\n    AlgebraRoots = () => {\r\n        // convert roots returning string to\r\n        if (!this.roots || this.roots.length === 0) this.solve();\r\n    };\r\n\r\n    approximate = (\r\n        method = Equation.Methods.newton,\r\n        N = 10,\r\n        boundary = 1000\r\n    ) => {\r\n        const allRoots = [];\r\n        // newton reaches to approx fast\r\n        // so N = 10 is enough (?????)\r\n        const isUnique = (newRoot) =>\r\n            !isNaN(newRoot) &&\r\n            allRoots.findIndex((rt) =>\r\n                !(rt instanceof Complex) ? rt === newRoot : rt.equals(newRoot)\r\n            ) === -1;\r\n        const isUniqueComplex = (newRoot) =>\r\n            newRoot instanceof Complex &&\r\n            allRoots.findIndex((rt) => newRoot.equals(rt)) === -1;\r\n\r\n        if (this.expression instanceof Algebra) {\r\n            let a0 = 0;\r\n            for (let i = this.expression.a.length - 1; i >= 0; i--)\r\n                if (this.expression.a[i]) {\r\n                    a0 = this.expression.a[i];\r\n                    break;\r\n                }\r\n            const an = this.expression.a[0];\r\n\r\n            if (a0 && an !== 0) boundary = Math.abs(a0 / an);\r\n\r\n            for (let x0 = -boundary; x0 <= boundary; x0++) {\r\n                let x = method(this.algebra, x0, N);\r\n                if (!isNaN(x)) {\r\n                    const rx = round(x);\r\n                    if (isUnique(rx)) allRoots.push(rx);\r\n                }\r\n                x = method(this.algebra, new Complex(0, x0), N);\r\n                if (isUniqueComplex(x)) allRoots.push(x);\r\n            }\r\n        }\r\n        return allRoots;\r\n    };\r\n    // approximation methods\r\n    durandKerner = (N = 20) => {\r\n        if (this.algebra instanceof Algebra) {\r\n            const f = this.algebra.$;\r\n            const n = this.algebra.degree();\r\n            let guess;\r\n            do {\r\n                guess = new Complex(Math.random(), Math.random());\r\n            } while (guess.isReal());\r\n            const roots = Array(n)\r\n                .fill(0)\r\n                .map((_) => []);\r\n            \r\n            roots[0].push(new Complex(1, 0));\r\n            for (let i = 1; i < n; i++)\r\n                roots[i][0] = guess.multiply(roots[i - 1][0]);\r\n            for (let iter = 0; iter < N; iter++) {\r\n                for (let i = 0; i < n; i++) {\r\n                    const xiN = roots[i][iter].copy();\r\n                    let sndTermDen = new Complex(1, 0);\r\n                    for (let j = 0; j < n; j++) {\r\n                        if (i !== j) {\r\n                            const xjN = roots[j][roots[j].length - 1];\r\n                            sndTermDen = sndTermDen.multiply(\r\n                                xiN.substract(xjN)\r\n                            );\r\n                        }\r\n                    }\r\n                    let sndTerm = f(xiN).devide(sndTermDen);\r\n                    // USING PUSH MAY SLOW DOWN THE ALGORITHM\r\n                    roots[i].push(xiN.substract(sndTerm));\r\n                }\r\n            }\r\n            return roots.map((r) => r[r.length - 1]);\r\n        }\r\n    };\r\n\r\n    static Methods = {\r\n        // needs work!\r\n        newton: (algebraf, x0 = 0, N = 20) => {\r\n            const f = algebraf.$;\r\n            const df = algebraf.derivative().$;\r\n            const xs = Array(N + 1).fill(0);\r\n            const dfx0 = df(x0);\r\n            if (dfx0 && (!(dfx0 instanceof Complex) || !dfx0.isZero())) {\r\n                if (x0 instanceof Complex) {\r\n                    xs[0] = x0;\r\n                    for (let i = 0; i < N; i++) {\r\n                        // const dfxsi = df(xs[i]);\r\n                        // console.log(\"xs[i] = \", xs[i].toString(), \"=> f(x) = \", f(xs[i]).toString(), \"=> df =\", dfxsi.toString(), \"res = \", f(xs[i]).devide(df(xs[i])))\r\n                        xs[i + 1] = xs[i].substract(f(xs[i]).devide(df(xs[i])));\r\n                    }\r\n\r\n                    const fx = f(xs[N]);\r\n                    if (\r\n                        Math.abs(fx.real()) > Equation.zeroPrecision ||\r\n                        Math.abs(fx.imaginary()) > Equation.zeroPrecision\r\n                    )\r\n                        return NaN;\r\n                } else {\r\n                    xs[0] = x0;\r\n\r\n                    for (let i = 0; i < N; i++) {\r\n                        xs[i + 1] = xs[i] - f(xs[i]) / df(xs[i]);\r\n                    }\r\n\r\n                    if (f(xs[N]) > Equation.zeroPrecision) return NaN;\r\n                }\r\n                //integrity check!\r\n                return xs[xs.length - 1];\r\n            }\r\n            return NaN;\r\n        },\r\n        // needs work!\r\n        middlePoint: (\r\n            f,\r\n            boundary = 1000\r\n            // decimalPrecision = precision.get()\r\n        ) => {\r\n            // NOTE: works fine for some equations\r\n            // and wronge for some others like:  x ** 2 - 4*x  - 5\r\n            boundary = Math.abs(boundary);\r\n            const expectedRate = Equation.zeroPrecision;\r\n            const poles = [];\r\n            let xa = 0,\r\n                xb = 1;\r\n            for (let i = 0; i < boundary; i++) {\r\n                xa = -boundary + i;\r\n                xb = boundary - i;\r\n\r\n                let rate =\r\n                    (xb - xa) / (2 * Math.max(Math.abs(xa), Math.abs(xb)));\r\n                let p = null;\r\n                while (rate >= expectedRate) {\r\n                    p = (xa + xb) / 2;\r\n                    if (!f(p)) break;\r\n                    else if (f(p) * f(xa) < 0) xb = p;\r\n                    else {\r\n                        xa = p;\r\n                        rate =\r\n                            (xb - xa) /\r\n                            (2 * Math.max(Math.abs(xa), Math.abs(xb)));\r\n                    }\r\n                }\r\n                if (!f(p)) poles.push(round(p));\r\n            }\r\n            return new Set(poles);\r\n        },\r\n    };\r\n}\r\n","import Algebra from \"../index\";\nimport Complex from \"../complex\";\nimport Exp from \"./exp\";\nimport Fraction from \"./fraction\";\nimport { Step } from \"math/input-signals/signals\";\nimport Poly from \"./poly\";\nimport { Cos, Sin } from \"./trigonometric\";\nimport { round } from \"math/calculus/index\";\nimport Equation from \"math/equation\";\n\nexport default class TransferFunction extends Fraction {\n    static Specials = {\n        $1: (k, a) =>\n            new TransferFunction([k], [1, -a]).setRoots([], [a]).setOrder(1),\n        $2: (k, a, b = a instanceof Complex ? a.conjugate : a) => {\n            // k / (s + a)(s + b) => must be converted to => k / (s2 + 2(a+b)s + ab)\n            let aplusb =\n                a instanceof Algebra\n                    ? a.add(b)\n                    : b instanceof Algebra\n                    ? b.add(a)\n                    : b + a;\n            let ab =\n                a instanceof Algebra\n                    ? a.multiply(b)\n                    : b instanceof Algebra\n                    ? b.multiply(a)\n                    : b * a;\n            if (aplusb instanceof Complex && aplusb.isReal())\n                aplusb = aplusb.real();\n            if (ab instanceof Complex && ab.isReal()) ab = ab.real();\n\n            return new TransferFunction(\n                [k],\n                [1, aplusb instanceof Algebra ? aplusb.negation() : -aplusb, ab]\n            )\n                .setRoots([], [a, b])\n                .setOrder(2);\n        },\n        $WnZ: (w_n, zeta) => new TransferFunction(null, null, { w_n, zeta }),\n        $design: (t_rise, overshoot) =>\n            new TransferFunction(null, null, { overshoot, t_rise }),\n    };\n\n    static omegaZetaPoles = (w_n, zeta) => {\n        if (Math.abs(zeta) >= 1) {\n            const alpha = -zeta * w_n;\n            const beta = w_n * (zeta * zeta - 1) ** 0.5;\n            return [alpha + beta, alpha - beta];\n        }\n        const alpha = -zeta * w_n;\n        const beta = w_n * (1 - zeta * zeta) ** 0.5;\n        return [new Complex(alpha, beta), new Complex(alpha, -beta)];\n    };\n    constructor(numerator, denominator, params = {}) {\n        let zeros = [],\n            poles = [];\n        if (params) {\n            if (params.overshoot && params.t_rise) {\n                params.overshoot = Number(params.overshoot);\n                params.t_rise = Number(params.t_rise);\n                const logMp = Math.log(params.overshoot);\n                params.zeta =\n                    -logMp / (Math.PI * Math.PI + logMp * logMp) ** 0.5;\n                params.w_d = Math.PI / params.t_rise;\n                params.w_n =\n                    params.w_d / (1 - params.zeta * params.zeta) ** 0.5;\n            }\n\n            if (params.w_n) {\n                params.w_n = Number(params.w_n);\n                params.zeta = Number(params.zeta);\n                // if the user sends w_n params it will override the given zero/pole list\n                const { w_n, zeta } = params;\n                const wn2 = w_n * w_n;\n                numerator = wn2;\n                denominator = [1, 2 * zeta * w_n, wn2];\n                poles = TransferFunction.omegaZetaPoles(w_n, zeta);\n                zeros = [];\n            }\n        }\n        super(numerator, denominator, \"s\", params);\n        // SIMPL;IFY\n        this.poles = [...poles]; //edit solve equations\n        this.zeros = [...zeros];\n        if (!this.a instanceof Array) this.a = [this.a];\n        if (this.a.length === 1 && !this.w_n) {\n            if (\n                this.b.length === 3 &&\n                this.b[this.b.length - 1] === this.a[0]\n            ) {\n                this.w_n = this.a[0];\n                this.zeta = this.b[1] / (2 * this.w_n);\n                this.timeConstant = round(1 / (this.zeta * this.w_n));\n                this.t_settle = 4 * this.timeConstant;\n                if (params && params.w_d) this.w_d = params.w_d;\n                else if (this.zeta >= -1 && this.zeta <= 1)\n                    this.w_d = this.w_n * (1 - this.zeta ** 2) ** 0.5;\n                this.order = 2;\n                this.setRoots(\n                    [],\n                    TransferFunction.omegaZetaPoles(this.w_n, this.zeta)\n                );\n            }\n        }\n        if (!this.order)\n            this.order =\n                denominator instanceof Array ? denominator.length - 1 : 1;\n        if (params.overshoot && params.t_rise) {\n            [this.overshoot, this.t_rise] = [params.overshoot, params.t_rise];\n        } else {\n            const dampingCharasteristics =\n                this.getDampingSystemCharasteristics();\n            if (dampingCharasteristics) {\n                this.overshoot = dampingCharasteristics.overshoot;\n                this.t_rise = dampingCharasteristics.t_rise;\n            }\n        }\n    }\n    static sortRoots = (rt) =>\n        rt.sort((ri, rj) =>\n            ri instanceof Algebra\n                ? ri.substract(rj)\n                : rj instanceof Algebra\n                ? rj.substract(ri)\n                : Math.abs(ri) - Math.abs(rj)\n        );\n    roots = () => [this.zeros, this.poles];\n    setRoots = (zeros, poles) => {\n        this.poles = poles.map((pi) =>\n            pi instanceof Complex && pi.isReal() ? pi.real() : pi\n        );\n        this.zeros = zeros.map((zi) =>\n            zi instanceof Complex && zi.isReal() ? zi.real() : zi\n        );\n        return this;\n    };\n\n    getDampingSystemCharasteristics = () =>\n        this.w_d\n            ? {\n                  t_rise: round(Math.PI / this.w_d),\n                  // WHAT IF W_D === 0?\n                  overshoot:\n                      this.zeta >= -1 && this.zeta <= 1\n                          ? round(\n                                100 *\n                                    Math.exp(\n                                        -(this.zeta * Math.PI) /\n                                            (1 - this.zeta ** 2) ** 0.5\n                                    )\n                            )\n                          : null,\n              }\n            : null;\n\n    getOrder = () => this.order;\n    setOrder = (order) => {\n        this.order = order;\n        return this;\n    };\n    getPoles = () => this.poles;\n    setPoles = (poles) => {\n        this.poles = TransferFunction.sortRoots(poles).map((pi) =>\n            pi instanceof Complex && pi.isReal() ? pi.real() : pi\n        );\n        return this;\n    };\n    getZeros = () => this.zeros;\n    setZeros = (zeros) => {\n        this.zeros = zeros.map((pi) =>\n            pi instanceof Complex && pi.isReal() ? pi.real() : pi\n        );\n        return this;\n    };\n\n    poleOrder = (pole) =>\n        this.poles.filter((pi) => Algebra.areTheseTwoEqual(pole, pi)).length;\n\n    laplace = () => this.copy(); // actually it has no laplace, this is for disfunctioning the laplace method in the parent class Algebra\n    laplaceInverse = () => {\n        const m = this.zeros.length - 1; // number of zeros\n        const n = this.poles.length - 1; // number of poles\n\n        if (m === 0) {\n            switch (n) {\n                case 2:\n                    return null;\n                case 1:\n                    return new Algebra(1, { type: \"exp\" }); //EDITTTTTTTTTTTTTTTT\n                case 0:\n                    return null; //u(t)\n                default:\n                    return null; //DEFINE AN UNKNOWN FUNCTION FOR CASE LIKE THIS\n            }\n        }\n    };\n    step = (inTimeDomain = true) => {\n        // normally will automatically return the time domain answer\n        // unless inLaplaceDomain is true\n        if (inTimeDomain) {\n            const m = this.zeros.length; // number of zeros\n            const n = this.poles.length; // number of poles\n            const nreal = this.poles.filter(\n                (pi) => !(pi instanceof Complex)\n            ).length; // number of real poles; can be eigher 2 or 0\n            if (m === 0) {\n                const k = this.numerator();\n                if (n === 0) {\n                    // return u(t)\n                    // DEFINE U(T) IN ALGEBRA\n                }\n                if (n === 1) {\n                } else if (n === 2) {\n                    const a = -this.poles[0],\n                        b = -this.poles[1];\n                    if (nreal === 2) {\n                        // if (a > 0 && b > 0) {\n                        if (a !== b)\n                            // two independent polesdddd\n                            // two negative independent poles\n                            return new Exp(1 / a, -a)\n                                .add(new Exp(-1 / b, -b))\n                                .multiply(k / (a - b))\n                                .multiply(new Step())\n                                .add(new Step(k / (a * b)));\n                        else {\n                            const a2 = a * a;\n                            return new Exp(-k / a2, -a)\n                                .multiply(new Poly([a, 1]))\n                                .multiply(new Step())\n                                .add(new Step(k / a2));\n                        }\n                        // } else {\n                        //     // repetetive poles\n                        // }\n                    } else if (nreal === 0) {\n                        // two conjugated complex poles\n                        //UNDERSHOOT BUG FIXLAYS HERE\n                        const a = -this.poles[0].real(),\n                            b = this.poles[0].imaginary();\n                        const ka2b2 = k / (a ** 2 + b ** 2);\n                        // FIND BUUUUUUG\n                        // return new Exp(-ka2b2, -a)\n                        //     .multiply(new Cos(1, b).add(new Sin(a / b, b)))\n                        //     .multiply(new Step())\n                        //     .add(new Step(ka2b2));\n                        return new Exp(-ka2b2, -a)\n                            .multiply(new Cos(1, b))\n                            .add(\n                                new Exp(-ka2b2, -a).multiply(new Sin(a / b, b))\n                            )\n                            .multiply(new Step())\n                            .add(new Step(ka2b2));\n                    }\n                    // else if( nreal == 1) // this cant happen, but what if sth went wrong?\n                }\n            }\n        } else {\n            const lstep = this.copy();\n            const poles = lstep.getPoles();\n            poles.push(0);\n            lstep.getB().push(0); //update denominator\n            lstep.setPoles(poles).setDenominator(lstep.getB());\n            return lstep;\n        }\n    };\n    copy = (linkPrevious = false) =>\n        new TransferFunction(this.a, this.b, {\n            overshoot: this.overshoot,\n            t_rise: this.t_rise,\n            t_settle: this.t_settle,\n            w_d: this.w_d,\n            timeConstant: this.timeConstant,\n            w_n: this.w_n,\n            zeta: this.zeta,\n            dot: this.dot,\n            plus: this.plus,\n            previous: linkPrevious ? this.previous : null,\n            input: this.input,\n        }).setRoots(this.zeros, this.poles);\n\n    lim = (s0) => {\n        let num, den;\n        // for simple polynomial numerator and denominator fractions\n        // IMPLEMENT HOPITAL AS WELL?\n        if (!s0) {\n            // s -> 0)\n\n            num = { a: 0, sp: this.a.length - 1 };\n            den = { b: 1, sp: this.b.length - 1 };\n            for (; num.sp > 0 && this.a[num.sp] === 0; num.sp--);\n            num.a = this.a[num.sp];\n            for (; den.sp > 0 && this.b[den.sp] === 0; den.sp--);\n            den.b = this.b[den.sp];\n            num.sp = this.a.length - num.sp - 1;\n            den.sp = this.b.length - den.sp - 1;\n            if (num.sp === den.sp) return num.a / den.b;\n            else {\n                const sMinPower = Math.min(den.sp, num.sp);\n                if (sMinPower) {\n                    num.sp -= sMinPower;\n                    den.sp -= sMinPower;\n                }\n                // now one of num.sp or den.sp is zero\n                if (den.sp)\n                    // zero on denominator\n                    return Infinity;\n                // if den.sp == 0 and num.sp != 0\n                return 0;\n            }\n        } else if (s0 === Infinity) {\n            // s -> infinity\n            num = { a: 0, sp: 0 };\n            den = { b: 1, sp: 0 };\n            for (; num.sp < this.a.length && this.a[num.sp] === 0; num.sp++);\n            num.a = this.a[num.sp];\n            for (; den.sp < this.b.length && this.b[den.sp] === 0; den.sp++);\n            den.b = this.b[den.sp];\n            num.sp = this.a.length - num.sp - 1;\n            den.sp = this.b.length - den.sp - 1;\n            if (num.sp === den.sp) return num.a / den.b;\n            // else\n            const sMinPower = Math.min(den.sp, num.sp);\n            if (sMinPower) {\n                num.sp -= sMinPower;\n                den.sp -= sMinPower;\n            }\n            // now one of num.sp or den.sp is zero\n            if (den.sp)\n                // zero on denominator\n                return 0;\n            // if den.sp == 0 and num.sp != 0\n            return Infinity;\n        } else {\n            // if s0 is just a no-zero limited number\n            num = this.numerator().$(s0);\n            den = this.denominator().$(s0);\n            if (den)\n                // simple non zero denominator limit\n                return num / den;\n            // if den == 0\n            // use Hopital or other limit methods\n            //return (num.a * (s0 ** num.sp)) / (den.b * (s0 ** den.sp));\n        }\n    };\n    errors = () => {\n        const sGs = this.multiply(new Poly([1, 0], \"s\"));\n        const s2Gs = sGs.multiply(new Poly([1, 0], \"s\"));\n        console.log(sGs);\n        return {\n            Ks: round(this.lim(0)),\n            Kr: round(sGs.lim(0)),\n            Ka: round(s2Gs.lim(0)),\n        };\n    };\n    $ = (t) => this.laplaceInverse().$(t); // valueOf function in certain point; I used character $ in many places as,\n    // acronym for \"set\" in setters, so $ here means that set the t ( or x or whatever) with a certain point\n\n    rootLocus = (k_min, k_max, N = 100) => {\n        // return root locus values for plotting\n        /* let dk = (k_max - k_min) / N; //time step size\n        while (dk >= 1) {\n            N *= 10;\n            dk = (k_max - k_min) / N; //time step size\n        }*/\n        // TEMPORARY:\n        let dk = 1;\n        const a = this.getA(), // numerator\n            b = this.getB(); // denominator => a / b\n        const na = a.length,\n            nb = b.length;\n        const reals = [],\n            imaginaries = [];\n        for (let k = k_min; k <= k_max; k += dk) {\n            // in this piece: using short form codes and using objects is set to minimum\n            // because root locus is time consuming and putting all the codes in one main loop is better\n            // const delta = b.add(a.multiply(k));\n            let delta = null;\n            // USE ARRAY DIRECT PROCESS FOR FASTER RESPONSE\n            // NUM + K * DEN\n            let expression = \"\";\n            if (na <= nb) {\n                delta = Array(nb);\n                const offsetB = nb - na;\n                for (\n                    let i = 0;\n                    i < offsetB;\n                    delta[i] = b[i],\n                        expression +=\n                            (delta[i] >= 0 ? \"+\" : \"\") +\n                            `${delta[i]}x^${nb - i - 1}`,\n                        i++\n                );\n                for (\n                    let i = 0, ib = offsetB;\n                    i < na;\n                    delta[ib] = b[ib] + k * a[i],\n                        expression +=\n                            (delta[ib] >= 0 ? \"+\" : \"\") +\n                            `${delta[ib]}x^${na - i - 1}`,\n                        i++,\n                        ib++\n                );\n            } else {\n                delta = Array(na);\n                const offsetA = na - nb;\n                for (\n                    let i = 0;\n                    i < offsetA;\n                    delta[i] = b[i],\n                        expression +=\n                            (delta[i] >= 0 ? \"+\" : \"\") +\n                            `${delta[i]}x^${na - i - 1}`,\n                        i++\n                );\n                for (\n                    let i = 0, ib = offsetA;\n                    i < nb;\n                    delta[ib] = b[ib] + k * a[i],\n                        expression +=\n                            (delta[ib] >= 0 ? \"+\" : \"\") +\n                            `${delta[ib]}x^${nb - i - 1}`,\n                        i++,\n                        ib++\n                );\n            }\n            // const roots = new Equation(new Poly(delta)).roots();\n            const roots = new Equation(expression).roots();\n            for (const root of roots) {\n                if (root instanceof Complex) {\n                    reals.push(root.real());\n                    imaginaries.push(root.imaginary());\n                } else {\n                    reals.push(root);\n                    imaginaries.push(0);\n                }\n            }\n        }\n        return [reals, imaginaries];\n    };\n}\n","import Algebra from \"math/algebra\";\nimport Complex from \"math/algebra/complex\";\nimport Exp from \"./exp\";\nimport Fraction from \"./fraction\";\n\nexport class Sin extends Algebra {\n    constructor(A, w, teta = 0, symbol = \"t\", params = {}) {\n        // Ae^wt\n        super(A, { symbol, type: \"sin\", b: w, teta, ...params });\n    }\n    copy = (linkPrevious = false) =>\n        new Sin(this.a, this.b, this.teta, this.symbol, {\n            dot: this.dot,\n            plus: this.plus,\n            previous: linkPrevious ? this.previous : null,\n            input: this.input,\n        });\n\n    toExp = () => {\n        const sin = this.copy();\n        const exp1 = new Exp(sin.a / 2, new Complex(0, -sin.b));\n        const exp2 = new Exp(-sin.a / 2, new Complex(0, sin.b));\n        return new Complex(0, exp1.add(exp2));\n    };\n\n    valueAt = (t) => {\n        const A = Algebra.valueOf(this.a, t);\n        const w = Algebra.valueOf(this.b, t);\n        const teta = Algebra.valueOf(this.teta, t);\n        return A * Math.sin(w * t + teta)\n    }\n}\n\nexport class Cos extends Algebra {\n    constructor(A, w, teta = 0, symbol = \"t\", params = {}) {\n        // Ae^wt\n        super(A, { symbol, type: \"cos\", b: w, teta, ...params });\n    }\n    copy = (linkPrevious = false) =>\n        new Cos(this.a, this.b, this.teta, this.symbol, {\n            dot: this.dot,\n            plus: this.plus,\n            previous: linkPrevious ? this.previous : null,\n            input: this.input,\n        });\n\n    toExp = () => {\n        const cos = this.copy();\n        const exp1 = new Exp(cos.a / 2, new Complex(0, cos.b));\n        const exp2 = new Exp(cos.a / 2, new Complex(0, -cos.b));\n        return exp1.add(exp2);\n    };\n\n\n    valueAt = (t) => {\n        const A = Algebra.valueOf(this.a, t);\n        const w = Algebra.valueOf(this.b, t);\n        const teta = Algebra.valueOf(this.teta, t);\n        return A * Math.cos(w * t + teta)\n    }\n}\n\nexport class Tan extends Algebra {\n    constructor(A, w, teta = 0, symbol = \"t\", params = {}) {\n        // Ae^wt\n        super(A, { symbol, type: \"tan\", b: w, teta, ...params });\n    }\n    copy = (linkPrevious = false) =>\n        new Tan(this.a, this.b, this.teta, this.symbol, {\n            dot: this.dot,\n            plus: this.plus,\n            previous: linkPrevious ? this.previous : null,\n            input: this.input,\n        });\n\n    toExp = () => {\n        const tan = this.copy();\n        const exp1 = new Exp(1, new Complex(0, -tan.b));\n        const numeratorExp2 = new Exp(-1, new Complex(0, tan.b));\n        const denominatorExp2 = new Exp(1, new Complex(0, tan.b));\n        return new Fraction(exp1.add(numeratorExp2), exp1.add(denominatorExp2));\n    };\n\n    valueAt = (t) => {\n        const A = Algebra.valueOf(this.a, t);\n        const w = Algebra.valueOf(this.b, t);\n        const teta = Algebra.valueOf(this.teta, t);\n        return A * Math.tan(w * t + teta)\n    }\n}\n\nexport class Cot extends Algebra {\n    constructor(A, w, teta = 0, symbol = \"t\", params = {}) {\n        // Ae^wt\n        super(A, { symbol, type: \"cot\", b: w, teta, ...params });\n    }\n    copy = (linkPrevious = false) =>\n        new Cot(this.a, this.b, this.teta, this.symbol, {\n            dot: this.dot,\n            plus: this.plus,\n            previous: linkPrevious ? this.previous : null,\n            input: this.input,\n        });\n    toExp = () => {\n        const cot = this.copy();\n        const exp1 = new Exp(1, new Complex(0, -cot.b));\n        const numeratorExp2 = new Exp(-1, new Complex(0, cot.b));\n        const denominatorExp2 = new Exp(1, new Complex(0, cot.b));\n        return new Fraction(exp1.add(denominatorExp2), exp1.add(numeratorExp2));\n    };\n\n\n    valueAt = (t) => {\n        const A = Algebra.valueOf(this.a, t);\n        const w = Algebra.valueOf(this.b, t);\n        const teta = Algebra.valueOf(this.teta, t);\n        return A * Math.cot(w * t + teta)\n    }\n}\n"],"names":["Exp","a","b","symbol","params","type","copy","linkPrevious","dot","plus","previous","input","toSin","exp","Complex","real","cos","Cos","imaginary","sin","Sin","valueAt","t","Algebra","Math","Fraction","num","den","Array","length","lim","numerator","Poly","denominator","setNumerator","setA","setDenominator","setB","Step","amplitude","amp","$","StandardInputSignal","Algebrite","require","Equation","roots","x","nroots","expression","toString","replaceAll","slice","split","filter","xi","map","i","separatorIndex","isDigit","terms","push","magnitude","replace","Number","AlgebraRoots","solve","approximate","method","Methods","newton","N","boundary","allRoots","isUnique","newRoot","isNaN","findIndex","rt","equals","isUniqueComplex","a0","an","abs","x0","algebra","rx","round","durandKerner","guess","f","n","degree","random","isReal","fill","_","multiply","iter","xiN","sndTermDen","j","xjN","substract","sndTerm","devide","r","this","zeroPrecision","precision","algebraf","df","derivative","xs","dfx0","isZero","fx","NaN","middlePoint","expectedRate","poles","xa","xb","rate","max","p","Set","TransferFunction","zeros","overshoot","t_rise","logMp","log","zeta","PI","w_d","w_n","wn2","omegaZetaPoles","setRoots","pi","zi","getDampingSystemCharasteristics","getOrder","order","setOrder","getPoles","setPoles","sortRoots","getZeros","setZeros","poleOrder","pole","laplace","laplaceInverse","m","step","inTimeDomain","lstep","getB","nreal","k","add","a2","ka2b2","t_settle","timeConstant","s0","sp","sMinPower","min","Infinity","errors","sGs","s2Gs","console","Ks","Kr","Ka","rootLocus","k_min","k_max","dk","getA","na","nb","reals","imaginaries","delta","offsetB","ib","offsetA","root","dampingCharasteristics","Specials","$1","$2","conjugate","aplusb","ab","negation","$WnZ","$design","alpha","beta","sort","ri","rj","A","w","teta","toExp","exp1","exp2"],"sourceRoot":""}