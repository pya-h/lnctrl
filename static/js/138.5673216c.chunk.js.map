{"version":3,"file":"static/js/138.5673216c.chunk.js","mappings":"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","sources":["math/algebra/complex.js","math/algebra/functions/poly.js","errors/algebra/NotScalarError.js","math/algebra/index.js","math/input-signals/index.js"],"sourcesContent":["import Algebra from \".\";\nimport { round, isDigit } from \"../calculus\";\n\nclass Complex extends Algebra {\n    constructor(preal, pimage = 0, params = {}) {\n        super(preal, { symbol: \"j\", type: \"complex\", b: pimage, ...params });\n    }\n\n    hasMultiTerms = () =>\n        this.plus || (this.a.toString() !== \"0\" && this.b.toString() !== \"0\");\n\n    toString = (parenthesis = false) => {\n        if(this.isZero())\n            return \"0\";\n        const rl = this.a;\n        let formula = parenthesis && this.hasMultiTerms() ? \"(\" : \"\";\n        if (rl !== 0)\n            formula +=\n                rl instanceof Algebra\n                    ? rl.toString(rl.hasMultiTerms())\n                    : round(rl);\n        let im = this.b;\n        if (im !== 0) {\n            //if (im < 0 || (im instanceof Algebra)) { im = im.negation()\n            if (im < 0) {\n                im *= -1;\n                formula += \" - \";\n            } else if (rl !== 0) formula += \" + \";\n\n            formula += this.symbol;\n            if (im !== 1)\n                formula +=\n                    im instanceof Algebra\n                        ? im.toString(im.hasMultiTerms())\n                        : round(im);\n        }\n        if (this.plus) formula += this.join(); // if there's a next term: casscade toString() calls\n\n        return parenthesis ? formula + \")\" : formula;\n    }; // a + jb\n\n    real = () => this.a;\n    imaginary = () => this.b;\n\n    copy = (linkPrevious = false) =>\n        new Complex(this.a, this.b, {\n            dot: this.dot,\n            plus: this.plus,\n            previous: linkPrevious ? this.previous : null,\n            input: this.input,\n        });\n\n    conjugate = () =>\n        new Complex(\n            this.a,\n            this.b instanceof Algebra ? this.b.negation() : -this.b\n        );\n\n    negation = () =>\n        new Complex(\n            this.a instanceof Algebra ? this.a.negation() : -this.a,\n            this.b instanceof Algebra ? this.b.negation() : -this.b\n        );\n\n    magnitude$2 = () => this.a ** 2 + this.b ** 2;\n\n    magnitude = () => (this.a ** 2 + this.b ** 2) ** 0.5;\n\n    isReal = () => this.b === 0;\n\n    hasSameTypeWith = (x) =>\n        (this.isReal() && x.isReal()) || (!this.isReal() && !x.isReal()); // both full imaginray or both real\n    realify = () => new Complex(this.a, 0); // return a simple real value in Complex object format (for methods that only accept Complex values)\n\n    add = (operand) => {\n        let Re = null,\n            Im = null;\n        if (operand instanceof Complex) {\n            if (this.a instanceof Algebra) Re = this.a.add(operand.real());\n            else if (operand.real() instanceof Algebra)\n                Re = operand.real().add(this.a);\n            else Re = this.a + operand.real();\n\n            if (this.b instanceof Algebra) Im = this.b.add(operand.imaginary());\n            else if (operand.imaginary() instanceof Algebra)\n                Im = operand.imaginary().add(this.b);\n            else Im = this.b + operand.imaginary();\n        } else {\n            if (this.a instanceof Algebra) Re = this.a.add(operand);\n            else if (operand instanceof Algebra) Re = operand.add(this.a);\n            else Re = this.a + operand;\n\n            Im = this.b;\n        }\n        return new Complex(Re, Im);\n    };\n\n    substract = (operand) => this.add(operand.negation());\n\n    equals = (operand) => {\n        if (operand instanceof Complex) {\n            // two complex number are equal to eachother if both thier real parts are the same, and their imaginary parts are the same\n            let realPartsEqual = false;\n            if (this.a instanceof Algebra)\n                realPartsEqual = this.a.equals(operand.real());\n            else if (operand.real() instanceof Algebra)\n                realPartsEqual = operand.real().equals(this.a);\n            else realPartsEqual = this.a === operand.real();\n            if (!realPartsEqual) return false;\n\n            if (this.b instanceof Algebra)\n                return this.b.equals(operand.imaginary());\n            else if (operand.imaginary() instanceof Algebra)\n                return operand.imaginary().equals(this.b);\n            return this.b === operand.imaginary();\n        }\n\n        // if operand is not a complex number then the only way it can be equal with this object of Complex,\n        // is for this object to have a zero imaginary part:\n        return (\n            this.isReal() &&\n            (operand instanceof Algebra\n                ? operand.equals(this.a)\n                : operand === this.a)\n        );\n    };\n\n    isConjugateWith = (operand) => this.conjugate().equals(operand);\n    multiply = (operand) => {\n        let Re = [],\n            Im = [];\n        if (operand instanceof Complex) {\n            // first term\n            if (this.a instanceof Algebra) {\n                Re.push(this.a.multiply(operand.real()));\n                Im.push(this.a.multiply(operand.imaginary()));\n            } else {\n                Re.push(\n                    operand.a instanceof Algebra\n                        ? operand.a.multiply(this.a)\n                        : operand.a * this.a\n                );\n\n                Im.push(\n                    operand.b instanceof Algebra\n                        ? operand.b.multiply(this.a)\n                        : this.a * operand.b\n                );\n            }\n\n            // second term\n            if (this.b instanceof Algebra) {\n                Re.push(this.b.multiply(operand.imaginary()));\n                Im.push(this.b.multiply(operand.real()));\n            } else {\n                Re.push(\n                    operand.b instanceof Algebra\n                        ? operand.b.multiply(this.b)\n                        : operand.b * this.b\n                );\n\n                Im.push(\n                    operand.a instanceof Algebra\n                        ? operand.a.multiply(this.b)\n                        : this.b * operand.a\n                );\n            }\n            return new Complex(Re[0] - Re[1], Im[0] + Im[1]);\n        } else {\n            Re =\n                this.a instanceof Algebra\n                    ? this.a.multiply(operand)\n                    : operand instanceof Algebra\n                    ? operand.multiply(this.a)\n                    : this.a * operand;\n\n            Im =\n                this.b instanceof Algebra\n                    ? this.b.multiply(operand)\n                    : operand instanceof Algebra\n                    ? operand.multiply(this.b)\n                    : this.b * operand;\n        \n            }\n        return new Complex(Re, Im);\n    };\n\n    devide = (denominator) => {\n        if (denominator instanceof Complex) {\n            const result =  this.multiply(denominator.conjugate()).devide(\n                denominator.magnitude$2()\n                );\n            // CHECK THIS\n            if(isNaN(result.real()))\n                result.setA(0);\n            if(isNaN(result.imaginary()))\n                result.setB(0);\n            return result;\n        } else if (denominator instanceof Algebra) {\n            // USE super().devide ?\n            return this.copy(); // for now to avoid craches\n        } else return this.multiply(1 / denominator); // number\n    };\n\n    raiseTo = (power) => {\n        let result = this.copy(true);\n        // for now power must be integr\n        if (Math.floor(power) === power)\n            for (let i = 1; i < power; i++) {\n                result = result.multiply(this);\n            }\n\n        return result;\n    };\n\n    devideInverse = (k) =>\n        (k instanceof Algebra ? k : new Complex(k, 0)).devide(this);\n\n    static extract = (strNumber) => {\n        // extract a string to a complex object\n\n        strNumber = strNumber.replace(/\\s/g, \"\");\n        let i = strNumber[0] === \"-\" || strNumber[0] === \"+\" ? 1 : 0;\n        let real = 0;\n        if (strNumber[i] !== \"j\") {\n            for (; i < strNumber.length && isDigit(strNumber[i]); i++);\n            real = Number(strNumber.slice(0, i) || 0);\n        }\n\n        let sign = 1;\n        for (\n            ;\n            i < strNumber.length &&\n            (strNumber[i] === \"j\" ||\n                strNumber[i] === \"+\" ||\n                strNumber[i] === \"-\");\n            i++\n        )\n            if (strNumber[i] === \"-\") sign = -1;\n\n        const img = Number(strNumber.slice(i, strNumber.length) || 0);\n        return new Complex(real, sign * img);\n    };\n\n    isZero = () => this.a === 0 && this.b === 0;\n}\n\nexport default Complex;\n","import Algebra from \"math/algebra\";\nimport Complex from \"../complex\";\n\nexport default class Poly extends Algebra {\n    static atn = (a, n, symbol = \"t\") => {\n        const aArray = Array(n + 1).fill(0);\n        aArray[0] = a;\n        return new Poly(aArray, symbol);\n    };\n    constructor(a, symbol = \"t\", params = {}) {\n        // ke^ct\n        super(a, { symbol, type: \"poly\", ...params });\n    }\n\n    copy = (linkPrevious = false) =>\n        new Poly(this.a, this.symbol, {\n            dot: this.dot,\n            plus: this.plus,\n            previous: linkPrevious ? this.previous : null,\n            input: this.input,\n        });\n\n    degree = () => this.a.length - 1;\n    \n    valueAt = (t) => {\n        if (typeof t === \"number\") return Algebra.polynomialValueAt(this.a, t);\n        else if (t instanceof Complex) {\n            const n = this.a.length - 1;\n            if (n >= 0) {\n                let powerTerm = 1,\n                    result =\n                        this.a[n] instanceof Complex\n                            ? this.a[n].copy()\n                            : new Complex(this.a[n], 0);\n                for (let i = n - 1; i >= 0; i--) {\n                    powerTerm = t.multiply(powerTerm);\n                    result = result.add(powerTerm.multiply(this.a[i]));\n                    \n                }\n                return result;\n            }\n            return 0;\n        }\n        return NaN;\n    };\n\n    static Symbolic = (\n        degree,\n        symbol = \"t\",\n        halfTermsVisible = 2,\n        coef = \"a\",\n        inline = false\n    ) => {\n        let res = inline ? \"\" : \"$$\";\n        if (degree === \"n\") {\n            res += `${coef}_n ${symbol}^n + `;\n            for (let i = 1; i < halfTermsVisible; i++)\n                res += `${coef}_{n - ${i}}${symbol}^{n - ${i}} + `;\n            res += \" ... \";\n            for (let i = halfTermsVisible - 1; i > 0; i--)\n                res += ` + ${coef}_{${i}}${symbol}^{${i}}`;\n            res += ` + ${coef}_0`;\n        } else if (typeof degree === \"number\") {\n            for (; degree >= 0; degree--) {\n                res += `${coef}_{${degree}}`;\n                if (degree > 0) res += `${symbol}^{${degree}} + `;\n            }\n        }\n        return res + (inline ? \"\" : \" $$\");\n    };\n    derivative = () => {\n        const result = this.copy(true);\n        if (!result.dot) {\n            const n = result.a.length - 1;\n            const da = Array(n).fill(0);\n            for (let i = n; i >= 1; i--) da[n - i] = i * result.a[n - i];\n            result.a = [...da];\n        }\n        if (result.plus) result.plus = result.plus.derivative();\n        return result;\n    };\n\n\n    expression = () => {\n        if (this.a instanceof Array) {\n            const n = this.a.length - 1;\n            if (\n                !n ||\n                !this.a.slice(0, n).filter((ci) => ci.toString() !== \"0\").length\n            )\n                return this.a[n].toString();\n            return this.a\n                .map((a_i, i) =>\n                    a_i\n                        ? Algebra.coefy(a_i, i, n) +\n                          (i < n\n                              ? this.symbol +\n                                (i < n - 1\n                                    ? \"^\" + (n - i).toString()\n                                    : \"\")\n                              : \"\")\n                        : \"\"\n                )\n                .join(\"\"); // joins all the coefficients, symbols, etc all together as for polynomal functions\n        }\n        return this.a.toString();\n    }\n}\n","import { error_codes } from \"config\";\n\nexport default class NotScalarError extends Error {\n    \n    constructor(cause = null){ // the parameter with problem\n        super(cause ? `${cause} => این عبارت باید اسکالر باشد!!` : \"این خطا بدلیل استفاده از یک عبارت غیر اسکالر در مکان غیر مجاز رخ داده است!\")\n        this.name = \"NotNumberError\";\n        this.type = \"Numeric\";\n        this.code = error_codes.not_scalar;\n        this.cause = cause;\n    }\n\n    describe = () => {\n        console.log(this.message + (this.cause ? \"\\n\" + this.cause : \"\"));\n        return this.message + (this.cause ? \"\\n\" + this.cause.toString() : \"\");\n    }\n}","import { CollectionsOutlined } from \"@mui/icons-material\";\nimport NotScalarError from \"errors/algebra/NotScalarError\";\nimport StandardInputSignal from \"math/input-signals\";\nimport { round, strictPrecisionFormat } from \"../calculus\";\n\nclass Algebra {\n    // symbolic expressions\n    constructor(\n        a,\n        { symbol = \"t\", type = \"poly\", b, dot, plus, teta = 0, previous, input }\n    ) {\n        // dot is the interface between terms\n        // g(t) = a * f(t) * {dot: as Algebra}\n        // teta is the offset for wt + alpha in sin/cos/tan/..\n\n        this.symbol = symbol;\n        this.type = type.toLowerCase();\n        this.setA(a).setB(b).setTeta(teta);\n\n        this.input = input; // u(t), r(t), puls, ...\n        if (dot) {\n            this.dot = dot.copy();\n        } // multiply a Algebra from different type into 'this'\n\n        if (plus) {\n            this.plus = plus.copy();\n            this.simplify();\n        } // add another Algebra with different type to this one\n\n        this.previous = previous; // the previous term in the chained Algebra objects\n        // term.plus => next term, term.previous => previous term, term.dot => an algebra from another type that is multiplied to actual term\n        // F(u) = a.f(u).dot(u) + term.plus(u)\n        this.link();\n    }\n    static identify = (parameter) => {\n        if (parameter instanceof Array)\n            return parameter.map((pi) =>\n                pi instanceof Algebra || pi instanceof StandardInputSignal\n                    ? pi.copy()\n                    : round(pi)\n            );\n        else if (parameter instanceof Algebra) {\n            return parameter.copy();\n        } else if (typeof parameter === \"number\") return round(parameter);\n        else if (!parameter) return 0;\n        console.log(parameter);\n        throw new NotScalarError(parameter);\n    };\n    setA = (a) => {\n        this.a = Algebra.identify(a);\n        return this;\n    };\n    getA = () => this.a;\n\n    setB = (b) => {\n        this.b = Algebra.identify(b);\n        return this;\n    };\n    getB = () => this.b;\n\n    setTeta = (teta) => {\n        this.teta = Algebra.identify(teta);\n        return this;\n    };\n    getTeta = () => this.teta;\n    // CONNECT AND LINK METHODS, FIND FIRST TERM AND LAST TERM AND ...\n    end = () => {\n        // returns the end term in the algebratic chain\n        let last = this;\n        while (last.plus) last = last.plus;\n        return last;\n    };\n\n    first = () => {\n        // returns the first term in the algebratic chain\n        let fst = this;\n        while (fst.previous) fst = fst.previous;\n        return fst;\n    };\n\n    enddot = () => {\n        // returns the end term in the algebratic chain\n        let last = this;\n        while (last.dot) last = last.dot;\n        return last;\n    };\n\n    firstdot = () => {\n        // returns the first term in the algebratic chain\n        let fst = this;\n        // WRONG *****************************\n        //while (fst.previous) fst = fst.previous;\n        return fst;\n    };\n    link = () => {\n        // some times .previous links are broken; so i decided to write this method just to make sure everything is connected\n        let term = this.first();\n        if (!term) term = this; // in case this.first() returns wrong answer\n        while (term.plus) {\n            if (term.plus) term.plus.previous = term;\n            term = term.plus; // go to next term in the chain\n        }\n        return this;\n    };\n\n    copy = (linkPrevious = false) =>\n        new Algebra(this.a, {\n            type: this.type,\n            b: this.b,\n            dot: this.dot,\n            plus: this.plus,\n            symbol: this.symbol,\n            teta: this.teta,\n            input: this.input,\n            previous: linkPrevious ? this.previous : null,\n        });\n\n    // SORT THE MULTIPLIERD TERMS ( TERMS CONNECTED WITH this.dot) IN A SPECIFIC ORDER (FOR BETTER SHOW AND COMPARE AND ETC.)\n    // LOOK HERE IT STILL HAS BUGS\n    sort = () => {\n        // sort .dot in special order: poly - exp - frac - ...\n        const orders = [\"poly\", \"exp\", \"frac\"];\n        let position = this;\n        for (const order of orders) {\n            while (position) {\n                let func = position.dot;\n                while (func) {\n                    if (func.type === order && !position.isPrior(order)) {\n                        const temp = position.copy();\n                        position.a =\n                            func.a instanceof Array ? [...func.a] : func.a;\n                        position.type = func.type;\n                        position.symbol = func.symbol;\n                        if (func.b instanceof Array) position.b = [...func.b];\n                        else position.b = func.b;\n\n                        func.a = temp.a instanceof Array ? [...temp.a] : temp.a;\n                        func.type = temp.type;\n                        func.symbol = temp.symbol;\n                        if (temp.b instanceof Array) func.b = [...temp.b];\n                        else func.b = temp.b;\n                    }\n                    func = func.dot;\n                }\n                position = position.dot;\n            }\n        }\n    };\n\n    isPrior = (order) => {\n        const orders = [\"poly\", \"exp\", \"frac\"];\n        const thisValue = orders.findIndex((or) => or === this.type);\n        const orderValue = orders.findIndex((or) => or === order);\n        return thisValue <= orderValue;\n    };\n\n    // CHECK IF ONE TERMS CAN BE ADDED TO ANOTHER ONE (MEANING THEY HAVE SAME PARAMETRIC TERMS)\n    unifiable = (exp) => {\n        // check if this is unifiable with expression:exp\n        //this.sort();\n        //exp.sort();\n        if (exp && this.type === exp.type && this.symbol === exp.symbol) {\n            // check if this and exp are sumable\n            // check .dot s:\n            if (this.dot || exp.dot)\n                return this.dot && this.dot.unifiable(exp.dot);\n\n            if (this.b instanceof Array && exp.b instanceof Array) {\n                if (this.b.length === exp.b.length) {\n                    const sameOnes = this.b.filter(\n                        (item, idx) => item === exp.b[idx]\n                    );\n                    return this.b.length === sameOnes.length;\n                }\n            }\n            return exp.b === this.b;\n        }\n        return false;\n    };\n\n    static valueOf = (x, t = 0) => {\n        if (x) {\n            let value = 0;\n            if (x instanceof Algebra || x instanceof StandardInputSignal)\n                value = x.$(t);\n            else if (x instanceof Array)\n                value = Algebra.polynomialValueAt(x, t);\n            else value = x;\n            return value;\n        }\n        return 0;\n    };\n\n    static polynomialValueAt = (arr, t) => {\n        let value = 0;\n        const n = arr.length - 1;\n        for (let i = 0; i <= n; i++) {\n            value += arr[i] * t ** (n - i);\n        }\n        return value;\n    };\n    // REMOVE REDUNDANT TERMS, SIGNS AND ETC.\n    simplify = () => {\n        let term = this.first();\n        while (term) {\n            if (term instanceof Algebra) {\n                if (\n                    term.a === 0 ||\n                    Algebra.polynomial(term.a, term.symbol) === 0\n                ) {\n                    if (term.previous) {\n                        term.previous.plus = term.plus;\n                    } else {\n                        // remove first term and transfer the second term to first one\n                        if (this === term) term.redundant = true;\n                        if (term.plus) {\n                            term = term.plus.copy(true);\n                            if (term.plus) {\n                                term.plus = term.plus.plus;\n                                if (term.plus) term.plus.previous = term;\n                            }\n                            term.previous = null;\n                        }\n                    }\n                    // }\n                }\n            }\n            term = term.plus;\n        }\n        return this;\n    };\n\n    $ = (t) => {\n        // valueOf function in certain point\n        // I used character $ in many places as acronym for \"set\" in setters, so $ here means that set the t ( or x or whatever) with a certain point\n        // for each type just implement the method literally\n        let result = this.valueAt(t);\n        if (this.dot) result *= this.dot.$(t);\n        if (this.plus) result += this.plus.$(t);\n\n        return result;\n    };\n\n    label = (name = undefined, index = undefined) =>\n        (name\n            ? name +\n              (index !== undefined ? \"_{\" + index + \"}\" : \"\") +\n              \"(\" +\n              this.symbol +\n              \") = \"\n            : \"\") + this.toString();\n\n    // RETURNS THE BEST AND SIMPLE AND SHORTEST WAY TO SHOW COEFFICIENTS\n    static coefy = (a_i, i, n) => {\n        if (a_i instanceof Algebra) {\n            let str = \"\";\n            let ai = a_i.copy();\n            if (i > 0) {\n                // write a method to edit all the + - occuring next to each other in toString()\n                if (ai.type === \"complex\" && typeof ai.a === \"number\") {\n                    if (ai.a < 0) {\n                        str += \" - \";\n                        ai.a *= -1;\n                    } else if (!ai.a && typeof ai.b === \"number\" && ai.b < 0) {\n                        str += \" - \";\n                        ai.b *= -1;\n                    }\n                } else str += \" + \";\n            }\n            return str + ai.toString(i < n && a_i.hasMultiTerms());\n        }\n        if (a_i instanceof StandardInputSignal) {\n            //EDIT THIS PART TOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO\n            let str = i > 0 ? \" + \" : \"\";\n            return str + a_i.toString(i < n && a_i.hasMultiTerms());\n        } else {\n            if (n === 0) return strictPrecisionFormat(a_i);\n            if (a_i === 0) return \"\";\n            if (i !== 0) {\n                let s = \"\";\n                if (a_i < 0) {\n                    s += \" - \";\n                    a_i *= -1;\n                } else s += \" + \";\n\n                if (a_i === 1 && i < n) return s;\n                return s + strictPrecisionFormat(a_i);\n            }\n            if (a_i === 1) return \"\";\n            if (a_i === -1) return \"-\";\n\n            return strictPrecisionFormat(a_i);\n        }\n    };\n\n    // DECIPHER THE OBJECT TO ITS POLYNOMINAL FORM (IF IT IS ONE ACTUALLY)\n    static polynomial = (coefs, symbol) => {\n        if (coefs instanceof Array) {\n            const n = coefs.length - 1;\n            if (\n                !n ||\n                !coefs.slice(0, n).filter((ci) => ci.toString() !== \"0\").length\n            )\n                return coefs[n].toString();\n            return coefs\n                .map((a_i, i) =>\n                    a_i\n                        ? Algebra.coefy(a_i, i, n) +\n                          (i < n\n                              ? symbol +\n                                (i < n - 1\n                                    ? \"^{\" + (n - i).toString() + \"}\"\n                                    : \"\")\n                              : \"\")\n                        : \"\"\n                )\n                .join(\"\"); // joins all the coefficients, symbols, etc all together as for polynomal functions\n        }\n        return coefs.toString();\n    };\n\n    join = () => {\n        // connect this term to its next terms; considering the right use of + or -\n        if (this.plus) {\n            let operator = \"+\",\n                next = this.plus.copy();\n            if (next.a instanceof Array) {\n                if (next.a[0] < 0) {\n                    operator = \"-\";\n                    next.a[0] *= -1;\n                }\n            } else {\n                if (next.a < 0) {\n                    operator = \"-\";\n                    next.a *= -1;\n                }\n            }\n            return operator + next.toString();\n        }\n        return \"\";\n    };\n\n    hasMultiTerms = () => {\n        if (this.plus) return true;\n        if (this.a instanceof Array && this.type !== \"frac\")\n            return this.a.filter((ai) => ai !== 0).length > 1;\n        return false;\n    };\n    isTriangular = () =>\n        this.type === \"sin\" ||\n        this.type === \"cos\" ||\n        this.type === \"tan\" ||\n        this.type === \"cot\";\n\n    // MATHEMATICAL OPERATIONS\n    // static add = (expressions) => expressions.map((el) => el.toString()).join(\" + \");\n    add = (right) => {\n        // result = this + operand\n        let result = this.link().copy();\n        if (right instanceof Algebra) {\n            let operand = right.link().copy();\n\n            let x = result; // now we try to add each term with its unifiable term in y\n            while (x) {\n                let y = operand;\n                while (y) {\n                    if (x.unifiable(y)) {\n                        if (x.a instanceof Algebra) x.a = x.a.add(y.a);\n                        else if (y.a instanceof Algebra) x.a = y.a.add(x.a);\n                        // **************************************************\n                        // else if x.a || y.a instanceof StandardInputSignal\n                        // *********************************************\n                        else if (x.a instanceof Array) {\n                            if (y.a instanceof Array) {\n                                if (y.a.length > x.a.length) x.a = [...y.a];\n                                for (\n                                    let i = 1;\n                                    i <= y.a.length && i <= x.a.length;\n                                    i++\n                                )\n                                    x.a[x.a.length - i] += y.a[y.a.length - i];\n                            } else {\n                                x.a[x.a.length - 1] += y.a;\n                            }\n                        } else {\n                            x.a += y.a;\n                        }\n                        // remove the term in y that has been processed\n                        if (y.previous) {\n                            y.previous.plus = y.plus;\n                            if (y.plus) y.plus.previous = y.previous;\n                            y.a = 0;\n                        }\n\n                        // its the first term\n                        else operand = operand.plus;\n                        // after this the garbage collector will remove the term because it has no reference to it\n                    }\n                    y = y.plus;\n                }\n                // if(x.plus) x.plus.previous = x;\n                x = x.plus; // go to next term in the chain\n            }\n\n            if (operand) {\n                // if the above algorythm leaves operand with non-null value\n                /// it means there was terms in the operand's algebratic chain that are'nt unifiable with x terms\n                // so we must connect the leftovers to last terms of the result\n                if (Algebra.polynomial(result.a, result.symbol) !== \"0\") {\n                    if (\n                        Algebra.polynomial(operand.getA(), operand.symbol) !==\n                        \"0\"\n                    ) {\n                        let endTerm = result.end();\n                        endTerm.plus = operand;\n                        endTerm.plus.previous = result;\n                    }\n                } else result = operand.copy(); // connect to next term\n            }\n            return result.simplify();\n        } else if (right instanceof StandardInputSignal) {\n            const endTerm = result.end();\n            endTerm.plus = right.copy();\n            endTerm.plus.previous = endTerm;\n        }\n        return result;\n    };\n\n    arrangeDots = () => {\n        let term = this;\n        let input = null;\n        while (term.dot) {\n            // enhance the algo for cases that more than one input signal erxists in .dot chain\n            if (term.dot instanceof StandardInputSignal) {\n                input = term.dot;\n                term.dot = term.dot.dot;\n            }\n            if (term.dot) term = term.dot;\n        }\n        term.dot = input;\n    };\n    // INCOMPLETE ***********\n    multiply = (operand) => {\n        const y = this.copy().link();\n        if (operand instanceof Algebra) {\n            // operand algebra or complex\n            // ***** TODO:  ****************\n            if (operand.type === \"poly\") {\n                if (this.type === \"poly\" || this.type === \"frac\") {\n                    // NEEDS ERDITING for FRACTIONs\n                    if (this.symbol === operand.symbol) {\n                        const ao = operand.getA();\n                        const no = ao.length - 1;\n                        const As = [];\n                        for (let i = no; i >= 0; i--) {\n                            if (operand.a[i]) {\n                                const zeros = Array(no - i).fill(0);\n                                const a = [...y.a].map(\n                                    (yai) => yai * operand.a[i]\n                                );\n                                a.push(...zeros);\n                                As.push(a);\n                            }\n                        }\n                        // now sum all the products\n                        console.table(As);\n                        let product = As.pop();\n                        for (let j = 0; j < As.length; j++)\n                            for (\n                                let i = 1;\n                                i <= As[j].length && i <= product.length;\n                                i++\n                            )\n                                product[product.length - i] +=\n                                    As[j][As[j].length - i];\n\n                        y.a = product;\n                        if (operand.dot) {\n                            // link dots ***IS THIS TRUE?>***\n                            const endDotTerm = y.enddot();\n                            endDotTerm.dot = operand.dot.copy(); // multiply\n                            endDotTerm.dot.previous = endDotTerm;\n                        }\n                    }\n                }\n            } else if (y.type !== operand.type && operand.plus) {\n                // like: exp(f(...)) * [Asin(...) * Bcos(...)]\n                // UPDATE SELF MULTIPLY AFTER SOLVING THIS ISSUE\n                y.plus = y.multiply(operand.plus.copy());\n                const lastyDot = y.enddot();\n                if(typeof y.a === 'number' && typeof operand.a === 'number' && operand.a !== 1){\n                    y.a *= operand.a;\n                    operand.a = 1;\n                }\n                lastyDot.dot = operand.copy();\n                lastyDot.dot.previous = lastyDot;\n                // UPDATE SELF MULTIPLY AFTER SOLVING THIS ISSUE\n\n            } else {\n                const endDotTerm = y.enddot();\n                if (typeof y.a === \"number\" && typeof operand.a === \"number\") {\n                    y.a *= operand.a;\n                    operand.a = 1;\n                }\n                endDotTerm.dot = operand.copy(); // multiply\n                endDotTerm.dot.previous = endDotTerm;\n            }\n            if (y.plus) y.plus = y.plus.multiply(operand);\n            if (operand.plus) y.end().plus = y.multiply(operand.plus);\n            return y; // for now just to avoid crashes\n        } else if (operand instanceof StandardInputSignal) {\n            // const endDotTerm = y.enddot();\n            // endDotTerm.dot = operand.copy(); // multiply\n            // endDotTerm.dot.previous = endDotTerm;\n            y.input = operand.copy();\n            if (y.plus) y.plus = y.plus.multiply(operand);\n        } else {\n            // scalar multiply\n            if (operand instanceof Algebra) {\n            } else {\n                if (y.a instanceof Array) y.a = y.a.map((ai) => operand * ai);\n                else if (y.a instanceof Algebra) y.a = y.a.multiply(operand);\n                else y.a = y.a * operand;\n            }\n            if (y.plus) y.plus = y.plus.multiply(operand);\n        }\n        // console.log(\"y = \", y, \"operand = \", operand)\n        return y;\n    };\n\n    selfmultiply = (operand) => {\n        if (operand instanceof Algebra) {\n            // operand algebra or complex\n            // ***** TODO:  ****************\n            if (operand.type === \"poly\") {\n                if (this.type === \"poly\" || this.type === \"frac\") {\n                    // NEEDS ERDITING for FRACTIONs\n                    if (this.symbol === operand.symbol) {\n                        const ao = operand.getA();\n                        const no = ao.length - 1;\n                        const As = [];\n                        for (let i = no; i >= 0; i--) {\n                            if (ao[i]) {\n                                const zeros = Array(no - i).fill(0);\n                                const a = [...this.a].map(\n                                    (yai) => yai * operand[i]\n                                );\n                                a.push(...zeros);\n                                As.push(a);\n                            }\n                        }\n                        // now sum all the products\n                        const product = As.pop();\n                        for (let i = 0; i < product.length; i++) {\n                            for (let j = 0; j < As.length; j++) {\n                                if (i < As[j].length) product[i] += As[j][i];\n                            }\n                        }\n                        this.a = product;\n                        if (operand.dot) {\n                            // link dots ***IS THIS TRUE?>***\n                            const endDotTerm = this.enddot();\n                            endDotTerm.dot = operand.dot.copy(); // multiply\n                            endDotTerm.dot.previous = endDotTerm;\n                        }\n                    }\n                }\n            } else {\n                const endDotTerm = this.enddot();\n                endDotTerm.dot = operand.copy(); // multiply\n                endDotTerm.dot.previous = endDotTerm;\n                if (this.plus) this.plus = this.plus.multiply(operand);\n            }\n        } else if (operand instanceof StandardInputSignal) {\n            // this.dot = operand.copy(); // multiply\n            // this.dot.previous = this;\n            this.input = operand.copy();\n            if (this.plus) this.plus.selfmultiply(operand);\n            if (operand.plus) this.end().plus = this.multiply(operand.plus);\n        } else {\n            // scalar multiply\n            if (this.a instanceof Array)\n                this.a = this.a.map((ai) => operand * ai);\n            else this.a *= operand;\n\n            if (this.plus) this.plus.selfmultiply(operand);\n        }\n    };\n\n    negation = () => this.multiply(-1);\n\n    substract = (operand) => this.add(operand.negation());\n\n    devide = (operand) => {\n        // u need to handle Complex objects as Algebra using their type to recognize them\n        if (operand instanceof Algebra) {\n            // operand algebra or complex\n            // ***** TODO:  ****************\n            // first u must do everything to simplify\n            // second at the simplest state of the terms,\n            // construct a new Algebra of \"frac\" type\n            return this.copy(); // for now just to avoid crashes\n        } else {\n            // scaler\n            return this.multiply(1 / operand);\n        }\n    };\n\n    laplace = () => {};\n\n    static areTheSame = (el1, el2) => {\n        // checkes the sameness of parameters like .a .b .teta , etc.\n        if(el1 instanceof Algebra && el2 instanceof Algebra)\n            return el1.equals(el2);\n        else if(el1 instanceof Array && el2 instanceof Array){\n            if(el1.length === el2.length){\n                let i = 0;\n                for(i = 0; i < el1.length; i++)\n                    if(el1[i] !== el2[i]) break;\n                return i >= el1.length;\n                \n            }\n        }\n        return typeof el1 === typeof el2 && el1 === el2;\n    }\n    equals = (operand) => operand instanceof Algebra && \n                            this.type === operand.type && \n                            this.symbol === operand.symbol &&\n                            this.type === operand.type &&\n                            this.symbol === operand.symbol &&\n                            Algebra.areTheSame(this.a, operand.a) &&\n                            Algebra.areTheSame(this.b, operand.b) &&\n                            Algebra.areTheSame(this.teta, operand.teta) &&\n                            (!this.dot || this.dot.equals(operand.dot)) &&\n                            (!this.plus || this.plus.equals(operand.plus)) &&\n                            (!this.previous || this.previous.equals(operand.previous));\n\n\n    static areTheseTwoEqual = (p1, p2) =>\n        p1 instanceof Algebra\n            ? p1.equals(p2)\n            : p2 instanceof Algebra\n            ? p2.equals(p1)\n            : p1 === p2;\n    // DECIPHERS THE CONNECT OBJECTS TO UNDERSTANDABLE MATHMATICALLY SHAPED TEXT\n    // IT IS FORMATTED COMPATIBLE FOR MathJax component\n    toString = (parenthesis = false) => {\n        // this.arrangeDots();\n        this.simplify(); // simplify current chain that's left from unknown number of operations\n        let formula = \"\";\n        // if ... + 0 || 0 + ... appears ===>>>>> see below !!\n        if (!this.a) return \"0\"; // what if **************************************** 0 / 0\n        if (parenthesis) formula += \"(\";\n        switch (this.type.toLowerCase()) {\n            case \"exp\": {\n                // if (this.a < 0) formula += \"(\";\n                let a0 = this.a;\n                if (a0 < 0) {\n                    formula += \"-\";\n                    a0 *= -1;\n                }\n                if (a0 !== 1)\n                    if (a0 instanceof Algebra)\n                        formula += a0.toString(\n                            a0 instanceof Algebra && a0.hasMultiTerms()\n                        );\n                    else if (a0 instanceof Array)\n                        // testTEST\n                        formula += Algebra.polynomial(a0, this.symbol);\n                    // FOR TEST\n                    else formula += strictPrecisionFormat(a0);\n                if (this.dot instanceof Algebra)\n                    formula += this.dot.toString(\n                        this.dot instanceof Algebra && this.dot.hasMultiTerms()\n                    );\n                if (this.b !== 0) {\n                    if (this.a !== 0) {\n                        formula += \"e^{\";\n                        let e0 = this.b;\n                        if (this.b instanceof Algebra)\n                            formula += this.b.toString(\n                                this.b instanceof Algebra &&\n                                    this.b.hasMultiTerms()\n                            );\n                        else if (this.b instanceof Array)\n                            formula += Algebra.polynomial(this.b, this.symbol);\n                        else {\n                            if (e0 < 0) {\n                                formula += \"-\";\n                                e0 *= -1;\n                            }\n                            if (e0 !== 1) formula += e0;\n                        }\n                        formula += this.symbol + \"}\";\n                    }\n                    if (this.input) formula += this.input.toString();\n                } else {\n                    if (a0 !== 1 || !this.dot)\n                        formula += strictPrecisionFormat(this.a);\n                }\n                // if (this.a < 0) formula += \")\";\n                if (this.plus) formula += this.join(); // if there's a next term: casscade toString() calls\n                break;\n            }\n            case \"poly\":\n                formula += Algebra.polynomial(this.a, this.symbol);\n                if (this.dot instanceof Algebra)\n                    formula += this.dot.toString(\n                        this.dot instanceof Algebra && this.dot.hasMultiTerms()\n                    );\n                if (this.input) {\n                    formula += (parenthesis ? \")\" : \"\") + this.input.toString();\n                    parenthesis = false;\n                }\n                if (this.plus) formula += this.join(); // if there's a next term: casscade toString() calls\n                break;\n            case \"frac\": {\n                if (this.dot instanceof Algebra)\n                    formula += this.dot.toString(\n                        this.dot instanceof Algebra && this.dot.hasMultiTerms()\n                    );\n                const numerator = Algebra.polynomial(this.a, this.symbol);\n                formula +=\n                    numerator !== \"0\"\n                        ? \"\\\\frac{\" +\n                          numerator +\n                          \"}{\" +\n                          Algebra.polynomial(this.b, this.symbol) +\n                          \"}\"\n                        : \"0\";\n                if (this.input) formula += this.input.toString();\n                if (this.plus) formula += this.join(); // if there's a next term: casscade toString() calls\n\n                break;\n            }\n            case \"sin\":\n            case \"asin\":\n            case \"cos\":\n            case \"tan\":\n            case \"cot\": {\n                // if (this.a < 0) formula += \"(\";\n                let a0 = this.a;\n                if (a0 < 0) {\n                    formula += \"-\";\n                    a0 *= -1;\n                }\n                if (a0 !== 1)\n                    if (a0 instanceof Algebra)\n                        formula += a0.toString(\n                            a0 instanceof Algebra && a0.hasMultiTerms()\n                        );\n                    else if (a0 instanceof Array)\n                        formula += Algebra.polynomial(a0, this.symbol);\n                    // FOR TEST\n                    else formula += strictPrecisionFormat(a0);\n                if (this.a !== 0) {\n                    if (this.dot && this.dot instanceof Algebra)\n                        formula += this.dot.toString(\n                            this.dot instanceof Algebra &&\n                                this.dot.hasMultiTerms()\n                        );\n                    if (this.b !== 0) {\n                        formula += this.type;\n                        if (this.b instanceof Algebra) {\n                            formula += this.b.toString(\n                                this.b instanceof Algebra &&\n                                    this.b.hasMultiTerms()\n                            );\n                        } else if (this.b instanceof Array)\n                            formula += Algebra.polynomial(this.b, this.symbol);\n                        // FOR TEST\n                        else {\n                            let w0 = this.b;\n                            formula += \"(\";\n                            if (w0 < 0) {\n                                formula += \"-\";\n                                w0 *= -1;\n                            }\n                            if (w0 !== 1) formula += strictPrecisionFormat(w0);\n                            formula += this.symbol;\n                            if (this.teta instanceof Algebra)\n                                formula += this.teta.toString();\n                            else if (this.teta) {\n                                let e0 = this.teta;\n                                if (e0 < 0) {\n                                    formula += \" - \";\n                                    e0 *= -1;\n                                } else formula += \" + \";\n                                formula += strictPrecisionFormat(e0);\n                            }\n                            formula += \")\";\n                        }\n                        if (this.input) formula += this.input.toString();\n                    }\n                    // simple num\n                } else {\n                    if (a0 !== 1 || !this.dot)\n                        formula += strictPrecisionFormat(this.a);\n                }\n                // if (this.a < 0) formula += \")\";\n                if (this.plus) formula += this.join(); // if there's a next term: casscade toString() calls\n                break;\n            }\n\n            default:\n                return null;\n        }\n        if (parenthesis) formula += \")\";\n\n        return formula;\n    };\n    toArray = () => {\n        let x = [];\n        const params = [\"a\", \"b\", \"teta\", \"symbol\", \"type\"],\n            linkers = [\"dot\", \"input\", \"plus\", \"previous\"];\n        for (const [key, value] of Object.entries(this)) {\n            if (typeof value !== \"function\") {\n                if (value) {\n                    // maximum toArray call happens\n                    if (params.filter((p) => p === key).length)\n                        x[key] =\n                            value instanceof Algebra ? value.toArray() : value;\n                    //)((value instanceof StandardInputSignal ? value.copy() : ));\n                    else if (linkers.filter((l) => l === key).length)\n                        x[key] =\n                            value instanceof StandardInputSignal\n                                ? value.copy()\n                                : value.toArray();\n                }\n            }\n        }\n        return x;\n    };\n}\n\nexport default Algebra;\n","import { round, strictPrecisionFormat } from \"../calculus\";\n\nexport default class StandardInputSignal {\n    constructor(amplitude = 1, type = \"u\", symbol = \"t\") {\n        this.symbol = symbol;\n        this.type = type;\n        this.amp = round(amplitude);\n    }\n\n    copy = () => new StandardInputSignal(this.amp, this.type, this.symbol);\n\n    toString = () => {\n        let str = \"\",\n            a = this.amp;\n        if (this.amp === -1) {\n            str += \"-\";\n            a *= -1;\n        }\n        if (a !== 1) str += strictPrecisionFormat(a);\n        return str + `${this.type}(${this.symbol})`;\n    };\n\n    ampiltude = () => this.amp;\n}\n"],"names":["Complex","preal","pimage","params","symbol","type","b","hasMultiTerms","plus","a","toString","parenthesis","isZero","rl","formula","Algebra","round","im","join","real","imaginary","copy","linkPrevious","dot","previous","input","conjugate","negation","magnitude$2","magnitude","isReal","hasSameTypeWith","x","realify","add","operand","Re","Im","substract","equals","isConjugateWith","multiply","push","devide","denominator","result","isNaN","setA","setB","raiseTo","power","Math","floor","i","devideInverse","k","extract","strNumber","replace","length","isDigit","Number","slice","sign","img","Poly","degree","valueAt","t","n","powerTerm","NaN","derivative","da","Array","fill","expression","filter","ci","map","a_i","atn","aArray","Symbolic","halfTermsVisible","coef","inline","res","NotScalarError","cause","describe","console","log","message","name","code","error_codes","Error","teta","identify","getA","getB","setTeta","getTeta","end","last","first","fst","enddot","firstdot","link","term","sort","position","order","func","isPrior","temp","orders","findIndex","or","unifiable","exp","sameOnes","item","idx","simplify","polynomial","redundant","$","label","undefined","index","operator","next","ai","isTriangular","right","y","endTerm","StandardInputSignal","arrangeDots","no","As","zeros","yai","table","product","pop","j","endDotTerm","lastyDot","selfmultiply","ao","laplace","areTheSame","toLowerCase","a0","strictPrecisionFormat","e0","numerator","w0","toArray","linkers","key","value","p","l","Object","entries","this","parameter","pi","valueOf","polynomialValueAt","arr","coefy","str","s","coefs","el1","el2","areTheseTwoEqual","p1","p2","amplitude","amp","ampiltude"],"sourceRoot":""}