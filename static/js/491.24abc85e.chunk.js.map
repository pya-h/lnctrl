{"version":3,"file":"static/js/491.24abc85e.chunk.js","mappings":"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","sources":["math/algebra/complex.js","math/algebra/functions/fraction.js","math/algebra/functions/poly.js","errors/algebra/NotScalarError.js","math/algebra/index.js","math/input-signals/index.js"],"sourcesContent":["import Algebra from \".\";\r\nimport { round, isDigit } from \"../calculus\";\r\n\r\nclass Complex extends Algebra {\r\n    constructor(preal, pimage = 0, params = {}) {\r\n        super(preal, { symbol: \"j\", type: \"complex\", b: pimage, ...params });\r\n    }\r\n\r\n    hasMultiTerms = () =>\r\n        this.plus || (this.a.toString() !== \"0\" && this.b.toString() !== \"0\");\r\n\r\n    toString = (parenthesis = false) => {\r\n        if (this.isZero())\r\n            return \"0\";\r\n        const rl = this.a;\r\n        let formula = parenthesis && this.hasMultiTerms() ? \"(\" : \"\";\r\n        if (rl !== 0)\r\n            formula +=\r\n            rl instanceof Algebra ?\r\n            rl.toString(rl.hasMultiTerms()) :\r\n            round(rl);\r\n        let im = this.b;\r\n        if (im !== 0) {\r\n            //if (im < 0 || (im instanceof Algebra)) { im = im.negation()\r\n            if (im < 0) {\r\n                im *= -1;\r\n                formula += \" - \";\r\n            } else if(im instanceof Algebra && im.getA() < 0){\r\n                im.setA(-im.getA());\r\n                formula += \" - \";\r\n            } \r\n            else if (rl !== 0) formula += \" + \";\r\n\r\n            formula += this.symbol;\r\n            if (im !== 1)\r\n                formula +=\r\n                im instanceof Algebra ?\r\n                im.toString(im.hasMultiTerms()) :\r\n                round(im);\r\n        }\r\n        if (this.plus) formula += this.join(); // if there's a next term: casscade toString() calls\r\n\r\n        return parenthesis ? formula + \")\" : formula;\r\n    }; // a + jb\r\n\r\n    real = () => this.a;\r\n    imaginary = () => this.b;\r\n\r\n    copy = (linkPrevious = false) =>\r\n        new Complex(this.a, this.b, {\r\n            dot: this.dot,\r\n            plus: this.plus,\r\n            previous: linkPrevious ? this.previous : null,\r\n            input: this.input,\r\n        });\r\n\r\n    conjugate = () =>\r\n        new Complex(\r\n            this.a,\r\n            this.b instanceof Algebra ? this.b.negation() : -this.b\r\n        );\r\n\r\n    negation = () =>\r\n        new Complex(\r\n            this.a instanceof Algebra ? this.a.negation() : -this.a,\r\n            this.b instanceof Algebra ? this.b.negation() : -this.b\r\n        );\r\n\r\n    magnitude$2 = () => this.a ** 2 + this.b ** 2;\r\n\r\n    magnitude = () => (this.a ** 2 + this.b ** 2) ** 0.5;\r\n\r\n    phase = () => {\r\n        const definiteA = +this.a,\r\n            definiteB = +this.b;\r\n        if (this.a === definiteA && this.b === definiteB)\r\n            return Math.atan2(definiteB, definiteA);\r\n        if (this.b instanceof Algebra)\r\n            return t => Math.atan2(this.b.$(t), (this.a instanceof Algebra ? this.a.$(t) : definiteA))\r\n        if (this.a instanceof Algebra)\r\n            return t => Math.atan2(definiteB, this.a.$(t));\r\n        return NaN;\r\n    }\r\n    isReal = () => this.b === 0;\r\n\r\n    hasSameTypeWith = (x) =>\r\n        (this.isReal() && x.isReal()) || (!this.isReal() && !x.isReal()); // both full imaginray or both real\r\n    realify = () => new Complex(this.a, 0); // return a simple real value in Complex object format (for methods that only accept Complex values)\r\n\r\n    add = (operand) => {\r\n        let Re = null,\r\n            Im = null;\r\n        if (operand instanceof Complex) {\r\n            if (this.a instanceof Algebra) Re = this.a.add(operand.real());\r\n            else if (operand.real() instanceof Algebra)\r\n                Re = operand.real().add(this.a);\r\n            else Re = this.a + operand.real();\r\n\r\n            if (this.b instanceof Algebra) Im = this.b.add(operand.imaginary());\r\n            else if (operand.imaginary() instanceof Algebra)\r\n                Im = operand.imaginary().add(this.b);\r\n            else Im = this.b + operand.imaginary();\r\n        } else {\r\n            if (this.a instanceof Algebra) Re = this.a.add(operand);\r\n            else if (operand instanceof Algebra) Re = operand.add(this.a);\r\n            else Re = this.a + operand;\r\n\r\n            Im = this.b;\r\n        }\r\n        return new Complex(Re, Im);\r\n    };\r\n\r\n    substract = (operand) => this.add(operand.negation());\r\n\r\n    equals = (operand) => {\r\n        if (operand instanceof Complex) {\r\n            // two complex number are equal to eachother if both thier real parts are the same, and their imaginary parts are the same\r\n            let realPartsEqual = false;\r\n            if (this.a instanceof Algebra)\r\n                realPartsEqual = this.a.equals(operand.real());\r\n            else if (operand.real() instanceof Algebra)\r\n                realPartsEqual = operand.real().equals(this.a);\r\n            else realPartsEqual = this.a === operand.real();\r\n            if (!realPartsEqual) return false;\r\n\r\n            if (this.b instanceof Algebra)\r\n                return this.b.equals(operand.imaginary());\r\n            else if (operand.imaginary() instanceof Algebra)\r\n                return operand.imaginary().equals(this.b);\r\n            return this.b === operand.imaginary();\r\n        }\r\n\r\n        // if operand is not a complex number then the only way it can be equal with this object of Complex,\r\n        // is for this object to have a zero imaginary part:\r\n        return (\r\n            this.isReal() &&\r\n            (operand instanceof Algebra ?\r\n                operand.equals(this.a) :\r\n                operand === this.a)\r\n        );\r\n    };\r\n\r\n    isConjugateWith = (operand) => this.conjugate().equals(operand);\r\n    multiply = (operand) => {\r\n        let Re = [],\r\n            Im = [];\r\n        if (operand instanceof Complex) {\r\n            // first term\r\n            if (this.a instanceof Algebra) {\r\n                Re.push(this.a.multiply(operand.real()));\r\n                Im.push(this.a.multiply(operand.imaginary()));\r\n            } else {\r\n                Re.push(\r\n                    operand.a instanceof Algebra ?\r\n                    operand.a.multiply(this.a) :\r\n                    operand.a * this.a\r\n                );\r\n\r\n                Im.push(\r\n                    operand.b instanceof Algebra ?\r\n                    operand.b.multiply(this.a) :\r\n                    this.a * operand.b\r\n                );\r\n            }\r\n\r\n            // second term\r\n            if (this.b instanceof Algebra) {\r\n                Re.push(this.b.multiply(operand.imaginary()));\r\n                Im.push(this.b.multiply(operand.real()));\r\n            } else {\r\n                Re.push(\r\n                    operand.b instanceof Algebra ?\r\n                    operand.b.multiply(this.b) :\r\n                    operand.b * this.b\r\n                );\r\n\r\n                Im.push(\r\n                    operand.a instanceof Algebra ?\r\n                    operand.a.multiply(this.b) :\r\n                    this.b * operand.a\r\n                );\r\n            }\r\n            return new Complex(Re[0] - Re[1], Im[0] + Im[1]);\r\n        } else {\r\n            Re =\r\n                this.a instanceof Algebra ?\r\n                this.a.multiply(operand) :\r\n                operand instanceof Algebra ?\r\n                operand.multiply(this.a) :\r\n                this.a * operand;\r\n\r\n            Im =\r\n                this.b instanceof Algebra ?\r\n                this.b.multiply(operand) :\r\n                operand instanceof Algebra ?\r\n                operand.multiply(this.b) :\r\n                this.b * operand;\r\n\r\n        }\r\n        return new Complex(Re, Im);\r\n    };\r\n\r\n    devide = (denominator) => {\r\n        if (denominator instanceof Complex) {\r\n            const result = this.multiply(denominator.conjugate()).devide(\r\n                denominator.magnitude$2()\r\n            );\r\n            // CHECK THIS\r\n            if (isNaN(result.real()))\r\n                result.setA(0);\r\n            if (isNaN(result.imaginary()))\r\n                result.setB(0);\r\n            return result;\r\n        } else if (denominator instanceof Algebra) {\r\n            // USE super().devide ?\r\n            return this.copy(); // for now to avoid craches\r\n        } else return this.multiply(1 / denominator); // number\r\n    };\r\n\r\n    raiseTo = (power) => {\r\n        let result = this.copy(true);\r\n        // for now power must be integr\r\n        if (Math.floor(power) === power)\r\n            for (let i = 1; i < power; i++) {\r\n                result = result.multiply(this);\r\n            }\r\n\r\n        return result;\r\n    };\r\n\r\n    devideInverse = (k) =>\r\n        (k instanceof Algebra ? k : new Complex(k, 0)).devide(this);\r\n\r\n    static extract = (strNumber) => {\r\n        // extract a string to a complex object\r\n\r\n        strNumber = strNumber.replace(/\\s/g, \"\");\r\n        let i = strNumber[0] === \"-\" || strNumber[0] === \"+\" ? 1 : 0;\r\n        let real = 0;\r\n        if (strNumber[i] !== \"j\") {\r\n            for (; i < strNumber.length && isDigit(strNumber[i]); i++);\r\n            real = Number(strNumber.slice(0, i) || 0);\r\n        }\r\n\r\n        let sign = 1;\r\n        for (; i < strNumber.length &&\r\n            (strNumber[i] === \"j\" ||\r\n                strNumber[i] === \"+\" ||\r\n                strNumber[i] === \"-\"); i++\r\n        )\r\n            if (strNumber[i] === \"-\") sign = -1;\r\n\r\n        const img = Number(strNumber.slice(i, strNumber.length) || 0);\r\n        return new Complex(real, sign * img);\r\n    };\r\n\r\n    isZero = () => this.a === 0 && this.b === 0;\r\n}\r\n\r\nexport default Complex;","import Algebra from \"math/algebra\";\r\nimport Poly from \"./poly\";\r\n\r\nexport default class Fraction extends Algebra {\r\n    constructor(num, den = [1], symbol = \"t\", params = {}) {\r\n        // ke^ct\r\n        if (!(num instanceof Algebra)) {\r\n            if (!(num instanceof Array)) num = [num];\r\n            // this.a\r\n            else if (num.length === 0) num = [0];\r\n        }\r\n        if (!(den instanceof Algebra)) {\r\n            if (!(den instanceof Array)) den = [den];\r\n            // this.b\r\n            else if (den.length === 0) den = [1];\r\n        }\r\n        super(num, { symbol, type: \"frac\", b: den, ...params });\r\n    }\r\n\r\n    copy = (linkPrevious = false) =>\r\n        new Fraction(this.a, this.b, this.symbol, {\r\n            dot: this.dot,\r\n            plus: this.plus,\r\n            previous: linkPrevious ? this.previous : null,\r\n            input: this.input\r\n        });\r\n\r\n    lim = () => {\r\n        // for all fractions with all kind of numerator and denominator\r\n    }\r\n    \r\n    numerator = () => this.a instanceof Algebra ? this.a.copy(true) : new Poly(this.a);\r\n    denominator = () => this.b instanceof Algebra ? this.b.copy(true) : new Poly(this.b);\r\n\r\n    setNumerator = (num) => {\r\n        if (!(num instanceof Algebra)) {\r\n            if (!(num instanceof Array)) num = [num];\r\n            // this.a\r\n            else if (num.length === 0) num = [0];\r\n        }\r\n        return this.setA(num);\r\n    }\r\n\r\n    setDenominator = (den) => {\r\n        if (!(den instanceof Algebra)) {\r\n            if (!(den instanceof Array)) den = [den];\r\n            // this.b\r\n            else if (den.length === 0) den = [1];\r\n        }\r\n        return this.setB(den);\r\n    }\r\n    valueAt = (t) => {\r\n        const num = this.numerator().$(t);\r\n        const den = this.denominator().$(t);\r\n        if(num instanceof Algebra)\r\n            return num.devide(den);\r\n        if(den instanceof Algebra)\r\n            return den.devideInverse(num);\r\n        if(den)\r\n            return num / den;\r\n        // THROW zero denominator ERROR \r\n        return NaN;\r\n    }\r\n\r\n}\r\n","import Algebra from \"math/algebra\";\r\nimport Complex from \"../complex\";\r\nimport Fraction from \"./fraction\";\r\n\r\nexport default class Poly extends Algebra {\r\n    static atn = (a, n, symbol = \"t\") => {\r\n        const aArray = Array(n + 1).fill(0);\r\n        aArray[0] = a;\r\n        return new Poly(aArray, symbol);\r\n    };\r\n    constructor(a, symbol = \"t\", params = {}) {\r\n        // ke^ct\r\n        super(a, { symbol, type: \"poly\", ...params });\r\n    }\r\n\r\n    copy = (linkPrevious = false) =>\r\n        new Poly(this.a, this.symbol, {\r\n            dot: this.dot,\r\n            plus: this.plus,\r\n            previous: linkPrevious ? this.previous : null,\r\n            input: this.input,\r\n        });\r\n\r\n    degree = () => this.a.length - 1;\r\n    \r\n    valueAt = (t) => {\r\n        if (typeof t === \"number\") return Algebra.polynomialValueAt(this.a, t);\r\n        else if (t instanceof Complex) {\r\n            const n = this.a.length - 1;\r\n            if (n >= 0) {\r\n                let powerTerm = 1,\r\n                    result =\r\n                        this.a[n] instanceof Complex\r\n                            ? this.a[n].copy()\r\n                            : new Complex(this.a[n], 0);\r\n                for (let i = n - 1; i >= 0; i--) {\r\n                    powerTerm = t.multiply(powerTerm);\r\n                    result = result.add(powerTerm.multiply(this.a[i]));\r\n                    \r\n                }\r\n                return result;\r\n            }\r\n            return 0;\r\n        }\r\n        return NaN;\r\n    };\r\n\r\n    static Symbolic = (\r\n        degree,\r\n        symbol = \"t\",\r\n        halfTermsVisible = 2,\r\n        coef = \"a\",\r\n        inline = false\r\n    ) => {\r\n        let res = inline ? \"\" : \"$$\";\r\n        if (degree === \"n\") {\r\n            res += `${coef}_n ${symbol}^n + `;\r\n            for (let i = 1; i < halfTermsVisible; i++)\r\n                res += `${coef}_{n - ${i}}${symbol}^{n - ${i}} + `;\r\n            res += \" ... \";\r\n            for (let i = halfTermsVisible - 1; i > 0; i--)\r\n                res += ` + ${coef}_{${i}}${symbol}^{${i}}`;\r\n            res += ` + ${coef}_0`;\r\n        } else if (typeof degree === \"number\") {\r\n            for (; degree >= 0; degree--) {\r\n                res += `${coef}_{${degree}}`;\r\n                if (degree > 0) res += `${symbol}^{${degree}} + `;\r\n            }\r\n        }\r\n        return res + (inline ? \"\" : \" $$\");\r\n    };\r\n    derivative = () => {\r\n        const result = this.copy(true);\r\n        if (!result.dot) {\r\n            const n = result.a.length - 1;\r\n            const da = Array(n).fill(0);\r\n            for (let i = n; i >= 1; i--) da[n - i] = i * result.a[n - i];\r\n            result.a = [...da];\r\n        }\r\n        if (result.plus) result.plus = result.plus.derivative();\r\n        return result;\r\n    };\r\n\r\n\r\n    expression = () => {\r\n        if (this.a instanceof Array) {\r\n            const n = this.a.length - 1;\r\n            if (\r\n                !n ||\r\n                !this.a.slice(0, n).filter((ci) => ci.toString() !== \"0\").length\r\n            )\r\n                return this.a[n].toString();\r\n            return this.a\r\n                .map((a_i, i) =>\r\n                    a_i\r\n                        ? Algebra.coefy(a_i, i, n) +\r\n                          (i < n\r\n                              ? this.symbol +\r\n                                (i < n - 1\r\n                                    ? \"^\" + (n - i).toString()\r\n                                    : \"\")\r\n                              : \"\")\r\n                        : \"\"\r\n                )\r\n                .join(\"\"); // joins all the coefficients, symbols, etc all together as for polynomal functions\r\n        }\r\n        return this.a.toString();\r\n    }\r\n\r\n    devide = (operand) => {\r\n        if(operand instanceof Poly && this.symbol === operand.symbol){\r\n            return new Fraction(this.getA(), operand.getA(), this.symbol);\r\n        }\r\n        if(operand === +operand)\r\n            return this.multiply(1 / Number(operand));\r\n        // is it true??\r\n        return super.devide();\r\n    }\r\n}\r\n","import { error_codes } from \"config\";\r\n\r\nexport default class NotScalarError extends Error {\r\n    \r\n    constructor(cause = null){ // the parameter with problem\r\n        super(cause ? `${cause} => این عبارت باید اسکالر باشد!!` : \"این خطا بدلیل استفاده از یک عبارت غیر اسکالر در مکان غیر مجاز رخ داده است!\")\r\n        this.name = \"NotNumberError\";\r\n        this.type = \"Numeric\";\r\n        this.code = error_codes.not_scalar;\r\n        this.cause = cause;\r\n    }\r\n\r\n    describe = () => {\r\n        console.log(this.message + (this.cause ? \"\\n\" + this.cause : \"\"));\r\n        return this.message + (this.cause ? \"\\n\" + this.cause.toString() : \"\");\r\n    }\r\n}","import NotScalarError from \"errors/algebra/NotScalarError\";\r\nimport StandardInputSignal from \"math/input-signals\";\r\nimport { round, strictPrecisionFormat } from \"../calculus\";\r\n\r\nclass Algebra {\r\n    // symbolic expressions\r\n    constructor(\r\n        a,\r\n        { symbol = \"t\", type = \"poly\", b, dot, plus, teta = 0, previous, input }\r\n    ) {\r\n        // dot is the interface between terms\r\n        // g(t) = a * f(t) * {dot: as Algebra}\r\n        // teta is the offset for wt + alpha in sin/cos/tan/..\r\n\r\n        this.symbol = symbol;\r\n        this.type = type.toLowerCase();\r\n        this.setA(a).setB(b).setTeta(teta);\r\n\r\n        this.input = input; // u(t), r(t), puls, ...\r\n        if (dot) {\r\n            this.dot = dot.copy();\r\n        } // multiply a Algebra from different type into 'this'\r\n\r\n        if (plus) {\r\n            this.plus = plus.copy();\r\n            this.simplify();\r\n        } // add another Algebra with different type to this one\r\n\r\n        this.previous = previous; // the previous term in the chained Algebra objects\r\n        // term.plus => next term, term.previous => previous term, term.dot => an algebra from another type that is multiplied to actual term\r\n        // F(u) = a.f(u).dot(u) + term.plus(u)\r\n        this.link();\r\n    }\r\n    static identify = (parameter) => {\r\n        if (parameter instanceof Array)\r\n            return parameter.map((pi) =>\r\n                pi instanceof Algebra || pi instanceof StandardInputSignal\r\n                    ? pi.copy()\r\n                    : round(pi)\r\n            );\r\n        else if (parameter instanceof Algebra) {\r\n            return parameter.copy();\r\n        } else if (typeof parameter === \"number\") return round(parameter);\r\n        else if(typeof parameter === 'string') return parameter;\r\n        else if (!parameter) return 0;\r\n        throw new NotScalarError(parameter);\r\n    };\r\n    setA = (a) => {\r\n        this.a = Algebra.identify(a);\r\n        return this;\r\n    };\r\n    getA = () => this.a;\r\n\r\n    setB = (b) => {\r\n        this.b = Algebra.identify(b);\r\n        return this;\r\n    };\r\n    getB = () => this.b;\r\n\r\n    setTeta = (teta) => {\r\n        this.teta = Algebra.identify(teta);\r\n        return this;\r\n    };\r\n    getTeta = () => this.teta;\r\n    // CONNECT AND LINK METHODS, FIND FIRST TERM AND LAST TERM AND ...\r\n    end = () => {\r\n        // returns the end term in the algebratic chain\r\n        let last = this;\r\n        while (last.plus) last = last.plus;\r\n        return last;\r\n    };\r\n\r\n    first = () => {\r\n        // returns the first term in the algebratic chain\r\n        let fst = this;\r\n        while (fst.previous) fst = fst.previous;\r\n        return fst;\r\n    };\r\n\r\n    enddot = () => {\r\n        // returns the end term in the algebratic chain\r\n        let last = this;\r\n        while (last.dot) last = last.dot;\r\n        return last;\r\n    };\r\n\r\n    firstdot = () => {\r\n        // returns the first term in the algebratic chain\r\n        let fst = this;\r\n        // WRONG *****************************\r\n        //while (fst.previous) fst = fst.previous;\r\n        return fst;\r\n    };\r\n    link = () => {\r\n        // some times .previous links are broken; so i decided to write this method just to make sure everything is connected\r\n        let term = this.first();\r\n        if (!term) term = this; // in case this.first() returns wrong answer\r\n        while (term.plus) {\r\n            if (term.plus) term.plus.previous = term;\r\n            term = term.plus; // go to next term in the chain\r\n        }\r\n        return this;\r\n    };\r\n\r\n    copy = (linkPrevious = false) =>\r\n        new Algebra(this.a, {\r\n            type: this.type,\r\n            b: this.b,\r\n            dot: this.dot,\r\n            plus: this.plus,\r\n            symbol: this.symbol,\r\n            teta: this.teta,\r\n            input: this.input,\r\n            previous: linkPrevious ? this.previous : null,\r\n        });\r\n\r\n    // SORT THE MULTIPLIERD TERMS ( TERMS CONNECTED WITH this.dot) IN A SPECIFIC ORDER (FOR BETTER SHOW AND COMPARE AND ETC.)\r\n    // LOOK HERE IT STILL HAS BUGS\r\n    sort = () => {\r\n        // sort .dot in special order: poly - exp - frac - ...\r\n        const orders = [\"poly\", \"exp\", \"frac\"];\r\n        let position = this;\r\n        for (const order of orders) {\r\n            while (position) {\r\n                let func = position.dot;\r\n                while (func) {\r\n                    if (func.type === order && !position.isPrior(order)) {\r\n                        const temp = position.copy();\r\n                        position.a =\r\n                            func.a instanceof Array ? [...func.a] : func.a;\r\n                        position.type = func.type;\r\n                        position.symbol = func.symbol;\r\n                        if (func.b instanceof Array) position.b = [...func.b];\r\n                        else position.b = func.b;\r\n\r\n                        func.a = temp.a instanceof Array ? [...temp.a] : temp.a;\r\n                        func.type = temp.type;\r\n                        func.symbol = temp.symbol;\r\n                        if (temp.b instanceof Array) func.b = [...temp.b];\r\n                        else func.b = temp.b;\r\n                    }\r\n                    func = func.dot;\r\n                }\r\n                position = position.dot;\r\n            }\r\n        }\r\n    };\r\n\r\n    isPrior = (order) => {\r\n        const orders = [\"poly\", \"exp\", \"frac\"];\r\n        const thisValue = orders.findIndex((or) => or === this.type);\r\n        const orderValue = orders.findIndex((or) => or === order);\r\n        return thisValue <= orderValue;\r\n    };\r\n\r\n    // CHECK IF ONE TERMS CAN BE ADDED TO ANOTHER ONE (MEANING THEY HAVE SAME PARAMETRIC TERMS)\r\n    unifiable = (exp) => {\r\n        // check if this is unifiable with expression:exp\r\n        //this.sort();\r\n        //exp.sort();\r\n        if (exp && this.type === exp.type && this.symbol === exp.symbol) {\r\n            // check if this and exp are sumable\r\n            // check .dot s:\r\n            let isUnifiable = true;\r\n            if (this.dot || exp.dot)\r\n                isUnifiable = this.dot && this.dot.unifiable(exp.dot);\r\n            \r\n            console.log(\"first: \", this.toString());\r\n            console.log(\"first: \", exp.toString());\r\n            if (this.b instanceof Array && exp.b instanceof Array) {\r\n                if (this.b.length === exp.b.length) {\r\n                    const sameOnes = this.b.filter(\r\n                        (item, idx) => item === exp.b[idx]\r\n                    );\r\n                    return isUnifiable && this.b.length === sameOnes.length;\r\n                }\r\n            }\r\n            else if(this.b instanceof Algebra)\r\n                return isUnifiable && this.b.equals(exp.b);\r\n            return isUnifiable && exp.b === this.b;\r\n        }\r\n        return false;\r\n    };\r\n\r\n    static valueOf = (x, t = 0) => {\r\n        if (x) {\r\n            let value = 0;\r\n            if (x instanceof Algebra || x instanceof StandardInputSignal)\r\n                value = x.$(t);\r\n            else if (x instanceof Array)\r\n                value = Algebra.polynomialValueAt(x, t);\r\n            else value = x;\r\n            return value;\r\n        }\r\n        return 0;\r\n    };\r\n\r\n    static polynomialValueAt = (arr, t) => {\r\n        let value = 0;\r\n        const n = arr.length - 1;\r\n        for (let i = 0; i <= n; i++) {\r\n            value += arr[i] * t ** (n - i);\r\n        }\r\n        return value;\r\n    };\r\n    // REMOVE REDUNDANT TERMS, SIGNS AND ETC.\r\n    simplify = () => {\r\n        let term = this.first();\r\n        while (term) {\r\n            if (term instanceof Algebra) {\r\n                if (\r\n                    term.a === 0 ||\r\n                    Algebra.polynomial(term.a, term.symbol) === 0\r\n                ) {\r\n                    if (term.previous) {\r\n                        term.previous.plus = term.plus;\r\n                    } else {\r\n                        // remove first term and transfer the second term to first one\r\n                        if (this === term) term.redundant = true;\r\n                        if (term.plus) {\r\n                            term = term.plus.copy(true);\r\n                            if (term.plus) {\r\n                                term.plus = term.plus.plus;\r\n                                if (term.plus) term.plus.previous = term;\r\n                            }\r\n                            term.previous = null;\r\n                        }\r\n                    }\r\n                    // }\r\n                }\r\n            }\r\n            term = term.plus;\r\n        }\r\n        return this;\r\n    };\r\n\r\n    $ = (t) => {\r\n        // valueOf function in certain point\r\n        // I used character $ in many places as acronym for \"set\" in setters, so $ here means that set the t ( or x or whatever) with a certain point\r\n        // for each type just implement the method literally\r\n        let result = this.valueAt(t);\r\n        if (this.dot) result *= this.dot.$(t);\r\n        if (this.plus) result += this.plus.$(t);\r\n\r\n        return result;\r\n    };\r\n\r\n    label = (name = undefined, index = undefined) =>\r\n        (name\r\n            ? name +\r\n              (index !== undefined ? \"_{\" + index + \"}\" : \"\") +\r\n              \"(\" +\r\n              this.symbol +\r\n              \") = \"\r\n            : \"\") + this.toString();\r\n\r\n    // RETURNS THE BEST AND SIMPLE AND SHORTEST WAY TO SHOW COEFFICIENTS\r\n    static coefy = (a_i, i, n) => {\r\n        if (a_i instanceof Algebra) {\r\n            let str = \"\";\r\n            let ai = a_i.copy();\r\n            if (i > 0) {\r\n                // write a method to edit all the + - occuring next to each other in toString()\r\n                if (ai.type === \"complex\" && typeof ai.a === \"number\") {\r\n                    if (ai.a < 0) {\r\n                        str += \" - \";\r\n                        ai.a *= -1;\r\n                    } else if (!ai.a && typeof ai.b === \"number\" && ai.b < 0) {\r\n                        str += \" - \";\r\n                        ai.b *= -1;\r\n                    }\r\n                } else str += \" + \";\r\n            }\r\n            return str + ai.toString(i < n && a_i.hasMultiTerms());\r\n        }\r\n        if (a_i instanceof StandardInputSignal) {\r\n            //EDIT THIS PART TOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO\r\n            let str = i > 0 ? \" + \" : \"\";\r\n            return str + a_i.toString(i < n && a_i.hasMultiTerms());\r\n        } else {\r\n            if (n === 0) return strictPrecisionFormat(a_i);\r\n            if (a_i === 0) return \"\";\r\n            if (i !== 0) {\r\n                let s = \"\";\r\n                if (a_i < 0) {\r\n                    s += \" - \";\r\n                    a_i *= -1;\r\n                } else s += \" + \";\r\n\r\n                if (a_i === 1 && i < n) return s;\r\n                return s + strictPrecisionFormat(a_i);\r\n            }\r\n            if (a_i === 1) return \"\";\r\n            if (a_i === -1) return \"-\";\r\n\r\n            return strictPrecisionFormat(a_i);\r\n        }\r\n    };\r\n\r\n    // DECIPHER THE OBJECT TO ITS POLYNOMINAL FORM (IF IT IS ONE ACTUALLY)\r\n    static polynomial = (coefs, symbol) => {\r\n        if (coefs instanceof Array) {\r\n            const n = coefs.length - 1;\r\n            if (\r\n                !n ||\r\n                !coefs.slice(0, n).filter((ci) => ci.toString() !== \"0\").length\r\n            )\r\n                return coefs[n].toString();\r\n            return coefs\r\n                .map((a_i, i) =>\r\n                    a_i\r\n                        ? Algebra.coefy(a_i, i, n) +\r\n                          (i < n\r\n                              ? symbol +\r\n                                (i < n - 1\r\n                                    ? \"^{\" + (n - i).toString() + \"}\"\r\n                                    : \"\")\r\n                              : \"\")\r\n                        : \"\"\r\n                )\r\n                .join(\"\"); // joins all the coefficients, symbols, etc all together as for polynomal functions\r\n        }\r\n        return coefs.toString();\r\n    };\r\n\r\n    join = () => {\r\n        // connect this term to its next terms; considering the right use of + or -\r\n        if (this.plus) {\r\n            let operator = \"+\",\r\n                next = this.plus.copy();\r\n            if (next.a instanceof Array) {\r\n                if (next.a[0] < 0) {\r\n                    operator = \"-\";\r\n                    next.a[0] *= -1;\r\n                }\r\n            } else {\r\n                if (next.a < 0) {\r\n                    operator = \"-\";\r\n                    next.a *= -1;\r\n                }\r\n            }\r\n            return operator + next.toString();\r\n        }\r\n        return \"\";\r\n    };\r\n\r\n    hasMultiTerms = () => {\r\n        if (this.plus) return true;\r\n        if (this.a instanceof Array && this.type !== \"frac\")\r\n            return this.a.filter((ai) => ai !== 0).length > 1;\r\n        return false;\r\n    };\r\n    isTriangular = () =>\r\n        this.type === \"sin\" ||\r\n        this.type === \"cos\" ||\r\n        this.type === \"tan\" ||\r\n        this.type === \"cot\";\r\n\r\n    // MATHEMATICAL OPERATIONS\r\n    // static add = (expressions) => expressions.map((el) => el.toString()).join(\" + \");\r\n    add = (right) => {\r\n        // result = this + operand\r\n        let result = this.link().copy();\r\n        if (right instanceof Algebra) {\r\n            let operand = right.link().copy();\r\n\r\n            let x = result; // now we try to add each term with its unifiable term in y\r\n            while (x) {\r\n                let y = operand;\r\n                while (y) {\r\n                    if (x.unifiable(y)) {\r\n                        if (x.a instanceof Algebra) x.a = x.a.add(y.a);\r\n                        else if (y.a instanceof Algebra) x.a = y.a.add(x.a);\r\n                        // **************************************************\r\n                        // else if x.a || y.a instanceof StandardInputSignal\r\n                        // *********************************************\r\n                        else if (x.a instanceof Array) {\r\n                            if (y.a instanceof Array) {\r\n                                if (y.a.length > x.a.length) x.a = [...y.a];\r\n                                for (\r\n                                    let i = 1;\r\n                                    i <= y.a.length && i <= x.a.length;\r\n                                    i++\r\n                                )\r\n                                    x.a[x.a.length - i] += y.a[y.a.length - i];\r\n                            } else {\r\n                                x.a[x.a.length - 1] += y.a;\r\n                            }\r\n                        } else {\r\n                            x.a += y.a;\r\n                        }\r\n                        // remove the term in y that has been processed\r\n                        if (y.previous) {\r\n                            y.previous.plus = y.plus;\r\n                            if (y.plus) y.plus.previous = y.previous;\r\n                            y.a = 0;\r\n                        }\r\n\r\n                        // its the first term\r\n                        else operand = operand.plus;\r\n                        // after this the garbage collector will remove the term because it has no reference to it\r\n                    }\r\n                    y = y.plus;\r\n                }\r\n                // if(x.plus) x.plus.previous = x;\r\n                x = x.plus; // go to next term in the chain\r\n            }\r\n\r\n            if (operand) {\r\n                // if the above algorythm leaves operand with non-null value\r\n                /// it means there was terms in the operand's algebratic chain that are'nt unifiable with x terms\r\n                // so we must connect the leftovers to last terms of the result\r\n                if (Algebra.polynomial(result.a, result.symbol) !== \"0\") {\r\n                    if (\r\n                        Algebra.polynomial(operand.getA(), operand.symbol) !==\r\n                        \"0\"\r\n                    ) {\r\n                        let endTerm = result.end();\r\n                        endTerm.plus = operand;\r\n                        endTerm.plus.previous = result;\r\n                    }\r\n                } else result = operand.copy(); // connect to next term\r\n            }\r\n            return result.simplify();\r\n        } else if (right instanceof StandardInputSignal) {\r\n            const endTerm = result.end();\r\n            endTerm.plus = right.copy();\r\n            endTerm.plus.previous = endTerm;\r\n        }\r\n        return result;\r\n    };\r\n\r\n    arrangeDots = () => {\r\n        let term = this;\r\n        let input = null;\r\n        while (term.dot) {\r\n            // enhance the algo for cases that more than one input signal erxists in .dot chain\r\n            if (term.dot instanceof StandardInputSignal) {\r\n                input = term.dot;\r\n                term.dot = term.dot.dot;\r\n            }\r\n            if (term.dot) term = term.dot;\r\n        }\r\n        term.dot = input;\r\n    };\r\n    // INCOMPLETE ***********\r\n    multiply = (operand) => {\r\n        const y = this.copy().link();\r\n        if (operand instanceof Algebra) {\r\n            // operand algebra or complex\r\n            // ***** TODO:  ****************\r\n            if (operand.type === \"poly\") {\r\n                if (this.type === \"poly\" || this.type === \"frac\") {\r\n                    // NEEDS ERDITING for FRACTIONs\r\n                    if (this.symbol === operand.symbol) {\r\n                        const ao = operand.getA();\r\n                        const no = ao.length - 1;\r\n                        const As = [];\r\n                        for (let i = no; i >= 0; i--) {\r\n                            if (operand.a[i]) {\r\n                                const zeros = Array(no - i).fill(0);\r\n                                const a = [...y.a].map(\r\n                                    (yai) => yai * operand.a[i]\r\n                                );\r\n                                a.push(...zeros);\r\n                                As.push(a);\r\n                            }\r\n                        }\r\n                        // now sum all the products\r\n                        console.table(As);\r\n                        let product = As.pop();\r\n                        for (let j = 0; j < As.length; j++)\r\n                            for (\r\n                                let i = 1;\r\n                                i <= As[j].length && i <= product.length;\r\n                                i++\r\n                            )\r\n                                product[product.length - i] +=\r\n                                    As[j][As[j].length - i];\r\n\r\n                        y.a = product;\r\n                        if (operand.dot) {\r\n                            // link dots ***IS THIS TRUE?>***\r\n                            const endDotTerm = y.enddot();\r\n                            endDotTerm.dot = operand.dot.copy(); // multiply\r\n                            endDotTerm.dot.previous = endDotTerm;\r\n                        }\r\n                    }\r\n                }\r\n            } else if (y.type !== operand.type && operand.plus) {\r\n                // like: exp(f(...)) * [Asin(...) * Bcos(...)]\r\n                // UPDATE SELF MULTIPLY AFTER SOLVING THIS ISSUE\r\n                y.plus = y.multiply(operand.plus.copy());\r\n                const lastyDot = y.enddot();\r\n                if(typeof y.a === 'number' && typeof operand.a === 'number' && operand.a !== 1){\r\n                    y.a *= operand.a;\r\n                    operand.a = 1;\r\n                }\r\n                lastyDot.dot = operand.copy();\r\n                lastyDot.dot.previous = lastyDot;\r\n                // UPDATE SELF MULTIPLY AFTER SOLVING THIS ISSUE\r\n\r\n            } else {\r\n                const endDotTerm = y.enddot();\r\n                if (typeof y.a === \"number\" && typeof operand.a === \"number\") {\r\n                    y.a *= operand.a;\r\n                    operand.a = 1;\r\n                }\r\n                endDotTerm.dot = operand.copy(); // multiply\r\n                endDotTerm.dot.previous = endDotTerm;\r\n            }\r\n            if (y.plus) y.plus = y.plus.multiply(operand);\r\n            if (operand.plus) y.end().plus = y.multiply(operand.plus);\r\n            return y; // for now just to avoid crashes\r\n        } else if (operand instanceof StandardInputSignal) {\r\n            // const endDotTerm = y.enddot();\r\n            // endDotTerm.dot = operand.copy(); // multiply\r\n            // endDotTerm.dot.previous = endDotTerm;\r\n            y.input = operand.copy();\r\n            if (y.plus) y.plus = y.plus.multiply(operand);\r\n        } else {\r\n            // scalar multiply\r\n            if (operand instanceof Algebra) {\r\n            } else {\r\n                if (y.a instanceof Array) y.a = y.a.map((ai) => operand * ai);\r\n                else if (y.a instanceof Algebra) y.a = y.a.multiply(operand);\r\n                else y.a = y.a * operand;\r\n            }\r\n            if (y.plus) y.plus = y.plus.multiply(operand);\r\n        }\r\n        // console.log(\"y = \", y, \"operand = \", operand)\r\n        return y;\r\n    };\r\n\r\n    selfmultiply = (operand) => {\r\n        if (operand instanceof Algebra) {\r\n            // operand algebra or complex\r\n            // ***** TODO:  ****************\r\n            if (operand.type === \"poly\") {\r\n                if (this.type === \"poly\" || this.type === \"frac\") {\r\n                    // NEEDS ERDITING for FRACTIONs\r\n                    if (this.symbol === operand.symbol) {\r\n                        const ao = operand.getA();\r\n                        const no = ao.length - 1;\r\n                        const As = [];\r\n                        for (let i = no; i >= 0; i--) {\r\n                            if (ao[i]) {\r\n                                const zeros = Array(no - i).fill(0);\r\n                                const a = [...this.a].map(\r\n                                    (yai) => yai * operand[i]\r\n                                );\r\n                                a.push(...zeros);\r\n                                As.push(a);\r\n                            }\r\n                        }\r\n                        // now sum all the products\r\n                        const product = As.pop();\r\n                        for (let i = 0; i < product.length; i++) {\r\n                            for (let j = 0; j < As.length; j++) {\r\n                                if (i < As[j].length) product[i] += As[j][i];\r\n                            }\r\n                        }\r\n                        this.a = product;\r\n                        if (operand.dot) {\r\n                            // link dots ***IS THIS TRUE?>***\r\n                            const endDotTerm = this.enddot();\r\n                            endDotTerm.dot = operand.dot.copy(); // multiply\r\n                            endDotTerm.dot.previous = endDotTerm;\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                const endDotTerm = this.enddot();\r\n                endDotTerm.dot = operand.copy(); // multiply\r\n                endDotTerm.dot.previous = endDotTerm;\r\n                if (this.plus) this.plus = this.plus.multiply(operand);\r\n            }\r\n        } else if (operand instanceof StandardInputSignal) {\r\n            // this.dot = operand.copy(); // multiply\r\n            // this.dot.previous = this;\r\n            this.input = operand.copy();\r\n            if (this.plus) this.plus.selfmultiply(operand);\r\n            if (operand.plus) this.end().plus = this.multiply(operand.plus);\r\n        } else {\r\n            // scalar multiply\r\n            if (this.a instanceof Array)\r\n                this.a = this.a.map((ai) => operand * ai);\r\n            else this.a *= operand;\r\n\r\n            if (this.plus) this.plus.selfmultiply(operand);\r\n        }\r\n    };\r\n\r\n    negation = () => this.multiply(-1);\r\n\r\n    substract = (operand) => this.add(operand.negation());\r\n\r\n    devide = (operand) => {\r\n        if(operand === +operand)\r\n            // scaler\r\n            return this.multiply(1 / Number(operand));\r\n        \r\n        // u need to handle Complex objects as Algebra using their type to recognize them\r\n        if (operand instanceof Algebra) {\r\n            // operand algebra or complex\r\n            // ***** TODO:  ****************\r\n            // first u must do everything to simplify\r\n            // second at the simplest state of the terms,\r\n            // construct a new Algebra of \"frac\" type\r\n            return this.copy(); // for now just to avoid crashes\r\n        } \r\n    };\r\n\r\n    devideInverse = (k) =>{\r\n        if(k === +k){\r\n            return new Algebra([k], {symbol: this.symbol, type: \"frac\", b: [1]});\r\n        }\r\n        else if(k instanceof Algebra)\r\n            return k.devide(this);\r\n    }\r\n\r\n    laplace = () => {};\r\n\r\n    static areTheSame = (el1, el2) => {\r\n        // checkes the sameness of parameters like .a .b .teta , etc.\r\n        if(el1 instanceof Algebra && el2 instanceof Algebra)\r\n            return el1.equals(el2);\r\n        else if(el1 instanceof Array && el2 instanceof Array){\r\n            if(el1.length === el2.length){\r\n                let i = 0;\r\n                for(i = 0; i < el1.length; i++)\r\n                    if(el1[i] !== el2[i]) break;\r\n                return i >= el1.length;\r\n                \r\n            }\r\n        }\r\n        return typeof el1 === typeof el2 && el1 === el2;\r\n    }\r\n    equals = (operand) => operand instanceof Algebra && \r\n                            this.type === operand.type && \r\n                            this.symbol === operand.symbol &&\r\n                            this.type === operand.type &&\r\n                            this.symbol === operand.symbol &&\r\n                            Algebra.areTheSame(this.a, operand.a) &&\r\n                            Algebra.areTheSame(this.b, operand.b) &&\r\n                            Algebra.areTheSame(this.teta, operand.teta) &&\r\n                            (!this.dot || this.dot.equals(operand.dot)) &&\r\n                            (!this.plus || this.plus.equals(operand.plus)) &&\r\n                            (!this.previous || this.previous.equals(operand.previous));\r\n\r\n\r\n    static areTheseTwoEqual = (p1, p2) =>\r\n        p1 instanceof Algebra\r\n            ? p1.equals(p2)\r\n            : p2 instanceof Algebra\r\n            ? p2.equals(p1)\r\n            : p1 === p2;\r\n    // DECIPHERS THE CONNECT OBJECTS TO UNDERSTANDABLE MATHMATICALLY SHAPED TEXT\r\n    // IT IS FORMATTED COMPATIBLE FOR MathJax component\r\n    toString = (parenthesis = false) => {\r\n        // this.arrangeDots();\r\n        this.simplify(); // simplify current chain that's left from unknown number of operations\r\n        let formula = \"\";\r\n        // if ... + 0 || 0 + ... appears ===>>>>> see below !!\r\n        if (!this.a) return \"0\"; // what if **************************************** 0 / 0\r\n        if (parenthesis) formula += \"(\";\r\n        switch (this.type.toLowerCase()) {\r\n            case \"exp\": {\r\n                // if (this.a < 0) formula += \"(\";\r\n                let a0 = this.a;\r\n                if (a0 < 0) {\r\n                    formula += \"-\";\r\n                    a0 *= -1;\r\n                }\r\n                if (a0 !== 1)\r\n                    if (a0 instanceof Algebra)\r\n                        formula += a0.toString(\r\n                            a0 instanceof Algebra && a0.hasMultiTerms()\r\n                        );\r\n                    else if (a0 instanceof Array)\r\n                        // testTEST\r\n                        formula += Algebra.polynomial(a0, this.symbol);\r\n                    // FOR TEST\r\n                    else formula += strictPrecisionFormat(a0);\r\n                if (this.dot instanceof Algebra)\r\n                    formula += this.dot.toString(\r\n                        this.dot instanceof Algebra && this.dot.hasMultiTerms()\r\n                    );\r\n                if (this.b !== 0) {\r\n                    if (this.a !== 0) {\r\n                        formula += \"e^{\";\r\n                        let e0 = this.b;\r\n                        if (this.b instanceof Algebra)\r\n                            formula += this.b.toString(\r\n                                this.b instanceof Algebra &&\r\n                                    this.b.hasMultiTerms()\r\n                            );\r\n                        else if (this.b instanceof Array)\r\n                            formula += Algebra.polynomial(this.b, this.symbol);\r\n                        else {\r\n                            if (e0 < 0) {\r\n                                formula += \"-\";\r\n                                e0 *= -1;\r\n                            }\r\n                            if (e0 !== 1) formula += e0;\r\n                        }\r\n                        formula += this.symbol + \"}\";\r\n                    }\r\n                    if (this.input) formula += this.input.toString();\r\n                } else {\r\n                    if (a0 !== 1 || !this.dot)\r\n                        formula += strictPrecisionFormat(this.a);\r\n                }\r\n                // if (this.a < 0) formula += \")\";\r\n                if (this.plus) formula += this.join(); // if there's a next term: casscade toString() calls\r\n                break;\r\n            }\r\n            case \"poly\":\r\n                formula += Algebra.polynomial(this.a, this.symbol);\r\n                if (this.dot instanceof Algebra)\r\n                    formula += this.dot.toString(\r\n                        this.dot instanceof Algebra && this.dot.hasMultiTerms()\r\n                    );\r\n                if (this.input) {\r\n                    formula += (parenthesis ? \")\" : \"\") + this.input.toString();\r\n                    parenthesis = false;\r\n                }\r\n                if (this.plus) formula += this.join(); // if there's a next term: casscade toString() calls\r\n                break;\r\n            case \"frac\": {\r\n                if (this.dot instanceof Algebra)\r\n                    formula += this.dot.toString(\r\n                        this.dot instanceof Algebra && this.dot.hasMultiTerms()\r\n                    );\r\n                const numerator = Algebra.polynomial(this.a, this.symbol);\r\n                formula +=\r\n                    numerator !== \"0\"\r\n                        ? \"\\\\frac{\" +\r\n                          numerator +\r\n                          \"}{\" +\r\n                          Algebra.polynomial(this.b, this.symbol) +\r\n                          \"}\"\r\n                        : \"0\";\r\n                if (this.input) formula += this.input.toString();\r\n                if (this.plus) formula += this.join(); // if there's a next term: casscade toString() calls\r\n\r\n                break;\r\n            }\r\n            case \"sin\":\r\n            case \"asin\":\r\n            case \"cos\":\r\n            case \"tan\":\r\n            case \"cot\": {\r\n                // if (this.a < 0) formula += \"(\";\r\n                let a0 = this.a;\r\n                if (a0 < 0) {\r\n                    formula += \"-\";\r\n                    a0 *= -1;\r\n                }\r\n                if (a0 !== 1)\r\n                    if (a0 instanceof Algebra)\r\n                        formula += a0.toString(\r\n                            a0 instanceof Algebra && a0.hasMultiTerms()\r\n                        );\r\n                    else if (a0 instanceof Array)\r\n                        formula += Algebra.polynomial(a0, this.symbol);\r\n                    // FOR TEST\r\n                    else formula += strictPrecisionFormat(a0);\r\n                if (this.a !== 0) {\r\n                    if (this.dot && this.dot instanceof Algebra)\r\n                        formula += this.dot.toString(\r\n                            this.dot instanceof Algebra &&\r\n                                this.dot.hasMultiTerms()\r\n                        );\r\n                    if (this.b !== 0) {\r\n                        formula += this.type;\r\n                        if (this.b instanceof Algebra) {\r\n                            formula += this.b.toString(\r\n                                this.b instanceof Algebra &&\r\n                                    this.b.hasMultiTerms()\r\n                            );\r\n                        } else if (this.b instanceof Array)\r\n                            formula += Algebra.polynomial(this.b, this.symbol);\r\n                        // FOR TEST\r\n                        else {\r\n                            let w0 = this.b;\r\n                            formula += \"(\";\r\n                            if (w0 < 0) {\r\n                                formula += \"-\";\r\n                                w0 *= -1;\r\n                            }\r\n                            if (w0 !== 1) formula += strictPrecisionFormat(w0);\r\n                            formula += this.symbol;\r\n                            if (this.teta instanceof Algebra)\r\n                                formula += this.teta.toString();\r\n                            else if (this.teta) {\r\n                                let e0 = this.teta;\r\n                                if (e0 < 0) {\r\n                                    formula += \" - \";\r\n                                    e0 *= -1;\r\n                                } else formula += \" + \";\r\n                                formula += strictPrecisionFormat(e0);\r\n                            }\r\n                            formula += \")\";\r\n                        }\r\n                        if (this.input) formula += this.input.toString();\r\n                    }\r\n                    // simple num\r\n                } else {\r\n                    if (a0 !== 1 || !this.dot)\r\n                        formula += strictPrecisionFormat(this.a);\r\n                }\r\n                // if (this.a < 0) formula += \")\";\r\n                if (this.plus) formula += this.join(); // if there's a next term: casscade toString() calls\r\n                break;\r\n            }\r\n\r\n            default:\r\n                return null;\r\n        }\r\n        if (parenthesis) formula += \")\";\r\n\r\n        return formula;\r\n    };\r\n    toArray = () => {\r\n        let x = [];\r\n        const params = [\"a\", \"b\", \"teta\", \"symbol\", \"type\"],\r\n            linkers = [\"dot\", \"input\", \"plus\", \"previous\"];\r\n        for (const [key, value] of Object.entries(this)) {\r\n            if (typeof value !== \"function\") {\r\n                if (value) {\r\n                    // maximum toArray call happens\r\n                    if (params.filter((p) => p === key).length)\r\n                        x[key] =\r\n                            value instanceof Algebra ? value.toArray() : value;\r\n                    //)((value instanceof StandardInputSignal ? value.copy() : ));\r\n                    else if (linkers.filter((l) => l === key).length)\r\n                        x[key] =\r\n                            value instanceof StandardInputSignal\r\n                                ? value.copy()\r\n                                : value.toArray();\r\n                }\r\n            }\r\n        }\r\n        return x;\r\n    };\r\n}\r\n\r\nexport default Algebra;\r\n","import { round, strictPrecisionFormat } from \"../calculus\";\r\n\r\nexport default class StandardInputSignal {\r\n    constructor(amplitude = 1, type = \"u\", symbol = \"t\") {\r\n        this.symbol = symbol;\r\n        this.type = type;\r\n        this.amp = round(amplitude);\r\n    }\r\n\r\n    copy = () => new StandardInputSignal(this.amp, this.type, this.symbol);\r\n\r\n    toString = () => {\r\n        let str = \"\",\r\n            a = this.amp;\r\n        if (this.amp === -1) {\r\n            str += \"-\";\r\n            a *= -1;\r\n        }\r\n        if (a !== 1) str += strictPrecisionFormat(a);\r\n        return str + `${this.type}(${this.symbol})`;\r\n    };\r\n\r\n    ampiltude = () => this.amp;\r\n}\r\n"],"names":["Complex","preal","pimage","params","symbol","type","b","hasMultiTerms","plus","a","toString","parenthesis","isZero","rl","formula","Algebra","round","im","getA","setA","join","real","imaginary","copy","linkPrevious","dot","previous","input","conjugate","negation","magnitude$2","magnitude","phase","definiteA","definiteB","Math","atan2","t","$","NaN","isReal","hasSameTypeWith","x","realify","add","operand","Re","Im","substract","equals","isConjugateWith","multiply","push","devide","denominator","result","isNaN","setB","raiseTo","power","floor","i","devideInverse","k","extract","strNumber","replace","length","isDigit","Number","slice","sign","img","Fraction","num","den","Array","lim","numerator","Poly","setNumerator","setDenominator","valueAt","degree","n","powerTerm","derivative","da","fill","expression","filter","ci","map","a_i","atn","aArray","Symbolic","halfTermsVisible","coef","inline","res","NotScalarError","cause","describe","console","log","message","name","code","error_codes","Error","teta","identify","getB","setTeta","getTeta","end","last","first","fst","enddot","firstdot","link","term","sort","position","order","func","isPrior","temp","orders","findIndex","or","unifiable","exp","isUnifiable","sameOnes","item","idx","simplify","polynomial","redundant","label","undefined","index","operator","next","ai","isTriangular","right","y","endTerm","StandardInputSignal","arrangeDots","no","As","zeros","yai","table","product","pop","j","endDotTerm","lastyDot","selfmultiply","ao","laplace","areTheSame","toLowerCase","a0","strictPrecisionFormat","e0","w0","toArray","linkers","key","value","p","l","Object","entries","this","parameter","pi","valueOf","polynomialValueAt","arr","coefy","str","s","coefs","el1","el2","areTheseTwoEqual","p1","p2","amplitude","amp","ampiltude"],"sourceRoot":""}