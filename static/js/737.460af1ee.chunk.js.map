{"version":3,"file":"static/js/737.460af1ee.chunk.js","mappings":"qFAUAA,EAAOC,QAVP,SAA2BC,EAAKC,IACnB,MAAPA,GAAeA,EAAMD,EAAIE,UAAQD,EAAMD,EAAIE,QAE/C,IAAK,IAAIC,EAAI,EAAGC,EAAO,IAAIC,MAAMJ,GAAME,EAAIF,EAAKE,IAC9CC,EAAKD,GAAKH,EAAIG,GAGhB,OAAOC,GAG2BN,EAAOC,QAAQO,YAAa,EAAMR,EAAOC,QAAiB,QAAID,EAAOC,S,kBCNzGD,EAAOC,QAJP,SAAyBC,GACvB,GAAIK,MAAME,QAAQP,GAAM,OAAOA,GAGCF,EAAOC,QAAQO,YAAa,EAAMR,EAAOC,QAAiB,QAAID,EAAOC,S,kBCEvGD,EAAOC,QANP,SAAyBS,EAAUC,GACjC,KAAMD,aAAoBC,GACxB,MAAM,IAAIC,UAAU,sCAIUZ,EAAOC,QAAQO,YAAa,EAAMR,EAAOC,QAAiB,QAAID,EAAOC,S,kBCNvG,SAASY,EAAkBC,EAAQC,GACjC,IAAK,IAAIV,EAAI,EAAGA,EAAIU,EAAMX,OAAQC,IAAK,CACrC,IAAIW,EAAaD,EAAMV,GACvBW,EAAWC,WAAaD,EAAWC,aAAc,EACjDD,EAAWE,cAAe,EACtB,UAAWF,IAAYA,EAAWG,UAAW,GACjDC,OAAOC,eAAeP,EAAQE,EAAWM,IAAKN,IAalDhB,EAAOC,QATP,SAAsBU,EAAaY,EAAYC,GAM7C,OALID,GAAYV,EAAkBF,EAAYc,UAAWF,GACrDC,GAAaX,EAAkBF,EAAaa,GAChDJ,OAAOC,eAAeV,EAAa,YAAa,CAC9CQ,UAAU,IAELR,GAGsBX,EAAOC,QAAQO,YAAa,EAAMR,EAAOC,QAAiB,QAAID,EAAOC,S,kBCWpGD,EAAOC,QA9BP,SAA+BC,EAAKG,GAClC,IAAIqB,EAAY,MAAPxB,EAAc,KAAyB,qBAAXyB,QAA0BzB,EAAIyB,OAAOC,WAAa1B,EAAI,cAE3F,GAAU,MAANwB,EAAJ,CACA,IAIIG,EAAIC,EAJJC,EAAO,GACPC,GAAK,EACLC,GAAK,EAIT,IACE,IAAKP,EAAKA,EAAGQ,KAAKhC,KAAQ8B,GAAMH,EAAKH,EAAGS,QAAQC,QAC9CL,EAAKM,KAAKR,EAAGS,QAETjC,GAAK0B,EAAK3B,SAAWC,GAH4B2B,GAAK,IAK5D,MAAOO,GACPN,GAAK,EACLH,EAAKS,EACL,QACA,IACOP,GAAsB,MAAhBN,EAAW,QAAWA,EAAW,SAC5C,QACA,GAAIO,EAAI,MAAMH,GAIlB,OAAOC,IAG+B/B,EAAOC,QAAQO,YAAa,EAAMR,EAAOC,QAAiB,QAAID,EAAOC,S,kBC1B7GD,EAAOC,QAJP,WACE,MAAM,IAAIW,UAAU,8IAGaZ,EAAOC,QAAQO,YAAa,EAAMR,EAAOC,QAAiB,QAAID,EAAOC,S,sBCJxG,IAAIuC,EAAiB,EAAQ,OAEzBC,EAAuB,EAAQ,OAE/BC,EAA6B,EAAQ,OAErCC,EAAkB,EAAQ,OAM9B3C,EAAOC,QAJP,SAAwBC,EAAKG,GAC3B,OAAOmC,EAAetC,IAAQuC,EAAqBvC,EAAKG,IAAMqC,EAA2BxC,EAAKG,IAAMsC,KAGrE3C,EAAOC,QAAQO,YAAa,EAAMR,EAAOC,QAAiB,QAAID,EAAOC,S,sBCZtG,IAAI2C,EAAmB,EAAQ,OAW/B5C,EAAOC,QATP,SAAqC4C,EAAGC,GACtC,GAAKD,EAAL,CACA,GAAiB,kBAANA,EAAgB,OAAOD,EAAiBC,EAAGC,GACtD,IAAIC,EAAI3B,OAAOK,UAAUuB,SAASd,KAAKW,GAAGI,MAAM,GAAI,GAEpD,MADU,WAANF,GAAkBF,EAAEK,cAAaH,EAAIF,EAAEK,YAAYC,MAC7C,QAANJ,GAAqB,QAANA,EAAoBxC,MAAM6C,KAAKP,GACxC,cAANE,GAAqB,2CAA2CM,KAAKN,GAAWH,EAAiBC,EAAGC,QAAxG,IAG4C9C,EAAOC,QAAQO,YAAa,EAAMR,EAAOC,QAAiB,QAAID,EAAOC,S,8NCVnH,WAs4BE,IAAIqD,EAAGC,IAAKC,IAAKC,IAAKC,IAAKC,YAAaC,OAAQC,QAASC,OAAQC,QAASC,OAAQC,QAASC,IAAKC,sBAAuBC,QAASC,WAAYC,KAAMC,QAASC,QAASC,QAASC,SAAUC,iBAAkBC,IAAKC,GAAIC,GAAIC,GAAIC,GAAIC,GAAIC,GAAIC,QAASC,MAAOC,OAAQC,QAASC,MAAOC,SAAUC,cAAeC,MAAOC,MAAOC,SAAUC,SAAUC,KAAMC,KAAMC,SAAUC,IAAKC,KAAMC,SAAUC,MAAOC,UAAWC,UAAWC,gBAAiBC,WAAYC,SAAUC,eAAgBC,YAAaC,kBAAmBC,WAAYC,eAAgBC,OAAQC,OAAQC,OAAQC,YAAaC,WAAYC,IAAKC,cAAeC,IAAKC,MAAOC,SAAUC,GAAIC,IAAKC,OAAQC,KAAMC,MAAOC,OAAQC,EAAGC,MAAOC,SAAUC,SAAUC,MAAOC,cAAeC,SAAUC,SAAUC,IAAKC,KAAMC,KAAMC,IAAKC,OAAQC,OAAQC,OAAQC,KAAMC,UAAWC,SAAUC,SAAUC,SAAUC,SAAUC,iBAAkBC,YAAaC,aAAcC,YAAaC,aAAcC,YAAaC,aAAcC,SAAUC,aAAcC,aAAcC,aAAcC,cAAeC,aAAcC,WAAYC,YAAaC,aAAcC,WAAYC,cAAeC,mBAAoBC,WAAYC,WAAYC,cAAeC,cAAeC,UAAWC,UAAWC,cAAeC,SAAUC,UAAWC,YAAaC,YAAaC,YAAaC,iBAAkBC,gBAAiBC,SAAUC,SAAUC,WAAYC,cAAeC,QAASC,YAAaC,WAAYC,cAAeC,cAAeC,SAAUC,UAAWC,SAAUC,YAAaC,YAAaC,YAAaC,YAAaC,eAAgBC,gBAAiBC,YAAaC,WAAYC,WAAYC,SAAUC,wBAAyBC,WAAYC,SAAUC,aAAcC,aAAcC,UAAWC,WAAYC,YAAYC,cAAeC,SAAUC,UAAWC,eAAgBC,aAAcC,cAAeC,SAAUC,aAAcC,cAAeC,SAAUC,YAAaC,SAAUC,cAAeC,cAAeC,SAAUC,YAAaC,YAAaC,eAAgBC,cAAeC,QAASC,WAAYC,aAAcC,kBAAmBC,WAAYC,WAAYC,eAAgBC,WAAYC,WAAYC,kBAAmBC,mBAAoBC,gBAAiBC,gBAAiBC,eAAgBC,aAAcC,WAAYC,cAAeC,UAAWC,iBAAkBC,UAAWC,UAAWC,WAAYC,WAAYC,UAAWC,SAAUC,WAAYC,mBAAoBC,YAAaC,cAAeC,SAAUC,UAAWC,UAAWC,UAAWC,WAAYC,SAAUC,SAAUC,iBAAkBC,SAAUC,UAAWC,YAAaC,YAAaC,UAAWC,YAAaC,YAAaC,YAAaC,YAAaC,YAAaC,eAAgBC,UAAWC,mBAAoBC,UAAWC,SAAUC,OAAQC,UAAWC,WAAYC,OAAQC,OAAQC,MAAOC,IAAKC,qBAAsBC,SAAUC,MAAMC,MAAOC,IAAKC,QAASC,QAASC,KAAMC,MAAOC,MAAOC,SAAUC,IAAKC,KAAMC,cAAeC,WAAYC,UAAWC,QAASC,SAAUC,KAAMC,mBAAoBC,gBAAiBC,iBAAkBC,gBAAiBC,iBAAkBC,WAAYC,IAAKC,QAASC,SAAUC,IAAKC,OAAQC,EAAGC,OAAQC,YAAaC,0CAA2CC,4CAA6CC,0BAA2BC,iBAAkBC,OAAQC,MAAOC,MAAOC,MAAOC,QAASC,IAAKC,MAAOC,SAAUC,MAAOC,EAAGC,IAAKC,IAAKC,OAAQC,WAAYC,aAAcC,eAAgBC,cAAeC,YAAaC,eAAgBC,KAAMC,IAAKC,OAAQC,UAAWC,SAAUC,GAAIC,MAAOC,QAASC,aAAcC,GAAIC,MAAOC,MAAOC,MAAOC,MAAOC,aAAcC,UAAWC,WAAYC,UAAWC,kBAAmBC,mBAAoBC,gBAAiBC,gBAAiBC,eAAgBC,eAAgBC,WAAYC,oBAAqBC,oBAAqBC,QAASC,MAAOC,SAAUC,KAAMC,YAAaC,KAAMC,MAAOC,MAAOC,QAASC,SAAUC,KAAMC,IAAKC,MAAOC,cAAeC,SAAUC,IAAKC,KAAMC,sBAAuBC,mBAAoBC,KAAMC,KAAMC,IAAKC,MAAOC,IAAKC,IAAKC,YAAaC,SAAUC,oBAAqBC,SAAUC,oBAAqBC,SAAUC,SAAUC,SAAUC,uBAAwBC,SAAUC,SAAUC,SAAUC,SAAUC,SAAUC,SAAUC,oBAAqBC,SAAUC,SAAUC,IAAKC,KAAMC,OAAQC,OAAQC,KAAMC,OAAQC,OAAQC,OAAQC,OAAQC,OAAQC,cAAeC,IAAKC,MAAOC,UAAWC,SAAUC,KAAMC,WAAYC,OAAQC,UAAWC,OAAQC,MAAOC,UAAWC,aAAcC,SAAUC,SAAUC,EAAGC,KAAMC,YAAaC,QAASC,KAAMC,IAAKC,OAAQC,KAAMC,YAAaC,WAAYC,aAAcC,YAAaC,cAAeC,oBAAqBC,MAAOC,WAAYC,YAAaC,YAAaC,4BAA6BC,qBAAsBC,OAAQC,IAAKC,YAAaC,QAAQC,cAAeC,IAAKC,0BAA2BC,2BAA4BC,QAASC,0BAA2BC,YAAaC,UAAWC,KAAMC,IAAKC,aAAcC,YAAaC,iBAAkBC,UAAWC,WAAYC,sBAAuBC,mBAAoBC,eAAgBC,0BAA2BC,sBAAuBC,2BAA4BC,4BAA6BC,0BAA2BC,kCAAmCC,sBAAuBC,oBAAqBC,uBAAwBC,6BAA8BC,qBAAsBC,sBAAuBC,sBAAuBC,mBAAoBC,oBAAqBC,6BAA8BC,iCAAkCC,wBAAyBC,sBAAsBC,OAAQC,QAASC,OAAQC,QAASC,QAAQC,QAASC,qCAAsCC,IAAKC,QAASC,gBAAiBC,kCAAmCC,MAAMC,UAAWC,eAAgBC,QAASC,QAASC,OAAQC,iBAAkBC,aAAcC,oBAAqBC,kBAAmBC,oBAAqBC,gBAAiBC,QAASC,SAAUC,OAAQC,aAAcC,OAAQC,MAAOC,KAAMC,QAASC,OAAQC,MAAOC,SAAUC,QAASC,OAAQC,QAASC,OAAQC,MAAOC,KAAMC,0BAA2BC,IAAKC,OAAQC,MAAOC,KAAMC,QAASC,MAAOC,SAAUC,OAAQC,MAAOC,KAAMC,IAAKC,QAASC,6CAA8CC,aAAcC,QAASC,iCAAkCC,eAAgBC,YAAaC,wBAAyBC,OAAQC,kBAAmBC,SAASC,wBAAyBC,mDAAoDC,cAAeC,WAAYC,SAAUC,UAAWC,UAAWC,SAAUC,UAAUC,UAAWC,gBAAiBC,QAASC,MAAOC,SAAUC,kCAAmCC,oBAAoBC,gBAAiBC,eAAgBC,cAAeC,aAAcC,gBAAiBC,kBAAmBC,gBAAiBC,WAAYC,+BAAgCC,uCAAwCC,WAAYC,UAAWC,KAAMC,UAAWC,SAAUC,yBAA0BC,2BAA4BC,YAAaC,OAAQC,gBAAiBC,oBAAqBC,OAAOC,0BAA0BC,mBAAoBC,QAASC,UAAWC,gBAAiBC,kBAAmBC,gBAAiBC,gBAAiBC,gBAAiBC,KAAMC,QAASC,SAAUC,QAASC,SAAUC,QAASC,SAAUC,UAAWC,UAAWC,UAAWC,UAAWC,KAAMC,MAAOC,GAAIC,QAAQC,eAAgBC,WAAYC,yBAA0BC,qBAAsBC,KAAMC,SAAUC,OAAQC,aAAaC,KAAMC,MAAOC,WAAYC,uBAAwBC,IAAKC,YAAaC,KAAMC,UAAWC,SAAUC,MAAOC,QAASC,aAAcC,YAAaC,OAAQC,eAAgBC,SAAUC,iBAAkBC,QAASC,KAAMC,iBAAkBC,YAAaC,4BAA6BC,4DAA6DC,gBAAiBC,yBAA0BC,KAAMC,OAAQC,SAAUC,UAAWC,iBAAkBC,KAAMC,KAAMC,MAAOC,KAAMC,KAAMC,MAAOC,KAAMC,MAAOC,WAAYC,KAAMC,iBAAkBC,kBAAmBC,UAAWC,YAAaC,wBAAyBC,iBAAkBC,cAAeC,cAAeC,oBAAqBC,cAAeC,YAAaC,gBAAiBC,wBAAyBC,WAAYC,YAAaC,aAAcC,YAAaC,YAAaC,mBAAmBC,UAAWC,cAAeC,mBAAoBC,OAAQC,MAAOC,OAAQC,OAAQC,KAAMC,aAAcC,SAAUC,mBAAoBC,gBAAiBC,KAAMC,QAAQC,aAAcC,cAAeC,aAAcC,aAAcC,cAAeC,cAAeC,UAAWC,OAAQC,YAAaC,WAAYC,OAAQC,GAAIC,IAAKC,GAAIC,GAAIC,GAAIC,GAAIC,GAAIC,WAAYC,OAAQC,SAAUC,aAAcC,SAAUC,cAAeC,oBAAqBC,YAAaC,UAAWC,WAAYC,QAASC,SAAUC,OAAQC,YAAaC,WAAYC,cAAeC,yBAA0BC,uBAAuBC,6BAA6BC,SAAUC,eAAgBC,YAAaC,KAAMC,oBAAqBC,UAAWC,UAAWC,MAAOC,MAAOC,OAAQC,iCAAkCC,MAAOC,aAAcC,OAAQC,IAAKC,SAAUC,YAAaC,UAAWC,0BAA2BC,oBAAqBC,gBAAiBC,QAASC,gBAAiBC,YAAaC,KAAKC,eAAgBC,aAAcC,YAAaC,6BAA8BC,0BAA2BC,uBAAuBC,eAAgBC,cAAeC,SAAUC,UAAWC,cAAeC,MAAOC,GAAIC,MAAOC,kBAAmBC,4BAA6BC,cAAeC,cAAeC,oBAAqBC,WAAYC,gBAAiBC,YAAaC,QAASC,QAASC,GAAIC,KAAMC,cAAeC,eAAgBC,KAAMC,WAAYC,OAAQC,OAAOC,QAASC,UAAWC,SAAUC,iBAAkBC,oBAAqBC,gBAAiBC,KAAKC,QAASC,cAAeC,KAAMC,yBAA0BC,cAAeC,uBAAuBC,aAAcC,QAASC,yBAA0BC,oBAAqBC,WAAYC,mBAAoBC,sCAAuCC,aAAcC,eAAgBC,UAAWC,iBAAkBC,iBAAkBC,cAAeC,MAAOC,oBAAqBC,QAASC,oBAAqBC,gBAAiBC,sBAAuBC,OAAQC,cAAeC,QAASC,SAAUC,cAAeC,SAAUC,YAAaC,YAAYC,WAAYC,iBAAkBC,kBAAmBC,wBAAyBC,gBAAiBC,aAAcC,UAAWC,gBAAiBC,wBAAyBC,MAAOC,UAAWC,WAAYC,sBAAuBC,kBAAmBC,wBAAyBC,WAAYC,WAAYC,iBAAkBC,eAAgBC,qBAAsBC,MAAOC,MAAOC,UAAWC,iBAAkBC,aAAcC,UAAWC,UAAWC,mBAAoBC,wBAAyBC,0BAA2BC,wBAAyBC,6BAA8BC,oCAAqCC,mCAAoCC,SAAUC,iBAAkBC,QAASC,cAAeC,WAAYC,QAASC,YAAaC,mBAAoBC,MAAOC,SAAUC,YAAYC,SAAUC,YAAaC,aAAcC,mCAAoCC,KAAMC,eAAgBC,GAAIC,SAAUC,UAAWC,gBAAiBC,eAAgBC,IAAKC,QAASC,SAAU/3B,OAAQg4B,MAAOC,MAAOC,KAAMC,WAAYC,UAAWC,OAAQC,aAAcC,UAAWC,KAAMC,aAAcC,eAAgBC,iBAAkBC,KAAMC,KAAMC,QAASC,KAAMC,QAASC,UAAWC,KAAMC,WAAYC,KAAMC,KAAMC,KAAMC,IAAKC,MAAOC,KAAMC,QAASC,WAAYC,eAAgBC,aAAcC,WAAYC,KAAMC,OAAQC,MAAOC,YAAaC,KAAMC,OAAQC,iBAAiBC,SAAUC,aAAcC,sBAAuBC,+BAAgCC,sBAAuBC,6BAA8BC,2BAA4BC,kBAAmBC,iBAAkBC,gBAAiBC,OAAQC,cAAeC,gBAAiBC,cAAeC,YAAaC,WAAYC,aAAcC,YAAaC,cAAeC,gBAAiBC,gBAAiBC,SAAUC,SAAUC,SAAUC,UAAWC,UAAWC,UAAWC,UAAWC,SAAUC,SAAUC,OAAQC,QAASC,WAAWC,wBAAyB95B,EAAG+5B,IAAKC,WAAYC,cAAeC,QAASC,UAAWC,cAAeC,MAAOC,GAAIC,GAAIC,GAAIC,GAAIC,GAAIC,GAAIC,GAAIC,GAAIC,GAAIC,GAAIC,MAAOC,eAAgBC,SAAUC,SAAUC,2BAA4BC,UAAWC,oBAAqBC,aAAcC,iBAAkBC,MAAOC,wBAAwBC,UAAUC,IAAKC,WAAYC,UAAWC,YAAaC,MAAOC,UAAWC,UAAWC,aAAcC,wDAAyDC,MAAOC,SAAUC,aAAcC,UAAWC,gBAAiBC,qBAAsBC,qBAAsBC,qBAAsBC,qBAAsBC,kBAAmBC,mBAAoBC,kBAAmBC,gBAAiBC,iBAAkBC,kBAAmBC,kBAAmBC,gBAAiBC,sBAAuBC,oBAAqBC,mBAAoBC,kBAAmBC,iBAAkBC,kBAAmBC,gBAAiBC,kBAAmBC,mBAAoBC,mBAAoBC,mBAAoBC,mBAAoBC,mBAAoBC,mBAAoBC,iBAAkBC,wBAAyBC,sBAAuBC,mBAAoBC,eAAgBC,WAAYC,oBAAqBC,WAAYC,YAAaC,aAAcC,oBAAqBC,eAAgBC,WAAYC,cAAcC,yBAA0BC,aAAcC,qBAAsBC,YAAYC,oBAAqBC,aAAcC,aAAaC,UAAWC,cAAeC,aAAcC,qBAAoBC,0BAA0BC,mBAAoBC,WAAYC,UAAWC,iBAAkBC,UAAWC,YAAaC,eAAgB5gC,KAAM6gC,sBAAuBC,UAAWC,YAAaC,YAAaC,WAAYC,qBAAsBC,aAAcC,cAAeC,YAAaC,kBAAmBC,WAAYC,iBAAkBC,KAAMC,KAAMC,KAAMC,KAAMC,MAAOC,YAAaC,WAAYC,SAAUC,YAAaC,yBAA0BC,KAAMC,YAAaC,MAAMC,oCAAqCC,uBAAuBC,IAAKC,KAAMC,cAAeC,0BAA2BC,kBAAmBC,QAASC,oBAAqBC,cAAcC,oBAAqBC,MAAOC,OAAQC,OAAQC,IAAKC,8BAA+BC,KAAMC,iBAAkBC,oBAAqBC,KAAMC,WAAYC,gBAAiBC,YAAaC,sCAAuCC,yCAA0CC,WAAYC,UAAWC,WAAYC,cAAeC,UAAWC,SAAUC,YAAaC,aAAcC,YAAaC,YAAaC,UAAWC,QAASC,mBAAoBC,KAAMC,UAAWC,YAAaC,cAAeC,aAAcC,aAAcC,eAAgBC,IAAKC,MAAOC,iBAAkBC,KAAMC,aAAcC,OAAQC,YAAaC,wBAAyBC,SAAUC,0BAA2BC,uBAAwBC,cAAeC,yBAA0BC,eAAgBC,mBAAoBC,8BAA+BC,qBAAsBC,gBAAiBC,cAAeC,oBAAoBC,KAAMC,cAAeC,kBAAmBC,2BAA4BC,WAAYC,OAAQC,MAAOC,MAAOC,eAAgBC,WAAYC,KAAMC,MAAOC,KAAMC,OAAQC,8BAA+BC,KAAMC,OAAOC,SAAUC,iBAAkBC,KAAMC,OAAQC,oBAAqBC,2BAA4BC,uCAAwCC,wBAAyBC,yBAA0BC,YAAaC,OAAQC,OAAQC,8BAA8BC,QAASC,OAAQC,OAAQC,mBAAoBC,oBAAqBC,WAAYC,UAAWC,YAAaC,UAAWC,MAAOC,UAAWC,UAAWC,IAAKC,eAAgBC,IAAKC,WAAWC,WAAWC,kBAAmBC,SAAUC,eAAgBC,cAAeC,wBAAyBC,KAAMC,SAAUC,OAAQC,UAAUC,iBAAkBC,8BAA+BC,gCAAiCC,WAAYC,UAAWC,QAASC,8BAA+BC,UAAWC,MAAOC,OAAQC,KAAMC,MAAOC,OAAQC,OAAQC,OAAQC,MAAOC,MAAOC,UAAWC,UAAWC,UAAWC,WAAYC,WAAYC,OAAQC,UAAUC,OAAQC,UAAWC,MAAOC,OAAQC,SAAUC,aAAcC,SAASC,QAASC,UAAWC,WAAYC,OAAQC,MAAOC,MAAOC,WAAYC,QAASC,QAASC,cAAeC,QAASC,MAAOC,SAAUC,OAAQC,UAAWC,KAAMC,QACp+eC,QAAU,GAAGC,eA60df,IA30dAhvB,OAASivB,oBAAQ,OAGjB7C,QAAU,QAEV50B,SAAW,EAGXpC,KAAO,IAEPrP,OAAQ,EAER4Q,gBAAiB,EAGjBF,gBAAkB,kBAElBH,kBAAoB,oBAEpBC,mBAAqB,qBAErBC,gBAAkB,kBAElBE,eAAiB,iBAIjBsoB,UAAYzoB,mBAEZoS,6DAA8D,EAE9D2b,oCAAsC,EAEtC5b,6BAA8B,EAE9BhJ,mCAAoC,EAEpCskB,SAAY,WAAW,IAmBfA,EAnBe,mEAyBrB,OAJAA,EAAS5iC,UAAU8tC,EAAI,KAEvBlL,EAAS5iC,UAAU+tC,EAAI,KAEhBnL,GAENniC,KAAKutC,MAERj0B,EAAK,WAAW,IACRA,EADQ,wBAUZ,aAAc,wBACZi0B,KAAKzqB,KAAO,GACZyqB,KAAKzqB,KAAKlD,IAAM,KAChB2tB,KAAKzqB,KAAKxC,IAAM,KAChBitB,KAAKC,EAAI,IAAIrL,SAdH,6CAEZ,WACE,OAAOxC,WAAW4N,QAHR,2BAMZ,WACE,OAAOvrB,kCAAkCurB,UAP/B,KAoCd,OAjBAj0B,EAAE/Z,UAAUujB,KAAO,KAEnBxJ,EAAE/Z,UAAUkuC,UAAY,GAExBn0B,EAAE/Z,UAAUmuC,IAAM,GAElBp0B,EAAE/Z,UAAUmpC,OAAS,KAGrBpvB,EAAE/Z,UAAUiuC,EAAI,KAEhBl0B,EAAE/Z,UAAUouC,EAAI,EAEhBr0B,EAAE/Z,UAAUquC,EAAI,EAEhBt0B,EAAE/Z,UAAUsuC,IAAM,EAEXv0B,GAENtZ,KAAKutC,MAER5jB,aAAe,GAGf9lB,KAAO,EAEP2P,IAAM,EAEN/N,OAAS,EAET8Q,IAAM,EAENyB,OAAS,EAETtB,IAAM,EAKNgN,QAAU,EAEVriB,IAAMqiB,UAENpiB,IAAMoiB,UAENniB,IAAMmiB,UAENliB,IAAMkiB,UAENjiB,YAAciiB,UAEdhiB,OAASgiB,UAET/hB,QAAU+hB,UAEV9hB,OAAS8hB,UAET7hB,QAAU6hB,UAEV5hB,OAAS4hB,UAET3hB,QAAU2hB,UAEV1hB,IAAM0hB,UAENxhB,QAAUwhB,UAEVrhB,QAAUqhB,UAEVphB,QAAUohB,UAEVnhB,QAAUmhB,UAEVlhB,SAAWkhB,UAEXzgB,QAAUygB,UAEVxgB,MAAQwgB,UAERvgB,OAASugB,UAETtgB,QAAUsgB,UAEVrgB,MAAQqgB,UAERpgB,SAAWogB,UAEXngB,cAAgBmgB,UAEhBlgB,MAAQkgB,UAERjgB,MAAQigB,UAERhgB,SAAWggB,UAEX/f,SAAW+f,UAEX9f,KAAO8f,UAEP5f,SAAW4f,UAEX3f,IAAM2f,UAEN1f,KAAO0f,UAEP7e,OAAS6e,UAET5e,OAAS4e,UAET3e,OAAS2e,UAET1e,YAAc0e,UAEdze,WAAaye,UAEbxe,IAAMwe,UAENte,IAAMse,UAENre,MAAQqe,UAERpe,SAAWoe,UAEXne,GAAKme,UAELle,IAAMke,UAENhe,KAAOge,UAEP9d,OAAS8d,UAET5d,MAAQ4d,UAER3d,SAAW2d,UAEX1d,SAAW0d,UAEXrd,IAAMqd,UAENpd,KAAOod,UAEPnd,KAAOmd,UAEPld,IAAMkd,UAENjd,OAASid,UAEThd,OAASgd,UAET/c,OAAS+c,UAETlU,OAASkU,UAETjU,UAAYiU,UAEZhU,WAAagU,UAEb/T,OAAS+T,UAET9T,OAAS8T,UAET7T,MAAQ6T,UAER5T,IAAM4T,UAEN1T,SAAW0T,UAEXxT,MAAQwT,UAERvT,IAAMuT,UAENtT,QAAUsT,UAEVrT,QAAUqT,UAEVpT,KAAOoT,UAEPnT,MAAQmT,UAERlT,MAAQkT,UAERjT,SAAWiT,UAEXhT,IAAMgT,UAEN/S,KAAO+S,UAEP5S,UAAY4S,UAEZ3S,QAAU2S,UAEV1S,SAAW0S,UAGXlS,IAAMkS,UAENjS,QAAUiS,UAEVhS,SAAWgS,UAEX/R,IAAM+R,UAEN9R,OAAS8R,UAETjR,IAAMiR,UAEN/Q,SAAW+Q,UAEX3Q,IAAM2Q,UAEN1Q,OAAS0Q,UAETjQ,OAASiQ,UAEThQ,UAAYgQ,UAEZ/P,SAAW+P,UAEX9P,GAAK8P,UAEL7P,MAAQ6P,UAER5P,QAAU4P,UAEV3P,aAAe2P,UAEfzP,MAAQyP,UAERxP,MAAQwP,UAERvP,MAAQuP,UAER1O,oBAAsB0O,UAEtBzO,oBAAsByO,UAEtBtP,MAAQsP,UAERrP,aAAeqP,UAEfpP,UAAYoP,UAEZnP,WAAamP,UAEblP,UAAYkP,UAEZ3O,WAAa2O,UAEbxO,QAAUwO,UAEVvO,MAAQuO,UAERtO,SAAWsO,UAEXrO,KAAOqO,UAEPpO,YAAcoO,UAEdnO,KAAOmO,UAEPjO,MAAQiO,UAER9J,OAAS8J,UAETlO,MAAQkO,UAER9N,KAAO8N,UAEP7N,IAAM6N,UAEN3N,cAAgB2N,UAEhB1N,SAAW0N,UAEXzN,IAAMyN,UAENxN,KAAOwN,UAEP5N,MAAQ4N,UAERrN,KAAOqN,UAEPpN,KAAOoN,UAEPlN,MAAQkN,UAERjN,IAAMiN,UAEN/M,YAAc+M,UAEd7L,IAAM6L,UAEN5L,KAAO4L,UAEP3L,OAAS2L,UAETzL,KAAOyL,UAEPxL,OAASwL,UAETvL,OAASuL,UAETtL,OAASsL,UAETrL,OAASqL,UAETpL,OAASoL,UAEThL,UAAYgL,UAEZnK,KAAOmK,UAEP7J,KAAO6J,UAIP5Q,IAAM4Q,UAENzS,KAAOyS,UAEPnS,WAAamS,UAEbxS,mBAAqBwS,UAErBvS,gBAAkBuS,UAElBtS,iBAAmBsS,UAEnBrS,gBAAkBqS,UAElBpS,iBAAmBoS,UAEnBvhB,WAAauhB,UAEbthB,KAAOshB,UAEPzhB,sBAAwByhB,UAExBjL,MAAQiL,UAER3T,qBAAuB2T,UAEvBxR,0BAA4BwR,UAE5B/J,IAAM+J,UAEN/d,MAAQ+d,UAERrR,MAAQqR,UAERpR,MAAQoR,UAERnR,MAAQmR,UAERhO,QAAUgO,UAEVjK,QAAUiK,UAEV1P,GAAK0P,UAEL9M,SAAW8M,UAEX5M,SAAW4M,UAEX1M,SAAW0M,UAEXzM,SAAWyM,UAEXxM,SAAWwM,UAEXtM,SAAWsM,UAEXrM,SAAWqM,UAEXpM,SAAWoM,UAEXnM,SAAWmM,UAEXlM,SAAWkM,UAEXjM,SAAWiM,UAEX/L,SAAW+L,UAEX9L,SAAW8L,UAEXvM,uBAAyBuM,UAEzB7M,oBAAsB6M,UAEtB3M,oBAAsB2M,UAEtBhM,oBAAsBgM,UAEtB/gB,GAAK+gB,UAEL9gB,GAAK8gB,UAEL7gB,GAAK6gB,UAEL5gB,GAAK4gB,UAEL3gB,GAAK2gB,UAEL1gB,GAAK0gB,UAELlK,YAAckK,UAEd7d,EAAI8T,IAKJnB,IAAM,IAEN9V,IAAM,IAENyP,iBAAmB,OAEnBJ,YAAc,IAEdC,0CAA4C,EAE5CC,4CAA8C,GAG9CH,OAAS,GAKTi2B,oBAAsB,GAEtBC,2BAA6B,GAE7BC,uCAAyC,GAEzChM,qBAAsB,EAEtBc,wDAA0D,CAAC,cAAe,MAAO,IAAK,IAAK,KAAM,MAAO,UAAW,MAAO,QAAS,WAAY,aAAc,SAAU,OAAQ,MAAO,MAAO,OAAQ,OAAQ,QAAS,QAAS,UAAW,OAAQ,QAAS,MAAO,OAAQ,QAO1QhB,4BAA6B,EAE7Bvb,6CAA+C,GAE/CgnB,8BAAgC,GAKhC7nB,2BAA4B,EAE5B+oB,OAAU,WAAW,IACbA,EADa,cAEjB,aAAc,qCACZ6E,KAAKO,IAAO,WACV,IAAIntC,EAAGgiC,EAAKoL,EAEZ,IADAA,EAAU,GACLptC,EAAI,EAAGgiC,EAAM7wB,OAAS,GAAK6wB,EAAMhiC,GAAKgiC,EAAMhiC,GAAKgiC,EAAM,GAAKA,EAAMhiC,IAAMA,IAC3EotC,EAAQ5tC,KAAK,GAEf,OAAO4tC,EANG,GAQZR,KAAKxlB,KAAO,MAahB,OARA2gB,EAAOnpC,UAAUyuC,KAAO,EAExBtF,EAAOnpC,UAAUuuC,IAAM,KAEvBpF,EAAOnpC,UAAU0uC,MAAQ,EAEzBvF,EAAOnpC,UAAUwoB,KAAO,KAEjB2gB,GAEN1oC,KAAKutC,MAERrnB,QAAW,WAAW,IACdA,EADc,mEAWpB,OARAA,EAAQ3mB,UAAU2uC,EAAI,EAEtBhoB,EAAQ3mB,UAAU4uC,EAAI,EAEtBjoB,EAAQ3mB,UAAUsB,EAAI,EAEtBqlB,EAAQ3mB,UAAU8tC,EAAI,GAEfnnB,GAENlmB,KAAKutC,MAERxE,YAAe,WAAW,IAClBA,EADkB,mEASxB,OANAA,EAAYxpC,UAAU6uC,OAAS,EAE/BrF,EAAYxpC,UAAU8uC,QAAU,EAEhCtF,EAAYxpC,UAAU+uC,MAAQ,EAEvBvF,GAEN/oC,KAAKutC,MAERjE,IAAM,EAEN/e,UAAY,EAEZV,mBAAqB,EAErBC,gBAAkB,EAElB+C,MAAQ,EAERF,UAAY,EAEZC,UAAY,EAEZ0d,UAAY,EAEZrN,SAAY,WACV,IAAIsR,EAAMpwC,EAAGqwC,EAAGC,EAGhB,IAFAA,EAAS,CAAC,GACVtwC,EAAI,EACGswC,EAAOvwC,OAAS6T,aAAa,CAGlC,IAFAy8B,EAAI,EACJD,EAAOG,KAAKC,KAAKxwC,GACVqwC,EAAIC,EAAOvwC,QAAUuwC,EAAOD,IAAMD,GAAM,CAC7C,GAAIpwC,EAAIswC,EAAOD,KAAO,EAAG,CACvBA,GAAK,EACL,MAEFA,KAES,IAAPA,GACFC,EAAOtuC,KAAKhC,GAEdA,GAAK,EAGP,OADAswC,EAAO18B,aAAe,EACf08B,EApBG,GAuBZ7kB,SAAW,EAEXxC,UAAY,EAEZkR,OAAS,EAEToR,SAAW,EAEXnT,OAAS,GAETuK,YAAc,GAGdwH,OAAS,GAIT5pB,QAAU,GAEVqS,oBAAsB,GAEtBpT,QAAU,GAEVspB,MAAQ,GAERna,MAAQ,EAERmO,GAAK,KAELC,GAAK,KAELC,GAAK,KAELC,GAAK,KAELC,GAAK,KAELC,GAAK,KAELC,GAAK,KAELC,GAAK,KAELC,GAAK,KAELC,GAAK,KAELsR,KAAO,KAEPtS,IAAM,KAENE,cAAgB,KAEhBnL,cAAgB,KAEhBoL,QAAU,GAEVC,UAAY,EAEZgO,UAAY,EAEZjnB,SAAU,EAEVwF,iBAAmB,KAEnB8iB,8BAAgC,GAEhCC,gCAAkC,GAElCX,kBAAoB,KAEpB1iB,gBAAkB,IAElB+gB,OAAS,SAAS8G,GAChB,OAAOtG,OAAOsG,IAGhB7c,OAAS,SAAS8c,GAChB,OAAOA,EAAEjB,IAAM/pC,MAGjBgxB,WAAa,SAASga,GACpB,OAAOA,EAAEjB,IAAMp6B,KAGjB0e,SAAW,SAAS2c,GAClB,OAAOA,EAAEjB,IAAMnoC,QAGjBirB,cAAgB,SAASme,GACvB,OAAOha,WAAWga,IAAM3c,SAAS2c,IAGnC5Z,MAAQ,SAAS4Z,GACf,OAAOA,EAAEjB,IAAMr3B,KAGjB6e,SAAW,SAASyZ,GAClB,GAAS,MAALA,EAGF,OAAOA,EAAEjB,IAAM51B,QAMnB2Y,uBAAwB,SAASke,GAC/B,IAAIxB,EAAGlvC,EAAG0C,EAAGF,EAAGgiC,EAChB,GAAIjS,cAAcme,IAAMA,IAAM/G,OAAO3wB,wBACnC,OAAO,EAET,IAAKie,SAASyZ,KAAOne,cAAcme,GAEjC,OAAO,EAIT,IAFAhuC,EAAIguC,EAAEnG,OAAOuF,MACbZ,EAAIwB,EAAEnG,OAAO3gB,KACR5pB,EAAIwC,EAAI,EAAGgiC,EAAM9hC,EAAI,GAAK8hC,EAAMhiC,EAAIgiC,EAAMhiC,EAAIgiC,EAAMxkC,EAAI,GAAKwkC,IAAQhiC,IAAMA,EAC9E,IAAKgwB,uBAAsB0c,EAAElvC,IAE3B,OAAO,EAGX,OAAO,GAGT+2B,SAAW,SAAS2Z,GAClB,OAAOA,EAAEjB,IAAMl3B,KAGjBuc,UAAY,SAAS4b,GACnB,OAAO3Z,SAAS2Z,IAAMxG,OAAOwG,GAAK/7B,KAGpC8M,IAAM,SAASivB,GACb,OAAI9c,OAAO8c,GACFA,EAAE/rB,KAAKlD,IAEPkoB,OAAOh1B,MAIlBwN,IAAM,SAASuuB,GACb,OAAI9c,OAAO8c,GACFA,EAAE/rB,KAAKxC,IAEPwnB,OAAOh1B,MAIlBkM,KAAO,SAAS6vB,GACd,OAAOjvB,IAAIA,IAAIivB,KAGjBnvB,KAAO,SAASmvB,GACd,OAAOjvB,IAAIU,IAAIuuB,KAGjB9uB,KAAO,SAAS8uB,GACd,OAAOvuB,IAAIV,IAAIivB,KAGjBxuB,KAAO,SAASwuB,GACd,OAAOvuB,IAAIA,IAAIuuB,KAGjB9vB,MAAQ,SAAS8vB,GACf,OAAOjvB,IAAIA,IAAIU,IAAIuuB,MAGrBpvB,MAAQ,SAASovB,GACf,OAAOjvB,IAAIU,IAAIA,IAAIuuB,MAGrB1vB,MAAQ,SAAS0vB,GACf,OAAOjvB,IAAIU,IAAIV,IAAIivB,MAGrB/uB,MAAQ,SAAS+uB,GACf,OAAOvuB,IAAIV,IAAIU,IAAIuuB,MAGrB5uB,MAAQ,SAAS4uB,GACf,OAAOvuB,IAAIA,IAAIV,IAAIivB,MAGrBzuB,MAAQ,SAASyuB,GACf,OAAOvuB,IAAIA,IAAIA,IAAIuuB,MAGrB/vB,OAAS,SAAS+vB,GAChB,OAAOjvB,IAAIA,IAAIU,IAAIA,IAAIuuB,OAGzB3vB,OAAS,SAAS2vB,GAChB,OAAOjvB,IAAIU,IAAIV,IAAIU,IAAIuuB,OAGzBvvB,OAAS,SAASuvB,GAChB,OAAOjvB,IAAIU,IAAIA,IAAIV,IAAIivB,OAGzBhvB,OAAS,SAASgvB,GAChB,OAAOvuB,IAAIV,IAAIU,IAAIA,IAAIuuB,OAGzBrvB,OAAS,SAASqvB,GAChB,OAAOjvB,IAAIU,IAAIA,IAAIA,IAAIuuB,OAGzB1uB,OAAS,SAAS0uB,GAChB,OAAOvuB,IAAIA,IAAIA,IAAIA,IAAIuuB,OAGzBtvB,QAAU,SAASsvB,GACjB,OAAOjvB,IAAIU,IAAIA,IAAIA,IAAIA,IAAIuuB,QAG7B5vB,QAAU,SAAS4vB,GACjB,OAAOjvB,IAAIU,IAAIV,IAAIU,IAAIA,IAAIuuB,QAG7B7uB,QAAU,SAAS6uB,GACjB,OAAOvuB,IAAIA,IAAIV,IAAIU,IAAIA,IAAIuuB,QAG7BxvB,QAAU,SAASwvB,GACjB,OAAOjvB,IAAIU,IAAIA,IAAIV,IAAIU,IAAIuuB,QAG7B3uB,SAAW,SAAS2uB,GAClB,OAAOvuB,IAAIA,IAAIA,IAAIV,IAAIU,IAAIA,IAAIuuB,SAGjCzvB,SAAW,SAASyvB,GAClB,OAAOjvB,IAAIU,IAAIA,IAAIV,IAAIU,IAAIA,IAAIuuB,SAIjCxY,WAAa,SAASwY,GACpB,IAAIC,EAEJ,IADAA,GAAc,EACP/c,OAAO8c,IACZA,EAAIvuB,IAAIuuB,GACRC,IAEF,OAAOA,GAITvU,QAAU,SAASsU,EAAGhuC,GACpB,IAAIiuC,EAEJ,IADAA,EAAa,EACNA,GAAcjuC,GACnBguC,EAAIvuB,IAAIuuB,GACRC,IAEF,OAAOlvB,IAAIivB,IAGbpd,MAAQ,SAASod,GACf,OAAOjvB,IAAIivB,KAAO/G,OAAOxmC,MAG3BgyB,WAAa,SAASub,GACpB,OAAOjvB,IAAIivB,KAAO/G,OAAOn1B,WAG3BgiB,QAAU,SAASka,GACjB,OAAOjvB,IAAIivB,KAAO/G,OAAO5zB,QAG3Bme,YAAc,SAASwc,GACrB,OAAOjvB,IAAIivB,KAAO/G,OAAOr4B,YAG3BmjB,aAAe,SAASic,GACtB,OAAQjvB,IAAIivB,KAAO/G,OAAOt3B,QAAYoP,IAAIivB,KAAO/G,OAAOtiC,MAG1D6vB,YAAc,SAASwZ,GACrB,OAAOjvB,IAAIivB,KAAO/G,OAAOpvB,YAG3Bsa,MAAQ,SAAS6b,GACf,OAAOjvB,IAAIivB,KAAO/G,OAAOp3B,MAM3B8hB,iBAAmB,SAASqc,GAC1B,OAAOA,IAAM/G,OAAO3wB,yBAGtBzE,MAAQ,SAASm8B,GACf,OAAIA,EAAEE,aACG,EACEF,EAAEG,SACJ,GAEC,GAIZx8B,QAAU,SAASq8B,GACjB,OAAOA,EAAE/tC,WAAW5C,QAGtB0U,MAAQ,SAASi8B,GACf,OAAOA,EAAEG,UAGX58B,OAAS,SAASy8B,EAAGhuC,GAInB,OAAOguC,EAAEI,OAAOpuC,IAGlBkiC,kBAAoB,WAMlB,OALAnL,QAAQ,GACRhO,SAAW,EACXxC,UAAY,EACZ0F,MAAQtU,IACRqR,mBAAqB,EACdC,gBAAkB,GAG3B1oB,EAAkD,OAAZrD,QAAmBA,QAAUwvC,KAEnEnsC,EAAEmpC,QAAUA,QAEZnpC,EAAEqwB,MAAQA,MAEVrwB,EAAEkyB,WAAaA,WAEflyB,EAAEuzB,QAAUA,QAEZvzB,EAAEixB,YAAcA,YAEhBjxB,EAAEwe,IAAMA,IAERxe,EAAEkf,IAAMA,IAERlf,EAAE4d,KAAOA,KAET5d,EAAEse,KAAOA,KAETte,EAAE2e,KAAOA,KAET3e,EAAEif,KAAOA,KAETjf,EAAE2d,MAAQA,MAEV3d,EAAEqe,MAAQA,MAEVre,EAAE+d,MAAQA,MAEV/d,EAAE0e,MAAQA,MAEV1e,EAAE6e,MAAQA,MAEV7e,EAAEgf,MAAQA,MAEVhf,EAAE0d,OAASA,OAEX1d,EAAE8d,OAASA,OAEX9d,EAAEke,OAASA,OAEXle,EAAEye,OAASA,OAEXze,EAAEoe,OAASA,OAEXpe,EAAE+e,OAASA,OAEX/e,EAAEme,QAAUA,QAEZne,EAAE6d,QAAUA,QAEZ7d,EAAE4e,QAAUA,QAEZ5e,EAAEie,QAAUA,QAEZje,EAAE8e,SAAWA,SAEb9e,EAAEge,SAAWA,SAEbhe,EAAE0mC,OAASA,OAEX1mC,EAAE2wB,OAASA,OAEX3wB,EAAEyzB,WAAaA,WAEfzzB,EAAE8wB,SAAWA,SAEb9wB,EAAEsvB,cAAgBA,cAElBtvB,EAAE6zB,MAAQA,MAEV7zB,EAAEg0B,SAAWA,SAEbh0B,EAAE8zB,SAAWA,SAEb9zB,EAAE6xB,UAAYA,UAEd7xB,EAAEyC,KAAOA,KAETzC,EAAEoS,IAAMA,IAERpS,EAAEqE,OAASA,OAEXrE,EAAEmV,IAAMA,IAERnV,EAAE4W,OAASA,OAEX5W,EAAEsV,IAAMA,IAgDRvS,WAAY,EAEZ2C,SAAW,WAGT,OAFA3G,KAAKuf,KAAKwb,KACVt0B,OACO+T,OAGTC,YAAc,WAIZ,OAHAhU,OACAiU,UACAjU,OACOqmC,WAUTtyB,IAAM,WACJ,IAAIu0B,EA0BJ,GAzBAA,EAAc9F,MACVjlC,WACFgrC,QAAQC,MAAM,gBAAkBF,GAElC1U,aACIr2B,WACFgrC,QAAQE,IAAI,iBAAmBpI,MAAMqC,IAAM,IAE7CzuB,UACI1W,WACFgrC,QAAQE,IAAI,qBAAuBpI,MAAMqC,IAAM,IAEjDnpC,KAAK+uC,GACL3pB,eACIphB,WACFgrC,QAAQE,IAAI,oBAAsBpI,MAAMqC,IAAM,IAEhDzuB,UACI1W,WACFgrC,QAAQE,IAAI,uBAAyBpI,MAAMqC,IAAM,IAEnDjjB,SACIliB,WACFgrC,QAAQE,IAAI,mBAAqBpI,MAAMqC,IAAM,IAE3CnlC,UACF,OAAOgrC,QAAQE,IAAI,iBAIvBx0B,QAAS,WACP,IAAIy0B,EAAeC,EAQnB,GAPA9L,OAEA8L,EADArU,GAAKqB,MAEDp4B,WACFgrC,QAAQE,IAAI,UAAYnU,IAGtBjK,mBAAmBiK,IASrB,OARI/2B,WACFgrC,QAAQE,IAAI,SAAWnU,GAAK,cAE9B/6B,KAAK6sC,MACD7oC,WACFgrC,QAAQE,IAAI,kBAAiBE,EAAQ,MAAQtI,MAAMqC,IAAM,SAE3DtG,UAGF,GAAIxP,iBAAiB0H,IAOnB,OANI/2B,WACFgrC,QAAQE,IAAI,SAAWnU,GAAK,oBAE9B/6B,KAAK+6B,IACLhC,cACA8J,UAGF,GAAItO,iBAAiBwG,IASnB,OARI/2B,WACFgrC,QAAQE,IAAI,SAAWnU,GAAK,oBAE9B/6B,KAAK+6B,IACD/2B,WACFgrC,QAAQE,IAAI,kBAAiBE,EAAQ,MAAQtI,MAAMqC,IAAM,SAE3DtG,UAGF,GAAI9H,KAAO4M,OAAO9zB,IAShB,OARI7P,WACFgrC,QAAQE,IAAI,SAAWnU,GAAK,UAE9B/6B,KAAK+6B,IACD/2B,WACFgrC,QAAQE,IAAI,kBAAiBE,EAAQ,MAAQtI,MAAMqC,IAAM,SAE3DtG,UAcF,GAAIpjB,IAAIsb,MAAQ4M,OAAOxmC,OAAS8qB,uBAAsB8O,KAAO7O,6BAA4B6O,KAAOjrB,MAAKirB,GAAIzL,gBA2BvG,OA1BItrB,WACFgrC,QAAQE,IAAI,SAAWnU,GAAK,aAE1B/2B,WACFgrC,QAAQE,IAAI,gBAGdlvC,KAAK+6B,IACLsH,QACAtH,GAAKqB,MACLp8B,KAAK+6B,IACLoH,OACAhB,aAAa,GACb3E,QACAx8B,KAAK+6B,IACL1L,OACA8R,aAAa,GACb3E,QACA5hB,MACAwmB,cAAc,EAAG,GACjB5E,QACA6J,gBACIriC,WACFgrC,QAAQE,IAAI,kBAAiBE,EAAQ,MAAQtI,MAAMqC,IAAM,SAE3DtG,UAGF,GAAIpjB,IAAIsb,MAAQ4M,OAAO5zB,QAAUsV,OAAO9J,KAAKwb,KAAM,GAoBjD,OAnBI/2B,WACFgrC,QAAQE,IAAI,SAAWnU,GAAK,uBAG1BrR,oBACE1lB,WACFgrC,QAAQE,IAAI,mCAEdnO,YAAY,KAER/8B,WACFgrC,QAAQE,IAAI,kCAEd/N,aAAa,IAEXn9B,WACFgrC,QAAQE,IAAI,kBAAiBE,EAAQ,MAAQtI,MAAMqC,IAAM,SAE3DtG,UAIF,GAAIpjB,IAAIsb,MAAQ4M,OAAO5zB,QAAUwgB,iBAAiBjV,MAAMyb,KAYtD,OAXI/2B,WACFgrC,QAAQE,IAAI,SAAWnU,GAAK,mDAE9B/6B,KAAKuf,KAAKwb,KACVvgB,MACAxa,KAAKsf,MAAMyb,KACXyB,QACIx4B,WACFgrC,QAAQE,IAAI,kBAAiBE,EAAQ,MAAQtI,MAAMqC,IAAM,SAE3DtG,UAIF,GAAIpjB,IAAIsb,MAAQ4M,OAAO5zB,QAAUwL,KAAKwb,MAAQ4M,OAAOjiC,GAYnD,OAXI1B,WACFgrC,QAAQE,IAAI,SAAWnU,GAAK,sBAG9B/6B,KAAKsf,MAAMyb,KACXoH,OACA7X,cACItmB,WACFgrC,QAAQE,IAAI,kBAAiBE,EAAQ,MAAQtI,MAAMqC,IAAM,SAE3DtG,UAGF,GAAIpjB,IAAIsb,MAAQ4M,OAAOn1B,UAAW,CAOhC,IANIxO,WACFgrC,QAAQE,IAAI,SAAWnU,GAAK,iBAG9BoU,GAAgB,EAChBpU,GAAK5a,IAAI4a,IACFnJ,OAAOmJ,KACZ/6B,KAAKyf,IAAIsb,KACTrgB,UACIy0B,GACF9W,WAEF8W,GAAgB,EAChBpU,GAAK5a,IAAI4a,IAMX,OAJI/2B,WACFgrC,QAAQE,IAAI,kBAAiBE,EAAQ,MAAQtI,MAAMqC,IAAM,SAE3DtG,UAGF,OAAIpjB,IAAIsb,MAAQ4M,OAAOzmC,MACjB8C,WACFgrC,QAAQE,IAAI,SAAWnU,GAAK,oBAG9BsG,YAAYngC,KACZlB,KAAKuf,KAAKwb,KACV9E,KAAK,GACDjyB,WACFgrC,QAAQE,IAAI,kBAAiBE,EAAQ,MAAQtI,MAAMqC,IAAM,SAE3DtG,WAiCE5N,SAAS8F,KACXpgB,qBACAkoB,aAGEvP,eAAeyH,KAAQtb,IAAIsb,MAAQ4M,OAAOxmC,MAAQmyB,eAAe/T,KAAKwb,QACxE/6B,KAAK+6B,IACLhC,SACAgC,GAAKqB,OAEHp4B,WACFgrC,QAAQE,IAAI,SAAWnU,GAAK,4BAE9BsG,YAAYngC,KACZlB,KAAK+6B,IACL9E,KAAK,GACDjyB,WACFgrC,QAAQE,IAAI,kBAAiBE,EAAQ,MAAQtI,MAAMqC,IAAM,IAEpDtG,YAITloB,cAAgB,WAWd,OAVuB,IAAnBogB,GAAGwN,OAAOsF,MACZ1G,KAAK,oCAEPnnC,KAAK+6B,IACL/6B,KAAK+6B,IACLrY,YACAiN,SACAyR,cAAc,EAAG,GACjB5E,QACAmJ,WACOl/B,QAGT6lB,KAAO,EAEP1lB,SAAW,WACT,IAAImnC,EAGJ,IAFAA,EAAI5E,IACJpO,GAAK5a,IAAI4a,IACFnJ,OAAOmJ,KACZ/6B,KAAKyf,IAAIsb,KACTt0B,OACAu0B,GAAKoB,MACLmF,WAAWvG,IACXD,GAAK5a,IAAI4a,IAEX,OAAO7f,UAAUiuB,IAAM4E,IAIzBhH,eAAiB,EAEjB7rB,UAAY,SAASxa,GACnB,IAAIqtC,EAAG/vC,EAAGoxB,EAAImG,EAAI/0B,EAAGgiC,EAAKC,EAAMmL,EAAYyB,EAW5C,GAVAtI,iBACA/oC,EAAI,EACJ+vC,EAAI5E,IAAMzoC,EAGNqD,OACFirC,QAAQE,IAAI,8BAAgCnI,gBAI1ChjC,MACF,IAAK/F,EAAIwC,EAAI,EAAGgiC,EAAM2G,IAAM,GAAK3G,EAAMhiC,EAAIgiC,EAAMhiC,EAAIgiC,EAAMxkC,EAAI,GAAKwkC,IAAQhiC,IAAMA,EAChFwuC,QAAQE,IAAIrP,YAAWiH,MAAM9oC,KAGjC,IAAKA,EAAIoxB,EAAK,EAAGA,EAAK,MAChB1uB,EAAI,KAGR4rB,KAAO,GAEP+iB,EAAgBvI,MAAMlmC,MAAMmtC,EAAGA,EAAIrtC,IACrB4uC,KAAK9tB,WACnBslB,MAAQA,MAAMlmC,MAAM,EAAGmtC,GAAGwB,OAAOF,GAAeE,OAAOzI,MAAMlmC,MAAMmtC,EAAIrtC,IAC1D,IAAT4rB,MAToBtuB,IAAMoxB,EAY9B1uB,EAAIuhB,cAAc8rB,EAAGrtC,GAGvB,OADA+2B,QAAQsW,EAAIrtC,GACJA,GACN,KAAK,EACCgpB,mBACFqX,YAAY,GAEZ/gC,KAAK6sC,MAEP,MACF,KAAK,EACH,MACF,QACE5W,KAAKv1B,GACLq6B,GAAKqB,MACLiF,YAAYlgC,KACZnB,KAAK+6B,IACLpY,OAOJ,GALI5e,OACFirC,QAAQE,IAAI,6BAA+BnI,gBAIzChjC,MAAO,CAET,IADA6pC,EAAU,GACL5vC,EAAIu3B,EAAK,EAAGkN,EAAO0G,IAAM,GAAK1G,EAAOlN,EAAKkN,EAAOlN,EAAKkN,EAAOzkC,EAAI,GAAKykC,IAASlN,IAAOA,EACzFqY,EAAQ5tC,KAAKgvC,QAAQE,IAAIrP,YAAWiH,MAAM9oC,MAE5C,OAAO4vC,IAKXnsB,gBAAkB,EAElBD,UAAY,SAASuZ,EAAIC,GACvB,IAAIh9B,EAAGwC,EAAGgiC,EAAKgN,EAMf,GALA/tB,kBAGAzjB,EAAI,EAEAuyB,cAAcwK,IAAOxK,cAAcyK,GAGrC,OAFA1O,KAAO,EAEA,EAGT,GAAI2I,SAAS8F,IAAO9F,SAAS+F,GAAK,CAChC,GAAID,EAAGwN,OAAOsF,KAAO7S,EAAGuN,OAAOsF,KAE7B,OAAQ,EAEV,GAAI9S,EAAGwN,OAAOsF,KAAO7S,EAAGuN,OAAOsF,KAE7B,OAAO,EAET,IAAK7vC,EAAIwC,EAAI,EAAGgiC,EAAMzH,EAAGwN,OAAOsF,KAAO,GAAKrL,EAAMhiC,EAAIgiC,EAAMhiC,EAAIgiC,EAAMxkC,EAAI,GAAKwkC,IAAQhiC,IAAMA,EAAG,CAC9F,GAAIu6B,EAAGwN,OAAOoF,IAAI3vC,GAAKg9B,EAAGuN,OAAOoF,IAAI3vC,GAEnC,OAAQ,EAEV,GAAI+8B,EAAGwN,OAAOoF,IAAI3vC,GAAKg9B,EAAGuN,OAAOoF,IAAI3vC,GAEnC,OAAO,EAKX,OAFAsuB,KAAO,EAEA,EAyBT,OAvBI7M,IAAIsb,KAAQ4M,OAAOn1B,YACrBuoB,EAAK5a,IAAI4a,GACLxK,cAAc9Q,IAAIsb,MACpBA,EAAK5a,IAAI4a,GACL5a,IAAI4a,KAAQ4M,OAAOh1B,OACrBooB,EAAKtb,IAAIsb,MAIXtb,IAAIub,KAAQ2M,OAAOn1B,YACrBwoB,EAAK7a,IAAI6a,GACLzK,cAAc9Q,IAAIub,MACpBA,EAAK7a,IAAI6a,GACL7a,IAAI6a,KAAQ2M,OAAOh1B,OACrBqoB,EAAKvb,IAAIub,MAKL,KADVwU,EAAIjuB,UAASwZ,EAAIC,MAEf1O,KAAO,GAGFkjB,GAGTvtB,cAAgB,SAASwtB,EAAG/uC,GAC1B,IAAI1C,EAAGoxB,EAAIif,EAAG9Y,EAAIma,EAAIC,EAAInvC,EAAGgiC,EAAKC,EAAMmN,EAAMC,EAAMC,EAAMC,EAAMC,EAAMC,EAAMC,EAAMC,EAAMX,EAWxF,IADAxxC,EAAI,EACGA,EAAK0C,EAAI,GAId,GAHA+f,iBACAwa,GAAK6L,MAAM2I,EAAIzxC,GACfk9B,GAAK4L,MAAM2I,EAAIzxC,EAAI,GACfi3B,SAASgG,KAAOhG,SAASiG,IAA7B,CAKE,GAJAl7B,KAAKi7B,IACLj7B,KAAKk7B,IACLsN,sBACAzN,GAAKqB,SACMuL,OAAOh1B,KAAM,CAEtB,IADAm0B,MAAM2I,EAAIzxC,GAAK+8B,GACVsT,EAAI7tC,EAAIgiC,EAAMxkC,EAAI,EAAGykC,EAAO/hC,EAAI,EAAI8hC,GAAOC,EAAOjiC,EAAIiiC,EAAOjiC,EAAIiiC,EAAO4L,EAAI7L,GAAOC,IAASjiC,IAAMA,EACrGsmC,MAAM2I,EAAIpB,GAAKvH,MAAM2I,EAAIpB,EAAI,GAE/B3tC,IACA1C,IAEFA,SAGF,GAAIi3B,SAASgG,KAAOhG,SAASiG,IAC3Bl9B,SAGF,GAAIuyB,cAAc0K,KAAO1K,cAAc2K,IAAvC,CAKE,GAJAl7B,KAAKi7B,IACLj7B,KAAKk7B,IACLjgB,cACA8f,GAAKqB,MACDtL,mBAAmBiK,IAAK,CAC1B,IAAKsT,EAAIjf,EAAKwgB,EAAO5xC,EAAG6xC,EAAOnvC,EAAI,EAAIkvC,GAAQC,EAAOzgB,EAAKygB,EAAOzgB,EAAKygB,EAAOxB,EAAIuB,GAAQC,IAASzgB,IAAOA,EACxG0X,MAAM2I,EAAIpB,GAAKvH,MAAM2I,EAAIpB,EAAI,GAE/B3tC,GAAK,MACA,CAEL,IADAomC,MAAM2I,EAAIzxC,GAAK+8B,GACVsT,EAAI9Y,EAAKua,EAAO9xC,EAAI,EAAG+xC,EAAOrvC,EAAI,EAAIovC,GAAQC,EAAOxa,EAAKwa,EAAOxa,EAAKwa,EAAO1B,EAAIyB,GAAQC,IAASxa,IAAOA,EAC5GuR,MAAM2I,EAAIpB,GAAKvH,MAAM2I,EAAIpB,EAAI,GAE/B3tC,IAEF1C,IACAA,SAGF,GAAIuyB,cAAc0K,KAAO1K,cAAc2K,IACrCl9B,SAiCF,GA9BI0rB,oBACFqR,GAAKN,cACLO,GAAKP,gBAELM,GAAKR,IACLS,GAAKT,KAEPiV,EAAI,EACA/vB,IAAIwb,MAAQ0M,OAAOn1B,YACrByoB,GAAK9a,IAAI8a,IACTuU,EAAI,EACAjf,cAAc9Q,IAAIwb,OACpBF,GAAKtb,IAAIwb,IACTA,GAAK9a,IAAI8a,IACL9a,IAAI8a,MAAQ0M,OAAOh1B,OACrBsoB,GAAKxb,IAAIwb,IACTuU,EAAI,KAIN/vB,IAAIyb,MAAQyM,OAAOn1B,YACrB0oB,GAAK/a,IAAI+a,IACL3K,cAAc9Q,IAAIyb,OACpBF,GAAKvb,IAAIyb,IACTA,GAAK/a,IAAI+a,IACL/a,IAAI+a,MAAQyM,OAAOh1B,OACrBuoB,GAAKzb,IAAIyb,OAIV9R,MAAM6R,GAAIC,IAQf,GAJAl7B,KAAK+6B,IACL/6B,KAAKg7B,IACL/f,cACA8f,GAAKqB,MACDtL,mBAAmBiK,IAAvB,CACE,IAAKsT,EAAIqB,EAAKM,EAAOhyC,EAAGiyC,EAAOvvC,EAAI,EAAIsvC,GAAQC,EAAOP,EAAKO,EAAOP,EAAKO,EAAO5B,EAAI2B,GAAQC,IAASP,IAAOA,EACxG5I,MAAM2I,EAAIpB,GAAKvH,MAAM2I,EAAIpB,EAAI,GAE/B3tC,GAAK,EACL1C,IACAA,QANF,CAmBA,IAVAgC,KAAK+6B,IACDyU,GACFxvC,KAAK2nC,OAAOn1B,WACZxS,KAAKi7B,IACLtY,QAEA3iB,KAAKi7B,IAEP5C,WACAyO,MAAM2I,EAAIzxC,GAAKo+B,MACViS,EAAIsB,EAAKO,EAAOlyC,EAAI,EAAGmyC,EAAOzvC,EAAI,EAAIwvC,GAAQC,EAAOR,EAAKQ,EAAOR,EAAKQ,EAAO9B,EAAI6B,GAAQC,IAASR,IAAOA,EAC5G7I,MAAM2I,EAAIpB,GAAKvH,MAAM2I,EAAIpB,EAAI,GAE/B3tC,IACA1C,IAEAA,SAhCEA,IAkCJ,OAAO0C,GAGT6gC,WAAa,SAASmN,GACpB,IAAId,EACJ,GAAInuB,IAAIivB,KAAO/G,OAAOxmC,KAAM,CAG1B,IAFAutC,EAAIvuB,IAAIuuB,GACRd,EAAU,GACHhc,OAAO8c,IACZ1uC,KAAKyf,IAAIivB,IACTd,EAAQ5tC,KAAK0uC,EAAIvuB,IAAIuuB,IAEvB,OAAOd,EACF,IAAK/c,WAAW6d,GACrB,OAAO1uC,KAAK0uC,IAKhB9zB,IAAM,WACJ,IAAImzB,EAQJ,OAPAzK,OACAtI,GAAKoB,MACLrB,GAAKqB,MACL2R,EAAI5E,IACJ5H,WAAWxG,IACXwG,WAAWvG,IACX9f,UAAUiuB,IAAM4E,GACTlL,WAGT9nB,QAAU,SAAS0yB,GACjB,IAAIM,EAAG/vC,EAAGwC,EAAGgiC,EAAKiN,EAKlB,IAJAzxC,EAAI,EACJslC,OACAmM,EAAItG,IAAMsE,EACVM,EAAI5E,IACCnrC,EAAIwC,EAAI,EAAGgiC,EAAMiL,EAAI,GAAKjL,EAAMhiC,EAAIgiC,EAAMhiC,EAAIgiC,EAAMxkC,EAAI,GAAKwkC,IAAQhiC,IAAMA,EAC9E+gC,WAAWuF,MAAM2I,EAAIzxC,IAMvB,OAJAkd,UAAUiuB,IAAM4E,GAChBhT,GAAKqB,MACL3E,QAAQ0R,IAAMsE,GACdztC,KAAK+6B,IACE8H,WAGT2E,SAAW,WAET,OADAzO,SACOne,OAGT/T,SAAW,WAGT,OAFA7G,KAAKuf,KAAKwb,KACVt0B,OACO2U,OAGTA,IAAM,WACJ,IAAepd,EAAGoxB,EAAIif,EAAG3tC,EAAGF,EAAGgiC,EAAKC,EAgBpC,IAfAzkC,EAAI,EACJqwC,EAAI,EACA,EACJ/K,OACAvI,GAAKqB,MACDnH,SAAS8F,KAA0B,IAAnBA,GAAGwN,OAAOsF,MAAc9S,GAAGwN,OAAOoF,IAAI,KAAO5S,GAAGwN,OAAOoF,IAAI,GACjE,EAEZxG,KAAK,+BAEPzmC,EAAIq6B,GAAGwN,OAAOoF,IAAI,IAClB3S,GAAK3f,aAAa3a,EAAIA,IACnB6nC,OAAOsF,KAAO,EACjB7S,GAAGuN,OAAOoF,IAAI,GAAKjtC,EACnBs6B,GAAGuN,OAAOoF,IAAI,GAAKjtC,EACd1C,EAAIwC,EAAI,EAAGgiC,EAAM9hC,EAAI,GAAK8hC,EAAMhiC,EAAIgiC,EAAMhiC,EAAIgiC,EAAMxkC,EAAI,GAAKwkC,IAAQhiC,IAAMA,EAC9E,IAAK6tC,EAAIjf,EAAK,EAAGqT,EAAO/hC,EAAI,GAAK+hC,EAAOrT,EAAKqT,EAAOrT,EAAKqT,EAAO4L,EAAI,GAAK5L,IAASrT,IAAOA,EACvFxN,SAASmZ,GAAIr6B,EAAG1C,EAAGqwC,GACnBrT,GAAGuN,OAAO3gB,KAAKlnB,EAAI2tC,EAAIrwC,GAAKo+B,MAIhC,OADAp8B,KAAKg7B,IACE6H,WAGT97B,iBAAmB,WACjB,IAAIgoC,EAGJ,OAFAA,EAAcxvB,KAAKwb,IACnB/6B,KAAK+uC,GACEhyB,yBAGTA,sBAAuB,WACrB,IAAI/e,EAAGoxB,EAAI5uB,EAAGgiC,EAAKC,EAInB,GAHAzkC,EAAI,EACJslC,OACAvI,GAAKqB,MACDnH,SAAS8F,IAAK,CAGhB,KAFAG,GAAK7f,aAAa0f,GAAGwN,OAAOuF,QACzBvF,OAAOsF,KAAO9S,GAAGwN,OAAOsF,KACtB7vC,EAAIwC,EAAI,EAAGgiC,EAAMzH,GAAGwN,OAAOsF,KAAO,GAAKrL,EAAMhiC,EAAIgiC,EAAMhiC,EAAIgiC,EAAMxkC,EAAI,GAAKwkC,IAAQhiC,IAAMA,EAC3F06B,GAAGqN,OAAOoF,IAAI3vC,GAAK+8B,GAAGwN,OAAOoF,IAAI3vC,GAEnC,IAAKA,EAAIoxB,EAAK,EAAGqT,EAAO1H,GAAGwN,OAAOuF,MAAQ,GAAKrL,EAAOrT,EAAKqT,EAAOrT,EAAKqT,EAAOzkC,EAAI,GAAKykC,IAASrT,IAAOA,EACrGpvB,KAAK+6B,GAAGwN,OAAO3gB,KAAK5pB,IACpB+e,wBACAme,GAAGqN,OAAO3gB,KAAK5pB,GAAKo+B,MACpBzb,wBAAwBua,IAE1Bl7B,KAAKk7B,SACIH,GAAG0S,IAAMnoC,QAClBtF,KAAK+6B,IACLpf,sBACSiW,OAAOmJ,KAChB/6B,KAAKyf,IAAIsb,KACThe,wBACA/c,KAAKmgB,IAAI4a,KACThe,wBACA4F,QAEA3iB,KAAK+6B,IAEP,OAAO8H,WAGTlnB,mBAAqB,WACnB,IAAIy0B,EAA2BC,EAAWC,EAAwBC,EAAoBC,EAAUC,EAGhG,GAFA3D,WACAyD,EAAqBnU,OACEqR,IAAMnoC,OAgB7B,OAFA+7B,YAAY//B,aACZtB,KAAK+uC,aACE9Y,KAAK,GAb4B,KADtCqa,GADAE,EAAWD,EAAmB/C,GACI7sC,WAAW+vC,MAAM,MACxB3yC,QACzBqyC,EAA4BE,EAAuB,GAAGvyC,OACtDsyC,EAAY,EAAI9B,KAAKoC,IAAI,GAAIP,GAC7BK,EAAWlkB,oBAAoBikB,EAAUH,GACzCjP,cAAcqP,EAAS,GAAIA,EAAS,KAEpCtP,aAAaqP,IAoBnBjkB,oBAAsB,SAASqkB,EAASC,GACtC,IAAIC,EAAaC,EAAqBC,EAAmBC,EAAqBC,EAAcC,EAAGC,EAQ/F,GAPAJ,OAAoB,EACpBD,OAAsB,EACtBD,OAAc,EACdK,OAAI,EACJF,OAAsB,EACtBC,OAAe,EACfE,EAAM,CAAC,EAAG,GACNC,MAAMT,GACR,OAAOQ,EAGT,GAAgB,WAAZR,EAIF,OAHAQ,EAAI,GAAK,EACTA,EAAI,GAAK,EAEFA,EAET,IAAiB,WAAbR,EAIF,OAHAQ,EAAI,IAAM,EACVA,EAAI,GAAK,EAEFA,EAQT,GALEN,EADEF,EAAU,GACG,EAED,EAEhBA,EAAUrC,KAAK/zB,IAAIo2B,GACfrC,KAAK/zB,IAAIo2B,EAAUrC,KAAK+C,MAAMV,IAAYC,EAM5C,OAJAG,EAAoBJ,EAAUE,EAC9BC,EAAsB,EACtBK,EAAI,GAAKJ,EACTI,EAAI,GAAKL,EACFK,EAET,GAAIR,EAAU,MAMZ,OAJAI,EAAoBF,EACpBC,EAAsB,KACtBK,EAAI,GAAKJ,EACTI,EAAI,GAAKL,EACFK,EAET,GAAIR,EAAU,KAKZ,OAJAI,EAAoB,KAAwBF,EAC5CC,EAAsB,EACtBK,EAAI,GAAKJ,EACTI,EAAI,GAAKL,EACFK,EAKT,IAHAD,EAAIP,EACJK,EAAsB,EACtBF,EAAsB,EAEpBI,EAAI,GAAOA,EAAI5C,KAAK+C,MAAMH,IAC1BD,EAAeH,EACfA,EAAsBA,EAAsBxC,KAAK+C,MAAMH,GAAKF,EAC5DA,EAAsBC,EACtBF,EAAoBzC,KAAK+C,MAAMV,EAAUG,EAAsB,IAEzDxC,KAAK/zB,IAAIo2B,EAAWI,EAAoBD,GAAwBF,GAAkBM,IAAM5C,KAAK+C,MAAMH,KAO3G,OAHAH,GAAoBF,EACpBM,EAAI,GAAKJ,EACTI,EAAI,GAAKL,EACFK,GAGT/0B,uBAAyB,EAEzBS,wBAA0B,EAE1BD,iCAAmC,EAEnCF,oBAAsB,EAEtBH,sBAAwB,EAExBD,qBAAuB,EAEvBE,sBAAwB,EAExBC,mBAAqB,EAErBJ,6BAA+B,EAE/BM,6BAA+B,EAE/BX,0BAA4B,SAASu0B,GACnC,IAAIe,EAAiBC,EAAYC,EAAOC,EAAY1zC,EAAGoxB,EAAIif,EAAGvwC,EAAK6zC,EAAkBC,EAAmBxB,EAA2B5vC,EAAG6vC,EAAWwB,EAAOrP,EAAa8N,EAErK,GAAsC,KADtCA,EAAyBE,EAAS7vC,WAAW+vC,MAAM,MACxB3yC,OAIzB,MAAO,CAAC,GAAKwwC,KAAK+C,MAAMd,GAAWn0B,uBAAwBkyB,KAAK+C,MAAMd,GAAW,EAAG,GAOtF,IAVEJ,EAA4BE,EAAuB,GAAGvyC,OACtDsyC,EAAY,EAAI9B,KAAKoC,IAAI,GAAIP,GAI/BpB,QAAQE,IAAI,cAAgBmB,GAE5BkB,EAAkB,KAClBK,EAAoBE,OAAOC,UAEtBvxC,EAAI,EAAG1C,GADZ0kC,EAAM,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,KACHzkC,OAAQyC,EAAI1C,EAAK0C,IAErC,IADAxC,EAAIwkC,EAAIhiC,GACH6tC,EAAIjf,EAAK,EAAGA,GAAM,GAAIif,IAAMjf,EAE/BsiB,EAAanD,KAAKC,KAAKxwC,GAAKqwC,EAExBE,KAAK/zB,IAAIk3B,GAAc,OACzBG,EAAQrB,EAAWkB,EACnBC,EAAmBpD,KAAKyD,MAAMH,GAE9BJ,EAAQlD,KAAK/zB,IAAI,EAAIq3B,EAAQF,KAE7BE,EAAQ,EACRF,EAAmB,EACnBF,EAAQlD,KAAK/zB,IAAIg2B,EAAWkB,IAG1BD,EAAQ,EAAIpB,IACdmB,EAAa9L,wBAAwBiM,EAAkB3zC,EAAGqwC,IACzCuD,IAEfA,EAAoBJ,EAGpBD,EAAkB,CAFTI,EAAmB,YAAc3zC,EAAI,QAAUqwC,EAE7B5xB,sBAAuBk1B,EAAkB3zC,EAAGqwC,IAK/E,OAAOkD,GAGT11B,0BAA4B,SAAS20B,GACnC,IAAIe,EAAiBC,EAAYC,EAAOC,EAAY1zC,EAAGoxB,EAAIif,EAAGvwC,EAAKm0C,EAAMN,EAAkBC,EAAmBxB,EAA2B5vC,EAAG6vC,EAAWwB,EAAOrP,EAAKC,EAAc6N,EAEjL,GAAsC,KADtCA,EAAyBE,EAAS7vC,WAAW+vC,MAAM,MACxB3yC,OAIzB,MAAO,CAAC,GAAKwwC,KAAK+C,MAAMd,GAAWn0B,uBAAwBkyB,KAAK+C,MAAMd,GAAW,EAAG,GAUtF,IAbEJ,EAA4BE,EAAuB,GAAGvyC,OACtDsyC,EAAY,EAAI9B,KAAKoC,IAAI,GAAIP,GAI/BpB,QAAQE,IAAI,cAAgBmB,GAE5BkB,EAAkB,KAClBK,EAAoBE,OAAOC,UAKtBvxC,EAAI,EAAG1C,GAJZ0kC,EAAM,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,KAINzkC,OAAQyC,EAAI1C,EAAK0C,IAGrC,IAFAxC,EAAIwkC,EAAIhiC,GAEH4uB,EAAK,EAAG6iB,GADbxP,EAAO,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,KACJ1kC,OAAQqxB,EAAK6iB,EAAM7iB,IAC1Cif,EAAI5L,EAAKrT,GAETsiB,EAAanD,KAAKC,KAAKxwC,EAAIqwC,GAEvBE,KAAK/zB,IAAIk3B,GAAc,OACzBG,EAAQrB,EAAWkB,EACnBC,EAAmBpD,KAAKyD,MAAMH,GAE9BJ,EAAQlD,KAAK/zB,IAAI,EAAIq3B,EAAQF,KAE7BE,EAAQ,EACRF,EAAmB,EACnBF,EAAQlD,KAAK/zB,IAAIg2B,EAAWkB,IAG1BD,EAAQ,EAAIpB,IACdmB,EAAa9L,wBAAwBiM,EAAkB3zC,EAAGqwC,IACzCuD,IAEfA,EAAoBJ,EAGpBD,EAAkB,CAFTI,EAAmB,aAAe3zC,EAAI,MAAQqwC,EAAI,KAEhC7xB,sBAAuBm1B,EAAkB3zC,EAAGqwC,IAK/E,OAAOkD,GAGT31B,eAAiB,SAAS40B,GACxB,IAAI0B,EAAiCC,EAAiC/B,EAA2BC,EAAWC,EAE5G,OAAsC,KADtCA,EAAyBE,EAAS7vC,WAAW+vC,MAAM,MACxB3yC,OAIlB,CAAC,GAAKwwC,KAAK+C,MAAMd,GAAWn0B,uBAAwBkyB,KAAK+C,MAAMd,GAAW,EAAG,IAHpFJ,EAA4BE,EAAuB,GAAGvyC,OACtDsyC,EAAY,EAAI9B,KAAKoC,IAAI,GAAIP,GAI/BpB,QAAQE,IAAI,cAAgBmB,GAOW,OADvC8B,EAAkCl2B,0BAA0Bu0B,IAEnD2B,EAG8B,OADvCD,EAAkCr2B,0BAA0B20B,IAEnD0B,EAEF,OAGTz2B,WAAa,SAAS+0B,GACpB,IAAI4B,EAA6BC,EAA6BjC,EAA2BC,EAAWC,EAEpG,OAAsC,KADtCA,EAAyBE,EAAS7vC,WAAW+vC,MAAM,MACxB3yC,OAIlB,CAAC,GAAKwwC,KAAK+C,MAAMd,GAAWn0B,uBAAwBkyB,KAAK+C,MAAMd,GAAW,EAAG,IAHpFJ,EAA4BE,EAAuB,GAAGvyC,OACtDsyC,EAAY,EAAI9B,KAAKoC,IAAI,GAAIP,GAI/BpB,QAAQE,IAAI,cAAgBmB,GAIO,OADnCgC,EAA8Bv2B,sBAAsB00B,IAE3C6B,EAG0B,OADnCD,EAA8B12B,sBAAsB80B,IAE3C4B,EAEF,OAGTt2B,sBAAwB,SAAS00B,GAC/B,IAAIe,EAAiBC,EAAYC,EAAOC,EAAY1zC,EAAGoxB,EAAIif,EAAGsD,EAAkBC,EAAmBxB,EAA2B5vC,EAAG6vC,EAAWwB,EAAevB,EAE3J,GAAsC,KADtCA,EAAyBE,EAAS7vC,WAAW+vC,MAAM,MACxB3yC,OAIzB,MAAO,CAAC,GAAKwwC,KAAK+C,MAAMd,GAAWn0B,uBAAwBkyB,KAAK+C,MAAMd,GAAW,EAAG,GAMtF,IATEJ,EAA4BE,EAAuB,GAAGvyC,OACtDsyC,EAAY,EAAI9B,KAAKoC,IAAI,GAAIP,GAI/BpB,QAAQE,IAAI,cAAgBmB,GAC5BkB,EAAkB,KAClBK,EAAoBE,OAAOC,UAEtB/zC,EAAIwC,EAAI,EAAGA,GAAK,EAAGxC,IAAMwC,EAC5B,IAAK6tC,EAAIjf,EAAK,EAAGA,GAAM,EAAGif,IAAMjf,EAE9BsiB,EAAanD,KAAKW,IAAIlxC,GAAKqwC,EAEvBE,KAAK/zB,IAAIk3B,GAAc,OACzBG,EAAQrB,EAAWkB,EACnBC,EAAmBpD,KAAKyD,MAAMH,GAE9BJ,EAAQlD,KAAK/zB,IAAI,EAAIq3B,EAAQF,KAE7BE,EAAQ,EACRF,EAAmB,EACnBF,EAAQlD,KAAK/zB,IAAIg2B,EAAWkB,IAWL,IAArBC,GAA0BpD,KAAK/zB,IAAI+zB,KAAK+C,MAAMK,EAAmBtD,MAAQE,KAAK/zB,IAAIm3B,EAAmBtD,IAGrGoD,EAAQ,IAAMpB,IAChBmB,EAAa9L,wBAAwBiM,EAAkB3zC,EAAGqwC,IACzCuD,IAEfA,EAAoBJ,EAGpBD,EAAkB,CAFTI,EAAmB,WAAa3zC,EAAI,QAAUqwC,EAE5BzxB,6BAA8B+0B,EAAkB3zC,EAAGqwC,IAKtF,OAAOkD,GAGT71B,sBAAwB,SAAS80B,GAC/B,IAAIe,EAAiBC,EAAYC,EAAOC,EAAY1zC,EAAGoxB,EAAIif,EAAGsD,EAAkBC,EAAmBxB,EAA2B5vC,EAAG6vC,EAAWwB,EAAevB,EAE3J,GAAsC,KADtCA,EAAyBE,EAAS7vC,WAAW+vC,MAAM,MACxB3yC,OAIzB,MAAO,CAAC,GAAKwwC,KAAK+C,MAAMd,GAAWn0B,uBAAwBkyB,KAAK+C,MAAMd,GAAW,EAAG,GAMtF,IATEJ,EAA4BE,EAAuB,GAAGvyC,OACtDsyC,EAAY,EAAI9B,KAAKoC,IAAI,GAAIP,GAI/BpB,QAAQE,IAAI,cAAgBmB,GAC5BkB,EAAkB,KAClBK,EAAoBE,OAAOC,UAEtB/zC,EAAIwC,EAAI,EAAGA,GAAK,EAAGxC,IAAMwC,EAC5B,IAAK6tC,EAAIjf,EAAK,EAAGA,GAAM,EAAGif,IAAMjf,EAE9BsiB,EAAanD,KAAKW,IAAIlxC,EAAIqwC,GAEtBE,KAAK/zB,IAAIk3B,GAAc,OACzBG,EAAQrB,EAAWkB,EACnBC,EAAmBpD,KAAKyD,MAAMH,GAE9BJ,EAAQlD,KAAK/zB,IAAI,EAAIq3B,EAAQF,KAE7BE,EAAQ,EACRF,EAAmB,EACnBF,EAAQlD,KAAK/zB,IAAIg2B,EAAWkB,IAG1BD,EAAQ,KAAOpB,IACjBmB,EAAa9L,wBAAwBiM,EAAkB3zC,EAAGqwC,IACzCuD,IAEfA,EAAoBJ,EAGpBD,EAAkB,CAFTI,EAAmB,WAAa3zC,EAAI,MAAQqwC,EAAI,KAE9B/xB,6BAA8Bq1B,EAAkB3zC,EAAGqwC,IAKtF,OAAOkD,GAGTx1B,2BAA6B,SAASy0B,GACpC,IAAIe,EAAiBC,EAAYC,EAAOC,EAAY1zC,EAAGoxB,EAAIif,EAAGsD,EAAkBC,EAAmBxB,EAA2B5vC,EAAG6vC,EAAWwB,EAAevB,EAE3J,GAAsC,KADtCA,EAAyBE,EAAS7vC,WAAW+vC,MAAM,MACxB3yC,OAIzB,MAAO,CAAC,GAAKwwC,KAAK+C,MAAMd,GAAWn0B,uBAAwBkyB,KAAK+C,MAAMd,GAAW,EAAG,GAMtF,IATEJ,EAA4BE,EAAuB,GAAGvyC,OACtDsyC,EAAY,EAAI9B,KAAKoC,IAAI,GAAIP,GAI/BpB,QAAQE,IAAI,cAAgBmB,GAC5BkB,EAAkB,KAClBK,EAAoBE,OAAOC,UAEtB/zC,EAAIwC,EAAI,EAAGA,GAAK,EAAGxC,IAAMwC,EAC5B,IAAK6tC,EAAIjf,EAAK,EAAGA,GAAM,GAAIif,IAAMjf,EAE/BsiB,EAAanD,KAAKoC,IAAIpC,KAAK7oC,EAAG1H,GAAKqwC,EAE/BE,KAAK/zB,IAAIk3B,GAAc,OACzBG,EAAQrB,EAAWkB,EACnBC,EAAmBpD,KAAKyD,MAAMH,GAE9BJ,EAAQlD,KAAK/zB,IAAI,EAAIq3B,EAAQF,KAE7BE,EAAQ,EACRF,EAAmB,EACnBF,EAAQlD,KAAK/zB,IAAIg2B,EAAWkB,IAG1BD,EAAQ,EAAIpB,IACdmB,EAAa9L,wBAAwBiM,EAAkB3zC,EAAGqwC,IACzCuD,IAEfA,EAAoBJ,EAGpBD,EAAkB,CAFTI,EAAmB,WAAa3zC,EAAI,QAAUqwC,EAE5B3xB,mBAAoBi1B,EAAkB3zC,EAAGqwC,IAK5E,OAAOkD,GAGTv1B,4BAA8B,SAASw0B,GACrC,IAAIe,EAAiBC,EAAYC,EAAOC,EAAY1zC,EAAGoxB,EAAIif,EAAGsD,EAAkBC,EAAmBxB,EAA2B5vC,EAAG6vC,EAAWwB,EAAevB,EAE3J,GAAsC,KADtCA,EAAyBE,EAAS7vC,WAAW+vC,MAAM,MACxB3yC,OAIzB,MAAO,CAAC,GAAKwwC,KAAK+C,MAAMd,GAAWn0B,uBAAwBkyB,KAAK+C,MAAMd,GAAW,EAAG,GActF,IAjBEJ,EAA4BE,EAAuB,GAAGvyC,OACtDsyC,EAAY,EAAI9B,KAAKoC,IAAI,GAAIP,GAI/BpB,QAAQE,IAAI,cAAgBmB,GAC5BkB,EAAkB,KASlBK,EAAoBE,OAAOC,UAEtB/zC,EAAIwC,EAAI,EAAGA,GAAK,EAAGxC,IAAMwC,EAC5B,IAAK6tC,EAAIjf,EAAK,EAAGA,GAAM,GAAIif,IAAMjf,EAE/BsiB,EAAanD,KAAKoC,IAAIpC,KAAK16B,GAAI7V,GAAKqwC,EAEhCE,KAAK/zB,IAAIk3B,GAAc,OACzBG,EAAQrB,EAAWkB,EACnBC,EAAmBpD,KAAKyD,MAAMH,GAE9BJ,EAAQlD,KAAK/zB,IAAI,EAAIq3B,EAAQF,KAE7BE,EAAQ,EACRF,EAAmB,EACnBF,EAAQlD,KAAK/zB,IAAIg2B,EAAWkB,IAG1BD,EAAQ,EAAIpB,IACdmB,EAAa9L,wBAAwBiM,EAAkB3zC,EAAGqwC,IACzCuD,IAEfA,EAAoBJ,EAGpBD,EAAkB,CAFTI,EAAmB,YAAc3zC,EAAI,QAAUqwC,EAAI,KAEjC1xB,oBAAqBg1B,EAAkB3zC,EAAGqwC,IAM7E,OAAOkD,GAGTn1B,oBAAsB,SAASo0B,GAC7B,IAAI8B,EAAyCC,EAA6BnC,EAA2BC,EAAWC,EAEhH,OAAsC,KADtCA,EAAyBE,EAAS7vC,WAAW+vC,MAAM,MACxB3yC,OAIlB,CAAC,GAAKwwC,KAAK+C,MAAMd,GAAWn0B,uBAAwBkyB,KAAK+C,MAAMd,GAAW,EAAG,IAHpFJ,EAA4BE,EAAuB,GAAGvyC,OACtDsyC,EAAY,EAAI9B,KAAKoC,IAAI,GAAIP,GAI/BpB,QAAQE,IAAI,cAAgBmB,GAGO,OADnCkC,EAA8Bp2B,sBAAsBq0B,IAE3C+B,EAGsC,OAD/CD,EAA0Cp2B,kCAAkCs0B,IAEnE8B,EAEF,OAGTn2B,sBAAwB,SAASq0B,GAC/B,IAAIe,EAAiBC,EAAYC,EAAOe,EAAUd,EAAY1zC,EAAGoxB,EAAIif,EAAGsD,EAAkBC,EAAmBxB,EAA2B5vC,EAAG6vC,EAAWwB,EAAevB,EAErK,GAAsC,KADtCA,EAAyBE,EAAS7vC,WAAW+vC,MAAM,MACxB3yC,OAIzB,MAAO,CAAC,GAAKwwC,KAAK+C,MAAMd,GAAWn0B,uBAAwBkyB,KAAK+C,MAAMd,GAAW,EAAG,GAUtF,IAbEJ,EAA4BE,EAAuB,GAAGvyC,OACtDsyC,EAAY,EAAI9B,KAAKoC,IAAI,GAAIP,GAI/BpB,QAAQE,IAAI,cAAgBmB,GAC5BkB,EAAkB,KAClBK,EAAoBE,OAAOC,UAMtB/zC,EAAIwC,EAAI,EAAGA,GAAK,EAAGxC,IAAMwC,EAC5B,IAAK6tC,EAAIjf,EAAK,EAAGA,GAAM,EAAGif,IAAMjf,EAE9BojB,EAAWx0C,EAAIqwC,EACfqD,EAAanD,KAAKkE,IAAID,GAElBjE,KAAK/zB,IAAIk3B,GAAc,OACzBG,EAAQrB,EAAWkB,EACnBC,EAAmBpD,KAAKyD,MAAMH,GAE9BJ,EAAQlD,KAAK/zB,IAAI,EAAIq3B,EAAQF,KAE7BE,EAAQ,EACRF,EAAmB,EACnBF,EAAQlD,KAAK/zB,IAAIg2B,EAAWkB,IAG1BD,EAAQ,EAAIpB,IACdmB,EAAa9L,wBAAwBiM,EAAkB3zC,EAAGqwC,IACzCuD,IAEfA,EAAoBJ,EAGpBD,EAAkB,CAFTI,EAAmB,WAAa3zC,EAAI,IAAMqwC,EAAI,KAE5BvxB,wBAAyB60B,EAAkB3zC,EAAGqwC,IAKjF,OAAOkD,GAGTr1B,kCAAoC,SAASs0B,GAC3C,IAAIe,EAAiBC,EAAYC,EAAOe,EAAUd,EAAY1zC,EAAGoxB,EAAIif,EAAGsD,EAAkBC,EAAmBxB,EAA2B5vC,EAAG6vC,EAAWwB,EAAevB,EAErK,GAAsC,KADtCA,EAAyBE,EAAS7vC,WAAW+vC,MAAM,MACxB3yC,OAIzB,MAAO,CAAC,GAAKwwC,KAAK+C,MAAMd,GAAWn0B,uBAAwBkyB,KAAK+C,MAAMd,GAAW,EAAG,GAMtF,IATEJ,EAA4BE,EAAuB,GAAGvyC,OACtDsyC,EAAY,EAAI9B,KAAKoC,IAAI,GAAIP,GAI/BpB,QAAQE,IAAI,cAAgBmB,GAC5BkB,EAAkB,KAClBK,EAAoBE,OAAOC,UAEtB/zC,EAAIwC,EAAI,EAAGA,GAAK,GAAIxC,IAAMwC,EAC7B,IAAK6tC,EAAIjf,EAAK,EAAGA,GAAM,GAAIif,IAAMjf,EAE/BojB,EAAWx0C,EAAIqwC,EACfqD,EAAanD,KAAKkE,IAAIlE,KAAK16B,GAAK2+B,GAE5BjE,KAAK/zB,IAAIk3B,GAAc,OACzBG,EAAQrB,EAAWkB,EACnBC,EAAmBpD,KAAKyD,MAAMH,GAE9BJ,EAAQlD,KAAK/zB,IAAI,EAAIq3B,EAAQF,KAE7BE,EAAQ,EACRF,EAAmB,EACnBF,EAAQlD,KAAK/zB,IAAIg2B,EAAWkB,IAI1BD,EAAQ,GAAKpB,IACfmB,EAAa9L,wBAAwBiM,EAAkB3zC,EAAGqwC,IACzCuD,IAEfA,EAAoBJ,EAGpBD,EAAkB,CAFTI,EAAmB,WAAa3zC,EAAI,IAAMqwC,EAAI,UAE5BxxB,iCAAkC80B,EAAkB3zC,EAAGqwC,IAK1F,OAAOkD,GAGT/1B,UAAY,SAASg1B,GACnB,IAAsBkC,EAAkBC,EAAsBC,EAAkCC,EAAmCC,EAA2BC,EAAiBC,EAAcC,EAAiB7C,EAA2BC,EAAWC,EAEpP,OAAsC,KADtCA,EAAyBE,EAAS7vC,WAAW+vC,MAAM,MACxB3yC,OAIlB,CAAC,GAAKwwC,KAAK+C,MAAMd,GAAWn0B,uBAAwBkyB,KAAK+C,MAAMd,GAAW,EAAG,IAHpFJ,EAA4BE,EAAuB,GAAGvyC,OACtDsyC,EAAY,EAAI9B,KAAKoC,IAAI,GAAIP,GAI/BpB,QAAQE,IAAI,cAAgBmB,GAC5B4C,EAAkBnB,OAAOC,UACzBiB,EAAe,EACfD,EAAkB,MACC,EAES,OAD5BJ,EAAuB/2B,eAAe40B,OAEpCwC,EAAetN,wBAAwBiN,IACpBM,GAEfjE,QAAQE,IAAI,yCAA2CyD,EAAuB,gBAAkBK,GAElGC,EAAkBD,EAClBD,EAAkBJ,GAGhB3D,QAAQE,IAAI,yCAA2CyD,EAAuB,gBAAkBK,IAK9E,OADxBN,EAAmBj3B,WAAW+0B,OAE5BwC,EAAetN,wBAAwBgN,IACpBO,GAEfjE,QAAQE,IAAI,qCAAuCwD,EAAmB,gBAAkBM,GAE1FC,EAAkBD,EAClBD,EAAkBL,GAGhB1D,QAAQE,IAAI,qCAAuCwD,EAAmB,gBAAkBM,IAKtD,OADxCJ,EAAmC72B,2BAA2By0B,OAE5DwC,EAAetN,wBAAwBkN,IACpBK,GAEfjE,QAAQE,IAAI,qDAAuD0D,EAAmC,gBAAkBI,GAE1HC,EAAkBD,EAClBD,EAAkBH,GAGhB5D,QAAQE,IAAI,qDAAuD0D,EAAmC,gBAAkBI,IAKrF,OADzCH,EAAoC72B,4BAA4Bw0B,OAE9DwC,EAAetN,wBAAwBmN,IACpBI,GAEfjE,QAAQE,IAAI,sDAAwD2D,EAAoC,gBAAkBG,GAE5HC,EAAkBD,EAClBD,EAAkBF,GAGhB7D,QAAQE,IAAI,sDAAwD2D,EAAoC,gBAAkBG,IAK/F,OADjCF,EAA4B12B,oBAAoBo0B,OAE9CwC,EAAetN,wBAAwBoN,IACpBG,GAEfjE,QAAQE,IAAI,8CAAgD4D,EAA4B,gBAAkBE,GAE5GC,EAAkBD,EAClBD,EAAkBD,GAGhB9D,QAAQE,IAAI,8CAAgD4D,EAA4B,gBAAkBE,IAIzGD,IAGTrN,wBAA0B,SAASwN,EAAS/F,EAAGgG,GAC7C,IAAIC,EAEJ,GADAA,EAAS,KACLF,aAAmBh1C,MAAO,CAK5B,OAAQg1C,EAAQ,IACd,KAAKr2B,iCACHu2B,EAAS,EACT,MAIF,KAAKz2B,oBACHy2B,EAAS7E,KAAKoC,IAAI,EAAGpC,KAAK/zB,IAAI04B,EAAQ,KAAO3E,KAAK/zB,IAAI04B,EAAQ,IAC9D,MACF,KAAKx2B,mBACH02B,EAAS7E,KAAKoC,IAAI,EAAGpC,KAAK/zB,IAAI04B,EAAQ,KAAO3E,KAAK/zB,IAAI04B,EAAQ,IAC9D,MACF,QACEE,EAAS,EAEbA,GAAU7E,KAAK/zB,IAAI04B,EAAQ,KAAO3E,KAAK/zB,IAAI04B,EAAQ,IAAM3E,KAAK/zB,IAAI04B,EAAQ,UAE1EE,GAAU7E,KAAK/zB,IAAI04B,IAAY3E,KAAK/zB,IAAI2yB,GAAKoB,KAAK/zB,IAAI24B,IAsBxD,OAlBmB,IAAfD,EAAQ,GACVE,GAAU,EAEVA,GAAU,EAEO,IAAfF,EAAQ,GACVE,GAAU,EAEVA,GAAU,EAEO,IAAfF,EAAQ,GACVE,GAAU,EAEVA,GAAU,EAERA,EAAS,IACXA,EAAS,GAEJA,GAGT1K,WAAa,WACX,IAAI+I,EAAOe,EAAUx0C,EAAGoxB,EAAIikB,EAAIC,EAAIjF,EAAG9Y,EAAIge,EAAIC,EAAIC,EAAI/D,EAAIgE,EAAIC,EAAI71C,EAAKm0C,EAAM2B,EAAMC,EAAMC,EAAMC,EAAMC,EAAMC,EAAMtE,EAAIuE,EAAIC,EAAIC,EAAIC,EAAI7zC,EAAG8zC,EAAIC,EAAIC,EAAeC,EAAIC,EAAIC,EAAIC,EAAIpS,EAAKC,EAAMmN,EAAMC,EAAMC,EAAMC,EAAMC,EAAMC,EAAM4E,EAAUC,EAAkBC,EAAeC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIt1C,GAAOu1C,GAAIC,GAAIC,GAAIC,GAE7T,IAAKn1C,EAAI,EAAG1C,GADZ0kC,EAAM,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,KACHzkC,OAAQyC,EAAI1C,EAAK0C,IAGrC,IAFAxC,EAAIwkC,EAAIhiC,GAEH4uB,EAAK,EAAG6iB,GADbxP,EAAO,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,KACD1kC,OAAQqxB,EAAK6iB,EAAM7iB,IAEtCpxB,KADJqwC,EAAI5L,EAAKrT,MAIT4f,QAAQE,IAAI,yCAAgDlxC,EAAI,QAAUqwC,GAC1EmE,EAAWx0C,EAAIqwC,EACfpuC,GAAQsuC,KAAKC,KAAKxwC,GAAKqwC,EAEvB0G,GADAF,EAAWj5B,eAAe3b,KACD,GAAKsuC,KAAKC,KAAKqG,EAAS,IAAMA,EAAS,GAC5DtG,KAAK/zB,IAAIva,GAAQ80C,GAAiB,OACpC/F,QAAQE,IAAI,sCAA6ClxC,EAAI,QAAUqwC,EAAI,gBAAkBwG,IAKnG,IAAKtf,EAAK,EAAGqe,GADbhE,EAAO,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,KACD7xC,OAAQw3B,EAAKqe,EAAMre,IAG1C,IAFAv3B,EAAI4xC,EAAKra,GAEJma,EAAK,EAAGmE,GADbhE,EAAO,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,KACD9xC,OAAQ2xC,EAAKmE,EAAMnE,IAEtC1xC,KADJqwC,EAAIwB,EAAKH,MAITV,QAAQE,IAAI,uDAA8DlxC,EAAI,QAAUqwC,GACxFmE,EAAWx0C,EAAIqwC,EAEfpuC,IADAu0C,EAAgBjG,KAAKC,KAAKxwC,GAAKqwC,GACTuH,QAAQ,GAE9Bb,GADAF,EAAWj5B,eAAe3b,KACD,GAAKsuC,KAAKC,KAAKqG,EAAS,IAAMA,EAAS,GAC5DtG,KAAK/zB,IAAIg6B,EAAgBO,GAAiB,OAC5C/F,QAAQE,IAAI,oDAA2DlxC,EAAI,QAAUqwC,EAAI,gBAAkBwG,IAKjH,IAAKlF,EAAK,EAAGmE,GADbhE,EAAO,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,KACD/xC,OAAQ4xC,EAAKmE,EAAMnE,IAG1C,IAFA3xC,EAAI8xC,EAAKH,GAEJyE,EAAK,EAAGL,GADbhE,EAAO,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,KACDhyC,OAAQq2C,EAAKL,EAAMK,IAEtCp2C,KADJqwC,EAAI0B,EAAKqE,MAITpF,QAAQE,IAAI,yCAAgDlxC,EAAI,MAAQqwC,EAAI,MAC5EmE,EAAWx0C,EAAIqwC,EACfpuC,GAAQsuC,KAAKC,KAAKxwC,EAAIqwC,GAEN,OADhBwG,EAAWj5B,eAAe3b,OAExB80C,EAAgBF,EAAS,GAAKtG,KAAKC,KAAKqG,EAAS,GAAKA,EAAS,IAC3DA,EAAS,KAAOr4B,uBAAyB+xB,KAAK/zB,IAAIva,GAAQ80C,GAAiB,OAC7E/F,QAAQE,IAAI,sCAA6ClxC,EAAI,MAAQqwC,EAAI,kBAAoBwG,KAMrG,IAAKP,EAAK,EAAGN,GADbhE,EAAO,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,KACJjyC,OAAQu2C,EAAKN,EAAMM,IAG1C,IAFAt2C,EAAIgyC,EAAKsE,GAEJG,EAAK,EAAGR,GADbhE,EAAO,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,KACJlyC,OAAQ02C,EAAKR,EAAMQ,IAC1CpG,EAAI4B,EAAKwE,GACC,IAANz2C,GAAiB,IAANqwC,IAGfW,QAAQE,IAAI,wDAA+DlxC,EAAI,MAAQqwC,EAAI,MAC3FmE,EAAWx0C,EAAIqwC,EAEfpuC,IADAu0C,EAAgBjG,KAAKC,KAAKxwC,EAAIqwC,IACRuH,QAAQ,GAE9Bb,GADAF,EAAWj5B,eAAe3b,KACD,GAAKsuC,KAAKC,KAAKqG,EAAS,GAAKA,EAAS,IAC3DA,EAAS,KAAOr4B,uBAAyB+xB,KAAK/zB,IAAIg6B,EAAgBO,GAAiB,OACrF/F,QAAQE,IAAI,qDAA4DlxC,EAAI,MAAQqwC,EAAI,kBAAoBwG,IAIlH,IAAK72C,EAAI22C,EAAK,EAAGA,GAAM,EAAG32C,IAAM22C,EAC9B,IAAKtG,EAAI2G,EAAK,EAAGA,GAAM,EAAG3G,IAAM2G,EAC9BhG,QAAQE,IAAI,kCAAyClxC,EAAI,QAAUqwC,GACnEmE,EAAWx0C,EAAIqwC,EACfpuC,GAAQsuC,KAAKW,IAAIlxC,GAAKqwC,EAEtB0G,GADAF,EAAWr5B,UAAUvb,KACI,GAAKsuC,KAAKW,IAAI2F,EAAS,IAAMA,EAAS,GAC3DtG,KAAK/zB,IAAIva,GAAQ80C,GAAiB,OACpC/F,QAAQE,IAAI,+BAAsClxC,EAAI,QAAUqwC,EAAI,gBAAkBwG,GAI5F,IAAK72C,EAAIk3C,EAAK,EAAGA,GAAM,EAAGl3C,IAAMk3C,EAC9B,IAAK7G,EAAI+G,EAAK,EAAGA,GAAM,EAAG/G,IAAM+G,EAC9BpG,QAAQE,IAAI,gDAAuDlxC,EAAI,QAAUqwC,GACjFmE,EAAWx0C,EAAIqwC,EAEfpuC,IADAu0C,EAAgBjG,KAAKW,IAAIlxC,GAAKqwC,GACRuH,QAAQ,GAE9Bb,GADAF,EAAWr5B,UAAUvb,KACI,GAAKsuC,KAAKW,IAAI2F,EAAS,IAAMA,EAAS,GAC3DtG,KAAK/zB,IAAIg6B,EAAgBO,GAAiB,OAC5C/F,QAAQE,IAAI,6CAAoDlxC,EAAI,QAAUqwC,EAAI,gBAAkBwG,GAI1G,IAAK72C,EAAIs3C,EAAK,EAAGA,GAAM,EAAGt3C,IAAMs3C,EAC9B,IAAKjH,EAAImH,GAAK,EAAGA,IAAM,EAAGnH,IAAMmH,GAC9BxG,QAAQE,IAAI,kCAAyClxC,EAAI,MAAQqwC,EAAI,MACrEmE,EAAWx0C,EAAIqwC,EACfpuC,GAAQsuC,KAAKW,IAAIlxC,EAAIqwC,GAErB0G,GADAF,EAAWr5B,UAAUvb,KACI,GAAKsuC,KAAKW,IAAI2F,EAAS,GAAKA,EAAS,IAC1DtG,KAAK/zB,IAAIva,GAAQ80C,GAAiB,OACpC/F,QAAQE,IAAI,+BAAsClxC,EAAI,MAAQqwC,EAAlD,kBAA+EwG,GAIjG,IAAK72C,EAAI03C,GAAK,EAAGA,IAAM,EAAG13C,IAAM03C,GAC9B,IAAKrH,EAAIgF,EAAK,EAAGA,GAAM,EAAGhF,IAAMgF,EAC9BrE,QAAQE,IAAI,gDAAuDlxC,EAAI,MAAQqwC,EAAI,MACnFmE,EAAWx0C,EAAIqwC,EAEfpuC,IADAu0C,EAAgBjG,KAAKW,IAAIlxC,EAAIqwC,IACPuH,QAAQ,GAE9Bb,GADAF,EAAWr5B,UAAUvb,KACI,GAAKsuC,KAAKW,IAAI2F,EAAS,GAAKA,EAAS,IAC1DtG,KAAK/zB,IAAIg6B,EAAgBO,GAAiB,OAC5C/F,QAAQE,IAAI,6CAAoDlxC,EAAI,MAAQqwC,EAAhE,kBAA6FwG,GAI/G,IAAK72C,EAAIu1C,EAAK,EAAGA,GAAM,EAAGv1C,IAAMu1C,EAC9B,IAAKlF,EAAIqF,EAAK,EAAGA,GAAM,GAAIrF,IAAMqF,EAC/B1E,QAAQE,IAAI,mCAA0ClxC,EAAI,QAAUqwC,GACpEmE,EAAWx0C,EAAIqwC,EACfpuC,GAAQsuC,KAAKoC,IAAIpC,KAAK7oC,EAAG1H,GAAKqwC,EAE9B0G,GADAF,EAAWr5B,UAAUvb,KACI,GAAKsuC,KAAKoC,IAAIpC,KAAK7oC,EAAGmvC,EAAS,IAAMA,EAAS,GACnEtG,KAAK/zB,IAAIva,GAAQ80C,GAAiB,OACpC/F,QAAQE,IAAI,gCAAuClxC,EAAI,QAAUqwC,EAAI,gBAAkBwG,GAI7F,IAAK72C,EAAIk2C,EAAK,EAAGA,GAAM,EAAGl2C,IAAMk2C,EAC9B,IAAK7F,EAAIgG,EAAK,EAAGA,GAAM,GAAIhG,IAAMgG,EAC/BrF,QAAQE,IAAI,8DAAqElxC,EAAI,QAAUqwC,GAC/FmE,EAAWx0C,EAAIqwC,EAEfpuC,IADAu0C,EAAgBjG,KAAKoC,IAAIpC,KAAK7oC,EAAG1H,GAAKqwC,GAChBuH,QAAQ,GAE9Bb,GADAF,EAAW94B,2BAA2B9b,KACb,GAAKsuC,KAAKoC,IAAIpC,KAAK7oC,EAAGmvC,EAAS,IAAMA,EAAS,GACnEtG,KAAK/zB,IAAIg6B,EAAgBO,GAAiB,OAC5C/F,QAAQE,IAAI,2DAAkElxC,EAAI,QAAUqwC,EAAI,gBAAkBwG,GAIxH,IAAK72C,EAAIu2C,EAAK,EAAGA,GAAM,EAAGv2C,IAAMu2C,EAC9B,IAAKlG,EAAIqG,EAAK,EAAGA,GAAM,GAAIrG,IAAMqG,EAC/B1F,QAAQE,IAAI,mCAA0ClxC,EAAI,MAAQqwC,GAClEmE,EAAWx0C,EAAIqwC,EACfpuC,GAAQsuC,KAAKoC,IAAIpC,KAAK16B,GAAI7V,GAAKqwC,EAE/B0G,GADAF,EAAWr5B,UAAUvb,KACI,GAAKsuC,KAAKoC,IAAIpC,KAAK16B,GAAIghC,EAAS,IAAMA,EAAS,GACpEtG,KAAK/zB,IAAIva,GAAQ80C,GAAiB,OACpC/F,QAAQE,IAAI,gCAAuClxC,EAAI,MAAQqwC,EAAI,kBAAoBwG,GAI7F,IAAK72C,EAAI42C,EAAK,EAAGA,GAAM,EAAG52C,IAAM42C,EAC9B,IAAKvG,EAAI4G,EAAK,EAAGA,GAAM,GAAI5G,IAAM4G,EAC/BjG,QAAQE,IAAI,+DAAsElxC,EAAI,MAAQqwC,GAC9FmE,EAAWx0C,EAAIqwC,EAEfpuC,IADAu0C,EAAgBjG,KAAKoC,IAAIpC,KAAK16B,GAAI7V,GAAKqwC,GACjBuH,QAAQ,GAE9Bb,GADAF,EAAW74B,4BAA4B/b,KACd,GAAKsuC,KAAKoC,IAAIpC,KAAK16B,GAAIghC,EAAS,IAAMA,EAAS,GACpEtG,KAAK/zB,IAAIg6B,EAAgBO,GAAiB,OAC5C/F,QAAQE,IAAI,4DAAmElxC,EAAI,MAAQqwC,EAAI,kBAAoBwG,GAIzH,IAAK72C,EAAIm3C,EAAK,EAAGA,GAAM,EAAGn3C,IAAMm3C,EAC9B,IAAK9G,EAAIgH,EAAK,EAAGA,GAAM,EAAGhH,IAAMgH,EAC9BrG,QAAQE,IAAI,mCAA0ClxC,EAAI,IAAMqwC,EAAI,MACpEmE,EAAWx0C,EAAIqwC,EACfpuC,GAAQsuC,KAAKkE,IAAID,GAEjBsC,GADAD,EAAWr5B,UAAUvb,KACO,GAAK40C,EAAS,GAC1CE,EAAgBF,EAAS,GAAKtG,KAAKkE,IAAIqC,GACnCvG,KAAK/zB,IAAIva,GAAQ80C,GAAiB,OACpC/F,QAAQE,IAAI,gCAAuClxC,EAAI,IAAMqwC,EAAI,kBAAoBwG,GAK3F,IAAK72C,EAAIu3C,EAAK,EAAGA,GAAM,EAAGv3C,IAAMu3C,EAC9B,IAAKlH,EAAIoH,GAAK,EAAGA,IAAM,EAAGpH,IAAMoH,GAC9BzG,QAAQE,IAAI,iDAAwDlxC,EAAI,IAAMqwC,EAAI,MAClFmE,EAAWx0C,EAAIqwC,EAEfpuC,IADAu0C,EAAgBjG,KAAKkE,IAAID,IACHoD,QAAQ,GAEd,OADhBf,EAAWr5B,UAAUvb,MAEnB+uC,QAAQE,IAAI,8CAAqDlxC,EAAI,IAAMqwC,EAAI,8BAEjFyG,EAAmBD,EAAS,GAAKA,EAAS,GAC1CE,EAAgBF,EAAS,GAAKtG,KAAKkE,IAAIqC,IACvCrD,EAAQlD,KAAK/zB,IAAIg6B,EAAgBO,IACrB,OACV/F,QAAQE,IAAI,8CAAqDlxC,EAAI,IAAMqwC,EAAI,kBAAoBwG,EAAW,WAAapD,GAKjI,IAAKzzC,EAAI23C,GAAK,EAAGA,IAAM,EAAG33C,IAAM23C,GAC9B,IAAKtH,EAAIiF,EAAK,EAAGA,GAAM,EAAGjF,IAAMiF,EAC9BtE,QAAQE,IAAI,iDAAwDlxC,EAAI,IAAMqwC,EAAI,MAClFmE,EAAWx0C,EAAIqwC,EAEfpuC,IADAu0C,EAAgBjG,KAAKkE,IAAID,IACHoD,QAAQ,GAEd,OADhBf,EAAWr5B,UAAUvb,MAEnB+uC,QAAQE,IAAI,8CAAqDlxC,EAAI,IAAMqwC,EAAI,8BAEjFyG,EAAmBD,EAAS,GAAKA,EAAS,GAC1CE,EAAgBF,EAAS,GAAKtG,KAAKkE,IAAIqC,IACvCrD,EAAQlD,KAAK/zB,IAAIg6B,EAAgBO,IACrB,OACV/F,QAAQE,IAAI,8CAAqDlxC,EAAI,IAAMqwC,EAAI,kBAAoBwG,EAAW,WAAapD,GAoKjI,IA/J4B,MAAxBj2B,UADJvb,GAAQ,GACa,IACnB+uC,QAAQE,IAAI,yBAGc,MAAxB1zB,UADJvb,GAAQ,GACa,IACnB+uC,QAAQE,IAAI,2BAGc,MAAxB1zB,UADJvb,GAAQ,GACa,IACnB+uC,QAAQE,IAAI,4BAGc,MAAxB1zB,UADJvb,GAAQ,GACa,IACnB+uC,QAAQE,IAAI,6BAGc,MAAxB1zB,UADJvb,GAAQ,GACa,IACnB+uC,QAAQE,IAAI,8BAGc,MAAxB1zB,UADJvb,GAAQ,GACa,IACnB+uC,QAAQE,IAAI,yBAGc,MAAxB1zB,UADJvb,GAAQ,GACa,IACnB+uC,QAAQE,IAAI,2BAGc,MAAxB1zB,UADJvb,GAAQ,GACa,IACnB+uC,QAAQE,IAAI,4BAGc,MAAxB1zB,UADJvb,GAAQ,GACa,IACnB+uC,QAAQE,IAAI,6BAGc,MAAxB1zB,UADJvb,GAAQ,GACa,IACnB+uC,QAAQE,IAAI,8BAGc,MAAxB1zB,UADJvb,GAAQ,GACa,IACnB+uC,QAAQE,IAAI,+BAEdjvC,GAAQsuC,KAAKC,KAAK,GACU,sBAAxBhzB,UAAUvb,IAAO,IACnB+uC,QAAQE,IAAI,oCAGc,sBAAxB1zB,UADJvb,GAAQ,MACa,IACnB+uC,QAAQE,IAAI,4BAKmB,sBAA7BtzB,eADJ3b,GAAQ,KACkB,IACxB+uC,QAAQE,IAAI,4BAGe,qBAAzBzzB,WADJxb,GAAQ,IACc,IACpB+uC,QAAQE,IAAI,wBAGe,qBAAzBzzB,WADJxb,GAAQ,KACc,IACpB+uC,QAAQE,IAAI,yBAGe,qBAAzBzzB,WADJxb,GAAQ,IACc,IACpB+uC,QAAQE,IAAI,wBAGe,qBAAzBzzB,WADJxb,GAAQ,MACc,IACpB+uC,QAAQE,IAAI,yBAGc,qBAAxB1zB,UADJvb,GAAQ,MACa,IACnB+uC,QAAQE,IAAI,wBAGc,qBAAxB1zB,UADJvb,GAAQ,OACa,IACnB+uC,QAAQE,IAAI,yBAGc,qBAAxB1zB,UADJvb,GAAQ,KACa,IACnB+uC,QAAQE,IAAI,uBAGc,qBAAxB1zB,UADJvb,GAAQ,MACa,IACnB+uC,QAAQE,IAAI,wBAEdjvC,GAAQsuC,KAAKC,KAAK,GACU,sBAAxBhzB,UAAUvb,IAAO,IACnB+uC,QAAQE,IAAI,oCAGc,MAAxB1zB,UADJvb,GAAQ,GACa,IACnB+uC,QAAQE,IAAI,8BAGc,wBAAxB1zB,UADJvb,GAAQ,UACa,IACnB+uC,QAAQE,IAAI,gCAGc,yBAAxB1zB,UADJvb,GAAQ,UACa,IACnB+uC,QAAQE,IAAI,gCAGc,0BAAxB1zB,UADJvb,GAAQ,UACa,IACnB+uC,QAAQE,IAAI,gCAGc,+BAAxB1zB,UADJvb,GAAQ,mBACa,IACnB+uC,QAAQE,IAAI,yCAEdjvC,GAAQsuC,KAAKC,KAAK,GACoB,wBAAlCpyB,oBAAoBnc,IAAO,IAC7B+uC,QAAQE,IAAI,0CAEdjvC,GAAQsuC,KAAKC,KAAK,GACoB,wBAAlCpyB,oBAAoBnc,IAAO,IAC7B+uC,QAAQE,IAAI,0CAEdjvC,IAASsuC,KAAKC,KAAK,GAAKD,KAAKC,KAAK,IAAM,EACZ,yBAAxBhzB,UAAUvb,IAAO,IACnB+uC,QAAQE,IAAI,uDAEdjvC,GAAQsuC,KAAKC,KAAK,EAAID,KAAKC,KAAK,IAAM,EACV,wBAAxBhzB,UAAUvb,IAAO,IACnB+uC,QAAQE,IAAI,qDAEdjvC,IAASsuC,KAAKC,KAAK,GAAKD,KAAKC,KAAK,IAAM,EACZ,yBAAxBhzB,UAAUvb,IAAO,IACnB+uC,QAAQE,IAAI,uDAEdjvC,GAAQsuC,KAAKC,KAAK,EAAID,KAAKC,KAAK,IAAM,EACV,yBAAxBhzB,UAAUvb,IAAO,IACnB+uC,QAAQE,IAAI,qDAEdjvC,IAASsuC,KAAKC,KAAK,GAAK,GAAK,EACD,yBAAxBhzB,UAAUvb,IAAO,IACnB+uC,QAAQE,IAAI,4CAEdjvC,GAAQsuC,KAAKC,KAAK,GAAK,EAAID,KAAKC,KAAK,IAAM,EACf,wBAAxBhzB,UAAUvb,IAAO,IACnB+uC,QAAQE,IAAI,wDAGdjvC,GAAQsuC,KAAKkE,IAAIlE,KAAK16B,GAAK,GACC,wBAAxB2H,UAAUvb,IAAO,IACnB+uC,QAAQE,IAAI,2CAGdjvC,GAAQsuC,KAAKkE,IAAIlE,KAAK16B,GAAK,GACC,wBAAxB2H,UAAUvb,IAAO,IACnB+uC,QAAQE,IAAI,2CAGgC,wBAA1ClzB,4BADJ/b,GAAQ,YAC+B,IACrC+uC,QAAQE,IAAI,gDAETlxC,EAAIw1C,EAAK,EAAGA,GAAM,GAAIx1C,IAAMw1C,EAC/B,IAAKnF,EAAIoF,EAAK,EAAGA,GAAM,GAAIpF,IAAMoF,EAC/BzE,QAAQE,IAAI,yCAAgDlxC,EAAI,IAAMqwC,EAAI,WAC1EmE,EAAWx0C,EAAIqwC,EACfpuC,GAAQsuC,KAAKkE,IAAIlE,KAAK16B,GAAK2+B,GAK3BsC,GADAD,EAAWz4B,oBAAoBnc,KACH,GAAK40C,EAAS,GAC1CE,EAAgBF,EAAS,GAAKtG,KAAKkE,IAAIlE,KAAK16B,GAAKihC,GAC7CvG,KAAK/zB,IAAIva,GAAQ80C,GAAiB,OACpC/F,QAAQE,IAAI,sCAA6ClxC,EAAI,IAAMqwC,EAAI,uBAAyBwG,GAItG,IAAK72C,EAAI21C,EAAK,EAAGA,GAAM,GAAI31C,IAAM21C,EAC/B,IAAKtF,EAAI8F,EAAK,EAAGA,GAAM,GAAI9F,IAAM8F,EAKrB,IAANn2C,GAAiB,KAANqwC,GAAkB,IAANrwC,GAAiB,KAANqwC,IAGtCW,QAAQE,IAAI,uDAA8DlxC,EAAI,IAAMqwC,EAAI,WACxFmE,EAAWx0C,EAAIqwC,EAEfpuC,IADAu0C,EAAgBjG,KAAKkE,IAAIlE,KAAK16B,GAAK2+B,IACboD,QAAQ,GAK9Bd,GADAD,EAAWz4B,oBAAoBnc,KACH,GAAK40C,EAAS,GAC1CE,EAAgBF,EAAS,GAAKtG,KAAKkE,IAAIlE,KAAK16B,GAAKihC,IACjDrD,EAAQlD,KAAK/zB,IAAIg6B,EAAgBO,IACrB,OACV/F,QAAQE,IAAI,oDAA2DlxC,EAAI,IAAMqwC,EAAI,uBAAyBwG,EAAW,WAAapD,IAI5I,OAAOzC,QAAQE,IAAI,oBAGrBjuC,EAAE2a,eAAiBA,eAEnB3a,EAAE6a,sBAAwBA,sBAE1B7a,EAAEua,UAAYA,UAEdva,EAAEynC,WAAaA,WAEf1hC,YAAc,WAGZ,OAFAhH,KAAKuf,KAAKwb,KACVt0B,OACOuW,UAGTA,OAAS,WACP,IAAIwwB,EAKJ,GAJI,EACJA,EAAI,EACJlK,OACAvI,GAAKqB,MACD3c,IAAIsb,MAAQ4M,OAAO/jC,KAGrB,OAFA5D,KAAKuf,KAAKwb,UACV8H,UAGF,GAAI9Q,SAASgJ,IAQX,OAPQ,EACRyS,EAAIe,KAAKsH,KAAK9a,GAAGyS,GAIjBzM,YAAYyM,QACZ3K,UAKF,GAAKlP,iBAAiBoH,KAAStb,IAAIsb,MAAQ4M,OAAOn1B,WAAa8W,OAAO7J,IAAIU,IAAI4a,KAAM,EAAG,IAAMtb,IAAIA,IAAIU,IAAIA,IAAI4a,SAAW4M,OAAO5zB,QAAUsV,OAAO5J,IAAIU,IAAIV,IAAIU,IAAIA,IAAI4a,QAAS,IAAMzR,OAAO7J,IAAIU,IAAIA,IAAIV,IAAIU,IAAIA,IAAI4a,SAAU,EAAG,GAS7N,OARIrR,mBACFqX,YAAYwN,KAAK16B,GAAK,IAEtButB,cAAc,EAAG,GACjBC,YAAYxtB,IACZwkB,iBAEFwK,UAKF,GAAK7P,sBAAsB+H,KAAStb,IAAIsb,MAAQ4M,OAAOn1B,WAAa8W,OAAO7J,IAAIU,IAAI4a,MAAO,EAAG,IAAMtb,IAAIA,IAAIU,IAAIA,IAAI4a,SAAW4M,OAAO5zB,QAAUsV,OAAO5J,IAAIU,IAAIV,IAAIU,IAAIA,IAAI4a,QAAS,IAAMzR,OAAO7J,IAAIU,IAAIA,IAAIV,IAAIU,IAAIA,IAAI4a,SAAU,EAAG,GASnO,OARIrR,mBACFqX,YAAsB,EAAVwN,KAAK16B,GAAW,IAE5ButB,cAAc,EAAG,GACjBC,YAAYxtB,IACZwkB,iBAEFwK,UAIF,GAAIhO,mBAAmBkG,IASrB,OARIrR,mBACFqX,YAAYwN,KAAK16B,GAAK,IAEtButB,cAAc,EAAG,GACjBC,YAAYxtB,IACZwkB,iBAEFwK,UAIF,GAAI3P,wBAAwB6H,IAS1B,OARIrR,mBACFqX,YAAY,EAAMwN,KAAK16B,GAAK,IAE5ButB,cAAc,EAAG,GACjBC,YAAYxtB,IACZwkB,iBAEFwK,UAGF,IAAKnO,WAAWqG,IAKd,OAJAsG,YAAY9/B,QACZvB,KAAK+6B,IACL9E,KAAK,QACL4M,UAOF,OAJA7iC,KAAK+6B,IACLoG,aAAa,GACb9I,WACIkE,eAEF,KAAM,EACA7S,mBACFqX,YAAYwN,KAAK16B,IAEjBwtB,YAAYxtB,IAEd,MACF,KAAM,EACA6V,mBACFqX,YAAsB,EAAVwN,KAAK16B,GAAW,IAE5ButB,cAAc,EAAG,GACjBC,YAAYxtB,IACZwkB,YAEF,MACF,KAAK,EACC3O,mBACFqX,YAAYwN,KAAK16B,GAAK,IAEtButB,cAAc,EAAG,GACjBC,YAAYxtB,IACZwkB,YAEF,MACF,KAAK,EACC3O,mBACFqX,YAAYwN,KAAK16B,GAAK,IAEtButB,cAAc,EAAG,GACjBC,YAAYxtB,IACZwkB,YAEF,MACF,KAAK,EACC3O,mBACFqX,YAAY,GAEZ/gC,KAAK6sC,MAEP,MACF,QACExL,YAAY9/B,QACZvB,KAAK+6B,IACL9E,KAAK,GAET,OAAO4M,WAGT57B,aAAe,WAGb,OAFAjH,KAAKuf,KAAKwb,KACVt0B,OACOwW,WAGTA,QAAU,WACR,IAAIuwB,EAIJ,OAHAA,EAAI,EACJlK,OACAvI,GAAKqB,MACD3c,IAAIsb,MAAQ4M,OAAO9jC,OACrB7D,KAAKuf,KAAKwb,UACV8H,WAGE9Q,SAASgJ,MACXyS,EAAIzS,GAAGyS,GACC,GACNrG,KAAK,8CAEPqG,EAAIe,KAAKW,IAAI1B,EAAIe,KAAKC,KAAKhB,EAAIA,EAAI,IACnCzM,YAAYyM,QACZ3K,WAGEhP,UAAUkH,KACZ/6B,KAAK6sC,WACLhK,YAGFxB,YAAY7/B,SACZxB,KAAK+6B,IACL9E,KAAK,GACE4M,YAGT37B,YAAc,WAGZ,OAFAlH,KAAKuf,KAAKwb,KACVt0B,OACOyW,UAGTA,OAAS,WACP,IAAIswB,EAKJ,GAJI,EACJA,EAAI,EACJlK,OACAvI,GAAKqB,MACD3c,IAAIsb,MAAQ4M,OAAO7xB,KAGrB,OAFA9V,KAAKuf,KAAKwb,UACV8H,UAGF,GAAI9Q,SAASgJ,IAQX,OAPQ,EACRyS,EAAIe,KAAKuH,KAAK/a,GAAGyS,GAIjBzM,YAAYyM,QACZ3K,UAKF,GAAKlP,iBAAiBoH,KAAStb,IAAIsb,MAAQ4M,OAAOn1B,WAAa8W,OAAO7J,IAAIU,IAAI4a,KAAM,EAAG,IAAMtb,IAAIA,IAAIU,IAAIA,IAAI4a,SAAW4M,OAAO5zB,QAAUsV,OAAO5J,IAAIU,IAAIV,IAAIU,IAAIA,IAAI4a,QAAS,IAAMzR,OAAO7J,IAAIU,IAAIA,IAAIV,IAAIU,IAAIA,IAAI4a,SAAU,EAAG,GAK7N,OAJAqG,cAAc,EAAG,GACjBC,YAAYxtB,IACZwkB,gBACAwK,UAKF,GAAK7P,sBAAsB+H,KAAStb,IAAIsb,MAAQ4M,OAAOn1B,WAAa8W,OAAO7J,IAAIU,IAAI4a,MAAO,EAAG,IAAMtb,IAAIA,IAAIU,IAAIA,IAAI4a,SAAW4M,OAAO5zB,QAAUsV,OAAO5J,IAAIU,IAAIV,IAAIU,IAAIA,IAAI4a,QAAS,IAAMzR,OAAO7J,IAAIU,IAAIA,IAAIV,IAAIU,IAAIA,IAAI4a,SAAU,EAAG,GASnO,OARIrR,mBACFqX,aAAawN,KAAK16B,GAAK,IAEvButB,eAAe,EAAG,GAClBC,YAAYxtB,IACZwkB,iBAEFwK,UAIF,GAAIhO,mBAAmBkG,IASrB,OARIrR,mBACFqX,YAAYwN,KAAK16B,GAAK,IAEtButB,cAAc,EAAG,GACjBC,YAAYxtB,IACZwkB,iBAEFwK,UAIF,GAAI3P,wBAAwB6H,IAS1B,OARIrR,mBACFqX,aAAawN,KAAK16B,GAAK,IAEvButB,eAAe,EAAG,GAClBC,YAAYxtB,IACZwkB,iBAEFwK,UAGF,IAAKnO,WAAWqG,IAKd,OAJAsG,YAAY5/B,QACZzB,KAAK+6B,IACL9E,KAAK,QACL4M,UAOF,OAJA7iC,KAAK+6B,IACLoG,aAAa,GACb9I,WACIkE,eAEF,KAAM,EACA7S,mBACFqX,aAAawN,KAAK16B,GAAK,IAEvButB,eAAe,EAAG,GAClBC,YAAYxtB,IACZwkB,YAEF,MACF,KAAM,EACA3O,mBACFqX,aAAawN,KAAK16B,GAAK,IAEvButB,eAAe,EAAG,GAClBC,YAAYxtB,IACZwkB,YAEF,MACF,KAAK,EACC3O,mBACFqX,YAAY,GAEZ/gC,KAAK6sC,MAEP,MACF,KAAK,EACCnjB,mBACFqX,YAAYwN,KAAK16B,GAAK,IAEtButB,cAAc,EAAG,GACjBC,YAAYxtB,IACZwkB,YAEF,MACF,KAAK,EACC3O,mBACFqX,YAAYwN,KAAK16B,GAAK,IAEtButB,cAAc,EAAG,GACjBC,YAAYxtB,IACZwkB,YAEF,MACF,QACEgJ,YAAY5/B,QACZzB,KAAK+6B,IACL9E,KAAK,GAET,OAAO4M,WAGT17B,aAAe,WAGb,OAFAnH,KAAKuf,KAAKwb,KACVt0B,OACO0W,WAGTA,QAAU,WACR,IAAIqwB,EAIJ,OAHAA,EAAI,EACJlK,OACAvI,GAAKqB,MACD3c,IAAIsb,MAAQ4M,OAAO5xB,OACrB/V,KAAKuf,KAAKwb,UACV8H,WAGE9Q,SAASgJ,KACXyS,EAAIzS,GAAGyS,EACPA,EAAIe,KAAKW,IAAI1B,EAAIe,KAAKC,KAAKhB,EAAIA,EAAI,IACnCzM,YAAYyM,QACZ3K,WAGE/R,mBAAmBiK,KACrB/6B,KAAK6sC,WACLhK,YAGFxB,YAAY3/B,SACZ1B,KAAK+6B,IACL9E,KAAK,GACE4M,YAGTz7B,YAAc,WAGZ,OAFApH,KAAKuf,KAAKwb,KACVt0B,OACO2W,WAGTA,QAAS,WACP,IAAIowB,EAIJ,OAHAA,EAAI,EACJlK,OACAvI,GAAKqB,MACD3c,IAAIsb,MAAQ4M,OAAOjwB,MACrB1X,KAAKuf,KAAKwb,UACV8H,WAGE9Q,SAASgJ,KACH,EACRyS,EAAIe,KAAKwH,KAAKhb,GAAGyS,GAIjBzM,YAAYyM,QACZ3K,WAGE/R,mBAAmBiK,KACrB/6B,KAAK6sC,WACLhK,WAGEzP,WAAW2H,KACb/6B,KAAK+6B,IACLhC,SACA3b,UACA2b,cACA8J,WAIE/yB,MAAKirB,GAAI4M,OAAO7xB,OAAShG,MAAKirB,GAAI4M,OAAO/jC,QAC3C5D,KAAK+6B,IACLV,aACAW,GAAKoB,MACLp8B,KAAK+6B,IACL3V,eACA6V,GAAKmB,MACD3c,IAAIub,MAAQ2M,OAAO7xB,MAAQ2J,IAAIwb,MAAQ0M,OAAO/jC,MAAQwlB,MAAM7J,KAAKyb,IAAKzb,KAAK0b,OAC7Ej7B,KAAKuf,KAAKyb,UACV6H,WAMCpjB,IAAIsb,MAAQ4M,OAAO5zB,QAAUsV,OAAO9J,KAAKwb,IAAK,IAAMzR,OAAOhK,MAAMyb,KAAM,EAAG,IAAQtb,IAAIsb,MAAQ4M,OAAOn1B,WAAa8W,OAAO7J,IAAIU,IAAI4a,KAAM,EAAG,IAAMtb,IAAIA,IAAIU,IAAIA,IAAI4a,SAAW4M,OAAO5zB,QAAUsV,OAAO5J,IAAIU,IAAIV,IAAIU,IAAIA,IAAI4a,QAAS,IAAMzR,OAAO7J,IAAIU,IAAIA,IAAIV,IAAIU,IAAIA,IAAI4a,SAAU,EAAG,IACrRqG,cAAc,EAAG,GACb1X,mBACFqX,YAAYwN,KAAK16B,IAEjB7T,KAAK2nC,OAAO9zB,KAEdwkB,gBACAwK,WAIExZ,OAAO0R,GAAI,IACbqG,cAAc,EAAG,GACb1X,mBACFqX,YAAYwN,KAAK16B,IAEjB7T,KAAK2nC,OAAO9zB,KAEdwkB,gBACAwK,WAIEpjB,IAAIsb,MAAQ4M,OAAO5zB,QAAUsV,OAAO9J,KAAKwb,IAAK,IAAMzR,OAAOhK,MAAMyb,IAAK,EAAG,IAC3EqG,cAAc,EAAG,GACb1X,mBACFqX,YAAYwN,KAAK16B,IAEjB7T,KAAK2nC,OAAO9zB,KAEdwkB,gBACAwK,YAGFxB,YAAY1/B,QACZ3B,KAAK+6B,IACL9E,KAAK,GACE4M,YAGTx7B,aAAe,WAGb,OAFArH,KAAKuf,KAAKwb,KACVt0B,OACO4W,WAGTA,QAAU,WACR,IAAImwB,EAIJ,OAHAA,EAAI,EACJlK,OACAvI,GAAKqB,MACD3c,IAAIsb,MAAQ4M,OAAOhwB,OACrB3X,KAAKuf,KAAKwb,UACV8H,WAGE9Q,SAASgJ,OACXyS,EAAIzS,GAAGyS,IACE,GAAOA,EAAI,IAClBrG,KAAK,2DAEPqG,EAAIe,KAAKW,KAAK,EAAM1B,IAAM,EAAMA,IAAM,EACtCzM,YAAYyM,QACZ3K,WAGE/R,mBAAmBiK,KACrB/6B,KAAK6sC,WACLhK,YAGFxB,YAAYz/B,SACZ5B,KAAK+6B,IACL9E,KAAK,GACE4M,YAGT5+B,WAAY,EAEZqD,SAAW,WAGT,OAFAtH,KAAKuf,KAAKwb,KACVt0B,OACO8W,OAGTA,IAAM,WAUJ,OATA+lB,OACAvI,GAAKqB,MACLp8B,KAAK+6B,IACLV,aACA0Q,QACA/qC,KAAK+6B,IACL3V,eACA2lB,QACAvD,WACO3E,WAKTkI,MAAQ,WAIN,GAHAzH,OACAvI,GAAKqB,MAED7H,iBAAiBwG,KAAOA,KAAO4M,OAAO9zB,IACpCke,SAASgJ,KAAOrR,mBAClBqX,YAAY,GAEZI,aAAa,QAEV,GAAI9N,iBAAiB0H,IACtBhJ,SAASgJ,KAAOrR,mBAClBqX,YAAYwN,KAAK16B,IAEjB7T,KAAK2nC,OAAO9zB,KAEdklB,cAKK,GAAIhE,SAASgG,IAClBsG,YAAYx/B,KACZ7B,KAAK+6B,IACL9E,KAAK,QACA,GAAIxW,IAAIsb,MAAQ4M,OAAO5zB,QAAUsV,OAAO9J,KAAKwb,KAAM,GAEpDrR,mBACFqX,YAAYwN,KAAK16B,IAEjB7T,KAAK2nC,OAAO9zB,KAEd7T,KAAKsf,MAAMyb,KACX1C,gBACK,GAAI5Y,IAAIsb,MAAQ4M,OAAO5zB,QAAUwL,KAAKwb,MAAQ4M,OAAOjiC,GAE1D1F,KAAKsf,MAAMyb,KACX1L,YAGK,GAAI5P,IAAIsb,MAAQ4M,OAAO5zB,QAAU6f,aAAatU,MAAMyb,KACrD92B,WACF+qC,QAAQE,IAAI,kBAAoBnU,IAKlC/6B,KAAKuf,KAAKwb,KACVxd,MACItZ,WACF+qC,QAAQE,IAAI,YAAcpI,MAAMqC,IAAM,IAExCnpC,KAAKsf,MAAMyb,KACX1C,gBACK,GAAI5Y,IAAIsb,MAAQ4M,OAAOn1B,UAI5B,IAFA2uB,aAAa,GACbpG,GAAK5a,IAAI4a,IACFnJ,OAAOmJ,KACZ/6B,KAAKyf,IAAIsb,KACTxd,MACA3C,MACAmgB,GAAK5a,IAAI4a,SAEFtb,IAAIsb,MAAQ4M,OAAOxmC,MAE5BnB,KAAK+6B,IACLsH,QACAtH,GAAKqB,MACLp8B,KAAK+6B,IACLoH,OACAnH,GAAKoB,MACLp8B,KAAK+6B,IACL1L,OACA4L,GAAKmB,MACDtL,mBAAmBkK,KACjBtR,mBACFqX,YAAYwN,KAAK16B,IAEjB7T,KAAK2nC,OAAO9zB,KAEVuf,WAAW6H,KACblC,WAGF/4B,KAAKi7B,IACLj7B,KAAKg7B,IACL9U,SACA9I,UACIgW,WAAW4H,MACTtR,mBACFqX,YAAYwN,KAAK16B,IAEjBwtB,YAAYxtB,IAEVuf,WAAW6H,IACbuM,WAEA5sB,SAKDkW,mBAAmBhD,YAAY6Z,OAAO7lC,0BAMzCu/B,YAAYx/B,KACZ7B,KAAK+6B,IACL9E,KAAK,IANLkL,aAAa,GASjB,OAAO0B,WAITllB,MAAO,WACL,IAAIowB,EAAG0B,EAAGD,EAAGf,EAAGuH,EAAGC,EAenB,GAdAlI,EAAI,EACA,EACA,EACA,EACA,EACA,EACJ3jB,YACAkZ,OACAvI,GAAKqB,MACLqT,EAAI1b,mBAAmBgH,GAAI4M,OAAOvwB,WAClCo4B,EAAIzb,mBAAmBgH,GAAI4M,OAAOtwB,WAClCo3B,EAAI1a,mBAAmBgH,GAAI4M,OAAOrwB,WAClC0+B,EAAIjiB,mBAAmBgH,GAAI4M,OAAOnwB,WAClCy+B,EAAIliB,mBAAmBgH,GAAI4M,OAAOlwB,WACxB,IAANg4B,GAAiB,IAAND,GAAiB,IAANf,GAAiB,IAANuH,GAAiB,IAANC,EAC9Cjb,GAAK2M,OAAOvwB,UACZwG,iBACK,GAAU,IAAN6xB,GAAiB,IAAND,GAAiB,IAANf,GAAiB,IAANuH,GAAiB,IAANC,EACrDjb,GAAK2M,OAAOtwB,UACZuG,iBACK,GAAU,IAAN6xB,GAAiB,IAAND,GAAiB,IAANf,GAAiB,IAANuH,GAAiB,IAANC,EACrDjb,GAAK2M,OAAOrwB,UACZsG,iBACK,GAAU,IAAN6xB,GAAiB,IAAND,GAAiB,IAANf,GAAiB,IAANuH,GAAiB,IAANC,EACrDjb,GAAK2M,OAAOnwB,UACZoG,iBACK,GAAU,IAAN6xB,GAAiB,IAAND,GAAiB,IAANf,GAAiB,IAANuH,GAAiB,IAANC,EACrDjb,GAAK2M,OAAOlwB,UACZmG,iBAKK,GAAKgU,OAAOmJ,KAAQtb,IAAIsb,MAAQ4M,OAAOh4B,KAAM,CAIlD,IAHAo+B,EAAI5E,IACJnpC,KAAKyf,IAAIsb,KACTA,GAAK5a,IAAI4a,IACFnJ,OAAOmJ,KACZ/6B,KAAKyf,IAAIsb,KACTpd,QACAod,GAAK5a,IAAI4a,IAEX9E,KAAKkT,IAAM4E,QAEX/tC,KAAK+6B,IAGP,OADA8H,UACOzY,aAGT+R,UAAW,WACT,IAAI4R,EAKJ,GAJAA,EAAI,EACJzK,OACAtI,GAAKoB,MACLrB,GAAKqB,MACDrI,mBAAmBgH,GAAIC,IACzBpd,iBACK,GAAIgU,OAAOmJ,IAAK,CAIrB,IAHAgT,EAAI5E,IACJnpC,KAAKyf,IAAIsb,KACTA,GAAK5a,IAAI4a,IACFnJ,OAAOmJ,KACZ/6B,KAAKyf,IAAIsb,KACT/6B,KAAKg7B,IACLmB,YACApB,GAAK5a,IAAI4a,IAEX9E,KAAKkT,IAAM4E,QAEX/tC,KAAK+6B,IAEP,OAAO8H,WAGTjlB,UAAY,WACV,IAAIsvB,EAAGa,EAAG/vC,EAAGyvC,EAAG/sC,EAAGF,EASnB,IARI,EACJxC,EAAI,EACA,EACA,EAEJkvC,EAAI/D,IACJsE,EAAI9rB,MAAMqZ,GAAID,IACdgT,EAAI5E,IACCnrC,EAAIwC,EAAUitC,EAAI,EAAGjtC,GAAK,EAAGxC,EAAIwC,IAAM,EAC1Cu6B,GAAK+L,MAAMoG,EAAIlvC,GACf6f,eAAe7f,GAWjB,OATA0C,EAAIyoC,IAAM4E,GACF,IACN9X,KAAKv1B,GACLV,KAAK2nC,OAAOxmC,MACZumC,OACA/kB,QAEFoY,GAAKqB,MACL3E,QAAQ0R,IAAMsE,GACPztC,KAAK+6B,KAMdld,eAAiB,SAAS4vB,GACxB,IAAIM,EAAGrtC,EAGP,GAFI,EACA,GACAowB,mBAAmBiK,IAAvB,CAIA,GAAU,IAAN0S,EAAJ,CAcA,GAFAM,EAAI5E,IAEA1pB,IAAIsb,MAAQ4M,OAAOn1B,UAErB,IADAuoB,GAAK5a,IAAI4a,IACFnJ,OAAOmJ,KACZ/6B,KAAKyf,IAAIsb,KACTA,GAAK5a,IAAI4a,SAED1R,OAAO0R,GAAI,IACrB/6B,KAAK+6B,IAYP,OATU,IAAN0S,EACFztC,KAAKg7B,KAELh7B,KAAK2nC,OAAO5zB,QACZ/T,KAAKg7B,IACLmG,aAAasM,GACbxX,KAAK,KAEPv1B,EAAIyoC,IAAM4E,GACF,GACN9X,KAAKv1B,GACLV,KAAK2nC,OAAOn1B,WACZk1B,OACO/kB,aAJT,EAhCE,GAAIlD,IAAIsb,MAAQ4M,OAAOxmC,KAErB,IADA45B,GAAK5a,IAAI4a,IACFnJ,OAAOmJ,KACZ/6B,KAAKyf,IAAIsb,KACTA,GAAK5a,IAAI4a,SAGX/6B,KAAK+6B,MAiCXxzB,aAAe,WAKb,OAJAvH,KAAKuf,KAAKwb,KACVt0B,OACAzG,KAAKsf,MAAMyb,KACXt0B,OACOqX,WAGTA,QAAU,WAGR,OAFAwlB,OACA0H,YACOnI,WAMTmI,UAAY,WACV,IAAIwC,EAAG9sC,EAQP,GAPA8sC,EAAI,EACA,EACJxS,GAAKoB,MACLrB,GAAKqB,MACLp8B,KAAKg7B,IACLt6B,EAAI67B,cAEAxK,SAASgJ,MAAQsW,MAAM3wC,GAGzB,OAFA8sC,EAAI0I,GAAGx1C,EAAGq6B,GAAGyS,QACbzM,YAAYyM,GAId,GAAI1c,mBAAmBiK,KAAOjK,mBAAmBkK,IAC/CmG,aAAa,OADf,CAKA,IAAIrQ,mBAAmBiK,KAAQsW,MAAM3wC,GAKrC,OAAIs6B,GAAGyS,IAAMp6B,KAAOpB,OAAO+oB,GAAGqS,EAAEF,EAAG,GAE7Bl7B,OAAO+oB,GAAGqS,EAAEH,EAAG,IACbxjB,mBACFqX,YAAY,EAAMwN,KAAK16B,KAEvBstB,aAAa,GACbE,YAAYxtB,IACZqS,UAEFlmB,KAAK+6B,IACL7U,SACAkb,cAAc,EAAG,GACjB5E,QACAx8B,KAAK+6B,IACLwL,YACAlO,YAIEpmB,OAAO+oB,GAAGqS,EAAEH,GAAI,IACdxjB,mBACFqX,YAAY,EAAMwN,KAAK16B,KAEvBstB,aAAa,GACbE,YAAYxtB,IACZqS,UAEFlmB,KAAK+6B,IACL7U,SACAkb,cAAc,EAAG,GACjB5E,QACAx8B,KAAK+6B,IACL9X,cACAoV,aAIF8I,aAAa5uB,MAAMyoB,GAAGqS,EAAEH,IACxBjS,GAAKmB,MACL+E,aAAa,GACbnhC,KAAK+6B,IACL7U,SACAlmB,KAAKg7B,IACLh7B,KAAKi7B,IACLuM,WACAnP,WACAr4B,KAAK+6B,IACL/6B,KAAKg7B,IACLh7B,KAAKi7B,IACLuM,WACA1pB,UACAua,WACAr4B,KAAK+6B,IACL/6B,KAAKg7B,IACLmG,aAAa,GACbnhC,KAAKi7B,IACL5C,WACAmP,WACA1pB,eACA0pB,YAIElU,eAAeyH,KACjB/6B,KAAK+6B,IACLhC,SACA/4B,KAAKg7B,IACLwB,QACAx8B,KAAK+6B,IACL/6B,KAAKg7B,IACLjC,SACAyD,QACAnE,WACAgJ,YAAYn/B,SACZlC,KAAK+6B,IACLhC,SACA/4B,KAAKg7B,IACL/E,KAAK,QACLoC,YAGE/E,eAAe0H,KACjBmG,cAAc,GACdnhC,KAAKg7B,IACLwB,QACA6E,YAAYn/B,SACZlC,KAAK+6B,IACL/6B,KAAKg7B,IACLjC,SACA9C,KAAK,QACLoC,aAIFr4B,KAAK2nC,OAAOzlC,UACZlC,KAAK+6B,IACL/6B,KAAKg7B,IACE/E,KAAK,IAtGVkL,aAAa,KAyGjB35B,aAAe,WAKb,OAJAxH,KAAKuf,KAAKwb,KACVt0B,OACAzG,KAAKsf,MAAMyb,KACXt0B,OACOsX,WAGTA,QAAU,WAGR,OAFAulB,OACA2H,YACOpI,WAKToI,UAAY,WACV,IAAIuC,EAAG9sC,EAOP,OANA8sC,EAAI,EACA,EACJxS,GAAKoB,MACLrB,GAAKqB,MACLp8B,KAAKg7B,IACLt6B,EAAI67B,cACAxK,SAASgJ,MAAQsW,MAAM3wC,IACzB8sC,EAAI2I,GAAGz1C,EAAGq6B,GAAGyS,QACbzM,YAAYyM,IAGVla,eAAe0H,KACjBmG,cAAc,GACdnhC,KAAKg7B,IACLwB,QACA6E,YAAYl/B,SACZnC,KAAK+6B,IACL/6B,KAAKg7B,IACLjC,SACA9C,KAAK,QACLoC,aAGFgJ,YAAYl/B,SACZnC,KAAK+6B,IACL/6B,KAAKg7B,SACL/E,KAAK,KAMPkB,KAAO,SAAS+V,GACd,OAAOlvB,OAAOkvB,IAGhBxc,QAAU,SAASwc,GACjB,OAAOA,EAAEkJ,IAAItE,OAAOuE,mBAAqBnJ,EAAEoJ,IAAIxE,OAAOyE,mBAIxD1R,UAAY,SAASqI,EAAGC,GACtB,GAAID,EAAE0B,cACJ,GAAIzB,EAAI,EACN,OAAOD,EAAE7U,SAASra,QAAQ,SAI5B,GAAImvB,EAAI,EACN,OAAOD,EAAE7U,SAASra,QAAQ,IAG9B,OAAOkvB,GAGTzW,eAAiB,SAASyW,EAAGC,GAC3B,GAAID,EAAE0B,cACJ,GAAIzB,EAAEqJ,aACJ,OAAOtJ,EAAE7U,SAASra,QAAQ,SAI5B,GAAImvB,EAAEyB,aACJ,OAAO1B,EAAE7U,SAASra,QAAQ,IAG9B,OAAOkvB,GAGT1W,aAAe,SAAS0W,GACtB,OAAIA,EAAEsJ,aACGtJ,EAAE7U,SAASra,QAAQ,IAErBkvB,GA4FTjyB,YAAc,WACZ,IAAIiyB,EAAGC,EAIP,GAHAD,EAAI,EACJC,EAAI,GAEAzY,WAAWoS,MAAMqC,IAAM,MAAOzU,WAAWoS,MAAMqC,IAAM,IAmBzD,OAfA7F,OACAtI,GAAKoB,MACLrB,GAAKqB,MAEH8Q,EADEnb,SAASgJ,IACPA,GAAGyS,EAEHzqB,2BAA2BgY,IAG/BoS,EADEpb,SAASiJ,IACPA,GAAGwS,EAEHzqB,2BAA2BiY,IAGjC+F,YADYmM,EAAIC,GAETtK,UAlBLpB,QAqBJgG,iBAAmB,WACjB,IAAIyF,EAAGC,EAGP,GAFAD,EAAI,EACJC,EAAI,GACAzY,WAAWoS,MAAMqC,IAAM,MAAOzU,WAAWoS,MAAMqC,IAAM,IAkBzD,OAdA7F,OACAtI,GAAKoB,MACLrB,GAAKqB,MAEH8Q,EADEnb,SAASgJ,IACPA,GAAGyS,EAEHzqB,2BAA2BgY,IAG/BoS,EADEpb,SAASiJ,IACPA,GAAGwS,EAEHzqB,2BAA2BiY,IAEjC+F,YAAYmM,EAAIC,GACTtK,UAjBL4T,QAoBJ5d,iBAAmB,WACjB,IAAIqU,EAAGC,EAGP,GAFAD,EAAI,EACJC,EAAI,GACAzY,WAAWoS,MAAMqC,IAAM,MAAOzU,WAAWoS,MAAMqC,IAAM,IAkBzD,OAdA7F,OACAtI,GAAKoB,MACLrB,GAAKqB,MAEH8Q,EADEnb,SAASgJ,IACPA,GAAGyS,EAEHzqB,2BAA2BgY,IAG/BoS,EADEpb,SAASiJ,IACPA,GAAGwS,EAEHzqB,2BAA2BiY,IAEjC+F,YAAYmM,EAAIC,GACTtK,UAjBLlB,QAoBJxb,eAAiB,WACf,IAAI+mB,EAAGC,EAGP,GAFAD,EAAI,EACJC,EAAI,GACAzY,WAAWoS,MAAMqC,IAAM,MAAOzU,WAAWoS,MAAMqC,IAAM,IAqBzD,OAjBA7F,OACAtI,GAAKoB,MACLrB,GAAKqB,MACDtL,mBAAmBkK,KACrBmM,KAAK,kBAGL+F,EADEnb,SAASgJ,IACPA,GAAGyS,EAEHzqB,2BAA2BgY,IAG/BoS,EADEpb,SAASiJ,IACPA,GAAGwS,EAEHzqB,2BAA2BiY,IAEjC+F,YAAYmM,EAAIC,GACTtK,UApBLnB,QAuBJtR,cAAgB,WACd,IAAI8c,EAAGC,EAOP,OALA7J,OACAvI,GAAKqB,MACDtL,mBAAmBiK,KACrBoM,KAAK,kBAEHpV,SAASgJ,KACXgG,YAAY,EAAIhG,GAAGyS,QACnB3K,YAGFqK,EAAIlvB,OAAO+c,GAAGsS,EAAEH,GAChBC,EAAInvB,OAAO+c,GAAGsS,EAAEF,GAChBA,EAAI1W,eAAe0W,EAAGD,GACtBA,EAAIrI,UAAUqI,EAAG,IACjBnS,GAAK,IAAI5hB,GACNs0B,EAAIp6B,IACP0nB,GAAGsS,EAAEH,EAAIC,EACTpS,GAAGsS,EAAEF,EAAID,EACTltC,KAAK+6B,IACE8H,YAITzgB,kBAAoB,SAAS8qB,EAAGC,GAC9B,IAAIuJ,EAAIC,EAMR,OALI,EAEJD,EAAKrf,KAAK6V,EAAEG,EAAEH,EAAGC,EAAEE,EAAEF,GACrBwJ,EAAKtf,KAAK6V,EAAEG,EAAEF,EAAGA,EAAEE,EAAEH,GACjBtW,KAAK8f,EAAIC,IAKfx0B,gBAAkB,SAAS+qB,EAAGC,GAC5B,IAAIsB,EAAGuH,EAGP,OAFAvH,EAAI,EACJuH,EAAI,EACAthB,WAAWwY,IAAMxY,WAAWyY,GACvB/qB,kBAAkB8qB,EAAGC,IAG5BsB,EADE1c,SAASmb,GACPA,EAAEM,EAEFzqB,2BAA2BmqB,KAG/B8I,EADEjkB,SAASob,GACPA,EAAEK,EAEFzqB,2BAA2BoqB,KAGvB,EAENsB,EAAIuH,EACC,EAEF,GAGT9c,cAAgB,WAGd,GAFAoK,OACAvI,GAAKqB,MACDtL,mBAAmBiK,IAGrB,OAFA/6B,KAAK+6B,SACL8H,UAGF,OAAQ9H,GAAG0S,GACT,KAAKp6B,KACH2nB,GAAK,IAAI7hB,GACNs0B,EAAIp6B,IACP2nB,GAAGqS,EAAEH,EAAIlvB,OAAO+c,GAAGsS,EAAEH,EAAE7U,SAASra,OAAO44B,WACvC5b,GAAGqS,EAAEF,EAAInvB,OAAO+c,GAAGsS,EAAEF,GACrBntC,KAAKg7B,IACL,MACF,KAAK11B,OACHy7B,aAAahG,GAAGyS,GAChB,MACF,QACErG,KAAK,kCAET,OAAOtE,WAGTvkB,gBAAkB,WAChB,IAAI4uB,EAUJ,OARA5J,OACAvI,GAAKqB,MACL8Q,EAAIpW,KAAKiE,GAAGsS,EAAEH,EAAGnS,GAAGsS,EAAEF,IACtBpS,GAAK,IAAI5hB,GACNs0B,EAAIp6B,IACP0nB,GAAGsS,EAAEH,EAAIA,EACTnS,GAAGsS,EAAEF,EAAInvB,OAAO,GAChBhe,KAAK+6B,IACE8H,WAGTjL,aAAe,WAGb,OAFA0L,QACAvI,GAAKqB,OACEqR,IAAMp6B,KACXrT,KAAKu6B,UACLsI,aAGF7H,GAAK,IAAI7hB,GACNs0B,EAAIp6B,IACP2nB,GAAGqS,EAAEH,EAAIlvB,OAAO+c,GAAGsS,EAAEH,GACrBlS,GAAGqS,EAAEF,EAAInvB,OAAO,GAChBhe,KAAKg7B,IACE6H,YAGTlL,eAAiB,WAGf,OAFA2L,QACAvI,GAAKqB,OACEqR,IAAMp6B,KACXrT,KAAKu6B,UACLsI,aAGF7H,GAAK,IAAI7hB,GACNs0B,EAAIp6B,IACP2nB,GAAGqS,EAAEH,EAAIlvB,OAAO+c,GAAGsS,EAAEF,GACrBnS,GAAGqS,EAAEF,EAAInvB,OAAO,GAChBhe,KAAKg7B,IACE6H,YAIT1kB,oBAAsB,SAAS04B,GAC7B,IAAI3J,EAAGC,EAAGqC,EAmBV,OAjBAlM,OACAvI,GAAKqB,MACL8Q,EAAIpV,KAAKiD,GAAGsS,EAAEH,EAAGqB,KAAK/zB,IAAIq8B,IAC1B1J,EAAIrV,KAAKiD,GAAGsS,EAAEF,EAAGoB,KAAK/zB,IAAIq8B,IACtBA,EAAO,IAETrH,EAAItC,EAGJA,EAAIzW,eAFJyW,EAAIC,EACJA,EAAIqC,GAEJrC,EAAItI,UAAUsI,EAAG,KAEnBpS,GAAK,IAAI5hB,GACNs0B,EAAIp6B,IACP0nB,GAAGsS,EAAEH,EAAIA,EACTnS,GAAGsS,EAAEF,EAAIA,EACTntC,KAAK+6B,IACE8H,WAIT/f,yBAA2B,SAAS4rB,GAClC,OAAOA,EAAEoI,cAIX/zB,2BAA6B,SAAS2rB,GACpC,IAAIqI,EAMJ,OALIrI,EAAErB,GAGN0J,EAAuBrI,EAAErB,EAAEH,EAAE8J,OAAOtI,EAAErB,EAAEF,IACV8J,SAAWF,EAAqBG,UAAYxI,EAAErB,EAAEF,EAAE2J,cAKlF3d,YAAc,SAASz4B,GACrB,IAAIy2C,EAKJ,OAJAA,EAAgB,IAAIh+B,GACNs0B,EAAIp6B,IAClB8jC,EAAc9J,EAAEH,EAAIlvB,OAAOtd,GAC3By2C,EAAc9J,EAAEF,EAAInvB,OAAO,GACpBm5B,GAIThW,aAAe,SAASzgC,GAItB,OAHIqD,OACFirC,QAAQE,IAAI,mBAAqBxuC,GAE5BV,KAAKm5B,YAAYz4B,KAI1BqgC,YAAc,SAASyM,GAMrB,OALAlK,QACAvI,GAAK,IAAI5hB,GACNs0B,EAAInoC,OACPy1B,GAAGyS,EAAIA,EACPxtC,KAAK+6B,IACE8H,WAITzB,cAAgB,SAAS8L,EAAGC,GAW1B,IAAIuB,EAKJ,OAJAA,EAAI,IAAIv1B,GACNs0B,EAAIp6B,IACNq7B,EAAErB,EAAEH,EAAIlvB,OAAOkvB,GACfwB,EAAErB,EAAEF,EAAInvB,OAAOmvB,GACRntC,KAAK0uC,IAGdnS,YAAc,WACZ,IAAI77B,EAIJ,OAHAA,EAAI,IACJ4iC,QACAvI,GAAKqB,OACMqR,GACT,KAAKp6B,IACCqf,UAAUqI,KAAOrK,QAAQqK,GAAGsS,EAAEH,KAChCxsC,EAAIq6B,GAAGsS,EAAEH,EAAE4J,cAEb,MACF,KAAKxxC,OACCvB,OACFirC,QAAQE,IAAI,uCAEVX,KAAK+C,MAAMvW,GAAGyS,KAAOzS,GAAGyS,IACtBzpC,OACFirC,QAAQE,IAAI,8BAEdxuC,EAAIq6B,GAAGyS,GAIb,OADA3K,UACOniC,GAIT2+B,aAAe,SAASqP,EAAGpiB,GACzB,IAAI8qB,EAAaC,EAQjB,OAPAD,EAAc,GACdC,EAAMxwB,yBAAyB6nB,EAAElB,GAE/B4J,GAAenX,UADJ,IAAT3T,GAAsB,MAAR+qB,EACSA,EAAM,EAENA,IAM7Bh5B,oBAAsB,SAASoxB,GAC7B,IAAIvC,EAAGoK,EAAUC,EAmBjB,OAhBAjU,OAGc,OADdiU,EAAQ9H,EADR6H,EAAW,KAEoB,MAAVC,GACnBD,IAGFpK,EAAIlvB,OAAOyxB,EAAE+H,UAAUF,KACvBvc,GAAK,IAAI5hB,GACNs0B,EAAIp6B,IACP0nB,GAAGsS,EAAEH,EAAIA,EACTnS,GAAGsS,EAAEF,EAAInvB,OAAO,GAChBhe,KAAK+6B,IACS,MAAVwc,GACFxe,SAEK8J,WAITzkB,kBAAoB,SAASqxB,GAC3B,OAAO1O,YAAY0W,WAAWhI,KAUhC1P,aAAe,SAAS2O,EAAGgJ,GACzB,IAAIC,EAAWP,EAAkBQ,EAIjC,OAHAR,EAAc,GACdQ,EAAoB,GACd,GACElJ,EAAEjB,GACR,KAAKp6B,IACHskC,EAAYjJ,EAAErB,EAAEH,EAAEvsC,WACb+2C,GACkB,MAAjBC,EAAU,KACZA,EAAYA,EAAUH,UAAU,IAGhCxa,YAAcvoB,iBAAmB2d,WAAWsc,KAC9CiJ,EAAY,UAAYA,EAAY,MAEtCP,GAAeO,EACXvlB,WAAWsc,KACT1R,YAAcvoB,kBAChB2iC,GAAe,KAEjBQ,EAAoBlJ,EAAErB,EAAEF,EAAExsC,WACtBq8B,YAAcvoB,kBAChBmjC,GAAqB,KAEvBR,GAAeQ,GAEjB,MACF,KAAKtyC,OACHqyC,EAAY9wB,yBAAyB6nB,EAAElB,GAClCkK,GACkB,MAAjBC,EAAU,KACZA,EAAYA,EAAUH,UAAU,IAGpCJ,GAAeO,EAEnB,OAAOP,GAGTjqB,YAAc,WAYZ,OAXAmW,OACAtI,GAAKoB,MACLrB,GAAKqB,OAGLnB,GAAK,IAAI9hB,GACNs0B,EAAIp6B,IACP4nB,GAAGoS,EAAEH,EAAIjW,KAAK8D,GAAGsS,EAAEH,EAAGlS,GAAGqS,EAAEH,GAC3BjS,GAAGoS,EAAEF,EAAIlW,KAAK8D,GAAGsS,EAAEF,EAAGnS,GAAGqS,EAAEF,GAC3BlS,GAAGoS,EAAEH,EAAIrI,UAAU5J,GAAGoS,EAAEH,EAAG,GAC3BltC,KAAKi7B,IACE4H,WAGTxG,WAAa,WACX,IAAImR,EAIJ,OAHAA,EAAI,EACJlK,QACAvI,GAAKqB,OACMqR,GACT,KAAKp6B,IACHm6B,EAAIzqB,2BAA2BgY,IAC/B,MACF,KAAKz1B,OACHkoC,EAAIzS,GAAGyS,EACP,MACF,QACEA,EAAI,EAGR,OADA3K,UACO2K,GAGTtvB,aAAe,WACb,IAAIsvB,EAGJ,OAFI,EACJA,EAAIzqB,2BAA2BqZ,OACxB2E,YAAYyM,IAMrBvvB,iBAAmB,SAASvd,GAO1B,OANA4iC,QACAvI,GAAK,IAAI5hB,GACNs0B,EAAIp6B,IACP0nB,GAAGsS,EAAEH,EAAIpzB,YAAYpZ,GACrBq6B,GAAGsS,EAAEF,EAAInvB,OAAO,GAChBhe,KAAK+6B,IACE8H,WAIT/oB,YAAc,SAASpZ,GACrB,IAAIwsC,EAAGC,EAAGnvC,EAAGwC,EAAGgiC,EAGhB,GAFAxkC,EAAI,EAEM,IAAN0C,GAAiB,IAANA,EAEb,OADAwsC,EAAIlvB,OAAO,GAKb,GAFAkvB,EAAIlvB,OAAO,GACXmvB,EAAInvB,OAAO,GACP,GAAKtd,EACP,IAAK1C,EAAIwC,EAAI,EAAGgiC,EAAM9hC,EAAI,GAAK8hC,EAAMhiC,GAAKgiC,EAAMhiC,GAAKgiC,EAAMxkC,EAAI,GAAKwkC,IAAQhiC,IAAMA,EAChF2sC,EAAInvB,OAAOhgB,GAEXkvC,EADI7V,KAAK6V,EAAGC,GAIhB,OAAOD,GAGTvW,KAAO,CAAC,EAAY,EAAY,EAAY,EAAY,GAAY,GAAY,GAAY,IAAY,IAAY,IAAY,KAAY,KAAY,KAAY,KAAY,MAAY,MAAY,MAAY,OAAY,OAAY,OAAY,QAAY,QAAY,QAAY,QAAY,SAAY,SAAY,SAAY,UAAY,UAAY,UAAY,WAAY,YAG5XkB,WAAa,SAAS4W,EAAGhB,GAGvB,OAFAuB,QAAQE,IAAI,uBAELT,EAAEhB,EAAI,KAAO9W,KAAK8W,EAAI,KAI/B/V,WAAa,SAAS+W,EAAGhB,GAGvB,OAFAuB,QAAQE,IAAI,uBAELT,EAAEhB,EAAI,MAAQ9W,KAAK8W,EAAI,KAIhCxV,YAAc,SAASiV,GACrB,OAAWA,EAAE2K,cAcfnwC,cAAgB,WAKd,OAJA1H,KAAKuf,KAAKwb,KACVt0B,OACAzG,KAAKsf,MAAMyb,KACXt0B,OACO+X,YAGTA,SAAW,WAGT,OAFA8kB,OACAgH,YACOzH,WAKTyH,UAAY,WAGV,GAFAtP,GAAKoB,MACLrB,GAAKqB,MACsB,IAAvB95B,mBAaJ,OATAtC,KAAK+6B,IACLvP,YACAxrB,KAAKg7B,IACLxP,YACAtF,SACAlmB,KAAK+6B,IACL/6B,KAAKg7B,IACLwM,WACAhc,YACOtF,SAZLlmB,KAAK6sC,OAeTvqC,iBAAmB,WACjB,OAAIiuB,cAAcwK,KAAOhF,MAAMgF,GAAI8R,OAExBtc,cAAcyK,KAAOjF,MAAMiF,GAAI6R,OAE/Btc,cAAcwK,KAAOxK,cAAcyK,KAAOjF,MAAMgF,GAAIC,IAHtD,EAMA,GAIXrzB,aAAe,WAGb,OAFA3H,KAAKuf,KAAKwb,KACVt0B,OACO2Z,WAGTA,QAAU,WAGR,OAFAkjB,OACA4H,YACOrI,WAGTqI,UAAY,WACV,IAAIsC,EAGJ,OAFAA,EAAI,EACJzS,GAAKqB,MACA7L,cAAcwK,IAMfhJ,SAASgJ,KACXyS,EAAIe,KAAKH,KAAKrT,GAAGyS,QACjBzM,YAAYyM,IAGV9a,UAAUqI,SACZ/6B,KAAK+6B,MAGPE,GAAK,IAAI9hB,GACNs0B,EAAIp6B,IACP4nB,GAAGoS,EAAEH,EAAIpW,KAAKiE,GAAGsS,EAAEH,EAAGnS,GAAGsS,EAAEF,GAC3BlS,GAAGoS,EAAEF,EAAIhW,KAAK,GACdn3B,KAAKi7B,IACD5H,iBAAiB0H,IACA,GAEnBoG,aAAa,GACNvmB,SAvBPymB,YAAYv+B,SACZ9C,KAAK+6B,SACL9E,KAAK,KAyBTpuB,YAAc,WAKZ,OAJA7H,KAAKuf,KAAKwb,KACVt0B,OACAzG,KAAKsf,MAAMyb,KACXt0B,OACOma,UAOTA,OAAS,WAIP,OAHA0iB,OACAtI,GAAKoB,MACLrB,GAAKqB,MACuB,IAAxBvb,qBACFsgB,aAAa,QACb0B,YAGF7iC,KAAK+6B,IACLvP,YACAxrB,KAAKg7B,IACLxP,YACAtF,SACAlmB,KAAK+6B,IACL/6B,KAAKg7B,IACLwM,WACAhc,YACAtF,SACO2c,YAGThiB,kBAAoB,WAClB,OAAI0P,cAAcwK,KAAOhF,MAAMgF,GAAI8R,OAExBtc,cAAcyK,KAAOjF,MAAMiF,GAAI6R,OAE/Btc,cAAcwK,KAAOxK,cAAcyK,KAAOjF,MAAMgF,GAAIC,IAHtD,EAMA,GAIXlzB,aAAe,WAKb,OAJA9H,KAAKuf,KAAKwb,KACVt0B,OACAqa,WAEOra,QAGTqa,SAAU,WACR,IAAIitB,EAAG/vC,EAAGwC,EAAGgiC,EAKb,GAJAxkC,EAAI,EACJ+vC,EAAI,EACJzK,OACAvI,GAAKqB,MACD3c,IAAIsb,MAAQ4M,OAAO/jC,KAIrB,OAHA5D,KAAKuf,KAAKwb,KACV1Q,cACAwY,UAGF,GAAIpjB,IAAIsb,MAAQ4M,OAAO7xB,KAIrB,OAHA9V,KAAKuf,KAAKwb,KACVvQ,cACAqY,UAGF,GAAIpjB,IAAIsb,MAAQ4M,OAAOjwB,KAuBrB,OAtBAqjB,GAAKxb,KAAKwb,IACV/6B,KAAKsvB,eACLtvB,KAAK+6B,IACL1C,WACA/N,cACA0Q,GAAKoB,MACLp8B,KAAKsvB,eACLtvB,KAAK+6B,IACL1C,WACAU,SACAzO,cACA2Q,GAAKmB,MACLp8B,KAAKi7B,IACLj7B,KAAKg7B,IACLwM,WACAxnC,KAAKsvB,eACL+I,WACAr4B,KAAKg7B,IACLh7B,KAAKi7B,IACLrgB,MACAsL,cACA2c,UAGF,GAAIpjB,IAAIsb,MAAQ4M,OAAO9jC,MAWrB,OAVAk3B,GAAKxb,KAAKwb,IACV/6B,KAAK+6B,IACLzQ,cACAtqB,KAAK+6B,IACLhC,SACAzO,cACA1P,MACAwmB,cAAc,EAAG,GACjB/I,gBACAwK,UAGF,GAAIpjB,IAAIsb,MAAQ4M,OAAO5xB,MAWrB,OAVAglB,GAAKxb,KAAKwb,IACV/6B,KAAK+6B,IACLzQ,cACAtqB,KAAK+6B,IACLhC,SACAzO,cACAkd,WACApG,cAAc,EAAG,GACjB/I,gBACAwK,UAGF,GAAIpjB,IAAIsb,MAAQ4M,OAAOhwB,MAerB,OAdAojB,GAAKxb,KAAKwb,IACV/6B,KAAK+6B,IACLoG,aAAa,GACb9I,WACA/N,cACAyQ,GAAKqB,MACLp8B,KAAK+6B,IACLoG,aAAa,GACbqG,WACAxnC,KAAK+6B,IACLoG,aAAa,GACbvmB,MACAsL,cACA2c,UAGF,GAAIjR,OAAOmJ,IAAK,CAEd,IADAgT,EAAI5E,IACGvX,OAAOmJ,KACZ/6B,KAAKyf,IAAIsb,KACTja,WACAia,GAAK5a,IAAI4a,IAIX,OAFA9E,KAAKkT,IAAM4E,QACXlL,UAGF,GAAI9H,GAAG0S,IAAM51B,OAAQ,CAInB,IAHA7X,KAAK+6B,IACL/X,cAEKhlB,EAAIwC,EAAI,EAAGgiC,GADhBzH,GAAKqB,OACoBmM,OAAOuF,MAAQ,GAAKtL,EAAMhiC,EAAIgiC,EAAMhiC,EAAIgiC,EAAMxkC,EAAI,GAAKwkC,IAAQhiC,IAAMA,EAC5FR,KAAK+6B,GAAGwN,OAAO3gB,KAAK5pB,IACpB8iB,WACAia,GAAGwN,OAAO3gB,KAAK5pB,GAAKo+B,MAItB,OAFAp8B,KAAK+6B,SACL8H,UAIF,OADA7iC,KAAK+6B,IACE8H,WAGT76B,cAAgB,WAEd,OADAye,cACOzmB,KAAK2nC,OAAOh1B,OAGrB8T,YAAc,WAOZ,OANkB,IAAdkiB,WACFznB,aAEFsF,mBACAvF,gBACAgE,OACOvD,SAAU,GAInBP,SAAW,WACT,OAAOiiB,IAAI,aAKbpiB,mDAAqD,WACnD,IAAIhjB,EAAGwC,EAAGgiC,EAAKoL,EAEf,IADAA,EAAU,GACL5vC,EAAIwC,EAAI,EAAGgiC,EAAM2F,OAAOpqC,OAAS,GAAKykC,EAAMhiC,EAAIgiC,EAAMhiC,EAAIgiC,EAAMxkC,EAAI,GAAKwkC,IAAQhiC,IAAMA,GACZ,IAA1E2nC,OAAOnqC,GAAGsvC,UAAUwK,QAAQ,0CAE9B3P,OAAOnqC,GAAGyvC,EAAIl3B,IACd4xB,OAAOnqC,GAAGsvC,UAAY,GACtB/uB,QAAQvgB,GAAKmqC,OAAOnqC,GACpB4vC,EAAQ5tC,KAAK4wB,oBAAoB5yB,IAAK,IAEtC4vC,EAAQ5tC,UAAK,GAGjB,OAAO4tC,GAGT7lC,WAAa,WACX,IAAIgwC,EAAYC,EAEhB,IADAhd,GAAK7a,IAAI4a,IACFnJ,OAAOoJ,MACZgd,EAAsBv4B,IAAIub,KAEFyS,IAAMl3B,KAC5B4wB,KAAK,gBAKP4Q,EAAa5P,OAAO2P,QAAQE,GAC5B7P,OAAO4P,GAAYtK,EAAIl3B,IACvB4xB,OAAO4P,GAAYzK,UAAY,GAC/B/uB,QAAQw5B,GAAc5P,OAAO4P,GAC7BnnB,oBAAoBmnB,IAAc,EAClC/c,GAAK7a,IAAI6a,IAEX,OAAOh7B,KAAK2nC,OAAOh1B,OAuBrBzO,iBAAkB,EAElBgE,WAAa,WAGX,OAFAlI,KAAKuf,KAAKwb,KACVt0B,OACO2a,aAGTA,UAAY,WAmDV,OAlDAkiB,OAEAvI,GAAKqB,MACLp8B,KAAK+6B,IACLvgB,MACItW,iBACF8qC,QAAQE,IAAI,qBAAuBnU,GAAK,MAAQ+L,MAAMqC,IAAM,IAM9D9H,YAAYttB,OACZotB,cAAc,GACdnhC,KAAK+6B,IACLxd,MACIrZ,iBACF8qC,QAAQE,IAAI,qBAAuBnU,GAAK,MAAQ+L,MAAMqC,IAAM,IAE1Dzf,mBACFqX,YAAYwN,KAAK16B,IAEjB7T,KAAK2nC,OAAO9zB,KAEdqS,SACIhiB,iBACF8qC,QAAQE,IAAI,uBAAyBpI,MAAMqC,IAAM,IAEnDlT,KAAK,GACD/xB,iBACF8qC,QAAQE,IAAI,sBAAwBpI,MAAMqC,IAAM,IAElD9Q,WACIn0B,iBACF8qC,QAAQE,IAAI,yBAA2BpI,MAAMqC,IAAM,IAgB9CtG,WAqBT16B,WAAa,WAoBX,OAnBAnI,KAAKuf,KAAKwb,KACVt0B,OACAzG,KAAKsf,MAAMyb,KACXt0B,OACAzG,KAAKqf,OAAO0b,KACZt0B,OACAw0B,GAAKmB,MACLpB,GAAKoB,MACLrB,GAAKqB,MACDnB,KAAO0M,OAAOh1B,OAChBsoB,GAAKD,GACLA,GAAK2M,OAAOrwB,WAEdtX,KAAK+6B,IACL/6B,KAAKg7B,IACLh7B,KAAKi7B,IACLuB,QACAtW,SACAlmB,KAAKg7B,IACEpP,UAgBTjK,MAAQ,SAASs2B,EAAUC,GACzB,IAAIC,EAAaC,EAAUC,EAA2BC,EAWtD,IAVIv0C,OACFirC,QAAQE,IAAI,UAAY+I,EAAW,IAAMC,GAQ3CC,EAAc,IACD,CAeX,GAdAn4C,KAAKk4C,GACLl4C,KAAKi4C,GACLj4C,KAAK6sC,MACLtF,SACA9gC,OACA2xC,EAAWhc,MAGXp8B,KAAKo4C,GACLD,IACAn4C,KAAKk4C,GACLl4C,KAAKo4C,GACL5Q,WACA6Q,EAA4Bjc,MACxBhT,MAAMivB,EAA2BxL,MAInC,OAHI9oC,OACFirC,QAAQE,IAAI,kBAAoBiJ,GAE3BA,EAETn4C,KAAKq4C,GACLr4C,KAAKi4C,GACLK,EAAiBluB,UACjBA,UAAY,EACZlE,SACAkE,UAAYkuB,EAGZJ,EAAa9b,QAIjBh0B,cAAgB,WACd,IAAepK,EAAGqwC,EAAG3tC,EAyBrB,OAxBI,EACA,EACA,EACJV,KAAKuf,KAAKwb,KACVt0B,OACAu0B,GAAKoB,MACDnH,SAAS+F,KAA0B,IAAnBA,GAAGuN,OAAOsF,MAAc7S,GAAGuN,OAAOoF,IAAI,KAAO3S,GAAGuN,OAAOoF,IAAI,GACjE,EAEZxG,KAAK,6CAEPzmC,EAAIs6B,GAAGuN,OAAOoF,IAAI,GAClB3tC,KAAKsf,MAAMyb,KACXt0B,SACAzI,EAAIu+B,eACI,GAAKv+B,EAAI0C,IACfymC,KAAK,yCAEPnnC,KAAKqf,OAAO0b,KACZt0B,SACA4nC,EAAI9R,eACI,GAAK8R,EAAI3tC,IACfymC,KAAK,4CAEAvlB,SAASoZ,GAAIt6B,EAAG1C,EAAI,EAAGqwC,EAAI,IAGpCzsB,SAAW,SAAS8sB,EAAGhuC,EAAG63C,EAAKC,GAC7B,IAAIx6C,EAAGoxB,EAAIif,EAAG7tC,EAAGgiC,EAAKC,EAGtB,IAFAzkC,EAAI,EACJqwC,EAAI,EACCrwC,EAAIwC,EAAI,EAAGgiC,EAAM9hC,EAAI,GAAK8hC,EAAMhiC,EAAIgiC,EAAMhiC,EAAIgiC,EAAMxkC,EAAI,GAAKwkC,IAAQhiC,IAAMA,EAC9E,IAAK6tC,EAAIjf,EAAK,EAAGqT,EAAO/hC,EAAI,GAAK+hC,EAAOrT,EAAKqT,EAAOrT,EAAKqT,EAAO4L,EAAI,GAAK5L,IAASrT,IAAOA,EACnFpxB,IAAMu6C,GAAOlK,IAAMmK,GACrBx4C,KAAK0uC,EAAEnG,OAAO3gB,KAAKlnB,EAAI1C,EAAIqwC,IAKjC,GADA3oB,YAAYhlB,EAAI,IACX63C,EAAMC,GAAO,EAChB,OAAOzf,UAKX1wB,cAAgB,WAGd,OAFArI,KAAKuf,KAAKwb,KACVt0B,OACO3C,YAGTA,SAAW,WACT,IAAIw0C,EAMJ,OALAA,EAAiBluB,UACjBA,UAAY,EACZkZ,OACA6H,aACAtI,UACOzY,UAAYkuB,GAGrBnN,WAAa,WAGX,GADApQ,GAAKqB,MACD3c,IAAIsb,MAAQ4M,OAAOxmC,KAAvB,CAQA,IAHA85B,GAAK9a,IAAI4a,IACT/6B,KAAKyf,IAAIwb,KACTA,GAAK9a,IAAI8a,IACFrJ,OAAOqJ,KACZj7B,KAAKyf,IAAIwb,KACLl3B,OACFirC,QAAQE,IAAI,4BAA8BpI,MAAMqC,IAAM,GAAK,QAAUrC,MAAMqC,IAAM,IAEnFlc,MACIlpB,OACFirC,QAAQE,IAAI,gBAAkBpI,MAAMqC,IAAM,IAE5ClO,GAAK9a,IAAI8a,IAUX,IARIl3B,OACFirC,QAAQE,IAAI,+CAAiDpI,MAAMqC,IAAM,IAG3EhZ,UACA6K,GAAKoB,MACLp8B,KAAK6sC,MACL5R,GAAK9a,IAAI4a,IACFnJ,OAAOqJ,KACZj7B,KAAKg7B,IACLh7B,KAAKyf,IAAIwb,KAETrC,oBACAhe,MACAqgB,GAAK9a,IAAI8a,IASX,OAHA0Q,WAEA3rC,KAAKg7B,IACE9U,SAzCLlmB,KAAK+6B,KA4CTzyB,UAAY,WAKV,OAJAtI,KAAKuf,KAAKwb,KACVt0B,OACAs0B,GAAKqB,MACLp8B,KAAK+6B,IACAjrB,MAAKirB,GAAIzL,eAKL5M,aAJPuZ,QACAvZ,YACOtB,cAQXsB,UAAY,WAKV,OAJA1iB,KAAKsvB,eACLtvB,KAAKsvB,eACLyJ,SACAwO,SACO9gC,QAITmc,UAAY,EAEZD,KAAO,WACL,IAAI+rB,EAsBJ,OArBA9rB,YACI7e,OACFirC,QAAQE,IAAI,aAAe/F,IAAM,MAAQvmB,YAK3C8rB,EAAI,IAAIv1B,GACNs0B,EAAI/pC,KACNgrC,EAAE/rB,KAAKxC,IAAMic,MACTsS,IAAMA,EAAE/rB,KAAKxC,KAEf6uB,QAAQE,IAAI,gCAEdR,EAAE/rB,KAAKlD,IAAM2c,MAONp8B,KAAK0uC,IAGdlmC,cAAgB,WAYd,OAXAxI,KAAKuf,KAAKwb,KACVt0B,OACIyZ,KAAK6a,MAAQ4M,OAAOh1B,MACtBwuB,aAAa,GACbA,aAAa,KAEbnhC,KAAKsf,MAAMyb,KACXt0B,OACAzG,KAAKqf,OAAO0b,KACZt0B,QAEKoc,YAGTA,SAAW,WAGT,OAFAygB,OACA8H,aACOvI,WAGTuI,WAAa,WACX,IAAI8B,EAAGuL,EAAIC,EAAIvL,EAAGY,EAAG/vC,EAAGoxB,EAAIif,EAAG9Y,EAAIkY,EAAGkL,EAAGjJ,EAAIkJ,EAAGjJ,EAAIjvC,EAAG0zC,EAAIvG,EAAMC,EAAOttC,EAAG8zC,EAAI9R,EAAKC,EAAMmN,EAAMC,EAAMC,EAAMC,EAAMC,EAelH,GAdAjC,EAAI,EACJ/vC,EAAI,EACJqwC,EAAI,EACJZ,EAAI,EACJkL,EAAI,EACJC,EAAI,EACA,EACG,EACP9K,EAAQ,EACR2K,EAAK,GACLC,EAAK,GACLzd,GAAKmB,MACLpB,GAAKoB,MACLrB,GAAKqB,OACAnH,SAAS8F,IAKZ,OAJKjK,mBAAmBiK,KACtBoM,KAAK,2DAEPnnC,KAAK6sC,MAgBP,IAbA7sC,KAAKg7B,IACL2d,EAAIpc,cACJv8B,KAAKi7B,IACL2d,EAAIrc,cACJsR,EAAO9S,GAAGwN,OAAOsF,MACb8K,EAAI,GAAKA,EAAI9K,GAAQ+K,EAAI,GAAKA,EAAI/K,GAAQ8K,IAAMC,GAAK7d,GAAGwN,OAAOoF,IAAIgL,EAAI,KAAO5d,GAAGwN,OAAOoF,IAAIiL,EAAI,KAClGzR,KAAK,gCAEPwR,IACAC,IACAl4C,EAAIq6B,GAAGwN,OAAOoF,IAAIgL,GAElB7K,EAAQ,EACH9vC,EAAIwC,EAAI,EAAGgiC,EAAMqL,EAAO,GAAKrL,EAAMhiC,EAAIgiC,EAAMhiC,EAAIgiC,EAAMxkC,EAAI,GAAKwkC,IAAQhiC,IAAMA,EAC7ExC,IAAM26C,GAAK36C,IAAM46C,IACnB9K,GAAS/S,GAAGwN,OAAOoF,IAAI3vC,IAQ3B,KAJAg9B,GAAK3f,aAAayyB,IAEfvF,OAAOsF,KAAOA,EAAO,EACxBQ,EAAI,EACCrwC,EAAIoxB,EAAK,EAAGqT,EAAOoL,EAAO,GAAKpL,EAAOrT,EAAKqT,EAAOrT,EAAKqT,EAAOzkC,EAAI,GAAKykC,IAASrT,IAAOA,EACtFpxB,IAAM26C,GAAK36C,IAAM46C,IACnB5d,GAAGuN,OAAOoF,IAAIU,KAAOtT,GAAGwN,OAAOoF,IAAI3vC,IAOvC,IAJAkvC,EAAInS,GAAGwN,OAAO3gB,KACdulB,EAAInS,GAAGuN,OAAO3gB,KAGT5pB,EAAIu3B,EAAK,EAAGqa,EAAO/B,EAAO,GAAK+B,EAAOra,EAAKqa,EAAOra,EAAKqa,EAAO5xC,EAAI,GAAK4xC,IAASra,IAAOA,EAC1FkjB,EAAGz6C,GAAK,EACR06C,EAAG16C,GAAK+8B,GAAGwN,OAAOoF,IAAI3vC,GAExB,IAAKA,EAAI0xC,EAAK,EAAGG,EAAO/B,EAAQ,GAAK+B,EAAOH,EAAKG,EAAOH,EAAKG,EAAO7xC,EAAI,GAAK6xC,IAASH,IAAOA,EAAI,CAE/F,IADA1vC,KAAK6sC,MACAwB,EAAIsB,EAAK,EAAGG,EAAOpvC,EAAI,GAAKovC,EAAOH,EAAKG,EAAOH,EAAKG,EAAOzB,EAAI,GAAKyB,IAASH,IAAOA,EAAI,CAI3F,IAHA8I,EAAGE,GAAKtK,EACRoK,EAAGG,GAAKvK,EACRN,EAAI,EACCN,EAAI2G,EAAK,EAAGrE,EAAOlC,EAAO,GAAKkC,EAAOqE,EAAKrE,EAAOqE,EAAKrE,EAAOtC,EAAI,GAAKsC,IAASqE,IAAOA,EAC1FrG,EAAKA,EAAI2K,EAAGjL,GAAMgL,EAAGhL,GAEvBztC,KAAKktC,EAAEa,IAEPnzB,MAKF,IAFAuyB,EAAEnvC,GAAKo+B,MAEFiS,EAAIiG,EAAKtE,EAAOnC,EAAO,EAAImC,GAAQ,EAAIsE,GAAM,EAAIA,GAAM,EAAIjG,EAAI2B,GAAQ,IAAMsE,IAAOA,EACvF,GAAIjG,IAAMsK,GAAKtK,IAAMuK,EAArB,CAGA,KAAMH,EAAGpK,GAAKqK,EAAGrK,GACf,MAEFoK,EAAGpK,GAAK,GAGZ,OACSruC,KADK,IAAV8tC,EACUX,EAAE,GAEFnS,KAoBhBvyB,SAAW,WAGT,OAFAzI,KAAKuf,KAAKwb,KACVt0B,OACOwc,UAGTA,OAAS,WAQP,OAPAqgB,OACAvI,GAAKqB,MACD3c,IAAIsb,MAAQ4M,OAAOxmC,KACrBgiB,sBAEAD,kBAEK2f,WAOT1f,oBAAsB,WAEpB,IADA6X,GAAK7a,IAAI4a,IACFnJ,OAAOoJ,KAAK,CAEjB,GADAE,GAAKzb,IAAIub,IACLxH,MAAM0H,IAgBR,OAfAl7B,KAAK+6B,IACL/6B,KAAKk7B,IACLsM,WACAvM,GAAKmB,MACLp8B,KAAKi7B,IACLhY,SACAjjB,KAAKk7B,IACLjY,SACAoV,WACAr4B,KAAKi7B,IACLsL,OACAvmC,KAAKk7B,IACLqL,OACAlO,gBACAmP,WAGFxM,GAAK7a,IAAI6a,IAEX,OAAO9X,mBAGTA,gBAAkB,WAChB,IAAIsqB,EAAG9sC,EACP,GAAI+e,IAAIsb,MAAQ4M,OAAOpmC,QAAvB,CAIA,GAAIwwB,SAASgJ,IAMX,OALAyS,EAAIe,KAAKsK,IAAI9d,GAAGyS,GACZe,KAAK/zB,IAAIgzB,GAAK,QAChBA,EAAI,QAENzM,YAAYyM,GAYd,GARIpa,WAAW2H,MACb/6B,KAAK+6B,IACLhC,SACAgC,GAAKqB,OAKH3c,IAAIsb,MAAQ4M,OAAOhmC,QAQrB,OAPAw/B,aAAa,GACbnhC,KAAKuf,KAAKwb,KACVoG,aAAa,GACb3E,QACA5hB,MACAwmB,eAAe,EAAG,QAClB5E,QAyBF,GAbAx8B,KAAK+6B,IACLoG,aAAa,KACb9I,WACI3O,mBACFqX,YAAYwN,KAAK16B,IAEjBwtB,YAAYxtB,IAEdqS,UACAxlB,EAAI67B,eAII,GAAK8U,MAAM3wC,GAIjB,OAHAV,KAAK2nC,OAAO/jC,MACZ5D,KAAK+6B,SACL9E,KAAK,GAGP,OAAQv1B,EAAI,KACV,KAAK,GACL,KAAK,IACH,OAAOygC,aAAa,GACtB,KAAK,GACL,KAAK,IACH,OAAOC,cAAc,EAAG,GAC1B,KAAK,IACL,KAAK,IACH,OAAOA,eAAe,EAAG,GAC3B,KAAK,GACL,KAAK,IAKH,OAJAA,cAAc,EAAG,GACjBD,aAAa,GACbC,cAAc,EAAG,GACjB5E,QACOnE,WACT,KAAK,IACL,KAAK,IAKH,OAJA+I,eAAe,EAAG,GAClBD,aAAa,GACbC,cAAc,EAAG,GACjB5E,QACOnE,WACT,KAAK,GACL,KAAK,IAKH,OAJA+I,cAAc,EAAG,GACjBD,aAAa,GACbC,cAAc,EAAG,GACjB5E,QACOnE,WACT,KAAK,IACL,KAAK,IAKH,OAJA+I,eAAe,EAAG,GAClBD,aAAa,GACbC,cAAc,EAAG,GACjB5E,QACOnE,WACT,KAAK,EACH,OAAO8I,aAAa,GACtB,KAAK,IACH,OAAOA,cAAc,GACvB,QAGE,OAFAnhC,KAAK2nC,OAAO/jC,MACZ5D,KAAK+6B,IACE9E,KAAK,SAvGdj2B,KAAKuf,KAAKwb,MA2GdryB,UAAY,WAGV,OAFA1I,KAAKuf,KAAKwb,KACVt0B,OACO8jC,SAGTA,MAAQ,WAGN,OAFAjH,OACA+H,SACOxI,WAGTwI,OAAS,WACP,IAAImC,EAGJ,GAFAA,EAAI,EACJzS,GAAKqB,MACD3c,IAAIsb,MAAQ4M,OAAOnmC,SAAvB,CAIA,GAAIuwB,SAASgJ,IAMX,OALAyS,EAAIe,KAAKuK,KAAK/d,GAAGyS,GACbe,KAAK/zB,IAAIgzB,GAAK,QAChBA,EAAI,QAENzM,YAAYyM,GAGd,IAAI1c,mBAAmBiK,IAMvB,OAFAsG,YAAYx9B,MACZ7D,KAAK+6B,IACE9E,KAAK,GALVj2B,KAAKu6B,UAZLv6B,KAAKuf,KAAKwb,MAiCdpyB,YAAc,WACZ,IAAIolC,EAiBJ,OAhBAzK,OACA0L,QAAQE,IAAI,mDACZnB,EAAI5E,IACJnpC,KAAK2nC,OAAOh1B,MACZ3S,KAAKuf,KAAKwb,KACVt0B,OACAzG,KAAKsf,MAAMyb,KACXt0B,QACAs0B,GAAKqB,SACMuL,OAAOh1B,KAChB8b,QAEAzuB,KAAK+6B,IAEPnW,SAAO,GACPqR,KAAKkT,IAAM4E,GACJlL,WAGThC,sBAAwB,SAASkY,GAC/B,KAAI5P,IAAM,IACJplC,OACFirC,QAAQE,IAAI,aAAe6J,EAAa,QAAUjS,MAAMqC,IAAM,IAE5D/f,MAAM2vB,EAAYjS,MAAMqC,IAAM,MAOpC,OAAOnpC,KAAK+4C,GANJh1C,OACFirC,QAAQE,IAAI,YAAc6J,EAAa,oCAS/Cn0B,QAAS,SAASo0B,GAQhB,GAPA1V,OACAtI,GAAKoB,MACLrB,GAAKqB,MACDr4B,OACFirC,QAAQE,IAAI,eAAiBnU,IAG3Bie,GACF,IAAKpnB,OAAOmJ,IAMV,OALIh3B,OACFirC,QAAQE,IAAI,kBAAoBnU,IAElC8F,sBAAsB9F,SACtB8H,eAIF,GAAqB,IAAjB/yB,MAAKirB,GAAIC,IAQX,OAPIj3B,OACFirC,QAAQE,IAAI,kCAEdrO,sBAAsB9F,SAGtB8H,UAKJ,GAAIvR,MAAMyJ,IAGR,OAFAjW,WAAWk0B,QACXnW,UAIF,GAAI1P,WAAW4H,IAGb,OAFAlW,eAAem0B,QACfnW,UAWF,IAPI9+B,OACFirC,QAAQE,IAAI,iBAEdjU,GAAK9a,IAAI4a,IACLh3B,OACFirC,QAAQE,IAAI,eAAiBjU,IAExBrJ,OAAOqJ,KAKR+d,GACFh5C,KAAKyf,IAAIwb,KAEPl3B,OACFirC,QAAQE,IAAI,2BAEdlvC,KAAKyf,IAAIwb,KACLl3B,OACFirC,QAAQE,IAAI,YAAczvB,IAAIwb,KAEhCj7B,KAAKg7B,IACDj3B,OACFirC,QAAQE,IAAI,OAASlU,IAEvBpW,QAAOo0B,GACP/d,GAAK9a,IAAI8a,IAEX,OAAO4H,WAGT/d,WAAa,SAASk0B,GACpB,IAAIjL,EAOJ,IANIhqC,OACFirC,QAAQE,IAAI,yBAEV,EAEJjU,GAAK9a,IAAI4a,IACFnJ,OAAOqJ,MACRnrB,MAAK2P,IAAIwb,IAAKD,KAAOge,KACvBh5C,KAAKyf,IAAIwb,KACTj7B,KAAKg7B,IACLpW,QAAOo0B,IAET/d,GAAK9a,IAAI8a,IAKX,IAFA8S,EAAI5E,IACJlO,GAAK9a,IAAI4a,IACFnJ,OAAOqJ,KACc,IAAtBnrB,MAAK2P,IAAIwb,IAAKD,KAChB6F,sBAAsBphB,IAAIwb,KAE5BA,GAAK9a,IAAI8a,IAEX,GAAIkO,IAAM4E,EAKR,OAJAhzB,QAAQouB,IAAM4E,GACd9S,GAAKmB,MACLyE,sBAAsB5F,IACtBj7B,KAAKi7B,IACElC,UAIXlU,eAAiB,SAASm0B,GACxB,IAAIjL,EAOJ,IANIhqC,OACFirC,QAAQE,IAAI,6BAEV,EAEJjU,GAAK9a,IAAI4a,IACFnJ,OAAOqJ,MACRnrB,MAAK2P,IAAIwb,IAAKD,KAAOge,KACvBh5C,KAAKyf,IAAIwb,KACTj7B,KAAKg7B,IACLpW,QAAOo0B,IAET/d,GAAK9a,IAAI8a,IAKX,IAFA8S,EAAI5E,IACJlO,GAAK9a,IAAI4a,IACFnJ,OAAOqJ,KACc,IAAtBnrB,MAAK2P,IAAIwb,IAAKD,KAChB6F,sBAAsBphB,IAAIwb,KAE5BA,GAAK9a,IAAI8a,IAEX,GAAIkO,IAAM4E,EACR,OAAOzV,aAAa6Q,IAAM4E,IA0C9B/oB,qBAAuB,WAgCrB,OA/BAiW,GAAKrc,MAAMmc,IACXG,GAAKvb,MAAMob,IACXI,GAAK7b,MAAMyb,IACNhG,SAASkG,KACZkM,KAAK,kBAGH1nB,IAAI0b,MAAQwM,OAAOvhC,QACrBpG,KAAKuf,KAAK4b,KACV10B,OACA00B,GAAKiB,OAePiF,YAAYxxB,UACZ7P,KAAKm7B,IACLn7B,KAAKk7B,IACLjF,KAAK,GACLkF,GAAKiB,MACL0I,YAAY7J,GAAIE,IACTkG,YAAY1uB,MAGrBrI,wBAA0B,WACxB,OAAOtK,KAAK+6B,KA0BdnyB,YAAc,WAQZ,IAPA5I,KAAKuf,KAAKwb,KACVt0B,OACAu0B,GAAKoB,MACLrB,GAAK7a,KAAK6a,IAIHnJ,OAAOmJ,KACZ/6B,KAAKyf,IAAIsb,KACTA,GAAK5a,IAAI4a,IACTt0B,OACAw0B,GAAKmB,MACLp8B,KAAKyf,IAAIsb,KACTA,GAAK5a,IAAI4a,IACTt0B,OACAy0B,GAAKkB,MACLp8B,KAAKyf,IAAIsb,KACTA,GAAK5a,IAAI4a,IACTt0B,OACA00B,GAAKiB,MAOLp8B,KAAKg7B,IACLh7B,KAAKi7B,IACLnL,WACAkL,GAAKoB,MAGLp8B,KAAKg7B,IACLh7B,KAAKi7B,IACLj7B,KAAKm7B,IACLoM,SACA9gC,OAEAzG,KAAKg7B,IACLh7B,KAAKi7B,IACLj7B,KAAKk7B,IACLqM,SACA9gC,OAQA+gC,WACAxM,GAAKoB,MAEP,OAAOp8B,KAAKg7B,KAGdnyB,YAAc,WAWZ,OAVA7I,KAAKuf,KAAKwb,KACVt0B,OACAzG,KAAKsf,MAAMyb,KACXt0B,QACAs0B,GAAKqB,SACMuL,OAAOh1B,KAChB8b,QAEAzuB,KAAK+6B,IAEA5V,UAqBTA,OAAS,WAOP,OANAme,OACAtI,GAAKoB,MACLrB,GAAKqB,MACLnB,GAAK4R,KACLvB,UAASvQ,IACT/6B,KAAKi7B,IACE4H,WAGTyI,UAAW,SAASoD,GAClB,IAAId,EACJ,GAAIxkB,MAAMslB,EAAG1T,KACX,GAAIlK,mBAAmBmK,IACrB,OAAOA,GAAKV,SAET,GAAI9a,IAAIivB,KAAO/G,OAAO5zB,QAC3B,GAAIqV,MAAM7J,KAAKmvB,GAAI1T,KAAOzK,cAAcjR,MAAMovB,KAAO3Y,MAAMkF,GAAI3b,MAAMovB,IACnE,OAAOzT,GAAK3b,MAAMovB,QAEf,GAAI9c,OAAO8c,GAAI,CAGpB,IAFAA,EAAIvuB,IAAIuuB,GACRd,EAAU,GACHhc,OAAO8c,IACZpD,UAAS7rB,IAAIivB,IACbd,EAAQ5tC,KAAK0uC,EAAIvuB,IAAIuuB,IAEvB,OAAOd,IAIX9kC,iBAAmB,WAGjB,OAFA9I,KAAKuf,KAAKwb,KACVt0B,OACO2e,gBAGTA,aAAc,WACZ,IAAI2oB,EAAGgB,EASP,GARAhB,EAAI,EACJgB,EAAc3S,MAEV3c,IAAIsvB,KAAiBpH,OAAOxmC,OAC9BnB,KAAK+uC,GACL9M,cACA8M,EAAc3S,OAEZ3c,IAAIsvB,KAAiBpH,OAAOn1B,WAAcqhB,UAAUpU,IAAIU,IAAI4uB,KASzD,OAAIra,WAAWqa,IACpB/uC,KAAK+uC,GACEpX,kBACElY,IAAIsvB,KAAiBpH,OAAO5zB,QAAUuf,eAAehU,MAAMyvB,KACpE/uC,KAAK+uC,GACE3M,eAEApiC,KAAKu6B,KAbZ,IAFAwT,EAAI5E,IACJ4F,EAAc5uB,IAAI4uB,GACXnd,OAAOmd,IACZ/uC,KAAKyf,IAAIsvB,IACT3pB,eACA2pB,EAAc5uB,IAAI4uB,GAEpB,OAAOzW,aAAa6Q,IAAM4E,IAiB9BhlC,gBAAkB,WAChB,IAAkBqmB,EAAI1uB,EAAGF,EAAGgiC,EAAKC,EAkCjC,IAhCI,EACJ1H,GAAK5a,IAAI4a,IACT/6B,KAAKyf,IAAIsb,KACTt0B,OAUAs0B,GAAK5a,IAAI4a,IACT/6B,KAAKyf,IAAIsb,KACTt0B,QACAu0B,GAAKoB,SACMuL,OAAOh1B,MAChB8b,QACAzuB,KAAK2nC,OAAOh1B,OACH4d,cAAcyK,KACvBvM,QACAzuB,KAAKg7B,MAELh7B,KAAKg7B,IACLD,GAAK5a,IAAI4a,IACT/6B,KAAKyf,IAAIsb,KACTt0B,QAEF00B,GAAKiB,MACLlB,GAAKkB,MACLnB,GAAKmB,QACK,CAYR,GAVI7L,cAAc4K,KAChBn7B,KAAKm7B,IACLz6B,EAAI67B,cACA8U,MAAM3wC,IACRymC,KAAK,4BAGPzmC,EAAI,EAENV,KAAKi7B,IACDv6B,GAAK,EACP,IAASF,EAAI,EAAGgiC,EAAM9hC,EAAI,GAAK8hC,EAAMhiC,EAAIgiC,EAAMhiC,EAAIgiC,EAAU,GAAKA,IAAQhiC,IAAMA,EAC9ER,KAAKk7B,IACL3V,kBAIF,IAAS6J,EAAK,EAAGqT,EADjB/hC,GAAKA,EACuB,GAAK+hC,EAAOrT,EAAKqT,EAAOrT,EAAKqT,EAAW,GAAKA,IAASrT,IAAOA,EACvFpvB,KAAKk7B,IACLpL,WAIJ,GADAmL,GAAKmB,MACDjB,KAAOwM,OAAOh1B,KAChB,MAaF,GAAI4d,cAAc4K,IAAK,CAKrB,GAJAJ,GAAK5a,IAAI4a,IACT/6B,KAAKyf,IAAIsb,KACTt0B,QACA00B,GAAKiB,SACMuL,OAAOh1B,KAChB,MAEE4d,cAAc4K,IACJ,GAEZD,GAAKC,GACLJ,GAAK5a,IAAI4a,IACT/6B,KAAKyf,IAAIsb,KACTt0B,OACA00B,GAAKiB,YAGPlB,GAAKC,GACLJ,GAAK5a,IAAI4a,IACT/6B,KAAKyf,IAAIsb,KACTt0B,OACA00B,GAAKiB,MAGT,OAAOp8B,KAAKi7B,KAGd1V,WAAa,WAoBX,OAnBA+d,OACAtI,GAAKoB,MACLrB,GAAKqB,MACD7L,cAAcyK,KAChBmM,KAAK,sBAEHlS,SAAS8F,IACP9F,SAAS+F,IACXnX,kBAEAD,kBAGEqR,SAAS+F,IACXrX,kBAEAF,kBAGGof,WAGTpf,gBAAkB,WAChB,OAAIsR,SAASiG,IACJtX,qBAIP1jB,KAAK+6B,IACL/6B,KAAKg7B,IACLh7B,KAAK2nC,OAAOpyB,UACZgyB,SACAvnC,KAAK2nC,OAAOpyB,UACZgQ,aACAvlB,KAAK2nC,OAAOpyB,UACZvV,KAAKg7B,IACEuM,WAIX7jB,kBAAoB,WAElB,GAAI0F,MAAM2R,GAAIC,IACZh7B,KAAKu6B,UAGP,GAAK3I,OAAOmJ,IAIZ,GAAIzJ,MAAMyJ,IACRzT,YAGF,GAAI7H,IAAIsb,MAAQ4M,OAAOn1B,UAIvB,GAAIiN,IAAIsb,MAAQ4M,OAAO5zB,OAIvB,GAAI0L,IAAIsb,MAAQ4M,OAAO7iC,YAIvB,GAAI2a,IAAIsb,MAAQ4M,OAAOn2B,KAIvB,GAAIiO,IAAIsb,MAAQ4M,OAAO7xB,KAIvB,GAAI2J,IAAIsb,MAAQ4M,OAAO/jC,KAIvB,GAAI6b,IAAIsb,MAAQ4M,OAAOjwB,KAIvB,GAAI+H,IAAIsb,MAAQ4M,OAAOlmC,QAIvB,GAAIge,IAAIsb,MAAQ4M,OAAOpmC,QAIvB,GAAIke,IAAIsb,MAAQ4M,OAAOhmC,QAIvB,GAAI8d,IAAIsb,MAAQ4M,OAAO5xB,MAIvB,GAAI0J,IAAIsb,MAAQ4M,OAAO9jC,MAIvB,GAAI4b,IAAIsb,MAAQ4M,OAAOhwB,MAIvB,GAAI8H,IAAIsb,MAAQ4M,OAAOjmC,SAIvB,GAAI+d,IAAIsb,MAAQ4M,OAAOnmC,SAIvB,GAAIie,IAAIsb,MAAQ4M,OAAO/lC,SAIvB,GAAI6d,IAAIsb,MAAQ4M,OAAOzmC,KAIvB,GAAIue,IAAIsb,MAAQ4M,OAAOjyB,KAIvB,GAAI+J,IAAIsb,MAAQ4M,OAAO13B,SAIvB,GAAIwP,IAAIsb,MAAQ4M,OAAOzhC,KAIvB,GAAIuZ,IAAIsb,MAAQ4M,OAAOxhC,MAIvB,GAAIsZ,IAAIsb,MAAQ4M,OAAOzlC,SAQvB,GAAIud,IAAIsb,MAAQ4M,OAAOxlC,SAAvB,CAQA,GAAIsd,IAAIsb,MAAQ4M,OAAOr3B,WAAagP,MAAMyb,MAAQC,GAIlD,OAAOpV,YAHLJ,8BARIsL,mBAAmBxR,MAAMyb,KAC3BxW,YAEAC,iBAXEsM,mBAAmBxR,MAAMyb,KAC3B1W,YAEAC,iBAPFgB,aAJAD,YAJAQ,gBAJAsB,YAJArD,YAJAM,gBAJAJ,gBAJAE,gBAJAsD,aAJA9C,aAJA2C,aAJAlD,eAJAJ,eAJAE,eAJAsD,YAJA9C,YAJA2C,YAJAb,YAJA5B,UAJAoC,cAJAC,gBARAhnB,KAAK6sC,OAkHTvlB,KAAO,WACL,IAAIymB,EAGJ,IAFAA,EAAI5E,IACJpO,GAAK5a,IAAI4a,IACFnJ,OAAOmJ,KACZ/6B,KAAKyf,IAAIsb,KACT/6B,KAAKg7B,IACLzV,aACAwV,GAAK5a,IAAI4a,IAEX,OAAOhgB,QAAQouB,IAAM4E,IAGvB/mB,SAAW,WACT,IAAIhpB,EAAGoxB,EAAIif,EAAG3tC,EAAGF,EAAGgiC,EAAKC,EAKzB,IAJAzkC,EAAI,EACJqwC,EAAI,EACA,EAECrwC,EAAIwC,EAAI,EAAGgiC,EADhB9hC,EAAI3C,OAAOg9B,IAAM,EACS,GAAKyH,EAAMhiC,EAAIgiC,EAAMhiC,EAAIgiC,EAAMxkC,EAAI,GAAKwkC,IAAQhiC,IAAMA,EAAG,CAEjF,IADAy6B,GAAK9a,IAAI4a,IACJsT,EAAIjf,EAAK,EAAGqT,EAAO/hC,EAAI,GAAK+hC,EAAOrT,EAAKqT,EAAOrT,EAAKqT,EAAO4L,EAAI,GAAK5L,IAASrT,IAAOA,EACvFpvB,KAAKyf,IAAIwb,KACLj9B,IAAMqwC,IACRruC,KAAKg7B,IACLzV,cAEF0V,GAAK9a,IAAI8a,IAEX3C,aAAa53B,GAEf,OAAOqa,QAAQra,IAmBjBqmB,OAAS,WAgBP,OAfA/mB,KAAKsf,MAAMyb,KACX/6B,KAAKuf,KAAKwb,KACV7U,SACAlmB,KAAKuf,KAAKwb,KACV/6B,KAAKg7B,IACLzV,aACA8S,WACAr4B,KAAKuf,KAAKwb,KACV5E,YACAn2B,KAAKsf,MAAMyb,KACX/6B,KAAKg7B,IACLzV,aACA8S,WACAzd,MACA5a,KAAK+6B,IACE1C,YAGT9R,KAAO,WAKL,OAJAvmB,KAAKuf,KAAKwb,KACV/6B,KAAKg7B,IACLzV,aACAvlB,KAAKuf,KAAKwb,KACH7U,UAcTvB,GAAK,WAMH,OAJA3kB,KAAKuf,KAAKwb,KACV/6B,KAAKg7B,IACLzV,aACA0V,GAAKmB,MACD3c,IAAIwb,MAAQ0M,OAAO7iC,aAErBu8B,YAAYv8B,YACZu8B,YAAYv8B,YACZ9E,KAAKuf,KAAK0b,KACNlF,MAAMzW,MAAM2b,IAAK3b,MAAMyb,MACzB/6B,KAAKsf,MAAM2b,KACXhF,KAAK,GACLj2B,KAAKsf,MAAMyb,OAEX/6B,KAAKsf,MAAMyb,KACX9E,KAAK,GACLj2B,KAAKsf,MAAM2b,MAENhF,KAAK,KAEZj2B,KAAKi7B,IACLj7B,KAAKsf,MAAMyb,KACJxV,eAKXK,UAAY,WAEV,OADAqV,GAAK9a,IAAI4a,OACE4M,OAAOh1B,MAAQ7C,MAAKmrB,GAAID,KACjCqG,YAAYv8B,YACZ9E,KAAK+6B,IACL/6B,KAAKg7B,IACE/E,KAAK,IAELj2B,KAAK6sC,OAIhBzlB,KAAO,WAML,OALApnB,KAAKuf,KAAKwb,KACV/6B,KAAKg7B,IACLzV,aACAvlB,KAAKuf,KAAKwb,KACV9X,SACOoV,YAGT5T,KAAO,WAOL,OANAzkB,KAAKuf,KAAKwb,KACV/6B,KAAKg7B,IACLzV,aACAvlB,KAAKuf,KAAKwb,KACVwL,OACAlO,WACOU,UAGTxR,KAAO,WAQL,OAPAvnB,KAAKuf,KAAKwb,KACV/6B,KAAKg7B,IACLzV,aACAvlB,KAAKuf,KAAKwb,KACV9X,SACAke,cAAc,GACd3E,QACOnE,YAGTpU,QAAU,WAWR,OAVAjkB,KAAKuf,KAAKwb,KACV/6B,KAAKg7B,IACLzV,aACA4b,aAAa,GACbnhC,KAAKuf,KAAKwb,KACVoG,aAAa,GACb3E,QACAgL,WACApG,eAAe,EAAG,GAClB5E,QACOnE,YAGTtU,QAAU,WAYR,OAXA/jB,KAAKuf,KAAKwb,KACV/6B,KAAKg7B,IACLzV,aACA4b,aAAa,GACbnhC,KAAKuf,KAAKwb,KACVoG,aAAa,GACb3E,QACAgL,WACApG,eAAe,EAAG,GAClB5E,QACAnE,WACOU,UAQT5U,QAAU,WAWR,OAVAnkB,KAAKuf,KAAKwb,KACV/6B,KAAKg7B,IACLzV,aACA4b,aAAa,GACbnhC,KAAKuf,KAAKwb,KACVoG,aAAa,GACb3E,QACA5hB,MACAuV,UACAkI,WACOsN,YAGTte,MAAQ,WAMN,OALArnB,KAAKuf,KAAKwb,KACV/6B,KAAKg7B,IACLzV,aACAvlB,KAAKuf,KAAKwb,KACVwP,QACOlS,YAGT3T,MAAQ,WAMN,OALA1kB,KAAKuf,KAAKwb,KACV/6B,KAAKg7B,IACLzV,aACAvlB,KAAKuf,KAAKwb,KACV+P,QACOzS,YAGT7Q,MAAQ,WAQN,OAPAxnB,KAAKuf,KAAKwb,KACV/6B,KAAKg7B,IACLzV,aACAvlB,KAAKuf,KAAKwb,KACVwP,QACApJ,cAAc,GACd3E,QACOnE,YAGTnU,SAAW,WAWT,OAVAlkB,KAAKuf,KAAKwb,KACV/6B,KAAKg7B,IACLzV,aACAvlB,KAAKuf,KAAKwb,KACVoG,aAAa,GACb3E,QACA2E,aAAa,GACbvmB,MACAwmB,eAAe,EAAG,GAClB5E,QACOnE,YAGTrU,SAAW,WAWT,OAVAhkB,KAAKuf,KAAKwb,KACV/6B,KAAKg7B,IACLzV,aACAvlB,KAAKuf,KAAKwb,KACVoG,aAAa,GACb3E,QACA2E,cAAc,GACdvmB,MACAwmB,eAAe,EAAG,GAClB5E,QACOnE,YAGTjU,SAAW,WAUT,OATApkB,KAAKuf,KAAKwb,KACV/6B,KAAKg7B,IACLzV,aACA4b,aAAa,GACbnhC,KAAKuf,KAAKwb,KACVoG,aAAa,GACb3E,QACAgL,WACArX,UACOkI,YAGTvU,KAAO,WAML,OALA9jB,KAAKuf,KAAKwb,KACV/6B,KAAKg7B,IACLzV,aACAvlB,KAAKuf,KAAKwb,KACVoK,MACO9M,YAGTlR,KAAO,WAQL,OAPAnnB,KAAKuf,KAAKwb,KACV/6B,KAAKg7B,IACLzV,aACAvlB,KAAKuf,KAAKwb,KACVjV,QACAuS,WACA8I,aAAa,GACN9I,YAGTxS,SAAW,WAaT,OAZA7lB,KAAKuf,KAAKwb,KACV/6B,KAAKg7B,IACLzV,aACA4b,aAAa,GACbnhC,KAAKsf,MAAMyb,KACX1C,WACAA,WACAr4B,KAAKuf,KAAKwb,KACV/6B,KAAKsf,MAAMyb,KACXoG,cAAc,GACdvmB,MACAsU,UACOmJ,YAGThT,KAAO,WAoBL,OAnBArlB,KAAKuf,KAAKwb,KACVoG,aAAa,GACb3E,QACA2E,cAAc,GACd9I,WACA/N,cACIZ,mBACFqX,YAAYwN,KAAK16B,IAEjBwtB,YAAYxtB,IAEdutB,eAAe,EAAG,GAClB5E,QACAnE,WACA8I,aAAa,GACb9I,WACAr4B,KAAKuf,KAAKwb,KACV/6B,KAAKg7B,IACLzV,aACO8S,YAGT/S,MAAQ,WAoBN,OAnBAtlB,KAAKuf,KAAKwb,KACVoG,aAAa,GACb3E,QACA2E,cAAc,GACd9I,WACA/N,cACIZ,mBACFqX,YAAYwN,KAAK16B,IAEjBwtB,YAAYxtB,IAEdutB,eAAe,EAAG,GAClB5E,QACAnE,WACA8I,cAAc,GACd9I,WACAr4B,KAAKuf,KAAKwb,KACV/6B,KAAKg7B,IACLzV,aACO8S,YAGThU,UAAY,WASV,OARArkB,KAAKuf,KAAKwb,KACV/6B,KAAKg7B,IACLzV,aACAvlB,KAAKuf,KAAKwb,KACVoG,aAAa,GACbrjB,UACAua,WACA8I,cAAc,GACP9I,YAGT/T,UAAY,WAmBV,OAlBAtkB,KAAKuf,KAAKwb,KACV/6B,KAAKg7B,IACLzV,aACAvlB,KAAKuf,KAAKwb,KACV/6B,KAAKsf,MAAMyb,KACXoG,cAAc,GACdvmB,MACAkD,UACA9d,KAAKsf,MAAMyb,KACXoG,cAAc,GACd9I,WACAr4B,KAAKuf,KAAKwb,KACV7U,SACAlmB,KAAKuf,KAAKwb,KACV/6B,KAAKsf,MAAMyb,KACXjd,UACAua,WACAzd,MACOyd,YAGT9T,UAAY,WASV,OARAvkB,KAAKuf,KAAKwb,KACV/6B,KAAKg7B,IACLzV,aACAvlB,KAAKuf,KAAKwb,KACVoG,aAAa,GACbrjB,UACAua,WACA8I,cAAc,GACP9I,YAGT7T,UAAY,WAmBV,OAlBAxkB,KAAKuf,KAAKwb,KACV/6B,KAAKg7B,IACLzV,aACAvlB,KAAKuf,KAAKwb,KACV/6B,KAAKsf,MAAMyb,KACXoG,cAAc,GACdvmB,MACAmD,UACA/d,KAAKsf,MAAMyb,KACXoG,cAAc,GACd9I,WACAr4B,KAAKuf,KAAKwb,KACV7U,SACAlmB,KAAKuf,KAAKwb,KACV/6B,KAAKsf,MAAMyb,KACXhd,UACAsa,WACAzd,MACOyd,YAGT7S,uBAAyB,WACvB,OAAOxlB,KAAKuf,KAAKwb,MAGnB/1B,cAAgB,WACd,OAAKiwB,SAAS8F,IAEgB,IAAnBA,GAAGwN,OAAOsF,MAEV9S,GAAGwN,OAAOoF,IAAI,KAAO5S,GAAGwN,OAAOoF,IAAI,GADrC,EAIA,EANA,GAUXloB,IAAM,WACJ,IAAIynB,EAAGlvC,EAAGoxB,EAAI1uB,EAAGF,EAAGgiC,EAAKC,EAMzB,GALAzkC,EAAI,EACA,EAEJslC,OACAvI,GAAKqB,MACmB,IAApBp3B,gBAKF,OAJAq8B,YAAYt8B,KACZ/E,KAAK+6B,IACL9E,KAAK,QACL4M,UAKF,IAFAniC,EAAIq6B,GAAGwN,OAAOuF,MACdZ,EAAInS,GAAGwN,OAAO3gB,KACT5pB,EAAIwC,EAAI,EAAGgiC,EAAM9hC,GAAI,GAAK8hC,EAAMhiC,EAAIgiC,EAAMhiC,EAAIgiC,IAC5CjS,cAAc2c,EAAElvC,IADkCA,EAAI,GAAKwkC,IAAQhiC,IAAMA,GAKhF,GAAIxC,IAAM0C,EACR6qC,aACK,CACL,IAAKvtC,EAAIoxB,EAAK,EAAGqT,EAAO1H,GAAGwN,OAAOuF,MAAQ,GAAKrL,EAAOrT,EAAKqT,EAAOrT,EAAKqT,EAAOzkC,EAAI,GAAKykC,IAASrT,IAAOA,EACrGpvB,KAAK+6B,GAAGwN,OAAO3gB,KAAK5pB,IAEtB0nB,YAAYqV,GAAGwN,OAAOoF,IAAI,IAE5B,OAAO9K,WAITnd,YAAc,SAAShlB,GACrB,IAAIwsC,EAAG+L,EAAsBlL,EAAG/vC,EAAGoxB,EAAIif,EAAGZ,EAAGjtC,EAAG6sC,EAAG7K,EAAKC,EAAMgN,EAAG8H,EAAO/H,EAgBxE,IAfI,EACJxxC,EAAI,EACJqwC,EAAI,EACJZ,EAAI,EACJJ,EAAI,EACJoC,EAAI,EACJ8H,EAAQ,EACR/H,EAAI,EACJtC,EAAI,GAEJa,EAAI5E,IAAMzoC,EAAIA,EAKT1C,EAAIwC,EAAI,EAAGgiC,EAAM9hC,EAAI,GAAK8hC,EAAMhiC,EAAIgiC,EAAMhiC,EAAIgiC,EAAMxkC,EAAI,GAAKwkC,IAAQhiC,IAAMA,EAC9E0sC,EAAElvC,GAAKA,EACPkvC,EAAElvC,EAAI0C,GAAK,EACXwsC,EAAElvC,EAAI0C,EAAIA,GAAK,EAIjB,IAFA62C,EAAQ,EACRv3C,KAAK6sC,QACK,CAMR,IAJE1L,aADY,IAAVoW,EACW,GAEC,GAEXv5C,EAAIoxB,EAAK,EAAGqT,EAAO/hC,EAAI,GAAK+hC,EAAOrT,EAAKqT,EAAOrT,EAAKqT,EAAOzkC,EAAI,GAAKykC,IAASrT,IAAOA,EACvFqe,EAAI/sC,EAAIwsC,EAAElvC,GAAKA,EACfgC,KAAK8mC,MAAMiH,EAAIN,IACfpV,WAOF,IALAzd,MAEAyzB,EAAI3tC,EAAI,EACR+uC,EAAI,EACJwJ,GAAuB,IAGrB,IADA5L,EAAIH,EAAExsC,EAAI2tC,GAAKnB,EAAExsC,EAAIA,EAAI2tC,IACjB,EACNnB,EAAExsC,EAAIA,EAAI2tC,IAAMnB,EAAExsC,EAAIA,EAAI2tC,GAC1BA,QAFF,CAKA,GAAIhB,IAAMgB,EAAI,EAUd,MATE,GAAU,IAANA,EAAS,CACX4K,GAAuB,EACvB,MAEFxJ,IACAvC,EAAExsC,EAAIA,EAAI2tC,IAAMnB,EAAExsC,EAAIA,EAAI2tC,GAC1BA,IAKJ,GAAI4K,EACF,MAEFzJ,EAAItC,EAAEmB,EAAInB,EAAExsC,EAAI2tC,GAAKoB,GACrBvC,EAAEmB,EAAInB,EAAExsC,EAAI2tC,GAAKoB,GAAKvC,EAAEmB,EAAIhB,EAAIoC,GAChCvC,EAAEmB,EAAIhB,EAAIoC,GAAKD,EACftC,EAAExsC,EAAI2tC,GAAKhB,EACXkK,GAASA,EAGX,OADAzQ,MAAMiH,GAAKjH,MAAMqC,IAAM,GAChB1R,QAAQsW,EAAI,IAiBrBpoB,KAAO,WAGL,OAFA2d,OACAvI,GAAKqB,MACmB,IAApBp3B,iBACFq8B,YAAYt8B,KACZ/E,KAAK+6B,IACL9E,KAAK,QACL4M,YAGF0I,SACO1I,YAGT0I,OAAS,WACP,IAAIvtC,EAAG0C,EAAGF,EAAGgiC,EAIb,IAHAxkC,EAAI,EACA,EAECA,EAAIwC,EAAI,EAAGgiC,GADhB9hC,EAAIq6B,GAAGwN,OAAOoF,IAAI,IACQjtC,EAAI,GAAK8hC,EAAMhiC,EAAIgiC,EAAMhiC,EAAIgiC,EAAMxkC,EAAI,GAAKwkC,IAAQhiC,IAAMA,EAClFR,KAAK+6B,GAAGwN,OAAO3gB,KAAK5pB,IAItB,OAFAs4B,UAAU51B,GACV+2B,QAAQ0R,IAAMzoC,EAAIA,GACXV,KAAK+6B,KAcdrpB,EAAI,SAASq8B,EAAGrtC,EAAG1C,EAAGqwC,GACpB,OAAOvH,MAAMiH,EAAIrtC,EAAI1C,EAAIqwC,IAG3BzJ,KAAO,SAASmJ,EAAGrtC,EAAG1C,EAAGqwC,EAAGpuC,GAC1B,OAAO6mC,MAAMiH,EAAIrtC,EAAI1C,EAAIqwC,GAAKpuC,GAGhCq2B,UAAY,SAAS51B,GACnB,IAAI8sC,EAAGO,EAAG/vC,EAAGoxB,EAAIif,EAAG9Y,EAAIma,EAAIC,EAAInvC,EAAGgiC,EAAKC,EAAMmN,EAAMC,EAAMC,EAAMC,EAAMC,EAAMC,EAAMC,EAOlF,IANA1C,EAAI,EACA,EACJxvC,EAAI,EACJqwC,EAAI,EACJN,EAAI5E,IAAMzoC,EAAIA,EACdq6B,GAAKR,IACAiT,EAAIhtC,EAAI,EAAGgiC,EAAM9hC,EAAI,EAAI,GAAK8hC,EAAMhiC,EAAIgiC,EAAMhiC,EAAIgiC,EAAMgL,EAAI,GAAKhL,IAAQhiC,IAAMA,EAAG,CAErF,GAAI4oB,MAAM1X,EAAEq8B,EAAGrtC,EAAG8sC,EAAGA,GAAIX,MAAO,CAE9B,IAAK7uC,EAAIoxB,EAAKqT,EAAO+K,EAAI,EAAGoC,EAAOlvC,GAAI+hC,GAAQmN,EAAOxgB,EAAKwgB,EAAOxgB,EAAKwgB,IAChExmB,MAAM1X,EAAEq8B,EAAGrtC,EAAG1C,EAAGwvC,GAAIX,MADkD7uC,EAAIykC,GAAQmN,IAASxgB,IAAOA,GAK1G,GAAIpxB,IAAM0C,EAAG,CACXq6B,GAAK8R,KACL,MAGF,IAAKwB,EAAI9Y,EAAKsa,EAAOrC,EAAGsC,EAAOpvC,EAAImvC,GAAQC,EAAOva,EAAKua,EAAOva,EAAKua,EAAOzB,EAAIwB,GAAQC,IAASva,IAAOA,EACpGyF,GAAKtpB,EAAEq8B,EAAGrtC,EAAG8sC,EAAGa,GAChBzJ,KAAKmJ,EAAGrtC,EAAG8sC,EAAGa,EAAG38B,EAAEq8B,EAAGrtC,EAAG1C,EAAGqwC,IAC5BzJ,KAAKmJ,EAAGrtC,EAAG1C,EAAGqwC,EAAGrT,IAGnBh7B,KAAK+6B,IACLhC,SACAgC,GAAKqB,MAQP,IALAp8B,KAAK+6B,IACL/6B,KAAK0R,EAAEq8B,EAAGrtC,EAAG8sC,EAAGA,IAChBnV,WACA0C,GAAKqB,MAEAp+B,EAAI0xC,EAAKK,EAAOvC,EAAI,EAAGwC,EAAOtvC,EAAIqvC,GAAQC,EAAON,EAAKM,EAAON,EAAKM,EAAOhyC,EAAI+xC,GAAQC,IAASN,IAAOA,EASxG,IAPA1vC,KAAK0R,EAAEq8B,EAAGrtC,EAAG1C,EAAGwvC,IAChBxtC,KAAK0R,EAAEq8B,EAAGrtC,EAAG8sC,EAAGA,IAChBtnB,SACA6S,SACAiC,GAAKoB,MAELwI,KAAKmJ,EAAGrtC,EAAG1C,EAAGwvC,EAAGX,MACZwB,EAAIsB,EAAKM,EAAOzC,EAAI,EAAG0C,EAAOxvC,EAAIuvC,GAAQC,EAAOP,EAAKO,EAAOP,EAAKO,EAAO7B,EAAI4B,GAAQC,IAASP,IAAOA,EACxG3vC,KAAK0R,EAAEq8B,EAAGrtC,EAAG8sC,EAAGa,IAChBruC,KAAKg7B,IACL3C,WACAr4B,KAAK0R,EAAEq8B,EAAGrtC,EAAG1C,EAAGqwC,IAChBzzB,MACAgqB,KAAKmJ,EAAGrtC,EAAG1C,EAAGqwC,EAAGjS,OAQvB,OAHAp8B,KAAK+6B,IACL/6B,KAAK0R,EAAEq8B,EAAGrtC,EAAGA,EAAI,EAAGA,EAAI,IACxB23B,WACO0C,GAAKqB,OAWdlzB,WAAa,WAGX,OAFAlJ,KAAKuf,KAAKwb,KACVt0B,OACOqf,SAGTA,MAAQ,WAGN,OAFAwd,OACAkH,SACO3H,WAIT2H,OAAS,WAEP,OADAzP,GAAKqB,MACDrK,SAASgJ,IACE,IAATA,GAAGyS,OACLrM,aAAa,QAGbA,aAAa,GAIbzM,WAAWqG,IACTtoB,MAAM4kB,KAAK0D,GAAGsS,EAAEH,EAAGnS,GAAGsS,EAAEF,SAC1BhM,aAAa,QAGbA,aAAa,GAIb1hB,IAAIsb,MAAQ4M,OAAO5zB,QACrBstB,YAAYn8B,OACZlF,KAAKuf,KAAKwb,UACV9E,KAAK,IAGH3C,eAAeyH,KACjBsG,YAAYn8B,OACZlF,KAAK+6B,IACLhC,cACA9C,KAAK,MAGH3C,eAAeyH,KAAQtb,IAAIsb,MAAQ4M,OAAOxmC,MAAQmyB,eAAe/T,KAAKwb,QACxE/6B,KAAK+6B,IACLhC,SACAgC,GAAKqB,OAEPiF,YAAYn8B,OACZlF,KAAK+6B,IACE9E,KAAK,KAYd7P,SAAW,WACT,IAAI2nB,EAAG/vC,EAAG0C,EAAGF,EAAGgiC,EAAK6M,EAerB,IAdArxC,EAAI,EACA,EACA,EACJslC,OACAyK,EAAI5E,IAAM,EACV9iB,mBACA3lB,EAAIyoC,IAAM4E,GAEVsB,EAAgBvI,MAAMlmC,MAAMmtC,EAAGA,EAAIrtC,IACrB4uC,KAAK/tB,WACnBulB,MAAQA,MAAMlmC,MAAM,EAAGmtC,GAAGwB,OAAOF,GAAeE,OAAOzI,MAAMlmC,MAAMmtC,EAAIrtC,KACvEq6B,GAAK1f,aAAa3a,IACf6nC,OAAOsF,KAAO,EACjB9S,GAAGwN,OAAOoF,IAAI,GAAKjtC,EACd1C,EAAIwC,EAAI,EAAGgiC,EAAM9hC,EAAI,GAAK8hC,EAAMhiC,EAAIgiC,EAAMhiC,EAAIgiC,EAAMxkC,EAAI,GAAKwkC,IAAQhiC,IAAMA,EAC9Eu6B,GAAGwN,OAAO3gB,KAAK5pB,GAAK8oC,MAAMiH,EAAI/vC,GAIhC,OAFAy5B,QAAQsW,GACR/tC,KAAK+6B,IACE8H,WAGTxc,iBAAmB,WACjB,IAAI0nB,EAAG/vC,EAAGyvC,EAAG/sC,EAAGF,EAAGgiC,EASnB,GARI,EACJxkC,EAAI,EACA,EACA,EACJslC,OACAvI,GAAKqB,MACL2R,EAAI5E,IAEA5Y,cAAcwK,IAChB/6B,KAAK+6B,IACLzP,2BACK,GAAI7L,IAAIsb,MAAQ4M,OAAOxmC,KAC5BnB,KAAK+6B,IACLlhB,oBAKK,GAAI4F,IAAIsb,MAAQ4M,OAAOn1B,UAO5B,IANAuoB,GAAK5a,IAAI4a,IACLxK,cAAc9Q,IAAIsb,OACpB/6B,KAAKyf,IAAIsb,KACTzP,sBACAyP,GAAK5a,IAAI4a,KAEJnJ,OAAOmJ,KACZC,GAAKvb,IAAIsb,IACLtb,IAAIub,MAAQ2M,OAAO5zB,QACrB/T,KAAKuf,KAAKyb,KACVh7B,KAAKsf,MAAM0b,OAEXh7B,KAAKg7B,IACLh7B,KAAKu6B,MAEPQ,GAAK5a,IAAI4a,SAEFtb,IAAIsb,MAAQ4M,OAAO5zB,QAC5B/T,KAAKuf,KAAKwb,KACV/6B,KAAKsf,MAAMyb,OAEX/6B,KAAK+6B,IACL/6B,KAAKu6B,MAQP,IANAkT,EAAItE,IAEJnpC,KAAKu6B,KACL5M,KAAIogB,EAAGN,GAGFzvC,EAAIwC,EAAI,EAAGgiC,EADhB9hC,EAAIyoC,IAAMsE,EACgB,GAAKjL,EAAMhiC,EAAIgiC,EAAMhiC,EAAIgiC,EAAMxkC,EAAI,GAAKwkC,IAAQhiC,IAAMA,EAC9EsmC,MAAMiH,EAAI/vC,GAAK8oC,MAAM2G,EAAIzvC,GAG3B,OADAy5B,QAAQsW,EAAIrtC,GACLmiC,WA6BTlV,KAAM,SAASogB,EAAGN,GAChB,IAAIoJ,EAAM74C,EAAGwC,EAAGgiC,EAKhB,GAJO,EACPxkC,EAAI,EACJslC,OACAvI,GAAKqB,MACD2R,IAAMN,EAGR,OAFAztC,KAAK+6B,SACL8H,UAOF,GAJA7H,GAAK8L,MAAMiH,EAAI,GACf9S,GAAK6L,MAAMiH,EAAI,GACf/tC,KAAKi7B,IACL4b,EAAOta,eACF8U,MAAMwF,GACT,IAAK74C,EAAIwC,EAAI,EAAGgiC,EAAM+L,KAAK/zB,IAAIq8B,GAAQ,GAAKrU,EAAMhiC,GAAKgiC,EAAMhiC,GAAKgiC,EAAMxkC,EAAI,GAAKwkC,IAAQhiC,IAAMA,EAC7FR,KAAK+6B,IACL/6B,KAAKg7B,IACLmG,aAAamE,KAAKuR,GAAQ74C,GAC1Bw+B,QACAnE,WACA1K,KAAIogB,EAAI,EAAGN,GAGf,OAAO5K,WAeThpB,aAAe,WAOb,IANAypB,OACAvI,GAAKqB,MAELnB,GAAK9a,IAAI4a,IACT/6B,KAAKyf,IAAIwb,KACTA,GAAK9a,IAAI8a,IACFrJ,OAAOqJ,KACZj7B,KAAKyf,IAAIwb,KACThO,MACAgO,GAAK9a,IAAI8a,IAIX,GADAD,GAAKoB,MACDvI,UAAUmH,IAIZ,OAHAh7B,KAAK+6B,IACL/6B,KAAKu6B,UACLsI,UAIF,GAAItS,cAAcyK,IAChBh7B,KAAKg7B,IACL1P,2BACK,GAAI7L,IAAIub,MAAQ2M,OAAOn1B,UAU5B,IATAyoB,GAAK9a,IAAI6a,IACLzK,cAAc9Q,IAAIwb,MACpBj7B,KAAKyf,IAAIwb,KACT3P,wBAEAtrB,KAAKyf,IAAIwb,KACTj7B,KAAKu6B,MAEPU,GAAK9a,IAAI8a,IACFrJ,OAAOqJ,KACZj7B,KAAKyf,IAAIwb,KACTj7B,KAAKu6B,KACLU,GAAK9a,IAAI8a,SAGXj7B,KAAKg7B,IACLh7B,KAAKu6B,KAQP,IALAv6B,KAAKg7B,IACL7K,UACA6K,GAAKoB,MACLp8B,KAAK6sC,MACL5R,GAAK9a,IAAI4a,IACFnJ,OAAOqJ,KACZj7B,KAAKg7B,IACLh7B,KAAKyf,IAAIwb,KACT5C,WACAzd,MACAqgB,GAAK9a,IAAI8a,IAGX,OADAj7B,KAAKu6B,KACEsI,WAIT/b,KAAO,WACL,IAAIomB,EAAGC,EAAG+L,EAAMrC,EAAMsC,EAAQC,EAc9B,OAbAlM,EAAI,EACJC,EAAI,EACG,EACA,EACPgM,EAAS,EACD,EACRtC,EAAOxa,aAGM,KAFb6c,EAAO7c,eAEawa,EAAO,GACzB1P,KAAK,kBAGH+R,GAAQ,GAAQrC,EAAO,IAAS,GAClCsC,EAAS5K,KAAKoC,IAAIuI,EAAMrC,QACxB9V,YAAYoY,KAGdA,EAAS5K,KAAKoC,IAAIpC,KAAK/zB,IAAI0+B,GAAOrC,GAClCuC,EAAQ7K,KAAK16B,GAAKgjC,EAEbA,EAAO,KAAS,GACnB3J,EAAI,EACJC,EAAIoB,KAAKkE,IAAI2G,KAEblM,EAAIqB,KAAKsK,IAAIO,GACbjM,EAAIoB,KAAKkE,IAAI2G,IAEfrY,YAAYmM,EAAIiM,GAChBpY,YAAYoM,EAAIgM,GAChBn5C,KAAKsvB,eACL+I,WACOzd,QAoFT9U,MAAQ,EAERE,SAAW,GAEXC,SAAW,GAEXqD,WAAa,WASX,OARwB,IAApBvD,iBACFohC,KAAK,0CAEPzf,MAAM/hB,OACNo1B,GAAKmP,WAAW,KAChBpF,YAAY/J,GAAIC,IAChBD,GAAKmP,WAAW,KAChBpF,YAAY/J,GAAIE,IACTj7B,KAAK2nC,OAAOh1B,OAGrBpJ,cAAgB,WACd,OAAwB,IAApBxD,iBACFs7B,YAAYz7B,UACZ5F,KAAK+6B,SACL9E,KAAK,KAGPvO,MAAM9hB,UACC5F,KAAKg7B,MAGdxxB,cAAgB,WACd,OAAwB,IAApBzD,iBACFs7B,YAAYx7B,UACZ7F,KAAK+6B,SACL9E,KAAK,KAGPvO,MAAM7hB,UACC7F,KAAKi7B,MAGdl1B,cAAgB,WACd,IAAI/H,EAAGoxB,EAAIif,EAAG9Y,EAAIma,EAAIlvC,EAAGgiC,EAAKC,EAAMmN,EAAMC,EAAMC,EAQhD,GAPA9xC,EAAI,EACJqwC,EAAI,EACJruC,KAAKuf,KAAKwb,KACVt0B,OACAolC,WACAplC,OACAs0B,GAAKqB,OACAnH,SAAS8F,IACZ,OAAO,EAMT,IAJuB,IAAnBA,GAAGwN,OAAOsF,MAAc9S,GAAGwN,OAAOoF,IAAI,KAAO5S,GAAGwN,OAAOoF,IAAI,IAC7DxG,KAAK,0CAGFnpC,EAAIwC,EAAI,EAAGgiC,EADhB18B,MAAQi1B,GAAGwN,OAAOoF,IAAI,GACQ,GAAKnL,EAAMhiC,EAAIgiC,EAAMhiC,EAAIgiC,EAAMxkC,EAAI,GAAKwkC,IAAQhiC,IAAMA,EAClF,IAAK6tC,EAAIjf,EAAK,EAAGqT,EAAO38B,MAAQ,GAAK28B,EAAOrT,EAAKqT,EAAOrT,EAAKqT,EAAO4L,EAAI,GAAK5L,IAASrT,IAAOA,EACtF2C,SAASgJ,GAAGwN,OAAO3gB,KAAK9hB,MAAQ9H,EAAIqwC,KACvClH,KAAK,kCAIX,IAAKnpC,EAAIu3B,EAAK,EAAGqa,EAAO9pC,MAAQ,EAAI,GAAK8pC,EAAOra,EAAKqa,EAAOra,EAAKqa,EAAO5xC,EAAI,GAAK4xC,IAASra,IAAOA,EAC/F,IAAK8Y,EAAIqB,EAAKG,EAAO7xC,EAAI,EAAG8xC,EAAOhqC,MAAQ+pC,GAAQC,EAAOJ,EAAKI,EAAOJ,EAAKI,EAAOzB,EAAIwB,GAAQC,IAASJ,IAAOA,EACxGnB,KAAK/zB,IAAIugB,GAAGwN,OAAO3gB,KAAK9hB,MAAQ9H,EAAIqwC,GAAGb,EAAIzS,GAAGwN,OAAO3gB,KAAK9hB,MAAQuoC,EAAIrwC,GAAGwvC,GAAK,OAChFrG,KAAK,oCAIX,OAAO,GAYTzf,MAAQ,SAAS2xB,GACf,IAAIr7C,EAAGoxB,EAAIif,EAAG9Y,EAAIma,EAAIC,EAAIyE,EAAI5zC,EAAG8zC,EAAIG,EAAIE,EAAInS,EAAKC,EAAM6W,EAAO1J,EAAMC,EAAMC,EAAMC,EAAMC,EAAMC,EAAMC,EAAMC,EAAMvC,EAASoH,EAMxH,IALAh3C,EAAI,EACJqwC,EAAI,EAICrwC,EAAIwC,EAAI,EAAGgiC,EAAM18B,MAAQA,MAAQ,GAAK08B,EAAMhiC,EAAIgiC,EAAMhiC,EAAIgiC,EAAMxkC,EAAI,GAAKwkC,IAAQhiC,IAAMA,EAC1FwF,SAAShI,GAAK,EAMhB,IAAKA,EAAIoxB,EAAK,EAAGqT,EAAO38B,MAAQA,MAAQ,GAAK28B,EAAOrT,EAAKqT,EAAOrT,EAAKqT,EAAOzkC,EAAI,GAAKykC,IAASrT,IAAOA,EACnGnpB,SAASjI,GAAK,EAMhB,IAAKA,EAAIu3B,EAAK,EAAGqa,EAAO9pC,MAAQ,GAAK8pC,EAAOra,EAAKqa,EAAOra,EAAKqa,EAAO5xC,EAAI,GAAK4xC,IAASra,IAAOA,EAE3F,IADAvvB,SAASF,MAAQ9H,EAAIA,GAAK+8B,GAAGwN,OAAO3gB,KAAK9hB,MAAQ9H,EAAIA,GAAGwvC,EACnDa,EAAIqB,EAAKG,EAAO7xC,EAAI,EAAG8xC,EAAOhqC,MAAQ+pC,GAAQC,EAAOJ,EAAKI,EAAOJ,EAAKI,EAAOzB,EAAIwB,GAAQC,IAASJ,IAAOA,EAC5G1pC,SAASF,MAAQ9H,EAAIqwC,GAAKtT,GAAGwN,OAAO3gB,KAAK9hB,MAAQ9H,EAAIqwC,GAAGb,EACxDxnC,SAASF,MAAQuoC,EAAIrwC,GAAK+8B,GAAGwN,OAAO3gB,KAAK9hB,MAAQ9H,EAAIqwC,GAAGb,EAI5D,IAAKxvC,EAAI2xC,EAAK,EAAGI,EAAOjqC,MAAQ,GAAKiqC,EAAOJ,EAAKI,EAAOJ,EAAKI,EAAO/xC,EAAI,GAAK+xC,IAASJ,IAAOA,EAE3F,IADA1pC,SAASH,MAAQ9H,EAAIA,GAAK,EACrBqwC,EAAI+F,EAAKpE,EAAOhyC,EAAI,EAAGiyC,EAAOnqC,MAAQkqC,GAAQC,EAAOmE,EAAKnE,EAAOmE,EAAKnE,EAAO5B,EAAI2B,GAAQC,IAASmE,IAAOA,EAC5GnuC,SAASH,MAAQ9H,EAAIqwC,GAAK,EAC1BpoC,SAASH,MAAQuoC,EAAIrwC,GAAK,EAI9B,IAAKA,EAAIs2C,EAAK,EAAGA,EAAK,KACL,IAAXrN,OADqBjpC,IAAMs2C,GASjC,GAJU,MAANt2C,GACFu7C,SAAS,oCAGPF,IAAO1zC,OAAS0zC,IAAOzzC,SAIzB,IAHA5F,KAAK+6B,IACL/X,cACAgY,GAAKoB,MACAp+B,EAAIy2C,EAAK,EAAGvE,EAAOpqC,MAAQ,GAAKoqC,EAAOuE,EAAKvE,EAAOuE,EAAKvE,EAAOlyC,EAAI,GAAKkyC,IAASuE,IAAOA,EAC3F,IAAKpG,EAAIsG,EAAK,EAAGxE,EAAOrqC,MAAQ,GAAKqqC,EAAOwE,EAAKxE,EAAOwE,EAAKxE,EAAO9B,EAAI,GAAK8B,IAASwE,IAAOA,EAC3F5T,YAAY/6B,SAASF,MAAQ9H,EAAIqwC,IACjCrT,GAAGuN,OAAO3gB,KAAK9hB,MAAQ9H,EAAIqwC,GAAKjS,MAKtC,GAAIid,IAAO1zC,OAAS0zC,IAAOxzC,SAAU,CAKnC,IAJA7F,KAAK+6B,IACL/X,cACAiY,GAAKmB,MACLwR,EAAU,GACL5vC,EAAIg3C,EAAK,EAAGsE,EAAQxzC,MAAQ,GAAKwzC,EAAQtE,EAAKsE,EAAQtE,EAAKsE,EAAQt7C,EAAI,GAAKs7C,IAAUtE,IAAOA,EAChGpH,EAAQ5tC,KAAM,WACZ,IAAIw5C,EAAOC,EAAUvE,EAErB,IADAuE,EAAW,GACNpL,EAAI6G,EAAK,EAAGsE,EAAQ1zC,MAAQ,GAAK0zC,EAAQtE,EAAKsE,EAAQtE,EAAKsE,EAAQnL,EAAI,GAAKmL,IAAUtE,IAAOA,EAChGnU,YAAY96B,SAASH,MAAQ9H,EAAIqwC,IACjCoL,EAASz5C,KAAKi7B,GAAGsN,OAAO3gB,KAAK9hB,MAAQ9H,EAAIqwC,GAAKjS,OAEhD,OAAOqd,EAPK,IAUhB,OAAO7L,IA0MX3G,KAAO,WACL,IAAI7jB,EAAOplB,EAAGoxB,EAAIif,EAAG7tC,EAAGgiC,EAAKC,EAAMmN,EAKnC,IAJA5xC,EAAI,EACJqwC,EAAI,EACJjrB,EAAQ,EAEHplB,EAAIwC,EAAI,EAAGgiC,EAAM18B,MAAQ,EAAI,GAAK08B,EAAMhiC,EAAIgiC,EAAMhiC,EAAIgiC,EAAMxkC,EAAI,GAAKwkC,IAAQhiC,IAAMA,EACtF,IAAK6tC,EAAIjf,EAAKqT,EAAOzkC,EAAI,EAAG4xC,EAAO9pC,MAAQ28B,GAAQmN,EAAOxgB,EAAKwgB,EAAOxgB,EAAKwgB,EAAOvB,EAAI5L,GAAQmN,IAASxgB,IAAOA,EAC5E,IAA5BppB,SAASF,MAAQ9H,EAAIqwC,KACvBnH,MAAMlpC,EAAGqwC,GACTjrB,KAIN,OAAOA,GAGT8jB,MAAQ,SAASwH,EAAGrB,GAClB,IAAI8F,EAAGuG,EAAItqB,EAAImG,EAAIkY,EAAGjtC,EAAGgiC,EAAKC,EAAMmN,EAAMH,EAAGkK,EAAInK,EAAG4J,EAqBpD,IApBA3L,EAAI,EACJ+B,EAAI,EACI,EACJ,EACJkK,EAAK,EACD,EACJC,EAAK,EAILP,EAAQ,IAAOpzC,SAASF,MAAQ4oC,EAAIA,GAAK1oC,SAASF,MAAQunC,EAAIA,IAAMrnC,SAASF,MAAQ4oC,EAAIrB,GACzFmC,EAAI,GAAOjB,KAAK/zB,IAAI4+B,GAAS7K,KAAKC,KAAK4K,EAAQA,EAAQ,IACnDA,EAAQ,IACV5J,GAAKA,GAGPC,EAAID,GADJ2D,EAAI,EAAM5E,KAAKC,KAAKgB,EAAIA,EAAI,IAKvB/B,EAAIjtC,EAAI,EAAGgiC,EAAM18B,MAAQ,GAAK08B,EAAMhiC,EAAIgiC,EAAMhiC,EAAIgiC,EAAMiL,EAAI,GAAKjL,IAAQhiC,IAAMA,EAClFk5C,EAAK1zC,SAASF,MAAQ4oC,EAAIjB,GAC1BkM,EAAK3zC,SAASF,MAAQunC,EAAII,GAC1BznC,SAASF,MAAQ4oC,EAAIjB,GAAK0F,EAAIuG,EAAKjK,EAAIkK,EACvC3zC,SAASF,MAAQunC,EAAII,GAAK0F,EAAIwG,EAAKlK,EAAIiK,EAKzC,IAAKjM,EAAIre,EAAK,EAAGqT,EAAO38B,MAAQ,GAAK28B,EAAOrT,EAAKqT,EAAOrT,EAAKqT,EAAOgL,EAAI,GAAKhL,IAASrT,IAAOA,EAC3FsqB,EAAK1zC,SAASF,MAAQ2nC,EAAIiB,GAC1BiL,EAAK3zC,SAASF,MAAQ2nC,EAAIJ,GAC1BrnC,SAASF,MAAQ2nC,EAAIiB,GAAKyE,EAAIuG,EAAKjK,EAAIkK,EACvC3zC,SAASF,MAAQ2nC,EAAIJ,GAAK8F,EAAIwG,EAAKlK,EAAIiK,EAKzC,IAAKjM,EAAIlY,EAAK,EAAGqa,EAAO9pC,MAAQ,GAAK8pC,EAAOra,EAAKqa,EAAOra,EAAKqa,EAAOnC,EAAI,GAAKmC,IAASra,IAAOA,EAC3FmkB,EAAKzzC,SAASH,MAAQ4oC,EAAIjB,GAC1BkM,EAAK1zC,SAASH,MAAQunC,EAAII,GAC1BxnC,SAASH,MAAQ4oC,EAAIjB,GAAK0F,EAAIuG,EAAKjK,EAAIkK,EACvC1zC,SAASH,MAAQunC,EAAII,GAAK0F,EAAIwG,EAAKlK,EAAIiK,EAGzC,OADA1zC,SAASF,MAAQ4oC,EAAIrB,GAAK,EACnBrnC,SAASF,MAAQunC,EAAIqB,GAAK,GAGnCjlC,SAAW,WAGT,OAFAzJ,KAAKuf,KAAKwb,KACVt0B,OACOgkC,QAGTA,KAAO,WAGL,OAFAnH,OACAmI,QACO5I,WAGT4I,MAAQ,WACN,IAAI+B,EAGJ,GAFAA,EAAI,EACJzS,GAAKqB,MACDrK,SAASgJ,IAGX,OAFAyS,EAAI,EAAMjkB,KAAKwR,GAAGyS,QAClBzM,YAAYyM,GAGd,GAAI1c,mBAAmBiK,IACrB/6B,KAAK6sC,UADP,CAIA,GAAIvZ,eAAeyH,IAMjB,OALAsG,YAAYn7B,KACZlG,KAAK+6B,IACLhC,SACA9C,KAAK,QACL8C,SAGFsI,YAAYn7B,KACZlG,KAAK+6B,IACL9E,KAAK,KAYPvsB,UAAY,WAGV,OAFA1J,KAAKuf,KAAKwb,KACVt0B,OACOikC,SAGTA,MAAQ,WAGN,OAFApH,OACAoI,SACO7I,WAGT6I,OAAS,WACP,IAAI8B,EAGJ,GAFAA,EAAI,EACJzS,GAAKqB,MACDrK,SAASgJ,IAGX,OAFAyS,EAAIjkB,KAAKwR,GAAGyS,QACZzM,YAAYyM,GAGV1c,mBAAmBiK,IACrB/6B,KAAKu6B,MAGP8G,YAAYl7B,MACZnG,KAAK+6B,IACL9E,KAAK,KAIP1M,KAAO,SAASklB,GACd,IAAImL,EAAKpK,EAAGyG,EACZ,OAAU,IAANxH,EACK,GAEL,EACA,EACE,EAGNmL,GADApK,EAAI,GAAO,EAAM,IADjByG,EAAI1H,KAAK/zB,IAAIi0B,MAEHF,KAAKsL,KAAK5D,EAAIA,EAAI,WAAazG,GAAK,WAAaA,GAAK,UAAaA,GAAK,UAAaA,GAAmBA,GAAK,UAAaA,GAAmBA,GAAK,WAAaA,GAAuB,UAAJA,EAAb,YAArC,aAArC,eACjGf,GAAK,EACAmL,EAEA,EAAMA,IASjBnzC,KAAO,WACL,IAAIqzC,EAWJ,OAVAr5B,iBACA6iB,OACAvI,GAAKqB,OAIA1S,oBAAsByI,YAAW4I,MACpC+e,GAAuB,EACvBpwB,sBAEMqR,GAAG0S,GACT,KAAK/pC,KACH6E,YACA,MACF,KAAK8K,IACCqW,mBACFqX,YAAYhe,2BAA2BgY,KAEvC/6B,KAAK+6B,IAEP,MACF,KAAKz1B,OACL,KAAK8Q,IACHpW,KAAK+6B,IACL,MACF,KAAKljB,OACHpJ,cACA,MACF,KAAK8H,IACHnI,WACA,MACF,QACE+4B,KAAK,SAKT,OAHI2S,GACFpwB,qBAEKmZ,WAGTz0B,SAAW,WACT,IAAI2rC,EAAa/7C,EAAGwC,EAAGw5C,EAAuCxX,EAAKC,EAUnE,GAAI3P,UAAUiI,IAKZ,OAJA/6B,KAAK+6B,IACL/6B,KAAK2nC,OAAO72B,OACZmlB,KAAK,QACLxvB,OAEK,GAAIs0B,KAAO4M,OAAO9zB,KAAO6V,mBAC9BqX,YAAYwN,KAAK16B,SAgBnB,GAZAmnB,GAAKlN,YAAYiN,IACbh3B,OACFirC,QAAQE,IAAI,cAAgBnU,GAAK,oBAAsBC,IAEzDh7B,KAAKg7B,IAQDD,KAAOC,GAAI,CAOb,IAA+C,KAD/Cgf,EAAwC35B,6CAA6Cy3B,QAAQ/c,KAC3C,CAEhD,IADAgf,EAAc,GACT/7C,EAAIwC,EAAIgiC,EAAMwX,EAAuCvX,EAAOpiB,6CAA6CtiB,OAASykC,GAAOC,EAAOjiC,EAAIiiC,EAAOjiC,EAAIiiC,EAAOzkC,EAAIwkC,GAAOC,IAASjiC,IAAMA,EACnLu5C,GAAe15B,6CAA6CriB,GAAGsvC,UAAY,OAI7E,OAFAyM,GAAehf,GAAGuS,eAClBnG,KAAK,oCAAsC4S,GAK7C,OAFA15B,6CAA6CrgB,KAAK+6B,IAClDt0B,OACO4Z,6CAA6C+b,QAIxD7zB,UAAY,WACV,IAAI0xC,EAWJ,GAVAA,EAAYx6B,IAAIsb,IAUZtb,IAAIw6B,KAAetS,OAAOvhC,MAO9B,OAHK2uB,SAASklB,IACZ9S,KAAK,SAECe,OAAO+R,IACb,KAAK/4C,IACH,OAAOyF,WACT,KAAKxF,IACH,OAAOyF,WACT,KAAKxF,IACH,OAAOyF,WACT,KAAKxF,IACH,OAAOyF,WACT,KAAKvF,OACH,OAAOyF,cACT,KAAKxF,QACH,OAAOyF,eACT,KAAKxF,OACH,OAAOyF,cACT,KAAKxF,QACH,OAAOyF,eACT,KAAKxF,OACH,OAAOyF,cACT,KAAKxF,QACH,OAAOyF,eACT,KAAKxF,IACH,OAAOyF,WACT,KAAKvF,QACH,OAAOm4C,eACT,KAAKh4C,QACH,OAAOqF,eACT,KAAKpF,QACH,OAAOqF,eACT,KAAKpF,QACH,OAAOqF,eACT,KAAKpF,SACH,OAAOqF,gBACT,KAAK5E,QACH,OAAO6E,eACT,KAAK5E,MACH,OAAO6E,aACT,KAAK5E,OACH,OAAO6E,cACT,KAAK5E,QACH,OAAO6E,eACT,KAAK5E,MACH,OAAO6E,aACT,KAAK5E,SACH,OAAO6E,gBACT,KAAK5E,cACH,OAAO6E,qBACT,KAAK5E,MACH,OAAO6E,aACT,KAAK5E,MACH,OAAO6E,aACT,KAAK5E,SACH,OAAO6E,gBACT,KAAK5E,SACH,OAAO6E,gBACT,KAAK5E,KACH,OAAO6E,YACT,KAAK3E,SACH,OAAO6E,gBACT,KAAK5E,IACH,OAAO6E,WACT,KAAK5E,KACH,OAAO6E,YACT,KAAKhE,OACH,OAAOiE,cACT,KAAK/D,OACH,OAAOiE,cACT,KAAKlE,OACH,OAAOiE,cACT,KAAK/D,YACH,OAAOiE,mBACT,KAAKhE,WACH,OAAOiE,kBACT,KAAKhE,IACH,OAAOiE,WACT,KAAK/D,IACH,OAAOgE,WACT,KAAK/D,MACH,OAAOgE,aACT,KAAK/D,SACH,OAAOgE,gBACT,KAAK/D,GACH,OAAOgE,UACT,KAAK/D,IACH,OAAOwF,cACT,KAAKtF,KACH,OAAO40C,YACT,KAAK10C,OACH,OAAO4D,cACT,KAAK1D,MACH,OAAO2D,aACT,KAAK1D,SACH,OAAO2D,gBACT,KAAK1D,SACH,OAAO2D,gBACT,KAAKtD,IACH,OAAOuD,WACT,KAAKtD,KACH,OAAOuD,YACT,KAAKtD,KACH,OAAOM,YACT,KAAKL,IACH,OAAOsD,WACT,KAAKrD,OACH,OAAOsD,cACT,KAAKrD,OACH,OAAOsD,cACT,KAAKrD,OACH,OAAOsD,cACT,KAAKuF,OACH,OAAOtF,cACT,KAAKuF,UACH,OAAOtF,iBACT,KAAKuF,WACH,OAAOtF,kBACT,KAAKuF,OACH,OAAOtF,cACT,KAAKuF,OACH,OAAOtF,aACT,KAAK7I,YACH,OAAOyF,mBACT,KAAK2I,MACH,OAAOtF,aACT,KAAKuF,IACH,OAAOtF,WAKT,KAAKwF,SACH,OAAOvF,0BACT,KAAKyF,MACH,OAAOxF,aACT,KAAKyF,IACH,OAAOxF,WACT,KAAKyF,QACH,OAAOxF,eACT,KAAKyF,QACH,OAAOxF,eACT,KAAKyF,KACH,OAAOxF,YACT,KAAKyF,MACH,OAAOxF,aACT,KAAKyF,MACH,OAAOxF,cACT,KAAKyF,SACH,OAAOxF,gBACT,KAAKyF,IACH,OAAOxF,WACT,KAAKyF,KACH,OAAOxF,YACT,KAAK2F,UACH,OAAO1F,iBACT,KAAK2F,QACH,OAAO1F,eACT,KAAK2F,SACH,OAAO1F,gBAET,KAAKkG,IACH,OAAOjG,WACT,KAAKkG,QACH,OAAOjG,eACT,KAAKkG,SACH,OAAOjG,gBACT,KAAKkG,IACH,OAAOjG,WACT,KAAKkG,OACH,OAAOjG,cACT,KAAK8G,IACH,OAAO7G,WACT,KAAK+G,SACH,OAAO9G,gBACT,KAAKkH,IACH,OAAOhH,WACT,KAAKiH,OACH,OAAOhH,cACT,KAAKyH,OACH,OAAOxH,cACT,KAAKyH,UACH,OAAOxH,iBACT,KAAKyH,SACH,OAAOxH,gBACT,KAAKyH,GACH,OAAOxH,UACT,KAAKyH,MACH,OAAOxH,aACT,KAAKyH,QACH,OAAOxH,eACT,KAAKyH,aACH,OAAOxH,oBACT,KAAK0H,MACH,OAAOzH,aACT,KAAK0H,MACH,OAAOzH,aACT,KAAK0H,MACH,OAAOxH,aACT,KAAKyH,MACH,OAAOxH,aACT,KAAKyH,aACH,OAAOxH,oBACT,KAAKyH,UACH,OAAOxH,qBACT,KAAKyH,WACH,OAAOvH,kBACT,KAAKwH,UACH,OAAOvH,iBACT,KAAK8H,WACH,OAAOhI,kBACT,KAAKmI,QACH,OAAOhI,eACT,KAAKiI,MACH,OAAOhI,aACT,KAAKiI,SACH,OAAOhI,gBACT,KAAKiI,KACH,OAAOhI,YACT,KAAKiI,YACH,OAAOhI,mBACT,KAAKiI,KACH,OAAOhI,YACT,KAAKkI,MACH,OAAO/H,aACT,KAAKkM,OACH,OAAOpM,YACT,KAAKgI,MACH,OAAO/H,aACT,KAAKmI,KACH,OAAOjI,YACT,KAAKkI,IACH,OAAOjI,WACT,KAAKmI,cACH,OAAOjI,qBACT,KAAKkI,SACH,OAAOhI,gBACT,KAAKiI,IACH,OAAOhI,WACT,KAAKiI,KACH,OAAOhI,YACT,KAAK4H,MACH,OAAOjI,aACT,KAAKwI,KACH,OAAOlI,YACT,KAAKmI,KACH,OAAOlI,YACT,KAAKoI,MACH,OAAOnI,aACT,KAAKoI,IACH,OAAOnI,WACT,KAAKqI,YACH,OAAOnI,mBACT,KAAKqJ,IACH,OAAOpJ,WACT,KAAKqJ,KACH,OAAOpJ,YACT,KAAKqJ,OACH,OAAOpJ,cACT,KAAKsJ,KACH,OAAOpJ,YACT,KAAKqJ,OACH,OAAOpJ,cACT,KAAKqJ,OACH,OAAOpJ,cACT,KAAKqJ,OACH,OAAOpJ,cACT,KAAKqJ,OACH,OAAOpJ,cACT,KAAKqJ,OACH,OAAOpJ,cACT,KAAKwJ,UACH,OAAOvJ,iBACT,KAAKoK,KACH,OAAOnK,YACT,KAAKyK,KACH,OAAOvK,YACT,QACE,OAAOD,0BAzRTA,sBA6RJzH,aAAe,WACb,OAAOzH,KAAK8tB,YAAYvO,KAAKwb,OAG/BnzB,WAAa,WACX,IAAIwyC,EAGJ,OAAmB,OADnBA,EAAcrpB,sCAAsCxR,KAAKwb,MAIhD/6B,KAAK+6B,IAGLoG,aAAaiZ,IAIxBpxC,SAAW,WAGT,OAFAhJ,KAAKuf,KAAKwb,KACVt0B,OACOgf,OAGTxc,SAAW,WACT,IAAIvI,EAYJ,OAVAV,KAAKuf,KAAKwb,KACVt0B,OACAu0B,GAAKoB,MACDxK,OAAO1R,KAAK6a,MACd/6B,KAAKsf,MAAMyb,KACXt0B,OACA/F,EAAI67B,eAEJ77B,EAAI,EAEDu0B,SAAS+F,IAEHt6B,EAAI,GAAKA,EAAIs6B,GAAGuN,OAAOsF,KACzB7tC,KAAK+6B,IAELoG,aAAanG,GAAGuN,OAAOoF,IAAIjtC,EAAI,IAJ/BygC,aAAa,IAQxBh4B,cAAgB,WAGd,OAFAnJ,KAAKuf,KAAKwb,KACVt0B,OACO2f,YAGThd,QAAU,WACR,IAAIwkC,EAIJ,IAHA5tC,KAAKyf,IAAIsb,KACTA,GAAK5a,IAAI4a,IACT6S,EAAU,GACHhc,OAAOmJ,KACZqB,MACAp8B,KAAKyf,IAAIsb,KACTt0B,OACAmnC,EAAQ5tC,KAAK+6B,GAAK5a,IAAI4a,KAExB,OAAO6S,GAGTvkC,YAAc,WAOZ,OANArJ,KAAKuf,KAAKwb,KACVt0B,OACAzG,KAAKsf,MAAMyb,KACXt0B,OACAzG,KAAKqf,OAAO0b,KACZt0B,OACO4zC,UAIT3zC,UAAY,WAIV,IAHA1G,KAAKuf,KAAKwb,KACVt0B,OACAs0B,GAAK7a,KAAK6a,IACHnJ,OAAOmJ,KACZ/6B,KAAKyf,IAAIsb,KACTt0B,OACAzG,KAAKuf,KAAKwb,KACVt0B,OACA8gC,SACAxM,GAAK7a,KAAK6a,IAEZ,OAAOt0B,QAKTkD,SAAW,WAGT,OAFA3J,KAAKuf,KAAKwb,KACVt0B,OACO6jB,eAGTtgB,eAAiB,WAGf,OAFAhK,KAAKuf,KAAKwb,KACVt0B,OACO+kB,aAGTvhB,gBAAkB,WAChB,IAAI2jC,EAUJ,IATA7S,GAAK5a,IAAI4a,IACT/6B,KAAKyf,IAAIsb,KACTt0B,OACAs0B,GAAK5a,IAAI4a,IACT/6B,KAAKyf,IAAIsb,KACTt0B,OACAglB,aACAsP,GAAK5a,IAAI4a,IACT6S,EAAU,GACHhc,OAAOmJ,KACZ/6B,KAAKyf,IAAIsb,KACTt0B,OACAglB,aACAmiB,EAAQ5tC,KAAK+6B,GAAK5a,IAAI4a,KAExB,OAAO6S,GAGTnjC,aAAe,WAKb,OAJAzK,KAAKuf,KAAKwb,KACVt0B,OACAzG,KAAKsf,MAAMyb,KACXt0B,OACOyoB,WAGTxkB,aAAe,WAGb,OAFA1K,KAAKuf,KAAKwb,KACVt0B,OACO0oB,WAGTvkB,WAAa,WACX,IAAImjC,EAAGuM,EAAMC,EAab,GAZAxM,EAAI5E,IACJmR,EAAOvf,GAIPA,GAAK5a,IAAI4a,IACT/6B,KAAKyf,IAAIsb,KACTt0B,OACA8zC,EAAYzT,MAAMqC,IAAM,GACpB5Y,cAAcgqB,IAChBpT,KAAK,0CAEFlS,SAASslB,GAKZ,OAFA9iB,QAAQsW,QACR/tC,KAAKs6C,GAOP,IADAvf,GAAK5a,IAAI4a,IACFnJ,OAAOmJ,KAAK,CAGjB,GAFA/6B,KAAKyf,IAAIsb,KACTt0B,QACKmsB,wBAAwBkU,MAAMqC,IAAM,IAKvC,OAFA1R,QAAQsW,QACR/tC,KAAKs6C,GAGPvf,GAAK5a,IAAI4a,IAEX,OAAOxL,eAAe4Z,IAAM4E,IAG9BhjC,SAAW,WAGT,OAFA/K,KAAKuf,KAAKwb,KACVt0B,OACOypB,QAGTllB,UAAY,WAGV,OAFAhL,KAAKuf,KAAKwb,KACVt0B,OACO4pB,QAGTplB,eAAiB,WAKf,GAHAjL,KAAKuf,KAAKwb,KACVt0B,OACAs0B,GAAKqB,MACD1H,WAAWqG,IACTrI,UAAUqI,IACZ/6B,KAAKu6B,KAELv6B,KAAK6sC,UAJT,CAQA,IAAI9a,SAASgJ,IAWb,OAFAsG,YAAY1wB,WACZ3Q,KAAK+6B,IACE9E,KAAK,GAVNsY,KAAK+C,MAAMvW,GAAGyS,KACRzS,GAAGyS,EACXxtC,KAAKu6B,KAELv6B,KAAK6sC,QASX/gC,YAAc,WAIZ,OAHA9L,KAAKuf,KAAKwb,KACVt0B,QACAs0B,GAAKqB,OACEqR,IAAMp6B,KAAO0nB,GAAG0S,IAAMnoC,OACpB67B,aAAa,GAEbA,aAAa,IAIxBn1B,cAAgB,WACd,IAAI+hC,EAIJ,IAHAA,EAAI5E,IACJ9H,YAAY7tB,UACZunB,GAAK5a,IAAI4a,IACFnJ,OAAOmJ,KACZ/6B,KAAKyf,IAAIsb,KACTt0B,OACAs0B,GAAK5a,IAAI4a,IAEX,OAAO9E,KAAKkT,IAAM4E,IAIpB/gC,WAAa,WACX,OAAOhN,KAAKuf,KAAKwb,MAInB7tB,UAAY,WAIV,OAHAlN,KAAKuf,KAAKwb,KACVt0B,OACAs0B,GAAKqB,MACDnH,SAAS8F,IACJoG,aAAapG,GAAGwN,OAAOsF,MAEvB7tC,KAAK6sC,OAqBhBr/B,UAAY,WAEV,GAAIoR,MAAMmc,MAAQ4M,OAAOv3B,OAAzB,CAKA,IAAIwhB,OAAOrS,KAAKwb,KAgBhB,OAZKhG,SAASxV,KAAKwb,MACjBoM,KAAK,sCAEPnnC,KAAKsf,MAAMyb,KACXt0B,OACAu0B,GAAKoB,MACL0I,YAAYvlB,KAAKwb,IAAKC,IAMfh7B,KAAK2nC,OAAOh1B,MAfjBqS,4BALAggB,gBA6CJA,aAAe,WACb,IAAI+I,EAoBJ,IAnBA7S,GAAKnc,OAAOgc,IACPhG,SAASmG,KAYZiM,KAAK,8CAEP4G,EAAI5E,IACJnpC,KAAKsf,MAAMyb,KACXt0B,OACAu0B,GAAKrb,MAAMob,IACJnJ,OAAOoJ,KACZh7B,KAAKyf,IAAIub,KACTv0B,OACAu0B,GAAK7a,IAAI6a,IAKX,OAHA+J,cAAcoE,IAAM4E,GACpB9S,GAAKmB,MACL0I,YAAY5J,GAAID,IACTj7B,KAAK2nC,OAAOh1B,OAGrB3E,UAAY,WAIV,OAHAhO,KAAKuf,KAAKwb,KACVt0B,OACA26B,cAAc,EAAG,GACV5E,SAGTvuB,UAAY,WACV,OAAOk5B,KAAK,cAGdj5B,WAAa,WAQX,OAPAlO,KAAKqf,OAAO0b,KACZt0B,OACAzG,KAAKsf,MAAMyb,KACXt0B,OACAzG,KAAKuf,KAAKwb,KACVt0B,OACA8gC,SACO9gC,QAOTwI,UAAY,WACV,IAAIjR,EAAG0C,EAAGF,EAAGgiC,EAMb,GALAxkC,EAAI,EACA,EACJgC,KAAKuf,KAAKwb,KACVt0B,OACA/F,EAAI67B,cACA8U,MAAM3wC,GACRV,KAAK+6B,QADP,CAIA,KAAIr6B,EAAI,GAAR,CAQA,KAJAq6B,GAAK1f,aAAa3a,EAAIA,IACnB6nC,OAAOsF,KAAO,EACjB9S,GAAGwN,OAAOoF,IAAI,GAAKjtC,EACnBq6B,GAAGwN,OAAOoF,IAAI,GAAKjtC,EACd1C,EAAIwC,EAAI,EAAGgiC,EAAM9hC,EAAI,GAAK8hC,EAAMhiC,EAAIgiC,EAAMhiC,EAAIgiC,EAAMxkC,EAAI,GAAKwkC,IAAQhiC,IAAMA,EAC9Eu6B,GAAGwN,OAAO3gB,KAAKlnB,EAAI1C,EAAIA,GAAKu8B,IAG9B,OADA5Z,wBAAwBoa,IACjB/6B,KAAK+6B,IAXV/6B,KAAK+6B,MAcTpvB,cAAgB,WACd,IAAI2sC,EAIJ,OAHAA,EAAiBluB,UACjBA,UAAY,EACZ3jB,OACO2jB,UAAYkuB,GAiBrB/rC,eAAiB,WAaf,OAZA+2B,OACAvI,GAAKkO,MACDxpB,IAAIsb,MAAQ4M,OAAOlyB,QAGrB2mB,MACAiF,YAAYtpB,QACZ/X,KAAKuf,KAAKwb,KACV/6B,KAAKsf,MAAMyb,KACX9E,KAAK,IAEPxvB,OACOo8B,WAaTj5B,YAAc,WAaZ,OAXA5J,KAAKuf,KAAKwb,KACVt0B,OAEAzG,KAAKsf,MAAMyb,KACXt0B,QACAu0B,GAAKoB,SACMuL,OAAOh1B,KAChB8b,QAEAzuB,KAAKg7B,IAEAnR,WAWTA,QAAS,WACP,IAAIyuB,EAIJ,GAHAhV,OACA/H,GAAKa,MACLjB,GAAKiB,MACDnH,SAASkG,IAGX,OAFAhR,qBACA0Y,UAIF,GAAIpjB,IAAI0b,MAAQwM,OAAOxmC,KA6BvB,OAfAnB,KAAKm7B,IACLd,aACAY,GAAKmB,MAELp8B,KAAKm7B,IACL/V,eACA4V,GAAKoB,MACLuG,4BAEA3iC,KAAKi7B,IACLj7B,KAAKg7B,IACLh7B,KAAKu7B,KAID9H,MAAMwH,MAAOxH,MAAMuH,KAChBjH,mBAAmBiH,GAAIO,MAAO9H,MAAMuH,KAU3C1U,UACA+U,GAAKe,MAELp8B,KAAKi7B,IACLj7B,KAAKg7B,IACLh7B,KAAKq7B,IACLhD,WACAmP,WACAvM,GAAKmB,MAEDtL,mBAAmBmK,KACrBj7B,KAAKq7B,SACLwH,YAMF7iC,KAAKg7B,IACLh7B,KAAKu7B,IACL9P,aACAuP,GAAKoB,MAELnS,eACAD,eACAF,eACImL,SAASiG,KACXl7B,KAAKk7B,IACLod,EAAiBluB,UACjBA,UAAY,EACZ8F,OACA9F,UAAYkuB,EACZt4C,KAAKi7B,IACLtL,SACA3vB,KAAKg7B,IACLrL,WAEA3vB,KAAKi7B,IACLj7B,KAAKk7B,IACLod,EAAiBluB,UACjBA,UAAY,EACZlE,SACAkE,UAAYkuB,EACZt4C,KAAKg7B,IACL3C,YAEFr4B,KAAKq7B,IACLzgB,MACOioB,aAzDHzG,MACAA,MACAA,MACAp8B,KAAKm7B,SAEL0H,WAjCF,IAFA1B,aAAa,GACbpG,GAAK5a,IAAIgb,IACFvJ,OAAOmJ,KACZ/6B,KAAKyf,IAAIsb,KACT/6B,KAAKu7B,IACL1R,UACAjP,MACAmgB,GAAK5a,IAAI4a,IAEX8H,WAiFJ1Y,cAAgB,WACd,IAAInsB,EAAGwC,EAAGgiC,EAKV,IAJAxkC,EAAI,EACJgC,KAAKm7B,IACLnY,cAEKhlB,EAAIwC,EAAI,EAAGgiC,GADhBrH,GAAKiB,OACoBmM,OAAOuF,MAAQ,GAAKtL,EAAMhiC,EAAIgiC,EAAMhiC,EAAIgiC,EAAMxkC,EAAI,GAAKwkC,IAAQhiC,IAAMA,EAC5FR,KAAKm7B,GAAGoN,OAAO3gB,KAAK5pB,IACpBgC,KAAKu7B,IACL1R,UACAsR,GAAGoN,OAAO3gB,KAAK5pB,GAAKo+B,MAEtB,OAAOp8B,KAAKm7B,KAGdwH,0BAA4B,WAC1B,IAAIoL,EAAG/vC,EAAGqwC,EAAGZ,EAAMjtC,EAAGgiC,EAYtB,IAXI,EACJxkC,EAAI,EACJqwC,EAAI,EACJZ,EAAI,EACA,EACJM,EAAI5E,IACJzd,QAAQsP,IACRtP,QAAQuP,IAGRoT,EAAI,EACCrwC,EAAIwC,EAAI,EAAGgiC,EAHZ2G,IAAM4E,EAGgB,GAAKvL,EAAMhiC,EAAIgiC,EAAMhiC,EAAIgiC,EAAMxkC,EAAI,GAAKwkC,IAAQhiC,IAAMA,EAC9Eu6B,GAAK+L,MAAMiH,EAAI/vC,GACXyhB,IAAIsb,MAAQ4M,OAAO5zB,QAGnBwL,KAAKwb,MAAQQ,KAGjBv7B,KAAKsf,MAAMyb,KACX0S,EAAIlR,cACA8U,MAAM5D,IAGNA,EAAIY,IACNA,EAAIZ,IAIR,GADAhW,QAAQsW,GACE,IAANM,EAgBJ,OAZAruC,KAAKg7B,IACLh7B,KAAKu7B,IACL4F,cAAckN,GACd7R,QACAnE,WACA2C,GAAKoB,MAELp8B,KAAKi7B,IACLj7B,KAAKu7B,IACL4F,cAAckN,GACd7R,QACAnE,WACO4C,GAAKmB,OA0DdnS,aAAe,WACb,IAAIijB,EAAGa,EAAG/vC,EAAGoxB,EAAIif,EAAG3tC,EAAGF,EAAG83C,EAAgB9V,EAAKC,EAO/C,GANI,EACJzkC,EAAI,EACJqwC,EAAI,EACA,EAEJN,EAAI5E,IACA1pB,IAAIub,MAAQ2M,OAAOn1B,UAErB,IADAuoB,GAAK5a,IAAI6a,IACFpJ,OAAOmJ,KACZI,GAAK1b,IAAIsb,IACT7Q,gBACA6Q,GAAK5a,IAAI4a,SAGXI,GAAKH,GACL9Q,gBAGF,GAAU,KADVxpB,EAAIyoC,IAAM4E,GACV,CASA,KALA7S,GAAK7f,aAAa3a,EAAIA,IACnB6nC,OAAOsF,KAAO,EACjB3S,GAAGqN,OAAOoF,IAAI,GAAKjtC,EACnBw6B,GAAGqN,OAAOoF,IAAI,GAAKjtC,EACnBwsC,EAAIa,EACC/vC,EAAIwC,EAAI,EAAGgiC,EAAM9hC,EAAI,GAAK8hC,EAAMhiC,EAAIgiC,EAAMhiC,EAAIgiC,EAAMxkC,EAAI,GAAKwkC,IAAQhiC,IAAMA,EAC9E,IAAK6tC,EAAIjf,EAAK,EAAGqT,EAAO/hC,EAAI,GAAK+hC,EAAOrT,EAAKqT,EAAOrT,EAAKqT,EAAO4L,EAAI,GAAK5L,IAASrT,IAAOA,EACvFpvB,KAAK8mC,MAAMoG,EAAImB,IACfruC,KAAKu7B,IACL4F,aAAanjC,GACbw+B,QACA8b,EAAiBluB,UACjBA,UAAY,EACZlE,SACAkE,UAAYkuB,EACZt4C,KAAKu7B,IACL3P,SACAsP,GAAGqN,OAAO3gB,KAAKlnB,EAAI1C,EAAIqwC,GAAKjS,MAGhC,OAAO3E,QAAQ0R,IAAMzoC,GAvBnBw6B,GAAKkB,OA0FTlS,cAAgB,WACd,IAAIsjB,EAAGxvC,EAAGqwC,EAAG3tC,EAAGF,EAAG83C,EAAgB9V,EAAKoL,EAKxC,GAJI,EACJ5vC,EAAI,EACJqwC,EAAI,EACJ3tC,EAAI,EACCoP,MAAKqrB,GAAII,IAAd,CAoBA,IAjBA+c,EAAiBluB,UACjBA,UAAY,EACZof,iBACApf,UAAYkuB,EACR74B,IAAI0b,MAAQwM,OAAO5zB,QACrB/T,KAAKsf,MAAM6b,KACXz6B,EAAI67B,cACJnB,GAAK7b,KAAK4b,MAEVz6B,EAAI,EACJ06B,GAAKD,IAEPn7B,KAAKo7B,IACLp7B,KAAKu7B,IACLpW,SACAqoB,EAAIjR,cACJqR,EAAU,GACL5vC,EAAIwC,EAAI,EAAGgiC,EAAM9hC,EAAI,GAAK8hC,EAAMhiC,EAAIgiC,EAAMhiC,EAAIgiC,EAAMxkC,EAAI,GAAKwkC,IAAQhiC,IAAMA,EAC9EotC,EAAQ5tC,KAAM,WACZ,IAAIovB,EAAIqT,EAAMgX,EAEd,IADAA,EAAW,GACNpL,EAAIjf,EAAK,EAAGqT,EAAO+K,EAAI,GAAK/K,EAAOrT,EAAKqT,EAAOrT,EAAKqT,EAAO4L,EAAI,GAAK5L,IAASrT,IAAOA,EACvFpvB,KAAKs7B,IACLt7B,KAAKo7B,IACL+F,aAAanjC,GACbw+B,QACA8b,EAAiBluB,UACjBA,UAAY,EACZiO,WACAjO,UAAYkuB,EACZt4C,KAAKu7B,IACL4F,aAAakN,GACb7R,QACA8b,EAAiBluB,UACjBA,UAAY,EACZiO,WACAohB,EAASz5C,KAAKoqB,UAAYkuB,GAE5B,OAAOmB,EApBK,IAuBhB,OAAO7L,IAITpE,eAAiB,WACf,IAAIuE,EAEJ,GADAA,EAAI,EACAtuB,IAAIub,MAAQ2M,OAAOn1B,UAAW,CAGhC,IAFAu7B,EAAI5E,IACJrO,GAAK3a,IAAI6a,IACFpJ,OAAOkJ,KACP1R,MAAM3J,IAAIqb,IAAKK,MAClBn7B,KAAKyf,IAAIqb,KACTr0B,QAEFq0B,GAAK3a,IAAI2a,IAEXxC,aAAa6Q,IAAM4E,QAEnB5M,aAAa,GAEf,OAAO7F,GAAKc,OAIdpS,aAAe,WACb,IAAIhsB,EAAG0C,EAAGF,EAAG83C,EAAgB9V,EAG7B,GAFAxkC,EAAI,EACA,EACCi3B,SAASiG,IAAd,CAOA,IAJAx6B,EAAIw6B,GAAGqN,OAAOoF,IAAI,IAClBrS,GAAKjgB,aAAa3a,IACf6nC,OAAOsF,KAAO,EACjBvS,GAAGiN,OAAOoF,IAAI,GAAKjtC,EACd1C,EAAIwC,EAAI,EAAGgiC,EAAM9hC,EAAI,GAAK8hC,EAAMhiC,EAAIgiC,EAAMhiC,EAAIgiC,EAAMxkC,EAAI,GAAKwkC,IAAQhiC,IAAMA,EAC9ER,KAAKi7B,IACLj7B,KAAKu7B,IACL4F,aAAanjC,GACbw+B,QACA8b,EAAiBluB,UACjBA,UAAY,EACZlE,SACAkE,UAAYkuB,EACZt4C,KAAKu7B,IACL3P,SACA0P,GAAGiN,OAAO3gB,KAAK5pB,GAAKo+B,MAEtB,OAAOnB,GAAKK,KAIdxR,aAAe,WACb,IAAIikB,EAAG/vC,EAAG0C,EAAGF,EAAGgiC,EAIhB,GAHI,EACJxkC,EAAI,EACA,GACCi3B,SAASiG,IAIZ,OAHAl7B,KAAKg7B,IACLoH,mBACApH,GAAKoB,OAIP,GADA2R,EAAI5E,IACA1pB,IAAIub,MAAQ2M,OAAOn1B,UAErB,IADA8oB,GAAKnb,IAAI6a,IACFpJ,OAAO0J,KACZH,GAAK1b,IAAI6b,IACTvR,gBACAuR,GAAKnb,IAAImb,SAGXH,GAAKH,GACLjR,gBAMF,KAHAuR,GAAKjgB,aADL3a,EAAIyoC,IAAM4E,IAEPxF,OAAOsF,KAAO,EACjBvS,GAAGiN,OAAOoF,IAAI,GAAKjtC,EACd1C,EAAIwC,EAAI,EAAGgiC,EAAM9hC,EAAI,GAAK8hC,EAAMhiC,EAAIgiC,EAAMhiC,EAAIgiC,EAAMxkC,EAAI,GAAKwkC,IAAQhiC,IAAMA,EAC9E86B,GAAGiN,OAAO3gB,KAAK5pB,GAAK8oC,MAAMiH,EAAI/vC,GAGhC,OADAy5B,QAAQsW,GACD/S,GAAKM,IAGdvR,cAAgB,WACd,IAAIyjB,EAAGxvC,EAAGqwC,EAAG3tC,EAAGF,EAAGgiC,EAAKoL,EAKxB,GAJI,EACJ5vC,EAAI,EACJqwC,EAAI,EACJ3tC,EAAI,EACCoP,MAAKqrB,GAAII,IAAd,CAaA,IAVI9b,IAAI0b,MAAQwM,OAAO5zB,SACrB/T,KAAKsf,MAAM6b,KACXz6B,EAAI67B,cACJpB,GAAK5b,KAAK4b,KAEZn7B,KAAKm7B,IACLn7B,KAAKu7B,IACLpW,SACAqoB,EAAIjR,cACJqR,EAAU,GACL5vC,EAAIwC,EAAIgiC,EAAM9hC,EAAI8hC,GAAO,EAAIhiC,EAAI,EAAIA,EAAI,EAAIxC,EAAIwkC,GAAO,IAAMhiC,IAAMA,EACvEotC,EAAQ5tC,KAAM,WACZ,IAAIovB,EAAIqT,EAAMgX,EAEd,IADAA,EAAW,GACNpL,EAAIjf,EAAK,EAAGqT,EAAO+K,EAAI,GAAK/K,EAAOrT,EAAKqT,EAAOrT,EAAKqT,EAAO4L,EAAI,GAAK5L,IAASrT,IAAOA,EACvFpvB,KAAKm7B,IACLgG,aAAanjC,GACbw+B,QACA4F,cACApiC,KAAKu7B,IACL4F,aAAakN,GACb7R,QACAid,EAASz5C,KAAKq4B,YAEhB,OAAOohB,EAbK,IAgBhB,OAAO7L,IAIT/jC,YAAc,WAGZ,OAFA7J,KAAKuf,KAAKwb,KACVt0B,OACO4jB,UAGTA,OAAS,WAiBP,OAhBAiZ,OACAvI,GAAKqB,MACLp8B,KAAKsvB,eACLtvB,KAAK+6B,IACL1C,WACA/N,cACA8W,cAAc,EAAG,GACjB/I,WACAr4B,KAAKsvB,eACLyJ,SACA/4B,KAAK+6B,IACL1C,WACA/N,cACA8W,cAAc,EAAG,GACjB/I,WACAzd,MACOioB,WAIT/4B,YAAc,WAGZ,OAFA9J,KAAKuf,KAAKwb,KACVt0B,OACO+jB,UAGTA,OAAS,WAqBP,OApBA8Y,OACAvI,GAAKqB,MACLp8B,KAAKsvB,eACLtvB,KAAK+6B,IACL1C,WACA/N,cACAtqB,KAAKsvB,eACLpJ,SACAkb,cAAc,EAAG,GACjB/I,WACAr4B,KAAKsvB,eACLyJ,SACA/4B,KAAK+6B,IACL1C,WACA/N,cACAtqB,KAAKsvB,eACLpJ,SACAkb,cAAc,EAAG,GACjB/I,WACAmP,WACO3E,WAIT94B,YAAc,WACZ,IAAI6jC,EAeJ,IAdA5tC,KAAKuf,KAAKwb,KACVt0B,OACAzG,KAAKsf,MAAMyb,KACXt0B,QACAu0B,GAAKoB,SACMuL,OAAOh1B,KAChB8b,QAEAzuB,KAAKg7B,IAEP/P,SAEA8P,GAAK9a,MAAM8a,IACX6S,EAAU,GACHhc,OAAOmJ,KACZ/6B,KAAKyf,IAAIsb,KACTt0B,OACA0kB,eACAyiB,EAAQ5tC,KAAK+6B,GAAK5a,IAAI4a,KAExB,OAAO6S,GAGTziB,aAAe,WACb,IAAI4iB,EAAGrtC,EAKP,GAJA4iC,OACAtI,GAAKoB,MACLrB,GAAKqB,MACL2R,EAAI5E,IACA1pB,IAAIsb,MAAQ4M,OAAOn1B,UAErB,IADAuoB,GAAK5a,IAAI4a,IACFnJ,OAAOmJ,KACZ/6B,KAAKyf,IAAIsb,KACT/6B,KAAKg7B,IACLzP,cACAwP,GAAK5a,IAAI4a,SAGX/6B,KAAK+6B,IACL/6B,KAAKg7B,IACLzP,cAMF,OAJA7qB,EAAIyoC,IAAM4E,GACF,GACNxV,sBAAsB73B,GAEjBmiC,WAGTtX,YAAc,WAIZ,GAHA+X,OACA7X,aACAsP,GAAKqB,MACD3c,IAAIsb,MAAQ4M,OAAOn1B,UAErB,IADAuoB,GAAK5a,IAAI4a,IACFnJ,OAAOmJ,KACZ/6B,KAAKyf,IAAIsb,KACTA,GAAK5a,IAAI4a,SAGX/6B,KAAK+6B,IAEP,OAAO8H,WAGT5X,OAAS,WAYP,OAXAqY,OACAtI,GAAKoB,MACLrB,GAAKqB,MACD1J,UAAUqI,KACZ/6B,KAAK+6B,IACL1P,kBAEArrB,KAAK+6B,IACL/6B,KAAKg7B,IACLvP,cAEKoX,WAITvX,oBAAsB,WACpB,IAAIkiB,EAAGqJ,EAAM74C,EAAG0C,EAAGF,EAAGgiC,EAUtB,IATAxkC,EAAI,EACJslC,OACA5iC,EAAI67B,cACA8U,MAAM3wC,IACRymC,KAAK,4BAEHzmC,EAAI,IACNA,GAAKA,GAEF1C,EAAIwC,EAAI,EAAGgiC,EAAM5wB,aAAc,GAAK4wB,EAAMhiC,EAAIgiC,EAAMhiC,EAAIgiC,OAC3DgL,EAAI1Q,SAAS9+B,IACL0C,EAAI8sC,GAFqDxvC,EAAI,GAAKwkC,IAAQhiC,IAAMA,EAAG,CAM3F,IADAq2C,EAAO,EACAn2C,EAAI8sC,IAAM,GACf9sC,GAAK8sC,EACLqJ,IAEEA,IACF1V,aAAaqM,GACbrM,aAAa0V,IAOjB,OAJIn2C,EAAI,IACNygC,aAAazgC,GACbygC,aAAa,IAER0B,WAGTrX,UAAY,WACV,IAAI9qB,EAMJ,OALI,EACJ4iC,OACAvI,GAAKqB,MACLp8B,KAAK+6B,KACLr6B,EAAI67B,eACI,GAAK8U,MAAM3wC,IACjB2gC,YAAY/xB,WACZtP,KAAK+6B,IACL9E,KAAK,QACL4M,YAGF5kB,iBAAiBvd,GACVmiC,YAsBTyD,oBAAqB,WACnB,IAAImI,EAMJ,GALI,EACJnL,OACAmL,EAAIrkB,UACJA,UAAY,EACZ2Q,GAAKqB,MACD3c,IAAIsb,MAAQ4M,OAAOxmC,KAAM,CAG3B,IAFAnB,KAAK6sC,MACL9R,GAAK5a,IAAI4a,IACFnJ,OAAOmJ,KACZ/6B,KAAKyf,IAAIsb,KACTuL,sBACA1rB,MACAmgB,GAAK5a,IAAI4a,IAIX,OAFA3Q,UAAYqkB,OACZ5L,UAGF,OAAIpjB,IAAIsb,MAAQ4M,OAAOn1B,WACrByyB,eACA7a,UAAYqkB,OACZ5L,YAGF7iC,KAAK+6B,IACL3Q,UAAYqkB,EACL5L,YAGToC,aAAe,WACb,IAAIjnC,EAAGoxB,EAAIif,EAAG9Y,EAAI70B,EAAGF,EAAGgiC,EAAKC,EAAMmN,EAAMC,EAAMJ,EAO/C,IANAzxC,EAAI,EACJqwC,EAAI,EACJ3tC,EAAI,EACJ+uC,EAAItG,IACJpO,GAAK5a,IAAI4a,IACTr6B,EAAI,EACGkxB,OAAOmJ,KACZ/6B,KAAKyf,IAAIsb,KACTA,GAAK5a,IAAI4a,IACTr6B,IAEF,IAAK1C,EAAIwC,EAAI,EAAGgiC,EAAM9hC,EAAI,EAAI,GAAK8hC,EAAMhiC,EAAIgiC,EAAMhiC,EAAIgiC,EAAMxkC,EAAI,GAAKwkC,IAAQhiC,IAAMA,EAClF,GAAIsmC,MAAM2I,EAAIzxC,KAAO2pC,OAAOh1B,KAG5B,IAAK07B,EAAIjf,EAAKqT,EAAOzkC,EAAI,EAAG4xC,EAAOlvC,EAAI+hC,GAAQmN,EAAOxgB,EAAKwgB,EAAOxgB,EAAKwgB,EAAOvB,EAAI5L,GAAQmN,IAASxgB,IAAOA,EACpG0X,MAAM2I,EAAIpB,KAAO1G,OAAOh1B,MAG5BuyB,eAAeuK,EAAGzxC,EAAGqwC,GAIzB,IADAruC,KAAKu6B,KACAv8B,EAAIu3B,EAAK,EAAGsa,EAAOnvC,EAAI,GAAKmvC,EAAOta,EAAKsa,EAAOta,EAAKsa,EAAO7xC,EAAI,GAAK6xC,IAASta,IAAOA,EACnFuR,MAAM2I,EAAIzxC,KAAO2pC,OAAOh1B,OAG5B3S,KAAK8mC,MAAM2I,EAAIzxC,IACfq6B,YAIF,OAFA0C,GAAKqB,MACL3E,QAAQ0R,IAAMzoC,GACPV,KAAK+6B,KAGdmK,eAAiB,SAASuK,EAAGvC,EAAGC,GAC9B,IAAInvC,EAAG0C,EAAGF,EAAGgiC,EAiBb,GAhBAxkC,EAAI,EACJ0C,EAAI,EACJq6B,GAAK+L,MAAM2I,EAAIvC,GACflS,GAAK8L,MAAM2I,EAAItC,GACX3Y,QAAQuG,KACVE,GAAK3b,MAAMyb,IACXA,GAAKxb,KAAKwb,KAEVE,GAAKV,IAEH/F,QAAQwG,KACVE,GAAK5b,MAAM0b,IACXA,GAAKzb,KAAKyb,KAEVE,GAAKX,IAEHrI,YAAY6I,KAAO7I,YAAY8I,IAAK,CAOtC,GALAh7B,KAAKi7B,IACLj7B,KAAKk7B,IACLtgB,MACA+wB,WAEU,KADVjrC,EAAI67B,eAEF,OAUF,GALAv8B,KAAKuf,KAAKwb,KACV/6B,KAAKuf,KAAKyb,KACVwM,WACAmE,WAEU,KADVjrC,EAAI67B,gBACW8U,MAAM3wC,GACnB,OAYF,IAVIA,EAAI,IACNA,GAAKA,EACLy6B,GAAKJ,GACLA,GAAKC,GACLA,GAAKG,GACLA,GAAKF,GACLA,GAAKC,GACLA,GAAKC,IAEPn7B,KAAKu6B,KACAv8B,EAAIwC,EAAI,EAAGgiC,EAAM9hC,EAAI,GAAK8hC,EAAMhiC,GAAKgiC,EAAMhiC,GAAKgiC,EAAMxkC,EAAI,GAAKwkC,IAAQhiC,IAAMA,EAChFR,KAAKuf,KAAKyb,KACVmG,aAAanjC,GACb4c,MACA5a,KAAKi7B,IACLuB,QACAnE,WAGF,OADAyO,MAAM2I,EAAIvC,GAAK9Q,MACR0K,MAAM2I,EAAItC,GAAKxF,OAAOh1B,OAKjC8Y,WAAa,WACX,IAAIysB,EAAYD,EAYhB,OAXIl0C,OACFirC,QAAQE,IAAI,eAAiBpI,MAAMqC,IAAM,GAAGxoC,WAAa,IAAMmmC,MAAMqC,IAAM,GAAGxoC,YAEhF2iC,OACA2U,EAAW7b,MACX8b,EAAa9b,MACRtsB,MAAKooC,EAAYD,IAAclkB,mBAAmBmkB,EAAYD,IAAcljB,SAASkjB,GAGxFrM,aAAaqM,EAAUC,GAFvBl4C,KAAKk4C,GAIArV,WAYT+I,aAAe,SAASqM,EAAUC,GAChC,IAAIsC,EAAGC,EAASC,EAAGC,EAAqBC,EAAUC,EAAeC,EAAYC,EAAkBC,EAAejN,EAAG/vC,EAAGoxB,EAAImG,EAAIma,EAAIlvC,EAAGy6C,EAA+BC,EAAW5C,EAAgB6C,EAAuB3Y,EAAKC,EAAMmN,EAAMC,EAAMuL,EAAeC,EAAmBC,EAAaC,EAuB1R,IAtBIx3C,QACF+2C,EAAa7C,EACbqD,EAAcpD,EACdlJ,QAAQE,IAAI,iBAAmB4L,EAAa,IAAMQ,IAEpDhY,OACAyK,EAAI5E,IACAhX,YAAW+lB,IACb/Q,KAAK,wCAEP+T,EAAY/R,IACZ0R,EAAgBl5B,MAAMs2B,EAAUC,GAAc,EAC1Cn0C,OACFirC,QAAQE,IAAI,iBAAmB4L,EAAa,IAAMQ,EAAc,mDAAqDT,GAEvHI,EAAgC/Y,yBAAyB6L,GACrDhqC,OACFirC,QAAQE,IAAI,iBAAmB4L,EAAa,IAAMQ,EAAc,mDAAqDT,GAGvHU,EAAyB,OACzBH,EAAgB,KACTP,EAAgB,GAAG,CAIxB,GAHI92C,OACFirC,QAAQE,IAAI,iBAAmB4L,EAAa,IAAMQ,EAAc,qCAAuCT,GAErG/pB,mBAAmBgW,MAAMoU,EAAY,IACnCn3C,OACFirC,QAAQE,IAAI,iBAAmB4L,EAAa,IAAMQ,EAAc,uBAElEd,EAAIjgB,IACJmgB,EAAI7N,UAGJ,GAA+B,SAA3B0O,EAAmC,OACbvtB,0BAA0BiqB,EAAU4C,EAAeK,GADtC,sBACpCF,EADoC,KACrBR,EADqB,KAClBE,EADkB,UAEhC,GAA+B,YAA3Ba,EAAsC,OACvBxtB,6BAA6BqtB,EAAeP,EAAeK,GADpC,sBAC9CH,EAD8C,KAC5BP,EAD4B,KAInD,GAA+B,SAA3Be,EAAmC,CACrC,GAAsB,IAAlBP,EAAqB,CACvBO,EAAyB,UACzB,SAwCA,IApCAv7C,KAAKw6C,GACLx6C,KAAKi4C,GACL5f,WACAr4B,KAAK06C,GACL9/B,MACA6/B,EAAUre,MACNr4B,OACFirC,QAAQE,IAAI,iBAAmB4L,EAAa,IAAMQ,EAAc,oBAAsBb,GAmBxFz6C,KAAKi7C,GACLj7C,KAAKy6C,GACL7hB,oBACAqiB,EAAgC7e,MAMhCoP,UAAUqP,EAAeK,EAAWV,EAAGE,GAChCG,GAAiB/pB,mBAAmBgW,MAAMoU,EAAYL,KAC3DA,IAGF,IADA76C,KAAK6sC,MACA7uC,EAAIwC,EAAI,EAAGgiC,EAAMqY,EAAgB,GAAKrY,EAAMhiC,GAAKgiC,EAAMhiC,GAAKgiC,EAAMxkC,EAAI,GAAKwkC,IAAQhiC,IAAMA,EAC5FR,KAAK8mC,MAAMoU,EAAYl9C,IACvBgC,KAAKi4C,GACL9W,aAAanjC,GACbw+B,QACAnE,WACAzd,MAEFwgC,EAAgBhf,WAGb,GAA+B,YAA3Bmf,EAAsC,CAC/C,GAAyB,IAArBR,EACF,MA6CA,GAzCA/6C,KAAKw6C,GACLx6C,KAAKi4C,GACLzQ,WAEAxnC,KAAKw6C,GACL93B,YACA1iB,KAAKi4C,GACLzQ,WAEAnP,WAIAgjB,EAAoBjf,MAChBr4B,OACFirC,QAAQE,IAAI,iBAAmB4L,EAAa,IAAMQ,EAAc,oBAAsBD,GAmBxFr7C,KAAKi7C,GACLE,EAAwB/e,MAExBp8B,KAAKi7C,GACLj7C,KAAKq7C,GACLziB,oBACAqiB,EAAgC7e,MACX,MAAjBgf,EAAuB,CAEzB,IADAp7C,KAAK6sC,MACA7uC,EAAIoxB,EAAK,EAAGqT,EAAOoY,EAAgB,GAAKpY,EAAOrT,GAAMqT,EAAOrT,GAAMqT,EAAOzkC,EAAI,GAAKykC,IAASrT,IAAOA,EACrGpvB,KAAK8mC,MAAMoU,EAAYl9C,IACvBgC,KAAKi4C,GACL9W,aAAanjC,GACbw+B,QACAnE,WACAzd,MAEFwgC,EAAgBhf,MAiBlB,GAVAp8B,KAJA46C,EAAWQ,GAMXp7C,KAAKq7C,GACLr7C,KAAKi4C,GACL3xB,UACA80B,EAAgBhf,MAChBp8B,KAAKo7C,GACLp7C,KAAKq7C,GACLhjB,WACAsiB,EAAsBve,OACjBhT,MAAMuxB,EAAqBC,GAqB9B,OAjBI72C,OACFirC,QAAQE,IAAI,qGAEVnrC,OACFirC,QAAQE,IAAI,2DAA6DiM,EAAwB,MAAQP,GAE3G56C,KAAKm7C,GACLn7C,KAAK46C,GACLtC,EAAiBluB,UACjBA,UAAY,EACZ+gB,aACA/gB,UAAYkuB,EACZ1f,oBACAqiB,EAAgC7e,MAChC0K,MAAMiH,GAAKkN,EACXxjB,QAAQsW,EAAI,QACZlL,UAiBF,IAAK7kC,EAAIu3B,EAAK,EAAGqa,EAAOiL,EAAgB,GAAKjL,EAAOra,GAAMqa,EAAOra,GAAMqa,EAAO5xC,EAAI,GAAK4xC,IAASra,IAAOA,EACrG6G,MAEFza,MAAMs2B,EAAUmD,GAChBP,GAAiB,GASvB,IAJI92C,OACFirC,QAAQE,IAAI,iBAAmB4L,EAAa,IAAMQ,EAAc,6DAElEt7C,KAAK6sC,MACA7uC,EAAI0xC,EAAK,EAAGG,EAAOgL,EAAgB,GAAKhL,EAAOH,GAAMG,EAAOH,GAAMG,EAAO7xC,EAAI,GAAK6xC,IAASH,IAAOA,EACrG1vC,KAAK8mC,MAAMoU,EAAYl9C,IACvBgC,KAAKi4C,GACL9W,aAAanjC,GACbw+B,QACAnE,WACAzd,MAsCF,OApCAs9B,EAAa9b,MACTr4B,OACFirC,QAAQE,IAAI,iBAAmB4L,EAAa,IAAMQ,EAAc,iDAAmDpD,EAAWv3C,YAEhIX,KAAKk4C,GACLI,EAAiBluB,UACjBA,UAAY,EACZ+gB,aACA/gB,UAAYkuB,EACZJ,EAAa9b,MACTr4B,OACFirC,QAAQE,IAAI,iBAAmB4L,EAAa,IAAMQ,EAAc,2CAA6CpD,EAAWv3C,YAKtHk6C,EAAgB,GAAKvnB,eAAewT,MAAMoU,EAAYL,MACxD76C,KAAKk4C,GAGLnf,SAEAmf,EAAa9b,MACbp8B,KAAKi7C,GACLhiB,kBACAgiB,EAAgC7e,OAElCp8B,KAAKi7C,GACLj7C,KAAKk4C,GACLtf,oBACAqiB,EAAgC7e,MAC5Br4B,OACFirC,QAAQE,IAAI,iBAAmB4L,EAAa,IAAMQ,EAAc,YAAcL,GAEhFnU,MAAMiH,GAAKkN,EACXxjB,QAAQsW,EAAI,GACLlL,WAGTX,yBAA2B,SAAS6L,GAClC,IAAI/vC,EAAGoxB,EAAI5uB,EAAGqxC,EAAO2J,EAAchZ,EAAKC,EAAMmN,EAAMC,EAGpD,IADAgC,EAAQtX,IACHv8B,EAAIwC,EAAIgiC,EAAMuL,EAAGtL,EAAO0G,IAAM3G,GAAOC,EAAOjiC,EAAIiiC,EAAOjiC,EAAIiiC,EAAOzkC,EAAIwkC,GAAOC,IAASjiC,IAAMA,EAC/FR,KAAK8mC,MAAM9oC,IACXonB,eACAplB,KAAK6xC,GACLjc,MACAic,EAAQzV,MAGV,IAAKp+B,EAAIoxB,EAAKwgB,EAAO7B,EAAG8B,EAAO1G,IAAMyG,GAAQC,EAAOzgB,EAAKygB,EAAOzgB,EAAKygB,EAAO7xC,EAAI4xC,GAAQC,IAASzgB,IAAOA,EACtGpvB,KAAK6xC,GACL7xC,KAAK8mC,MAAM9oC,IACXq6B,WACAyO,MAAM9oC,GAAKo+B,MASb,OANAp8B,KAAK6xC,GACLzP,cACAoZ,EAAepf,MACXr4B,OACFirC,QAAQE,IAAI,oCAAsCsM,EAAa76C,YAE1D66C,GAGTxtB,0BAA4B,SAASiqB,EAAU4C,EAAeK,GAC5D,IAAIO,EAAI/C,EAAIgD,EAAgB3N,EAAG/vC,EAAGoxB,EAAOmG,EAAIma,EAAIC,EAAIgM,EAAKC,EAAKp7C,EAAG03C,EAAY1V,EAAKC,EAAMmN,EAAMC,EAAMC,EAAM+L,EAAcC,EAAcC,EAAiBC,EAAeC,EAWvK,GAVIl4C,OACFirC,QAAQE,IAAI,6BAEdlxC,EAAI,EACA,EACA,EACC,EACA,EACC,EACA,EACF+F,MAAO,CAET,IADA/D,KAAK6sC,MACA7uC,EAAIwC,EAAI,EAAGgiC,EAAMqY,EAAgB,GAAKrY,EAAMhiC,GAAKgiC,EAAMhiC,GAAKgiC,EAAMxkC,EAAI,GAAKwkC,IAAQhiC,IAAMA,EAC5FR,KAAK8mC,MAAMoU,EAAYl9C,IACvBgC,KAAKi4C,GACL9W,aAAanjC,GACbw+B,QACAnE,WACAzd,MAEFs9B,EAAa9b,MACb4S,QAAQE,IAAI,QAAUgJ,GAWxB,GATAnK,EAAI5E,IACJuP,EAAKvP,IACLnpC,KAAK8mC,MAAMoU,EAAYL,IACvBx0B,mBACAu1B,EAAMzS,IAAMuP,EACZ+C,EAAKtS,IACLnpC,KAAK8mC,MAAMoU,EAAY,IACvB70B,mBACAs1B,EAAMxS,IAAMsS,EACR13C,MAAO,CAET,IADAirC,QAAQE,IAAI,yBACPlxC,EAAIoxB,EAAK,EAAGqT,EAAOkZ,EAAM,GAAKlZ,EAAOrT,EAAKqT,EAAOrT,EAAKqT,EAAOzkC,EAAI,GAAKykC,IAASrT,IAAOA,EACzF4f,QAAQE,IAAI,KAAOpI,MAAM2U,EAAKz9C,IAGhC,IADAgxC,QAAQE,IAAI,4BACPlxC,EAAIu3B,EAAK,EAAGqa,EAAOgM,EAAM,GAAKhM,EAAOra,EAAKqa,EAAOra,EAAKqa,EAAO5xC,EAAI,GAAK4xC,IAASra,IAAOA,EACzFyZ,QAAQE,IAAI,KAAOpI,MAAM4R,EAAK16C,IAIlC,IAAK69C,EAAenM,EAAK,EAAGG,EAAO+L,EAAM,GAAK/L,EAAOH,EAAKG,EAAOH,EAAKG,EAAOgM,EAAe,GAAKhM,IAASH,IAAOA,EAC/G,IAAKoM,EAAenM,EAAK,EAAGG,EAAO6L,EAAM,GAAK7L,EAAOH,EAAKG,EAAOH,EAAKG,EAAOgM,EAAe,GAAKhM,IAASH,IAAOA,EAAI,CAkBnH,GAhBAqM,EAAgBlV,MAAM4R,EAAKmD,GAC3BE,EAAkBjV,MAAM2U,EAAKK,GAC7B97C,KAAK+7C,GACL/7C,KAAKg8C,GACL91B,SACA6S,SACAkjB,EAAY7f,MACZsf,EAAiBtsC,SAASyrC,EAAeK,EAAWe,GAChDl4C,QACFirC,QAAQE,IAAI,SAAW8M,GACvBhN,QAAQE,IAAI,OAAS6M,GACrB/M,QAAQE,IAAI,UAAY+I,GACxBjJ,QAAQE,IAAI,SAAW+M,GACvBjN,QAAQE,IAAI,UAAY+M,GACxBjN,QAAQE,IAAI,KAAOwM,IAEjB5qB,mBAAmB4qB,GAKrB,OAJAjkB,QAAQsW,GACJhqC,OACFirC,QAAQE,IAAI,yCAEP,CAAC,EAAG8M,EAAeD,GAiB5B,GAfA/7C,KAAK+7C,GACLhjB,SACAgjB,EAAkB3f,MAClBp8B,KAAKi8C,GACLljB,SACAkjB,EAAY7f,MACZsf,EAAiBtsC,SAASyrC,EAAeK,EAAWe,GAChDl4C,QACFirC,QAAQE,IAAI,SAAW8M,GACvBhN,QAAQE,IAAI,OAAS6M,GACrB/M,QAAQE,IAAI,UAAY+I,GACxBjJ,QAAQE,IAAI,SAAW+M,GACvBjN,QAAQE,IAAI,UAAY+M,GACxBjN,QAAQE,IAAI,KAAOwM,IAEjB5qB,mBAAmB4qB,GAKrB,OAJAjkB,QAAQsW,GACJhqC,OACFirC,QAAQE,IAAI,yCAEP,CAAC,EAAG8M,EAAeD,GAQhC,OAJAtkB,QAAQsW,GACJhqC,OACFirC,QAAQE,IAAI,uCAEP,CAAC,EAAG,KAAM,OAGnBnhB,6BAA+B,SAASqtB,EAAeP,EAAeK,GACpE,IAAYQ,EAAgB3N,EAAM3e,EAAiB5uB,EAAGq7C,EAAcC,EAAcG,EAQlF,GAPI,EACA,EACA,EACC,EACA,EACC,EACA,EACFpB,GAAiB,EAInB,OAHI92C,OACFirC,QAAQE,IAAI,gFAEP,CAAC,EAAG,MAsBb,GApBInrC,OACFirC,QAAQE,IAAI,iCAAmCkM,GAEjDrN,EAAI5E,IACCA,IAGLhI,cAAc,GACdC,cAAc,EAAG,GACjB5E,QACA6F,QACA4Z,EAAY7f,MACRr4B,OACFirC,QAAQE,IAAI,qCAAuC+M,GAErDj8C,KAAKi8C,GACLP,EAAiBtsC,SAASyrC,EAAeK,EAAWe,GAChDl4C,OACFirC,QAAQE,IAAI,gCAAkCwM,GAE5C5qB,mBAAmB4qB,GAKrB,OAJAjkB,QAAQsW,GACJhqC,OACFirC,QAAQE,IAAI,4CAEP,CAAC,EAAG+M,GAkBb,GAbA9a,aAAa,GACbC,cAAc,EAAG,GACjB5E,QACA6F,QACA4Z,EAAY7f,MACRr4B,OACFirC,QAAQE,IAAI,qCAAuC+M,GAErDj8C,KAAKi8C,GACLP,EAAiBtsC,SAASyrC,EAAeK,EAAWe,GAChDl4C,OACFirC,QAAQE,IAAI,gCAAkCwM,GAE5C5qB,mBAAmB4qB,GAKrB,OAJAjkB,QAAQsW,GACJhqC,OACFirC,QAAQE,IAAI,4CAEP,CAAC,EAAG+M,GAIb,IAAKJ,EAAer7C,GAAK,GAAIA,GAAK,GAAIq7C,IAAiBr7C,EACrD,IAAKs7C,EAAe1sB,EAAK,EAAGA,GAAM,EAAG0sB,IAAiB1sB,EAcpD,GAbA+R,aAAa0a,GACb1a,aAAa2a,GACb97C,KAAKsvB,eACL+I,WACAzd,MACAynB,QACA4Z,EAAY7f,MACRr4B,OACFirC,QAAQE,IAAI,2DAA6D+M,GAE3Ej8C,KAAKi8C,GACLP,EAAiBtsC,SAASyrC,EAAeK,EAAWe,GAEhDnrB,mBAAmB4qB,GAKrB,OAJAjkB,QAAQsW,GACJhqC,OACFirC,QAAQE,IAAI,uBAAyBwM,GAEhC,CAAC,EAAGO,GAQjB,OAJAxkB,QAAQsW,GACJhqC,OACFirC,QAAQE,IAAI,4CAEP,CAAC,EAAG,OAkBb1D,UAAY,SAASqP,EAAeK,EAAWV,EAAGE,GAChD,IAAIwB,EAAGl+C,EAAGwC,EAAGgiC,EAEb,IADA0Z,EAAIrP,KACC7uC,EAAIwC,EAAIgiC,EAAMqY,EAAgBrY,GAAO,EAAIhiC,EAAI,EAAIA,EAAI,EAAIxC,EAAIwkC,GAAO,IAAMhiC,IAAMA,EACnFR,KAAK8mC,MAAMoU,EAAYl9C,IACvB8oC,MAAMoU,EAAYl9C,GAAKk+C,EACvBl8C,KAAKw6C,GACLt0B,SACAg2B,EAAI9f,MACJp8B,KAAK8mC,MAAMoU,EAAYl9C,EAAI,IAC3BgC,KAAKk8C,GACLl8C,KAAK06C,GACLriB,WACAmP,WACAV,MAAMoU,EAAYl9C,EAAI,GAAKo+B,MAG7B,GADA0K,MAAMoU,EAAY,GAAKgB,EACnBn4C,MACF,OAAOirC,QAAQE,IAAI,gBAAkBgN,EAAEv7C,aAI3CyO,SAAW,SAASyrC,EAAeK,EAAWiB,GAC5C,IAAIn+C,EAAGwC,EAAGgiC,EAEV,IADAxiC,KAAK6sC,MACA7uC,EAAIwC,EAAIgiC,EAAMqY,EAAgBrY,GAAO,EAAIhiC,GAAK,EAAIA,GAAK,EAAIxC,EAAIwkC,GAAO,IAAMhiC,IAAMA,EACrFR,KAAKm8C,GACL9jB,WACAr4B,KAAK8mC,MAAMoU,EAAYl9C,IAIvB4c,MAEF,OAAOwhB,OAqBT1Q,QAAU,SAASgjB,GACjB,IAAIX,EAEJ,GADAA,EAAI5E,IACA1pB,IAAIivB,KAAO/G,OAAOxmC,KAEpB,IADAutC,EAAIvuB,IAAIuuB,GACD9c,OAAO8c,IACZpN,kBAAkB7hB,IAAIivB,IACtBA,EAAIvuB,IAAIuuB,QAGVpN,kBAAkBoN,GAEpB,OAAOvF,IAAM4E,GAIfzM,kBAAoB,SAASoN,GAC3B,IAAId,EACJ,GAAInuB,IAAIivB,KAAO/G,OAAOn1B,UAAW,CAG/B,IAFAk8B,EAAIvuB,IAAIuuB,GACRd,EAAU,GACHhc,OAAO8c,IACZ1uC,KAAKyf,IAAIivB,IACTd,EAAQ5tC,KAAK0uC,EAAIvuB,IAAIuuB,IAEvB,OAAOd,EAEP,OAAO5tC,KAAK0uC,IAIhBxkC,YAAc,WACZ,IAAI0jC,EAMJ,IALA7S,GAAK5a,IAAI4a,IACT/6B,KAAKyf,IAAIsb,KACTt0B,OACAs0B,GAAK5a,IAAI4a,IACT6S,EAAU,GACHhc,OAAOmJ,KACZ/6B,KAAKyf,IAAIsb,KACTt0B,OACAmlB,SACAgiB,EAAQ5tC,KAAK+6B,GAAK5a,IAAI4a,KAExB,OAAO6S,GAGThiB,OAAS,WAKP,OAJA0X,OACAtI,GAAKoB,MACLrB,GAAKqB,MACLvQ,cACOgX,WAGThX,YAAc,WACZ,OAAIpM,IAAIsb,MAAQ4M,OAAOxmC,KACd2qB,aACEmJ,SAAS8F,IACXhP,gBACEjc,MAAKirB,GAAIC,IACXmG,aAAa,GAEbnhC,KAAK+6B,KAIhBjP,WAAa,WACX,IAAI8hB,EAIJ,IAHAzM,aAAa,GACbpG,GAAK5a,IAAI4a,IACT6S,EAAU,GACHhc,OAAOmJ,KACZ/6B,KAAKyf,IAAIsb,KACT/6B,KAAKg7B,IACLpP,SACAhR,MACAgzB,EAAQ5tC,KAAK+6B,GAAK5a,IAAI4a,KAExB,OAAO6S,GAGT7hB,cAAgB,WACd,IAAI/tB,EAAGoxB,EAAI1uB,EAAGF,EAAGgiC,EAAKC,EAMtB,IALAzkC,EAAI,EACA,EACJ0C,EAAIq6B,GAAGwN,OAAOuF,OACd7S,GAAK5f,aAAa3a,IACf6nC,OAAOsF,KAAO9S,GAAGwN,OAAOsF,KACtB7vC,EAAIwC,EAAI,EAAGgiC,EAAMzH,GAAGwN,OAAOsF,KAAO,GAAKrL,EAAMhiC,EAAIgiC,EAAMhiC,EAAIgiC,EAAMxkC,EAAI,GAAKwkC,IAAQhiC,IAAMA,EAC3Fy6B,GAAGsN,OAAOoF,IAAI3vC,GAAK+8B,GAAGwN,OAAOoF,IAAI3vC,GAEnC,IAAKA,EAAIoxB,EAAK,EAAGqT,EAAO/hC,EAAI,GAAK+hC,EAAOrT,EAAKqT,EAAOrT,EAAKqT,EAAOzkC,EAAI,GAAKykC,IAASrT,IAAOA,EACvFpvB,KAAK+6B,GAAGwN,OAAO3gB,KAAK5pB,IACpBgC,KAAKg7B,IACLpP,SACAqP,GAAGsN,OAAO3gB,KAAK5pB,GAAKo+B,MAEtB,OAAOp8B,KAAKi7B,KAGd9wB,WAAa,WAMX,OALAuf,qBACA1pB,KAAKuf,KAAKwb,KACVt0B,OACAolC,WACAplC,OACOijB,sBAGTlJ,iCAAmC,SAAS47B,GAC1C,IAAIC,EAAYC,EAAeC,EAAaC,EAAgBC,EAa5D,GAZAD,EAAiBn5B,0BAAyBskB,OAAO5zB,OAAQqoC,GACzDG,EAAcl5B,0BAAyBskB,OAAO9zB,IAAKuoC,GACnDC,EAAah5B,0BAAyBskB,OAAOjiC,GAAI02C,GACjDE,EAAgBj5B,0BAAyBskB,OAAOn1B,UAAW4pC,GAC3DK,EAAep5B,0BAAyBskB,OAAOxmC,KAAMi7C,GACjDr4C,QACFirC,QAAQE,IAAI,4BAA8BsN,GAC1CxN,QAAQE,IAAI,yBAA2BqN,GACvCvN,QAAQE,IAAI,wBAA0BmN,GACtCrN,QAAQE,IAAI,2BAA6BoN,GACzCtN,QAAQE,IAAI,0BAA4BuN,IAEtCD,EAAiB,GAAKD,EAAc,GAAKF,EAAa,GAAKC,EAAgB,GAAKG,EAAe,EACjG,OAAOtV,KAAK,kCAAoCiV,IAIpDtP,QAAU,WAUR,OATAxJ,OACA5Z,qBAIAjjB,OACAolC,WACAplC,OACAijB,qBACOmZ,WASTgJ,SAAU,WACR,IAAIkC,EAAG/vC,EAAGwC,EAAGgiC,EAMb,GALAxkC,EAAI,EACJ+vC,EAAI,EACJrkB,qBACA4Z,OACAvI,GAAKqB,MACDxK,OAAOmJ,IAAK,CAEd,IADAgT,EAAI5E,IACGvX,OAAOmJ,KACZ/6B,KAAKyf,IAAIsb,KACT8Q,WACA9Q,GAAK5a,IAAI4a,IAEX9E,KAAKkT,IAAM4E,QACN,GAAIhT,GAAG0S,IAAM51B,OAAQ,CAI1B,IAHA7X,KAAK+6B,IACL/X,cAEKhlB,EAAIwC,EAAI,EAAGgiC,GADhBzH,GAAKqB,OACoBmM,OAAOuF,MAAQ,GAAKtL,EAAMhiC,EAAIgiC,EAAMhiC,EAAIgiC,EAAMxkC,EAAI,GAAKwkC,IAAQhiC,IAAMA,EAC5FR,KAAK+6B,GAAGwN,OAAO3gB,KAAK5pB,IACpB6tC,WACA9Q,GAAGwN,OAAO3gB,KAAK5pB,GAAKo+B,MAEtBp8B,KAAK+6B,SACIA,GAAG0S,IAAMp6B,KAClBrT,KAAK+6B,IACL7c,gBACS6c,KAAO4M,OAAO9zB,IACvBktB,YAAYwN,KAAK16B,IACRknB,KAAO4M,OAAOjiC,GACvBq7B,YAAYwN,KAAK7oC,GAEjB1F,KAAK+6B,IAGP,OADA8H,UACOnZ,sBAGTtf,WAAa,WAGX,OAFApK,KAAKuf,KAAKwb,KACVt0B,OACOkkC,UAGTA,OAAS,WAGP,OAFArH,OACAwI,UACOjJ,WAGTiJ,QAAU,WACR,IAAI0B,EAGJ,OAFAA,EAAI,EACJzS,GAAKqB,MACA7L,cAAcwK,IAMfhJ,SAASgJ,KACXyS,EAAIe,KAAK+C,MAAMvW,GAAGyS,QAClBzM,YAAYyM,IAGV9a,UAAUqI,SACZ/6B,KAAK+6B,MAGPE,GAAK,IAAI9hB,GACNs0B,EAAIp6B,IACP4nB,GAAGoS,EAAEH,EAAIpW,KAAKiE,GAAGsS,EAAEH,EAAGnS,GAAGsS,EAAEF,GAC3BlS,GAAGoS,EAAEF,EAAIhW,KAAK,GACdn3B,KAAKi7B,IACD5H,iBAAiB0H,KACnBoG,cAAc,GACPvmB,YAFT,IAnBEymB,YAAY3xB,OACZ1P,KAAK+6B,SACL9E,KAAK,KA0CT5rB,SAAW,WACT,IAAIrM,EAAGqwC,EAAGZ,EAAGiP,EAAiBl8C,EAAGgiC,EAAKC,EAWtC,GAVAzkC,EAAI,EACA,EACA,EACJ0+C,EAAkBp9B,MAAMyb,IACnBhG,SAAS2nB,IACZvV,KAAK,oDAEPnnC,KAAKqf,OAAO0b,KACZt0B,OACA4nC,EAAI9R,cACA8U,MAAMhD,GACRruC,KAAK+6B,QADP,CAOA,GAHA/6B,KAAKof,QAAQ2b,KACbt0B,OACAgnC,EAAIlR,eACA8U,MAAM5D,GAAV,CAOA,IADAvS,GAAKpN,YAAY4uB,GACZ1+C,EAAIwC,EAAIgiC,EAAM6L,EAAG5L,EAAOgL,EAAIjL,GAAOC,EAAOjiC,GAAKiiC,EAAOjiC,GAAKiiC,EAAOzkC,EAAIwkC,GAAOC,IAASjiC,IAAMA,EAC/F2gC,aAAanjC,GACbm9B,GAAKiB,MACL0I,YAAY4X,EAAiBvhB,IAC7Bn7B,KAAKuf,KAAKwb,KACVt0B,OACA21B,MAKF,OAFA0I,YAAY4X,EAAiBxhB,IAEtBmG,YAAY1uB,KAjBjB3S,KAAK+6B,MA2BTxwB,WAAa,WAGX,OAFAvK,KAAKuf,KAAKwb,KACVt0B,OACOqmB,SAGTA,MAAQ,WAGN,OAFAwW,OACAtW,SACO6V,WAGT7V,OAAS,WAGP,OADA+N,GAAKqB,MACD1H,WAAWqG,KAAO9oB,OAAO8oB,GAAGsS,EAAEH,EAAG,IAAMj7B,OAAO8oB,GAAGsS,EAAEF,EAAG,IACpDzjB,mBACFqX,YAAYwN,KAAK16B,IAEjBwtB,YAAYxtB,IAEdutB,cAAc,EAAG,QACjB5E,SAGE9H,WAAWqG,KAAO9oB,OAAO8oB,GAAGsS,EAAEH,EAAG,IAAMj7B,OAAO8oB,GAAGsS,EAAEF,EAAG,IACpDzjB,mBACFqX,YAAYwN,KAAK16B,IAEjBwtB,YAAYxtB,IAEdutB,cAAc,EAAG,GACjB5E,QACA4E,cAAc,EAAG,QACjB/I,YASE/E,eAAeyH,KACbrR,mBACFqX,YAAYwN,KAAK16B,IAEjBwtB,YAAYxtB,IAEdstB,cAAc,GACd9I,WACI3O,mBACFqX,YAAYwN,KAAK16B,IAEjBwtB,YAAYxtB,IAEd7T,KAAK+6B,IACL1C,WACAkO,OACAvmC,KAAK+6B,IACL1C,WACAr4B,KAAK+6B,IACLhC,SACAjM,QACAuL,gBACAnS,eAGEzG,IAAIsb,MAAQ4M,OAAOxmC,MAIvBkgC,YAAYtxB,OACZ/P,KAAK+6B,IACL9E,KAAK,IALHlJ,iBAQJA,aAAe,WAEb,OADAkO,GAAK9a,IAAI4a,IACLrG,WAAWjV,IAAIwb,MAAQhpB,OAAOwN,IAAIwb,IAAIoS,EAAEH,EAAG,IAAMj7B,OAAOwN,IAAIwb,IAAIoS,EAAEF,EAAG,IACvEntC,KAAKuf,KAAK0b,KACVj7B,KAAKuf,KAAK0b,KACVnO,QACOuL,YAEH3D,WAAWjV,IAAIwb,MAAQhpB,OAAOwN,IAAIwb,IAAIoS,EAAEH,GAAI,IAAMj7B,OAAOwN,IAAIwb,IAAIoS,EAAEF,EAAG,IACxEntC,KAAKuf,KAAK0b,KACVnO,QACA9sB,KAAKuf,KAAK0b,KACVkG,cAAc,GACdvmB,MACOsL,WAEPmb,YAAYtxB,OACZ/P,KAAK+6B,SACL9E,KAAK,KASXzrB,SAAW,WACT,IAAIojC,EAMJ,IALA7S,GAAK5a,IAAI4a,IACT/6B,KAAKyf,IAAIsb,KACTt0B,OACAs0B,GAAK5a,IAAI4a,IACT6S,EAAU,GACHhc,OAAOmJ,KACZ/6B,KAAKyf,IAAIsb,KACTt0B,OACAwmB,MACA2gB,EAAQ5tC,KAAK+6B,GAAK5a,IAAI4a,KAExB,OAAO6S,GAGT3gB,IAAM,WACJ,IAAIqrB,EAKJ,OAJAA,EAAiBluB,UACjBkZ,OACApW,WACA2V,UACOzY,UAAYkuB,GAGrBprB,SAAW,WACT,IAAIyvB,EAOJ,GANAvyB,UAAY,EACZ4Q,GAAKoB,MACLrB,GAAKqB,MACDr4B,OACFirC,QAAQE,IAAI,iBAAmBnU,GAAK,QAAUC,IAE5C5R,MAAM2R,GAAIC,IACZh7B,KAAK+6B,QADP,CAIA,GAAIrG,WAAWqG,KAAOrG,WAAWsG,IAI/B,OAHAh7B,KAAK+6B,IACL/6B,KAAKg7B,SACL7N,cAGF,GAAKwvB,EAAUr/B,qCAAqCyd,GAAIC,IACtD5N,UAAUuvB,QAGZ,GAAIl9B,IAAIsb,MAAQ4M,OAAOxmC,MAAQse,IAAIub,MAAQ2M,OAAOxmC,KAYlD,GARIse,IAAIsb,MAAQ4M,OAAOxmC,OACrBqsB,QAAQuN,IACRA,GAAKqB,OAEH3c,IAAIub,MAAQ2M,OAAOxmC,OACrBqsB,QAAQwN,IACRA,GAAKoB,OAEH3c,IAAIsb,MAAQ4M,OAAOn1B,UAIvB,GAAIiN,IAAIub,MAAQ2M,OAAOn1B,UAAvB,CAIA,GAAIiN,IAAIsb,MAAQ4M,OAAOn1B,WAAaiN,IAAIub,MAAQ2M,OAAOn1B,UAIvD,OAAO6a,4BAHLC,2BAJAC,uBAJAE,uBAZAC,gBA0BJpQ,qCAAuC,SAASyd,EAAIC,GAClD,IAAI2hB,EAIJ,OAHI54C,OACFirC,QAAQE,IAAI,6CAA+CnU,EAAK,QAAUC,OAExE2hB,EAAUvnB,mCAAmC2F,MAC3C3F,mCAAmC4F,EAAI2hB,KAClCA,GAMbvvB,UAAY,SAASuvB,GAoDnB,GAnDI54C,OACFirC,QAAQE,IAAI,kBAAoBnU,GAAK,aAAe4hB,GAGtD38C,KAAK+6B,IACL/6B,KAAK28C,GACLlxB,aACAsP,GAAKqB,MACLp8B,KAAKg7B,IACLh7B,KAAK28C,GACLlxB,aACAuP,GAAKoB,MACDr4B,OACFirC,QAAQE,IAAI,wBAEVnrC,OACFirC,QAAQE,IAAI,QAAUnU,GAAGp6B,YAEvBoD,OACFirC,QAAQE,IAAI,QAAUlU,GAAGr6B,YAavB8e,IAAIsb,MAAQ4M,OAAOn1B,WAAaiN,IAAIub,MAAQ2M,OAAOn1B,YAIjDiN,IAAIsb,MAAQ4M,OAAOn1B,YACrB6uB,YAAY7uB,UACZxS,KAAK+6B,IACL/6B,KAAKu6B,KACLtE,KAAK,GACL8E,GAAKqB,OAEH3c,IAAIub,MAAQ2M,OAAOn1B,YACrB6uB,YAAY7uB,UACZxS,KAAKg7B,IACLh7B,KAAKu6B,KACLtE,KAAK,GACL+E,GAAKoB,QAGL3c,IAAIsb,MAAQ4M,OAAOn1B,WAAaiN,IAAIub,MAAQ2M,OAAOn1B,UAKvD,OADA6a,6BACO,EAJLC,uBAOJA,oBAAsB,WACpB,IAAIsgB,EAIJ,IAHA5tC,KAAKu6B,KACLU,GAAK9a,IAAI4a,IACT6S,EAAU,GACHhc,OAAOqJ,KAAK,CAEjB,IADAC,GAAK/a,IAAI6a,IACFpJ,OAAOsJ,KACZl7B,KAAKyf,IAAIwb,KACTj7B,KAAKyf,IAAIyb,KACTjO,MACAoL,WACA6C,GAAK/a,IAAI+a,IAEX0S,EAAQ5tC,KAAKi7B,GAAK9a,IAAI8a,KAExB,OAAO2S,GAGTvgB,0BAA4B,WAa1B,GAZI5N,IAAIsb,MAAQ4M,OAAO5zB,QACrBknB,GAAK3b,MAAMyb,IACXA,GAAKxb,KAAKwb,KAEVE,GAAKV,IAEH9a,IAAIub,MAAQ2M,OAAO5zB,QACrBmnB,GAAK5b,MAAM0b,IACXA,GAAKzb,KAAKyb,KAEVE,GAAKX,IAEFnR,MAAM2R,GAAIC,IAAf,CAKA,GAAIzK,cAAc0K,KAAO1K,cAAc2K,IAQrC,OAPAl7B,KAAK+6B,IACDhF,MAAMkF,GAAIC,IACZl7B,KAAKi7B,IAELj7B,KAAKk7B,SAEPsB,QAQF,GAJAx8B,KAAKi7B,IACLj7B,KAAKk7B,IACLhV,SACAiV,GAAKiB,MACD7L,cAAc4K,IAmBhB,OAlBAn7B,KAAK+6B,IAGHI,GADE1b,IAAIwb,MAAQ0M,OAAOn1B,WAAa+d,cAAchR,KAAK0b,KAChD1b,KAAK0b,IAELV,IAGLa,GADE3b,IAAIyb,MAAQyM,OAAOn1B,WAAa+d,cAAchR,KAAK2b,KAChD3b,KAAK2b,IAELX,IAEHxE,MAAMoF,GAAIC,IACZp7B,KAAKi7B,IAELj7B,KAAKk7B,SAEPsB,QAOF,GAJAx8B,KAAKi7B,IACLj7B,KAAKk7B,IACLsM,WACArM,GAAKiB,MACA7L,cAAc4K,IAWnB,OANAn7B,KAAK+6B,IACD1H,iBAAiB8H,IACnBn7B,KAAKi7B,IAELj7B,KAAKk7B,IAEAsB,QAVLx8B,KAAKu6B,UA7CLv6B,KAAKu6B,MA2DT7M,YAAc,WACZ,GAAI3vB,OAAOg9B,MAAQh9B,OAAOi9B,IAA1B,CAOA,IAHAC,GAAK9a,IAAI4a,IACT/6B,KAAKyf,IAAIwb,KACTA,GAAK9a,IAAI8a,IACFrJ,OAAOqJ,KACZj7B,KAAKyf,IAAIwb,KACThO,MACAgO,GAAK9a,IAAI8a,IAMX,IAJAA,GAAKmB,MACLlB,GAAK/a,IAAI6a,IACTh7B,KAAKyf,IAAIyb,KACTA,GAAK/a,IAAI+a,IACFtJ,OAAOsJ,KACZl7B,KAAKyf,IAAIyb,KACTjO,MACAiO,GAAK/a,IAAI+a,IAWX,OATAA,GAAKkB,MACLp8B,KAAK+6B,IACL/6B,KAAKi7B,IACL/U,SACAiV,GAAKiB,MACLp8B,KAAKg7B,IACLh7B,KAAKk7B,IACLhV,SACAkV,GAAKgB,MACDhT,MAAM+R,GAAIC,KACZp7B,KAAKm7B,IACLn7B,KAAKi7B,IACLj7B,KAAKk7B,IACLjO,MACOoL,YAEAr4B,KAAKu6B,KApCZv6B,KAAKu6B,MAwCT/M,QAAU,SAASkhB,GACjB,IAAId,EAKJ,IAJAc,EAAIvuB,IAAIuuB,GACR1uC,KAAKyf,IAAIivB,IACTA,EAAIvuB,IAAIuuB,GACRd,EAAU,GACHhc,OAAO8c,IACZ1uC,KAAKyf,IAAIivB,IACTzhB,MACA2gB,EAAQ5tC,KAAK0uC,EAAIvuB,IAAIuuB,IAEvB,OAAOd,GAGTngB,gBAAkB,WAChB,IAAImgB,EAIJ,IAHA5tC,KAAKu6B,KACLU,GAAK9a,IAAI4a,IACT6S,EAAU,GACHhc,OAAOqJ,KACZj7B,KAAKyf,IAAIwb,KACTj7B,KAAKg7B,IACL/N,MACAoL,WACAuV,EAAQ5tC,KAAKi7B,GAAK9a,IAAI8a,KAExB,OAAO2S,GAGTrgB,gBAAkB,WAChB,IAAIqgB,EAIJ,IAHA5tC,KAAKu6B,KACLW,GAAK/a,IAAI6a,IACT4S,EAAU,GACHhc,OAAOsJ,KACZl7B,KAAK+6B,IACL/6B,KAAKyf,IAAIyb,KACTjO,MACAoL,WACAuV,EAAQ5tC,KAAKk7B,GAAK/a,IAAI+a,KAExB,OAAO0S,GAITnf,MAAQ,WACN,IAAIigB,EAGJ,OAFAA,EAAItS,MACJp8B,KAAK0uC,GACD5+B,MAAK4+B,EAAG/G,OAAOrwB,WACV+pB,YAAY/pB,UACVxH,MAAK4+B,EAAG/G,OAAOnwB,WACjB6pB,YAAY7pB,UACV1H,MAAK4+B,EAAG/G,OAAOlwB,WACjB4pB,YAAY5pB,UACV3H,MAAK4+B,EAAG/G,OAAOtwB,WACjBgqB,YAAYhqB,UACVvH,MAAK4+B,EAAG/G,OAAOvwB,WACjBiqB,YAAYjqB,UAEZiqB,YAAY/pB,WAevB4X,QAAU,WAGR,OAFAoU,OACAyI,YACOlJ,WAUTkJ,UAAY,WACV,IAAIrrC,EAMJ,OALI,EACJs6B,GAAKoB,MACLrB,GAAKqB,MACLp8B,KAAKg7B,KACLt6B,EAAI67B,eACI,GAAK8U,MAAM3wC,IACjB2gC,YAAYpxB,SACZjQ,KAAK+6B,IACL/6B,KAAKg7B,SACL/E,KAAK,IAGHlB,SAASgG,IACJiR,WAAWtrC,IAElBu6B,GAAKF,GACLA,GAAK4M,OAAOpyB,SACZy2B,WAAWtrC,GACXq6B,GAAKE,GACLj7B,KAAK2nC,OAAOpyB,UACZvV,KAAK+6B,IACLwM,SACO9gC,SAIXulC,WAAa,SAAStrC,GACpB,IAAI1C,EAAGwC,EAAGgiC,EAAKoL,EAMf,IALA5vC,EAAI,EACJmjC,aAAa,GACbA,aAAa,GACbjG,GAAKkB,MACLwR,EAAU,GACL5vC,EAAIwC,EAAI,EAAGgiC,EAAM9hC,EAAI,GAAK8hC,EAAMhiC,EAAIgiC,EAAMhiC,EAAIgiC,EAAMxkC,EAAI,GAAKwkC,IAAQhiC,IAAMA,EAC9E26B,GAAKD,GACLA,GAAKkB,MACLp8B,KAAK+6B,IACL/6B,KAAKk7B,IACL7C,WACA8I,aAAanjC,GACbgC,KAAKm7B,IACL9C,WACAmP,WACArG,aAAa,GACbyM,EAAQ5tC,KAAKq4B,YAEf,OAAOuV,GAsBTze,QAAU,WACR,IAAInxB,EAAGoxB,EAAIif,EAAG3tC,EAAGF,EAAGgiC,EAAKC,EAQzB,GAPAzkC,EAAI,EACJqwC,EAAI,EACA,EACJ/K,OACAtI,GAAKoB,MACLp8B,KAAKg7B,KACLt6B,EAAI67B,eACI,EAKN,OAJA8E,YAAYnxB,SACZlQ,KAAKg7B,IACL/E,KAAK,QACL4M,UAKF,IAFArB,iBAAiB9gC,EAAGA,GACpBq6B,GAAKqB,MACAp+B,EAAIwC,EAAI,EAAGgiC,EAAM9hC,EAAI,GAAK8hC,EAAMhiC,EAAIgiC,EAAMhiC,EAAIgiC,EAAMxkC,EAAI,GAAKwkC,IAAQhiC,IAAMA,EAC9E,IAAK6tC,EAAIjf,EAAK,EAAGqT,EAAO/hC,EAAI,GAAK+hC,EAAOrT,EAAKqT,EAAOrT,EAAKqT,EAAO4L,EAAI,GAAK5L,IAASrT,IAAOA,EACvF+R,aAAanjC,EAAIqwC,EAAI,GACrBle,UACA4K,GAAGwN,OAAO3gB,KAAK5pB,EAAI0C,EAAI2tC,GAAKjS,MAIhC,OADAp8B,KAAK+6B,IACE8H,WAGT1+B,YAAa,EAEbwG,UAAY,WAGV,OAFA3K,KAAKuf,KAAKwb,KACVt0B,OACO4oB,QAGTA,KAAO,WAwBL,OAvBAiU,OACAjB,QACAtH,GAAKqB,MACDj4B,YACF6qC,QAAQE,IAAI,YAAcnU,IAE5B/6B,KAAK+6B,IACL/6B,KAAK+6B,IACLrY,YACIve,YACF6qC,QAAQE,IAAI,6BAA+BpI,MAAMqC,IAAM,IAEzD3B,WACArG,aAAa,GACbjb,SACI/hB,YACF6qC,QAAQE,IAAI,8BAAgCpI,MAAMqC,IAAM,IAE1DnpC,KAAKsvB,eACLpJ,SACI/hB,YACF6qC,QAAQE,IAAI,8BAAgCpI,MAAMqC,IAAM,IAEnDtG,WAOTtT,eAAiB,SAAS7uB,GACxB,IAAI1C,EAAGoxB,EAAImG,EAAIkY,EAAGiC,EAAIkJ,EAAGjJ,EAAI9B,EAAMC,EAAOttC,EAAGgiC,EAAKC,EAAMmN,EAAMC,EAAMC,EAAMC,EAAMC,EAAMC,EAAMR,EAAGD,EAgB/F,IAfAxxC,EAAI,EACJyvC,EAAI,EACA,EACG,EACPK,EAAQ,EACR0B,EAAI,EACJlM,QAIAsV,EAAIl4C,EAAI,IADRmtC,GADA9S,GAAK+L,MADL2I,EAAItG,IAAMzoC,IAEA6nC,OAAOsF,OAGf1G,KAAK,+BAEPsG,EAAI,EACCzvC,EAAIwC,EAAI,EAAGgiC,EAAMoW,EAAI,GAAKpW,EAAMhiC,EAAIgiC,EAAMhiC,EAAIgiC,EAAMxkC,EAAI,GAAKwkC,IAAQhiC,IAAMA,EAC9ER,KAAK8mC,MAAM2I,EAAIzxC,EAAI,MACnBwxC,EAAIjT,eACI,GAAKiT,EAAIzU,GAAGwN,OAAOoF,IAAI3vC,KAC7BmpC,KAAK,sBAEPsG,EAAIA,EAAI1S,GAAGwN,OAAOoF,IAAI3vC,GAAKwxC,EAAI,EAEjC,GAAI3B,IAAS+K,EAIX,OAHAnhB,QAAQ0R,IAAMzoC,GACdV,KAAK+6B,GAAGwN,OAAO3gB,KAAK6lB,SACpB5K,UAGF,IAAK7kC,EAAIoxB,EAAKqT,EAAOmW,EAAGhJ,EAAO/B,EAAOpL,GAAQmN,EAAOxgB,EAAKwgB,EAAOxgB,EAAKwgB,EAAO5xC,EAAIykC,GAAQmN,IAASxgB,IAAOA,EACvGqe,EAAIA,EAAI1S,GAAGwN,OAAOoF,IAAI3vC,GAAK,EAG7B,IADA8vC,EAAQ,EACH9vC,EAAIu3B,EAAKsa,EAAO+I,EAAG9I,EAAOjC,EAAOgC,GAAQC,EAAOva,EAAKua,EAAOva,EAAKua,EAAO9xC,EAAI6xC,GAAQC,IAASva,IAAOA,EACvGuY,GAAS/S,GAAGwN,OAAOoF,IAAI3vC,GAIzB,KAFAg9B,GAAK3f,aAAayyB,IACfvF,OAAOsF,KAAOA,EAAO+K,EACnB56C,EAAI0xC,EAAKK,EAAO6I,EAAG5I,EAAOnC,EAAOkC,GAAQC,EAAON,EAAKM,EAAON,EAAKM,EAAOhyC,EAAI+xC,GAAQC,IAASN,IAAOA,EACvG1U,GAAGuN,OAAOoF,IAAI3vC,EAAI46C,GAAK7d,GAAGwN,OAAOoF,IAAI3vC,GAEvC,IAAKA,EAAI2xC,EAAK,EAAGM,EAAOnC,EAAQ,GAAKmC,EAAON,EAAKM,EAAON,EAAKM,EAAOjyC,EAAI,GAAKiyC,IAASN,IAAOA,EAC3F3U,GAAGuN,OAAO3gB,KAAK5pB,GAAK+8B,GAAGwN,OAAO3gB,KAAK6lB,EAAIzvC,GAMzC,OAJA2iB,wBAAwBoa,IACxBpa,wBAAwBqa,IACxBvD,QAAQ0R,IAAMzoC,GACdV,KAAKg7B,IACE6H,WA0BTkC,cAAgB,SAASrkC,GACvB,IAAI1C,EAAGoxB,EAAImG,EAAIkY,EAAGiC,EAAIkJ,EAAGjJ,EAAIyE,EAAIvG,EAAMrtC,EAAGgiC,EAAKC,EAAMmN,EAAMC,EAAMC,EAAMC,EAAMC,EAAMP,EAAGD,EAsBtF,IArBAxxC,EAAI,EACJyvC,EAAI,EACA,EACG,EACP+B,EAAI,EACJlM,OACI5iC,EAAI,GACNymC,KAAK,2BAGPnM,GAAK8L,MADL2I,EAAItG,IAAMzoC,GAEVq6B,GAAK+L,MAAM2I,EAAI,GACVxa,SAAS8F,KACZoM,KAAK,yEAGPyR,EAAIl4C,EAAI,IADRmtC,EAAO9S,GAAGwN,OAAOsF,OAGf1G,KAAK,2BAEPsG,EAAI,EACCzvC,EAAIwC,EAAI,EAAGgiC,EAAMoW,EAAI,GAAKpW,EAAMhiC,EAAIgiC,EAAMhiC,EAAIgiC,EAAMxkC,EAAI,GAAKwkC,IAAQhiC,IAAMA,EAC9ER,KAAK8mC,MAAM2I,EAAIzxC,EAAI,MACnBwxC,EAAIjT,eACI,GAAKiT,EAAIzU,GAAGwN,OAAOoF,IAAI3vC,KAC7BmpC,KAAK,6BAEPsG,EAAIA,EAAI1S,GAAGwN,OAAOoF,IAAI3vC,GAAKwxC,EAAI,EAEjC,IAAKxxC,EAAIoxB,EAAKqT,EAAOmW,EAAGhJ,EAAO/B,EAAOpL,GAAQmN,EAAOxgB,EAAKwgB,EAAOxgB,EAAKwgB,EAAO5xC,EAAIykC,GAAQmN,IAASxgB,IAAOA,EACvGqe,EAAIA,EAAI1S,GAAGwN,OAAOoF,IAAI3vC,GAAK,EAK7B,KAFAi9B,GAAK5f,aAAa0f,GAAGwN,OAAOuF,QACzBvF,OAAOsF,KAAO9S,GAAGwN,OAAOsF,KACtB7vC,EAAIu3B,EAAK,EAAGsa,EAAO9U,GAAGwN,OAAOsF,KAAO,GAAKgC,EAAOta,EAAKsa,EAAOta,EAAKsa,EAAO7xC,EAAI,GAAK6xC,IAASta,IAAOA,EACpG0F,GAAGsN,OAAOoF,IAAI3vC,GAAK+8B,GAAGwN,OAAOoF,IAAI3vC,GAEnC,IAAKA,EAAI0xC,EAAK,EAAGI,EAAO/U,GAAGwN,OAAOuF,MAAQ,GAAKgC,EAAOJ,EAAKI,EAAOJ,EAAKI,EAAO9xC,EAAI,GAAK8xC,IAASJ,IAAOA,EACrGzU,GAAGsN,OAAO3gB,KAAK5pB,GAAK+8B,GAAGwN,OAAO3gB,KAAK5pB,GAKrC,GAHA2iB,wBAAwBoa,IACxBpa,wBAAwBsa,IACxBF,GAAKE,GACD4S,IAAS+K,EASX,OARI3jB,SAAS+F,KACXmM,KAAK,2BAEPpM,GAAGwN,OAAO3gB,KAAK6lB,GAAKzS,GACpBra,wBAAwBoa,IACxBtD,QAAQ0R,IAAMzoC,GACdV,KAAK+6B,SACL8H,UAUF,IAPK5N,SAAS+F,KACZmM,KAAK,2BAEH0G,EAAO+K,IAAM5d,GAAGuN,OAAOsF,MACzB1G,KAAK,2BAGFnpC,EAAI2xC,EAAK,EAAGI,EAAO/U,GAAGuN,OAAOsF,KAAO,GAAKkC,EAAOJ,EAAKI,EAAOJ,EAAKI,EAAO/xC,EAAI,GAAK+xC,IAASJ,IAAOA,EAChG5U,GAAGwN,OAAOoF,IAAIiL,EAAI56C,KAAOg9B,GAAGuN,OAAOoF,IAAI3vC,IACzCmpC,KAAK,2BAKT,IAAKnpC,EAAIo2C,EAAK,EAAGpE,EAAOhV,GAAGuN,OAAOuF,MAAQ,GAAKkC,EAAOoE,EAAKpE,EAAOoE,EAAKpE,EAAOhyC,EAAI,GAAKgyC,IAASoE,IAAOA,EACrGrZ,GAAGwN,OAAO3gB,KAAK6lB,EAAIzvC,GAAKg9B,GAAGuN,OAAO3gB,KAAK5pB,GAMzC,OAJA2iB,wBAAwBoa,IACxBpa,wBAAwBqa,IACxBvD,QAAQ0R,IAAMzoC,GACdV,KAAK+6B,IACE8H,WAGTh4B,YAAa,WACX,IAAI+xC,EAAY5+C,EAAGoxB,EAAImG,EAAIma,EAAImN,EAAkBr8C,EAAGs8C,EAAUta,EAAKC,EAAMmN,EAAMC,EAAMkN,EAAiBnP,EAAyBoP,EAAOC,EAiBtI,KAPAA,EAAe,IACFj9C,KAAKyf,IAAIU,IAAI4a,MACTtb,IAAIU,IAAIA,IAAI4a,QACN4M,OAAOh1B,MAC5Bw0B,KAAK,+DAEP0V,EAAmB18B,IAAIA,IAAI4a,KACpB8hB,IAAqBlV,OAAOh1B,MACjCsqC,EAAaj9C,KAAKyf,IAAIo9B,IACtBA,EAAmB18B,IAAI08B,GAGzB,GAAII,EAAal/C,OAAS,EAAG,CAK3B,IAJAsjC,YAAYhxB,OACZrQ,KAAKi9C,EAAaA,EAAal/C,OAAS,IACxCiC,KAAKi9C,EAAaA,EAAal/C,OAAS,IACxCk4B,KAAK,GACAj4B,EAAIwC,EAAI,EAAGgiC,EAAMya,EAAal/C,OAAS,GAAKykC,EAAMhiC,EAAIgiC,EAAMhiC,EAAIgiC,EAAMxkC,EAAI,GAAKwkC,IAAQhiC,IAAMA,EAChG6gC,YAAYhxB,OACZq3B,OACA1nC,KAAKi9C,EAAaA,EAAal/C,OAASC,EAAI,IAC5C0pC,OACAzR,KAAK,GAIP,OAFA8E,GAAKqB,WACLvxB,cAaF,IANAojB,uBAAsB8M,GADtB+hB,EAAW,IAKXC,EAAkB,GAEb/+C,EAAIoxB,EAAK,EAAGqT,EAAOqa,EAAS/+C,OAAS,GAAK0kC,EAAOrT,EAAKqT,EAAOrT,EAAKqT,EAAOzkC,EAAI,GAAKykC,IAASrT,IAAOA,EACjG0tB,EAAS9+C,KAAO2pC,OAAO3wB,yBAGzB+lC,EAAgB/8C,KAAK88C,EAAS9+C,IAKlC,GAFA8+C,EAAWC,EACXA,EAAkB,GACdD,EAAS/+C,OAAS,EAAG,CAOvB,IADAi/C,EAAQ,EACHh/C,EAAIu3B,EAAK,EAAGqa,EAAOkN,EAAS/+C,QAAS,GAAK6xC,EAAOra,EAAKqa,EAAOra,EAAKqa,IAEhE5xC,EAAIg/C,EAAQ,GAAOF,EAAS/+C,OAAS,IAClCyyB,uBAAsBssB,EAAS9+C,EAAIg/C,KAAWxsB,uBAAsBssB,EAAS9+C,EAAIg/C,EAAQ,IAe7FD,EAAgB/8C,KAAK88C,EAAS9+C,EAAIg/C,KAdlCh9C,KAAK88C,EAAS9+C,EAAIg/C,IAClBv2C,OACAypB,OACAlwB,KAAK88C,EAAS9+C,EAAIg/C,EAAQ,IAC1Bv2C,OACA+gC,WACAoV,EAAaxgB,MAETtL,mBAAmB8rB,GACrBI,GAAS,EAETD,EAAgB/8C,KAAK88C,EAAS9+C,EAAIg/C,KASpCh/C,EAAIg/C,IAAUF,EAAS/+C,OAAS,GAElCg/C,EAAgB/8C,KAAK88C,EAASA,EAAS/+C,OAAS,MAE9CC,EAAIg/C,GAASF,EAAS/+C,OAAS,IA5ByCC,EAAI,GAAK4xC,IAASra,IAAOA,GAgCvGunB,EAAWC,EAYb,GAFA/8C,KAAK2nC,OAAOt3B,UAERysC,EAAS/+C,OAAS,GAQpB,OAFAq+B,WACAp8B,KAAK2nC,OAAO3wB,yBANZ,IAAKhZ,EAAI0xC,EAAK,EAAGG,EAAOiN,EAAS/+C,OAAS,GAAK8xC,EAAOH,EAAKG,EAAOH,EAAKG,EAAO7xC,EAAI,GAAK6xC,IAASH,IAAOA,EAErG1vC,KAAK88C,EAAS9+C,IAelB,IAPAi4B,KAAK6mB,EAAS/+C,OAAS,GACvBg9B,GAAKqB,MACLrB,GAAK5a,IAAI4a,IACT/6B,KAAKyf,IAAIsb,KACTt0B,OACAs0B,GAAK5a,IAAI4a,IACT6S,EAAU,GACHhc,OAAOmJ,KACZ/6B,KAAKyf,IAAIsb,KACTt0B,OACAkpB,SACAie,EAAQ5tC,KAAK+6B,GAAK5a,IAAI4a,KAExB,OAAO6S,GAITje,OAAQ,WACN,IAAIutB,EAAMC,EAAMC,EAAMC,EAsCtB,GArCA/Z,OACAtI,GAAKoB,MACLrB,GAAKqB,MAQD9I,eAAe0H,KAAO1H,eAAeyH,MACvC/6B,KAAKg7B,IACLjC,SACAiC,GAAKoB,MACLp8B,KAAK+6B,IACLhC,SACAgC,GAAKqB,OAQH3J,aAAasI,MACfmiB,EAAOz9B,IAAIU,IAAI4a,KACfoiB,EAAO19B,IAAIU,IAAIA,IAAI4a,MACnBqiB,EAAOpiB,GACPD,GAAKmiB,EACLl9C,KAAKm9C,GACLn9C,KAAKo9C,GACLztB,SACAqL,GAAKoB,OAKHrB,KAAO4M,OAAO3wB,wBAGhB,OAFAhX,KAAKg7B,SACL6H,UAEK,GAAI7H,KAAO2M,OAAO3wB,wBAGvB,OAFAhX,KAAK+6B,SACL8H,UAGF,GAAI5N,SAAS8F,KAAO9F,SAAS+F,IAC3BpL,cACK,CACL,IAAMY,uBAAsBuK,MAAOvK,uBAAsBwK,MACvDh7B,KAAK+6B,IACL/6B,KAAKg7B,IACL9K,OACAsX,WACA6V,EAAoBjhB,MAChBtL,mBAAmBusB,IAGrB,OAFAhc,YAAYrqB,6BACZ6rB,UAMJ,GAAIzY,WAAakH,MAAMyJ,IAAK,CAG1B,IAFAA,GAAK5a,IAAI4a,IACT/6B,KAAK6sC,MACEjb,OAAOmJ,KACZ/6B,KAAKyf,IAAIsb,KACT/6B,KAAKg7B,IACLrL,SACA/U,MACAmgB,GAAK5a,IAAI4a,IAGX,YADA8H,UAGF,GAAIzY,WAAakH,MAAM0J,IAAK,CAG1B,IAFAA,GAAK7a,IAAI6a,IACTh7B,KAAK6sC,MACEjb,OAAOoJ,KACZh7B,KAAK+6B,IACL/6B,KAAKyf,IAAIub,KACTrL,SACA/U,MACAogB,GAAK7a,IAAI6a,IAGX,YADA6H,UASF,GANA7iC,KAAK+6B,IACL/6B,KAAKg7B,IAKD/F,SAAS8F,KAAOxK,cAAcyK,IAGhCyN,2BACK,GAAIlY,cAAcwK,KAAO9F,SAAS+F,IAGvCwI,0BACK,CACL,IAAIjT,cAAcwK,MAAOxK,cAAcyK,IAsBrC,OAPAoB,MACAA,MACAiF,YAAYhxB,OACZrQ,KAAK+6B,IACL/6B,KAAKg7B,IACL/E,KAAK,QACL4M,UAdAxK,YAmBN,OAAOwK,WAITjT,QAAU,WACR,IAAIsd,EAAGoQ,EAAInQ,EAAGoQ,EAAIpK,EAAGn1C,EAAGoxB,EAAIif,EAAG9Y,EAAIkY,EAAGiC,EAAIC,EAAIjvC,EAAG0zC,EAAIvG,EAAMrtC,EAAG8zC,EAAI9R,EAAKC,EAAMmN,EAAMC,EAAMC,EAAMC,EAAMC,EA6BrG,IA5BAhyC,EAAI,GACJ0C,EAAIq6B,GAAGwN,OAAOoF,IAAI5S,GAAGwN,OAAOsF,KAAO,MACzB7S,GAAGuN,OAAOoF,IAAI,IAEtBxG,KAAK,kCAEP0G,EAAO9S,GAAGwN,OAAOsF,KAAO7S,GAAGuN,OAAOsF,KAAO,GAC9Bl8B,QACTw1B,KAAK,yCAEP+F,EAAInS,GAAGwN,OAAO3gB,KACdulB,EAAInS,GAAGuN,OAAO3gB,KAgBd01B,EAAK,EACAt/C,EAAIwC,EAAI,EAAGgiC,EAAMzH,GAAGwN,OAAOsF,KAAO,EAAI,GAAKrL,EAAMhiC,EAAIgiC,EAAMhiC,EAAIgiC,EAAMxkC,EAAI,GAAKwkC,IAAQhiC,IAAMA,EAC/F88C,GAAMviB,GAAGwN,OAAOoF,IAAI3vC,GAGtB,IADAu/C,EAAK,EACAv/C,EAAIoxB,EAAK,EAAGqT,EAAOzH,GAAGuN,OAAOsF,KAAO,GAAKpL,EAAOrT,EAAKqT,EAAOrT,EAAKqT,EAAOzkC,EAAI,GAAKykC,IAASrT,IAAOA,EACpGmuB,GAAMviB,GAAGuN,OAAOoF,IAAI3vC,GAKtB,IAFAm1C,GADAlY,GAAK5f,aAAaiiC,EAAKC,IAChBhV,OAAO3gB,KAET5pB,EAAIu3B,EAAK,EAAGqa,EAAO0N,EAAK,GAAK1N,EAAOra,EAAKqa,EAAOra,EAAKqa,EAAO5xC,EAAI,GAAK4xC,IAASra,IAAOA,EACxF,IAAK8Y,EAAIqB,EAAK,EAAGG,EAAOnvC,EAAI,GAAKmvC,EAAOH,EAAKG,EAAOH,EAAKG,EAAOxB,EAAI,GAAKwB,IAASH,IAAOA,EACvF,IAAI5e,mBAAmBoc,EAAElvC,EAAI0C,EAAI2tC,IAGjC,IAAKZ,EAAIkC,EAAK,EAAGG,EAAOyN,EAAK,GAAKzN,EAAOH,EAAKG,EAAOH,EAAKG,EAAOrC,EAAI,GAAKqC,IAASH,IAAOA,EACxF3vC,KAAKktC,EAAElvC,EAAI0C,EAAI2tC,IACfruC,KAAKmtC,EAAEkB,EAAIkP,EAAK9P,IAChBpV,WACAr4B,KAAKmzC,EAAEn1C,EAAIu/C,EAAK9P,IAChB7yB,MACAu4B,EAAEn1C,EAAIu/C,EAAK9P,GAAKrR,MA8BtB,GAAa,IAATyR,EACF,OAAO7tC,KAAKi7B,GAAGsN,OAAO3gB,KAAK,IAI3B,IAFAqT,GAAGsN,OAAOsF,KAAOA,EACjBQ,EAAI,EACCrwC,EAAIo2C,EAAK,EAAGrE,EAAOhV,GAAGwN,OAAOsF,KAAO,EAAI,GAAKkC,EAAOqE,EAAKrE,EAAOqE,EAAKrE,EAAO/xC,EAAI,GAAK+xC,IAASqE,IAAOA,EACxGnZ,GAAGsN,OAAOoF,IAAI3vC,GAAK+8B,GAAGwN,OAAOoF,IAAI3vC,GAGnC,IADAqwC,EAAItT,GAAGwN,OAAOsF,KAAO,EAChB7vC,EAAIs2C,EAAK,EAAGtE,EAAOhV,GAAGuN,OAAOsF,KAAO,EAAI,GAAKmC,EAAOsE,EAAKtE,EAAOsE,EAAKtE,EAAOhyC,EAAI,GAAKgyC,IAASsE,IAAOA,EACxGrZ,GAAGsN,OAAOoF,IAAIU,EAAIrwC,GAAKg9B,GAAGuN,OAAOoF,IAAI3vC,EAAI,GAE3C,OAAOgC,KAAKi7B,KAOhBhN,uBAAwB,SAASuvB,EAAMC,GACrC,GAAK7rB,OAAO4rB,GAAZ,CAIA,GAAIr9B,IAAIq9B,KAAU7V,OAAOh1B,KAIzB,OAAI8f,aAAa+qB,IAEfvvB,uBAAsBxO,IAAIU,IAAIq9B,IAAQC,QACtCxvB,uBAAsB9N,IAAIA,IAAIq9B,IAAQC,IAGjCziC,0BAA0BwiC,EAAMC,GATrCD,EAAOvvB,uBAAsBxO,IAAI+9B,GAAOC,QAJxCziC,0BAA0BwiC,EAAMC,IAgBpCziC,0BAA4B,SAASwiC,EAAMC,GACzC,GAAID,IAAS7V,OAAOh1B,KAElB,OAAO8qC,EAAoBz9C,KAAKw9C,IAIpCnoB,KAAO,CAEL,WAEA,gBAEA,uBAKA,oBACA,wBACA,yBACA,aACA,eAEA,2BACA,+BACA,mCACA,uCAEA,2BAEA,2CAEA,kEAEA,4CAEA,uCAEA,sCAEA,8BAEA,gCAEA,sCAEA,oCAEA,8CAEA,kEAEA,4DAEA,oEAEA,uCAEA,wDAEA,sEAEA,mDAEA,kEAEA,yEAEA,8EAEA,oGAGA,sCAEA,mDAEA,qEAGA,gDAEA,4DAEA,mIAEA,wCAWA,kFAEA,oGAWA,wCAEA,yCAEA,yDAEA,2EAEA,iEAEA,sEAEA,mCAEA,kDAEA,oEAEA,yGAEA,kFAEA,gFAEA,0DAEA,sCAEA,0EAEA,sFAEA,2FAEA,kFAEA,+BAEA,uCAEA,gJAEA,iJAEA,2EAEA,oEAEA,yEAEA,0FAEA,yEAEA,8EAEA,gEAEA,uDAEA,0CAEA,gHAEA,0GAEA,0MAEA,2MAEA,oIAEA,qIAEA,kDAEA,iDAEA,8DAGA,sFAEA,2FAEA,gCAEA,wCAEA,2GAEA,8EAEA,mFAEA,iEAEA,6EAEA,0GAEA,uEAEA,iGAEA,0FAEA,0BAEA,yBAEA,+BAEA,gCAEA,uCAEA,kCAEA,qCAEA,+CAEA,yDAEA,qCAEA,8CAEA,yDAEA,kCAEA,6BAEA,wCAEA,kDAEA,wCAEA,2DAEA,yCAEA,2CAEA,4DAEA,iEAEA,iDAEA,8BAEA,6BAEA,2CAEA,0CAEA,qCAEA,wCAEA,2GAEA,2GAEA,0CAEA,4DAEA,0CAEA,4DAEA,iDAEA,iDAEA,oDAKA,qCAEA,yCAEA,wCAEA,oCAEA,uCAEA,sDAEA,qBAEA,qBAEA,0BAEA,iCAEA,iCAEA,+BAEA,yBAEA,+BAEA,iDAEA,0DAEA,uDAEA,kDAEA,wEACA,oFACA,gFACA,uCACA,2CACA,mDACA,uDACA,8DACA,oEACA,GAMFvqB,cAAgB,WACd,IAAkBskB,EAAI1uB,EAAGF,EAAGgiC,EAAKC,EAmCjC,IAlCI,EACJ/hC,EAAI,EAEJq6B,GAAK5a,IAAI4a,IACT/6B,KAAKyf,IAAIsb,KACTt0B,OAUAs0B,GAAK5a,IAAI4a,IACT/6B,KAAKyf,IAAIsb,KACTt0B,QACAu0B,GAAKoB,SACMuL,OAAOh1B,MAChB8b,QACAzuB,KAAK2nC,OAAOh1B,OACH4d,cAAcyK,KACvBvM,QACAzuB,KAAKg7B,MAELh7B,KAAKg7B,IACLD,GAAK5a,IAAI4a,IACT/6B,KAAKyf,IAAIsb,KACTt0B,QAEF00B,GAAKiB,MACLlB,GAAKkB,MACLnB,GAAKmB,QACK,CAYR,GAVI7L,cAAc4K,KAChBn7B,KAAKm7B,IACLz6B,EAAI67B,cACA8U,MAAM3wC,IACRymC,KAAK,0BAGPzmC,EAAI,EAENV,KAAKi7B,IACDv6B,GAAK,EACP,IAASF,EAAI,EAAGgiC,EAAM9hC,EAAI,GAAK8hC,EAAMhiC,EAAIgiC,EAAMhiC,EAAIgiC,EAAU,GAAKA,IAAQhiC,IAAMA,EAC9ER,KAAKk7B,IACLpL,gBAIF,IAASV,EAAK,EAAGqT,EADjB/hC,GAAKA,EACuB,GAAK+hC,EAAOrT,EAAKqT,EAAOrT,EAAKqT,EAAW,GAAKA,IAASrT,IAAOA,EACvFpvB,KAAKk7B,IACL3V,aAKJ,GAFA0V,GAAKmB,MAEDjB,KAAOwM,OAAOh1B,KAChB,MAaF,GAAI4d,cAAc4K,IAAK,CAKrB,GAJAJ,GAAK5a,IAAI4a,IACT/6B,KAAKyf,IAAIsb,KACTt0B,QACA00B,GAAKiB,SACMuL,OAAOh1B,KAChB,MAEE4d,cAAc4K,IACJ,GAEZD,GAAKC,GACLJ,GAAK5a,IAAI4a,IACT/6B,KAAKyf,IAAIsb,KACTt0B,OACA00B,GAAKiB,YAGPlB,GAAKC,GACLJ,GAAK5a,IAAI4a,IACT/6B,KAAKyf,IAAIsb,KACTt0B,OACA00B,GAAKiB,MAGT,OAAOp8B,KAAKi7B,KAGdnL,SAAW,WAkBT,OAjBAwT,OACAtI,GAAKoB,MACLrB,GAAKqB,MACD3c,IAAIsb,MAAQ4M,OAAOxmC,KACrB8uB,kBACSxQ,IAAIsb,MAAQ4M,OAAOn1B,UAC5Bwd,sBAEAD,mBAEFgL,GAAKqB,MACDtsB,MAAKirB,GAAI4M,OAAOr3B,YAClB62B,KAAK,8CAEPnnC,KAAK+6B,IACL4K,WACAl/B,OACOo8B,WAGT5S,gBAAkB,WAChB,IAAI2d,EAOJ,IANA7S,GAAK5a,IAAI4a,IACT/6B,KAAKyf,IAAIsb,KACT/6B,KAAKg7B,IACLlL,WACAiL,GAAK5a,IAAI4a,IACT6S,EAAU,GACHhc,OAAOmJ,KACZ/6B,KAAKyf,IAAIsb,KACT/6B,KAAKg7B,IACLlL,WACAlV,MACAgzB,EAAQ5tC,KAAK+6B,GAAK5a,IAAI4a,KAExB,OAAO6S,GAGT5d,oBAAsB,WAMpB,OALAhwB,KAAK+6B,IACL/6B,KAAKg7B,IACLa,YACAd,GAAKqB,MACLrM,mBACOsI,YAGTtI,iBAAmB,WACjB,IAAI2tB,EAAIC,EAGR,OAFAD,EAAKpoB,eAAeyF,GAAIC,IAAI4a,QAAQ,IACpC+H,EAAM1uB,YAAYyuB,KAUlB19C,KAAK+6B,IACL/6B,KAAKg7B,IACLoO,WAAUuU,GAAK,IACf1iB,GAAKmB,SACMuL,OAAOh1B,MAChB0uB,YAAY/wB,UACZtQ,KAAK+6B,IACL/6B,KAAKg7B,IACE/E,KAAK,IAELj2B,KAAKi7B,MAhBZoG,YAAY/wB,UACZtQ,KAAK+6B,IACL/6B,KAAKg7B,SACL/E,KAAK,KAuBTjH,gBAAkB,CAChB,EAAK,OACL,SAAY,QACZ,SAAY,mBACZ,UAAa,mBACb,IAAO,mBACP,OAAU,mBACV,IAAO,mBACP,OAAU,mBACV,IAAO,mBACP,OAAU,mBACV,KAAQ,mBACR,KAAQ,mBACR,KAAQ,mBACR,IAAO,kBACP,IAAO,oBAGTsG,eAAiB,SAASsoB,EAAGnP,GAC3B,IAAIoP,EACJ,GAAI9oB,SAAS6oB,GACX,OAAIx0B,MAAMw0B,EAAGnP,GACJzf,gBAAgByf,EAEhBzf,gBAAgBopB,SAEpB,GAAIxmB,OAAOgsB,GAChB,OAAQ1V,OAAOzoB,IAAIm+B,KACjB,KAAKz8C,IACH,OAAOytB,cAAczO,IAAIy9B,GAAInP,GAC/B,KAAKj8B,SACH,OAAOsc,oBAAoB3O,IAAIy9B,GAAInP,GACrC,KAAK16B,MACH,OAAOgb,WAAWxP,KAAKq+B,GAAIt+B,MAAMs+B,GAAInP,GACvC,KAAKpoC,IACH,OAAO0oB,WAAW4Y,OAAOjiC,GAAI6Z,KAAKq+B,GAAInP,GACxC,KAAKv4B,KAGH,OAFA6qB,YAAY,IACZ8c,EAAOzhB,MACArN,WAAWxP,KAAKq+B,GAAIC,EAAMpP,GACnC,QACE,OAAO5f,cAAc+uB,EAAGnP,GAG9B,OAAOzf,gBAAgBopB,UAGzBvpB,cAAgB,SAAS+uB,EAAGnP,GAC1B,IAAIqP,EAAU5E,EAAMp4C,EACpB,IAAKgP,MAAKyP,KAAKq+B,GAAInP,GACjB,OAAOzf,gBAAgBopB,SAKzB,GAHAt3C,EAAO2e,IAAIm+B,GACXE,EAAWxoB,eAAe/V,KAAKq+B,GAAInP,KACnCyK,EAAOlqB,gBAAgBluB,EAAKwsC,YAE1B,MAAM,IAAIyQ,MAAM,wBAA0Bj9C,EAAKwsC,WAEjD,OAAOiB,KAAKoC,IAAIuI,EAAM4E,IAGxBlvB,cAAgB,SAASovB,EAAOvP,GAC9B,IAAIhB,EAAGwQ,EAAKC,EAAiBC,EAE7B,IADAA,EAAW,GACJvsB,OAAOosB,IACZE,EAAOz+B,IAAIu+B,GACXA,EAAQ79B,IAAI69B,GACA,EASZG,GARIruC,MAAKouC,EAAMzP,GACDnZ,eAAe4oB,EAAMzP,GAKrBzf,gBAAgBopB,UAEXxC,QAAQ,KAAM,EAGnC,IAAKnI,KADLwQ,EAAM,EACIE,EACHpR,QAAQltC,KAAKs+C,EAAU1Q,KACxB0Q,EAAS1Q,GACbwQ,GAAYxG,WAAWhK,EAAG,KAE5B,OAAOwQ,GAGTnvB,oBAAsB,SAASkvB,EAAOvP,GACpC,IAAI2P,EAASF,EAEb,IADAE,EAAU,EACHxsB,OAAOosB,IACZE,EAAOz+B,IAAIu+B,GACXA,EAAQ79B,IAAI69B,GACRluC,MAAKouC,EAAMzP,KACb2P,GAAoB9oB,eAAe4oB,EAAMzP,IAG7C,OAAO2P,GAGTrvB,WAAa,SAASmqB,EAAM1c,EAAOiS,GACjC,IAAI4P,EAAWC,EAMf,GALAD,EAAYrvB,gBAAgBopB,SAC5BkG,EAAWtvB,gBAAgBuvB,SACvBzuC,MAAKopC,EAAMzK,KACb4P,EAAY/oB,eAAe4jB,EAAMzK,IAE/B3+B,MAAK0sB,EAAOiS,GACd6P,EAAWhpB,eAAekH,EAAOiS,OAC5B,CAEL,GAAI4P,IAAcrvB,gBAAgBopB,SAChC,OAAOppB,gBAAgBopB,SAErBrlB,WAAWyJ,GACb8hB,GAAY,EACH1qB,aAAa4I,GACtB8hB,EAAW,GACFrrB,kBAAkBuJ,GAC3B8hB,GAAY,GACHh1B,OAAOkT,EAAO,EAAG,GAC1B8hB,EAAW,EACFh1B,OAAOkT,GAAQ,EAAG,KAC3B8hB,GAAY,GAGhB,OAAO/P,KAAKoC,IAAI0N,EAAWC,IAG7B5nB,iBAAmB,WACjB,IAAI8nB,EAAMv/C,EAAKnB,EAAK0C,EAAGivC,EAAGkO,EAAKC,EAE/B,IADAD,EAAM,GACDn9C,EAAI,EAAG1C,EAAMu3B,KAAKt3B,OAAQyC,EAAI1C,IACjC2xC,EAAIpa,KAAK70B,IAD6BA,IAKtCwjC,UAAUyL,GACV+O,EAAIpiB,MACJwhB,EAAIr+B,KAAKi/B,GAGJb,EADL1+C,EADIq2B,eAAesoB,EAAGjW,OAAOv1B,QACrBwjC,QAAQ,MAEd+H,EAAI1+C,GAAO,IAEb0+C,EAAI1+C,GAAKe,KAAKyvC,GAGhB,OADAT,QAAQE,IAAI,iBAAmBuP,KAAKC,UAAUf,EAAK,KAAM,IAClDA,GAGT18C,EAAEy1B,iBAAmBA,iBAMrBzH,YAAc,CACZ,SAAY,CAAC,YACb,WAAY,CAAC,iBACb,WAAY,CAAC,wBACb,SAAY,CAAC,qBACb,SAAY,CAAC,yBACb,QAAY,CAAC,0BACb,WAAY,CAAC,cACb,QAAY,CAAC,gBACb,SAAY,CAAC,2BAA4B,4CACzC,SAAY,CAAC,gCACb,SAAY,CAAC,oCACb,SAAY,CAAC,wCACb,SAAY,CAAC,4BACb,QAAY,CAAC,kEAAmE,4CAA6C,8EAA+E,qGAC5M,QAAY,CAAC,uCAAwC,sCAAuC,uCAC5F,QAAY,CAAC,+BACb,QAAY,CAAC,iCACb,SAAY,CAAC,uCACb,QAAY,CAAC,qCACb,QAAY,CAAC,+CACb,QAAY,CAAC,mEACb,QAAY,CAAC,6DACb,SAAY,CAAC,qEACb,QAAY,CAAC,wCACb,QAAY,CAAC,yDACb,SAAY,CAAC,uEACb,QAAY,CAAC,oDACb,QAAY,CAAC,mEACb,QAAY,CAAC,0EACb,QAAY,CAAC,uCACb,QAAY,CAAC,oDACb,QAAY,CAAC,sEACb,QAAY,CAAC,iDACb,QAAY,CAAC,6DACb,QAAY,CAAC,oIACb,QAAY,CAAC,yCACb,QAAY,CAAC,kFAAmF,qGAChG,WAAY,CAAC,yCACb,WAAY,CAAC,0CACb,SAAY,CAAC,0DACb,SAAY,CAAC,4EACb,SAAY,CAAC,kEACb,SAAY,CAAC,uEACb,WAAY,CAAC,oCACb,QAAY,CAAC,mDACb,QAAY,CAAC,qEACb,QAAY,CAAC,yGAA0G,mFACvH,QAAY,CAAC,iFACb,SAAY,CAAC,0DAA2D,8DAA+D,iGAAkG,2FACzO,QAAY,CAAC,0EAA2E,sFAAuF,uFAC/K,WAAY,CAAC,2FAA4F,kFAAmF,4FAC5L,WAAY,CAAC,+BAAgC,iCAC7C,SAAY,CAAC,uCAAwC,yCACrD,SAAY,CAAC,gJAAiJ,kJAC9J,QAAY,CAAC,4EACb,WAAY,CAAC,qEACb,SAAY,CAAC,0EACb,SAAY,CAAC,0FAA2F,4GACxG,SAAY,CAAC,yEAA0E,8EAA+E,8EAA+E,0GAA2G,wEAChW,QAAY,CAAC,gEAAiE,oFAC9E,QAAY,CAAC,uDAAwD,gHAAiH,2GACtL,QAAY,CAAC,0CAA2C,kEACxD,WAAY,CAAC,0MAA2M,4MACxN,SAAY,CAAC,oIAAqI,sIAClJ,QAAY,CAAC,kDAAmD,kDAChE,SAAY,CAAC,8EACb,SAAY,CAAC,2BACb,SAAY,CAAC,0BACb,SAAY,CAAC,gCACb,QAAY,CAAC,iCACb,QAAY,CAAC,wCACb,QAAY,CAAC,mCACb,SAAY,CAAC,sCACb,WAAY,CAAC,+CAAgD,0DAC7D,SAAY,CAAC,sCACb,SAAY,CAAC,8CAA+C,0DAC5D,QAAY,CAAC,mCACb,QAAY,CAAC,8BACb,SAAY,CAAC,yCACb,WAAY,CAAC,mDACb,SAAY,CAAC,yCACb,SAAY,CAAC,4DACb,QAAY,CAAC,0CACb,QAAY,CAAC,4CACb,QAAY,CAAC,6DACb,QAAY,CAAC,kEACb,QAAY,CAAC,kDACb,SAAY,CAAC,+BACb,SAAY,CAAC,8BACb,QAAY,CAAC,2CAA4C,0CAA2C,4GACpG,QAAY,CAAC,qCAAsC,wCAAyC,4GAC5F,SAAY,CAAC,2CACb,SAAY,CAAC,6DACb,SAAY,CAAC,2CACb,QAAY,CAAC,6DACb,SAAY,CAAC,kDACb,SAAY,CAAC,kDACb,SAAY,CAAC,qDACb,SAAY,CAAC,sCACb,SAAY,CAAC,0CACb,SAAY,CAAC,yCACb,QAAY,CAAC,qCACb,SAAY,CAAC,wCACb,SAAY,CAAC,uDACb,SAAY,CAAC,sBACb,SAAY,CAAC,sBACb,WAAY,CAAC,2BACb,SAAY,CAAC,kCACb,SAAY,CAAC,kCACb,SAAY,CAAC,gCACb,SAAY,CAAC,0BACb,SAAY,CAAC,gCACb,SAAY,CAAC,kDACb,WAAY,CAAC,2DACb,SAAY,CAAC,wDACb,SAAY,CAAC,mDACb,WAAY,CAAC,wEAAyE,qFACtF,SAAY,CAAC,iFACb,SAAY,CAAC,wCACb,SAAY,CAAC,4CACb,SAAY,CAAC,oDACb,SAAY,CAAC,wDACb,WAAY,CAAC,+DACb,SAAY,CAAC,sEAwBfxe,cAAgB,WACd,OAAKwkB,SAAS8F,IAEgB,IAAnBA,GAAGwN,OAAOsF,MAEV9S,GAAGwN,OAAOoF,IAAI,KAAO5S,GAAGwN,OAAOoF,IAAI,GADrC,EAIA,EANA,GAUXzd,KAAM,WACJ,IAAIknB,EAAauH,EAAiBn+C,EAAGgiC,EAQrC,GAPI,EACA,EAEJc,OACAvI,GAAKqB,MAGDvJ,MAAMkI,IAGR,OAFA/6B,KAAKyf,IAAIU,IAAI4a,WACb8H,UAKF,GAAIxQ,iBAAiB0I,IAGnB,OAFA/6B,KAAK+6B,SACL8H,UASF,IAAIzY,YAAaqI,aAAasI,IAiB9B,OAAwB,IAApBtqB,iBACF4wB,YAAY9wB,KACZvQ,KAAK+6B,IACL9E,KAAK,QACL4M,YAGErS,uBAAsBuK,IACxBkR,UAEAjsC,KAAK+6B,IACL3f,MACApb,KAAK+6B,IACLtV,MACAuV,GAAKoB,MACDtL,mBAAmBkK,KACrBmM,KAAK,8BAEPnnC,KAAKg7B,IACL9U,UAEK2c,WAnCL,IAFA9H,GAAK5a,IAAI4a,IACTqc,EAAc,GACPxlB,OAAOmJ,KACZqc,EAAYp3C,KAAKyf,IAAIsb,KACrBA,GAAK5a,IAAI4a,IAEX,IAAK4jB,EAAYn+C,EAAIgiC,EAAM4U,EAAYr5C,OAAS,EAAIykC,GAAO,EAAIhiC,GAAK,EAAIA,GAAK,EAAIm+C,EAAYnc,GAAO,IAAMhiC,IAAMA,EAC9GR,KAAKo3C,EAAYuH,IACjBzuB,OACIyuB,IAAcvH,EAAYr5C,OAAS,GACrC4xB,SAGJkT,WA2BJxS,KAAO,WAGL,OAFAiT,OACAvI,GAAKqB,MACmB,IAApB3rB,iBACF4wB,YAAY7wB,MACZxQ,KAAK+6B,IACL9E,KAAK,QACL4M,YAGFoJ,SACOpJ,YAIToJ,OAAS,WACP,IAAI8B,EAAG/vC,EAAGoxB,EAAIif,EAAG9Y,EAAIma,EAAIhvC,EAAGF,EAAGgiC,EAAKC,EAAMmN,EAAMC,EAOhD,IANI,EACJ7xC,EAAI,EACJqwC,EAAI,EACA,EACJ3tC,EAAIq6B,GAAGwN,OAAOoF,IAAI,GAClBI,EAAI5E,IACCnrC,EAAIwC,EAAI,EAAGgiC,EAAM9hC,EAAI,GAAK8hC,EAAMhiC,EAAIgiC,EAAMhiC,EAAIgiC,EAAMxkC,EAAI,GAAKwkC,IAAQhiC,IAAMA,EAC9E,IAAK6tC,EAAIjf,EAAK,EAAGqT,EAAO/hC,EAAI,GAAK+hC,EAAOrT,EAAKqT,EAAOrT,EAAKqT,EAAO4L,EAAI,GAAK5L,IAASrT,IAAOA,EAErFpvB,KADEhC,IAAMqwC,EACH9T,IAEAsS,MAIX,IAAK7uC,EAAIu3B,EAAK,EAAGqa,EAAOlvC,EAAIA,EAAI,GAAKkvC,EAAOra,EAAKqa,EAAOra,EAAKqa,EAAO5xC,EAAI,GAAK4xC,IAASra,IAAOA,EAC3Fv1B,KAAK+6B,GAAGwN,OAAO3gB,KAAK5pB,IAOtB,IALA0S,WAAWhQ,IACXq6B,GAAK1f,aAAa3a,EAAIA,IACnB6nC,OAAOsF,KAAO,EACjB9S,GAAGwN,OAAOoF,IAAI,GAAKjtC,EACnBq6B,GAAGwN,OAAOoF,IAAI,GAAKjtC,EACd1C,EAAI0xC,EAAK,EAAGG,EAAOnvC,EAAIA,EAAI,GAAKmvC,EAAOH,EAAKG,EAAOH,EAAKG,EAAO7xC,EAAI,GAAK6xC,IAASH,IAAOA,EAC3F3U,GAAGwN,OAAO3gB,KAAK5pB,GAAK8oC,MAAMiH,EAAI/vC,GAGhC,OADAy5B,QAAQ0R,IAAM,EAAIzoC,EAAIA,GACfV,KAAK+6B,KAmBdrqB,WAAa,SAAShQ,GACpB,IAAIwsC,EAAGM,EAAGxvC,EAAGoxB,EAAIif,EAAG9Y,EAAIma,EAAIlvC,EAAGgiC,EAAKC,EAAMmN,EAAMC,EAAMC,EAAMlC,EAASgQ,EASrE,IARI,EACJpQ,EAAI,EACJxvC,EAAI,EACJqwC,EAAI,EACA,EAEJuP,GADA1Q,EAAI/D,IAAMzoC,EAAIA,GACNA,EAAIA,EACZktC,EAAU,GACLJ,EAAIhtC,EAAI,EAAGgiC,EAAM9hC,EAAI,GAAK8hC,EAAMhiC,EAAIgiC,EAAMhiC,EAAIgiC,EAAMgL,EAAI,GAAKhL,IAAQhiC,IAAMA,EAAG,CAEjF,GAAI4oB,MAAM0d,MAAMoG,EAAIxsC,EAAI8sC,EAAIA,GAAIX,MAAO,CAErC,IAAK7uC,EAAIoxB,EAAKqT,EAAO+K,EAAI,EAAGoC,EAAOlvC,GAAI+hC,GAAQmN,EAAOxgB,EAAKwgB,EAAOxgB,EAAKwgB,IAChExmB,MAAM0d,MAAMoG,EAAIxsC,EAAI1C,EAAIwvC,GAAIX,MAD2C7uC,EAAIykC,GAAQmN,IAASxgB,IAAOA,GAS1G,IAJIpxB,IAAM0C,GACRymC,KAAK,8BAGFkH,EAAI9Y,EAAK,EAAGsa,EAAOnvC,EAAI,GAAKmvC,EAAOta,EAAKsa,EAAOta,EAAKsa,EAAOxB,EAAI,GAAKwB,IAASta,IAAOA,EACvFyF,GAAK8L,MAAMoG,EAAIxsC,EAAI8sC,EAAIa,GACvBvH,MAAMoG,EAAIxsC,EAAI8sC,EAAIa,GAAKvH,MAAMoG,EAAIxsC,EAAI1C,EAAIqwC,GACzCvH,MAAMoG,EAAIxsC,EAAI1C,EAAIqwC,GAAKrT,GACvBA,GAAK8L,MAAM8W,EAAIl9C,EAAI8sC,EAAIa,GACvBvH,MAAM8W,EAAIl9C,EAAI8sC,EAAIa,GAAKvH,MAAM8W,EAAIl9C,EAAI1C,EAAIqwC,GACzCvH,MAAM8W,EAAIl9C,EAAI1C,EAAIqwC,GAAKrT,GAK3B,IADAA,GAAK8L,MAAMoG,EAAIxsC,EAAI8sC,EAAIA,GAClBa,EAAIqB,EAAK,EAAGI,EAAOpvC,EAAI,GAAKovC,EAAOJ,EAAKI,EAAOJ,EAAKI,EAAOzB,EAAI,GAAKyB,IAASJ,IAAOA,EACnFrB,EAAIb,IACNxtC,KAAK8mC,MAAMoG,EAAIxsC,EAAI8sC,EAAIa,IACvBruC,KAAKg7B,IACL9U,SACA4gB,MAAMoG,EAAIxsC,EAAI8sC,EAAIa,GAAKjS,OAEzBp8B,KAAK8mC,MAAM8W,EAAIl9C,EAAI8sC,EAAIa,IACvBruC,KAAKg7B,IACL9U,SACA4gB,MAAM8W,EAAIl9C,EAAI8sC,EAAIa,GAAKjS,MAEzBwR,EAAQ5tC,KAAM,WACZ,IAAI2vC,EAAII,EAAM0J,EAGd,IADAA,EAAW,GACNz7C,EAAI2xC,EAAK,EAAGI,EAAOrvC,EAAI,GAAKqvC,EAAOJ,EAAKI,EAAOJ,EAAKI,EAAO/xC,EAAI,GAAK+xC,IAASJ,IAAOA,EACnF3xC,IAAMwvC,IAIVxS,GAAK8L,MAAMoG,EAAIxsC,EAAI1C,EAAIwvC,GACvBiM,EAASz5C,KAAM,WACb,IAAIo0C,EAAIpE,EAAM4O,EAGd,IADAA,EAAW,GACNvQ,EAAI+F,EAAK,EAAGpE,EAAOtvC,EAAI,GAAKsvC,EAAOoE,EAAKpE,EAAOoE,EAAKpE,EAAO3B,EAAI,GAAK2B,IAASoE,IAAOA,EACnF/F,EAAIb,IACNxtC,KAAK8mC,MAAMoG,EAAIxsC,EAAI1C,EAAIqwC,IACvBruC,KAAK8mC,MAAMoG,EAAIxsC,EAAI8sC,EAAIa,IACvBruC,KAAKg7B,IACL3C,WACAmP,WACAV,MAAMoG,EAAIxsC,EAAI1C,EAAIqwC,GAAKjS,OAEzBp8B,KAAK8mC,MAAM8W,EAAIl9C,EAAI1C,EAAIqwC,IACvBruC,KAAK8mC,MAAM8W,EAAIl9C,EAAI8sC,EAAIa,IACvBruC,KAAKg7B,IACL3C,WACAmP,WACAoX,EAAS5+C,KAAK8mC,MAAM8W,EAAIl9C,EAAI1C,EAAIqwC,GAAKjS,OAEvC,OAAOwiB,EApBM,KAuBjB,OAAOnF,EAjCK,IAoChB,OAAO7L,GAGTxpC,UAAW,EASXysB,WAAa,SAAS6d,GACpB,OAAQA,EAAEjB,GACR,KAAKp6B,IACH,OAAOZ,MAAMi8B,EAAErB,EAAEH,GACnB,KAAK5nC,OACH,OAAe,IAARopC,EAAElB,EACX,QACE,OAAO,IAQbxc,aAAe,SAAS0d,GACtB,IAAI1wC,EAAGwC,EAAGgiC,EACV,GAAIkM,EAAEjB,IAAM51B,OACV,OAAO,EAET,IAAK7Z,EAAIwC,EAAI,EAAGgiC,EAAMkM,EAAEnG,OAAOuF,MAAQ,GAAKtL,EAAMhiC,EAAIgiC,EAAMhiC,EAAIgiC,EAAMxkC,EAAI,GAAKwkC,IAAQhiC,IAAMA,EAC3F,IAAKswB,mBAAmB4d,EAAEnG,OAAO3gB,KAAK5pB,IACpC,OAAO,EAGX,OAAO,GAOT8yB,mBAAqB,SAAS4d,GAC5B,OAAO7d,WAAW6d,IAAM1d,aAAa0d,IAYvC3d,sCAAwC,SAAS8tB,GAC/C,IAAIC,EASJ,GAPA9+C,KAAK6+C,GAGLtyC,iBACAuyC,EAAkB1iB,MAGdtL,mBAAmBguB,GACrB,OAAO,EAOT,GAAItuB,uBAAsBsuB,GACxB,OAAO,EAwBT,GAfA9+C,KAAK8+C,GACLhS,UACAgS,EAAkB1iB,MAadtL,mBAAmBguB,GACrB,OAAO,EAET,GAAItuB,uBAAsBsuB,GACxB,OAAO,EAUT,GAAIhvC,MAAKgvC,EAAiBxvB,eAAgB,CAMxC,GALAtvB,KAAK8+C,GACLrkC,cACAlO,iBACAuyC,EAAkB1iB,MAEdtL,mBAAmBguB,GACrB,OAAO,EAET,GAAItuB,uBAAsBsuB,GACxB,OAAO,EAQX,OAAO,MAITzrB,iBAAmB,SAASqb,GAC1B,OAAQA,EAAEjB,GACR,KAAKp6B,IACH,IAAsB,IAAlBd,MAAMm8B,EAAErB,EAAEH,GACZ,OAAO,EAET,MACF,KAAK5nC,OACH,GAAIopC,EAAElB,EAAI,EACR,OAAO,EAGb,OAAO,GAITjZ,iBAAmB,SAASma,GAC1B,OAAQA,EAAEjB,GACR,KAAKp6B,IACH,GAAqB,IAAjBd,MAAMm8B,EAAErB,EAAEH,GACZ,OAAO,EAET,MACF,KAAK5nC,OACH,GAAIopC,EAAElB,EAAI,EACR,OAAO,EAGb,OAAO,GAIT1Z,UAAY,SAAS4a,GACnB,OAAQA,EAAEjB,GACR,KAAKp6B,IACH,GAAIpB,OAAOy8B,EAAErB,EAAEH,EAAG,IAAMj7B,OAAOy8B,EAAErB,EAAEF,EAAG,GACpC,OAAO,EAET,MACF,KAAK7nC,OACH,GAAY,IAARopC,EAAElB,EACJ,OAAO,EAGb,OAAO,GAIT3Z,UAAY,SAAS6a,GACnB,OAAQA,EAAEjB,GACR,KAAKp6B,IACH,GAAIpB,OAAOy8B,EAAErB,EAAEH,EAAG,IAAMj7B,OAAOy8B,EAAErB,EAAEF,EAAG,GACpC,OAAO,EAET,MACF,KAAK7nC,OACH,GAAY,IAARopC,EAAElB,EACJ,OAAO,EAGb,OAAO,GAGTza,WAAa,SAAS2b,GACpB,OAAQA,EAAEjB,GACR,KAAKp6B,IACH,GAAIpB,OAAOy8B,EAAErB,EAAEH,GAAI,IAAMj7B,OAAOy8B,EAAErB,EAAEF,EAAG,GACrC,OAAO,EAET,MACF,KAAK7nC,OACH,IAAa,IAATopC,EAAElB,EACJ,OAAO,EAGb,OAAO,GAGT/Z,MAAQ,SAASib,GACf,OAAO7a,UAAU6a,IAAM3b,WAAW2b,IAGpChc,UAAY,SAASgc,GACnB,OAAIA,EAAEjB,IAAMp6B,KAAOpB,OAAOy8B,EAAErB,EAAEF,EAAG,GACxB,EAEA,GAIXva,wBAA0B,SAAS8b,GACjC,OAAIA,EAAEjB,IAAMnoC,OACNopC,EAAElB,IAAMe,KAAKyD,MAAMtD,EAAElB,GAChB,EAEF,EAEF9a,UAAUgc,IAGnBnb,qBAAuB,SAASmb,GAC9B,OAAIha,WAAWga,IAAMz8B,OAAOy8B,EAAErB,EAAEF,EAAG,IAAuB,IAAjB56B,MAAMm8B,EAAErB,EAAEH,GAC1C,EAEA,GAIX5Y,SAAW,SAASoa,GAClB,OAAIhc,UAAUgc,IAAuB,IAAjBn8B,MAAMm8B,EAAErB,EAAEH,GACrB,EAEA,GAKX9X,mCAAqC,SAASsZ,EAAGD,GAU/C,OATI1qC,OACFirC,QAAQE,IAAI,0CAA4CR,EAAI,OAASD,GAE9D,MAALA,IACFzuC,KAAK0uC,GACLjgB,QACAggB,EAAIrS,MACJA,OAEEjI,6BAA6Bua,EAAGD,IAAO3+B,MAAK4+B,EAAG/G,OAAOrwB,WAAaxH,MAAK4+B,EAAG/G,OAAOnwB,WAAa1H,MAAK4+B,EAAG/G,OAAOlwB,aAAe,EACxHg3B,EAEA,GAQXta,6BAA+B,SAASua,EAAGD,GACzC,OAAOra,oCAAoCsa,EAAGD,IAGhDra,oCAAsC,SAASsa,EAAGD,GAChD,GAAIhvB,IAAIivB,KAAO/G,OAAOn1B,UAAW,CAE/B,IADAk8B,EAAIvuB,IAAIuuB,GACD9c,OAAO8c,IAAI,CAIhB,GAHI3qC,OACFirC,QAAQE,IAAI,+CAAiDzvB,IAAIivB,KAE9Dra,mCAAmC5U,IAAIivB,GAAID,GAI9C,OAHI1qC,OACFirC,QAAQE,IAAI,uBAAyBzvB,IAAIivB,IAEpC,EAETA,EAAIvuB,IAAIuuB,GAEV,OAAO,EAEP,OAAOra,mCAAmCqa,EAAGD,IAIjDpa,mCAAqC,SAASqa,EAAGD,GAC/C,OAAIhvB,IAAIivB,KAAO/G,OAAO5zB,QAChBhQ,OACFirC,QAAQE,IAAI,2DAA6D5a,SAAShV,MAAMovB,IAAK3qC,MAAQirC,QAAQE,IAAI,2EAA6Elb,wBAAwBzU,KAAKmvB,GAAID,SAAM,IAEhOna,SAAShV,MAAMovB,KAAO1a,wBAAwBzU,KAAKmvB,GAAID,KAE1D1qC,OACFirC,QAAQE,IAAI,gFAAkFR,GAEzF1a,wBAAwB0a,EAAGD,KAKtC1a,mBAAqB,SAAS2a,EAAGD,GAC/B,OAAI3+B,MAAK4+B,EAAGD,GACHza,wBAAwB0a,EAAGD,GAE3B,GAIXza,wBAA0B,SAAS0a,EAAGD,GACpC,GAAIhvB,IAAIivB,KAAO/G,OAAOxmC,KAAM,CAE1B,IADAutC,EAAIvuB,IAAIuuB,GACD9c,OAAO8c,IAAI,CAChB,IAAKxa,wBAAwBzU,IAAIivB,GAAID,GACnC,OAAO,EAETC,EAAIvuB,IAAIuuB,GAEV,OAAO,EAEP,OAAOxa,wBAAwBwa,EAAGD,IAItCva,wBAA0B,SAASwa,EAAGD,GACpC,GAAIhvB,IAAIivB,KAAO/G,OAAOn1B,UAAW,CAE/B,IADAk8B,EAAIvuB,IAAIuuB,GACD9c,OAAO8c,IAAI,CAChB,IAAKza,0BAA0BxU,IAAIivB,GAAID,GACrC,OAAO,EAETC,EAAIvuB,IAAIuuB,GAEV,OAAO,EAEP,OAAOza,0BAA0Bya,EAAGD,IAIxCxa,0BAA4B,SAASya,EAAGD,GACtC,OAAIrlB,MAAMslB,EAAGD,GACJ,EAELhvB,IAAIivB,KAAO/G,OAAO5zB,QAAUqV,MAAM7J,KAAKmvB,GAAID,GACzCna,SAAShV,MAAMovB,IACV,EAEA,EAGP5+B,MAAK4+B,EAAGD,GACH,EAEA,GAKXnb,eAAiB,SAASob,GACxB,OAAIrb,iBAAiBqb,IAEVjvB,IAAIivB,KAAO/G,OAAOn1B,WAAa6gB,iBAAiB9T,KAAKmvB,IADvD,EAIA,GAIX/f,4BAA8B,SAAS+f,GACrC,OAAIjvB,IAAIivB,KAAO/G,OAAO5zB,QAAU2gB,WAAWjV,IAAIU,IAAIA,IAAIuuB,OAASrb,iBAAiB5T,IAAIU,IAAIuuB,MACnFtqC,UACF4qC,QAAQE,IAAI,gCAAkCR,EAAE/tC,WAAa,4BAExD,IAEHyD,UACF4qC,QAAQE,IAAI,gCAAkCR,EAAE/tC,WAAa,+BAExD,IAIX4xB,wBAA0B,SAASmc,GACjC,OAAKjvB,IAAIivB,KAAO/G,OAAOn1B,WAA2B,IAAdzU,OAAO2wC,IAAY3c,SAASxS,KAAKmvB,KAAO/f,4BAA4BrP,MAAMovB,KAAQtlB,MAAMslB,EAAGpf,eACtH,EAEA,GAIXgD,kBAAoB,SAASoc,GAC3B,OAAKjvB,IAAIivB,KAAO/G,OAAOn1B,WAA2B,IAAdzU,OAAO2wC,IAAYne,cAAchR,KAAKmvB,KAAOtlB,MAAM9J,MAAMovB,GAAIpf,gBAAmBlG,MAAMslB,EAAGpf,gBAAkBX,4BAA4BrP,MAAMovB,KAC3KtqC,UACF4qC,QAAQE,IAAI,sBAAwBR,EAAE/tC,WAAa,wBAE9C,IAEHyD,UACF4qC,QAAQE,IAAI,sBAAwBR,EAAE/tC,WAAa,8BAE9C,IAIXgxB,sBAAwB,SAAS+c,GAC/B,OAAKjvB,IAAIivB,KAAO/G,OAAOxmC,MAAsB,IAAdpD,OAAO2wC,IAAY3c,SAASxS,KAAKmvB,KAAOnc,wBAAwBjT,MAAMovB,KAAQnc,wBAAwBmc,GAC5H,EAEA,GAIXhd,gBAAkB,SAASgd,GAIzB,OAAKjvB,IAAIivB,KAAO/G,OAAOxmC,MAAsB,IAAdpD,OAAO2wC,IAAYne,cAAchR,KAAKmvB,KAAOpc,kBAAkBhT,MAAMovB,KAAQpc,kBAAkBoc,IACxH3qC,OACFirC,QAAQE,IAAI,oBAAsBR,EAAE/tC,WAAa,wBAE5C,IAEHoD,OACFirC,QAAQE,IAAI,oBAAsBR,EAAE/tC,WAAa,wBAE5C,IAIXqxB,cAAgB,SAAS0c,GACvB,OAAIhc,UAAUgc,IAAMA,EAAErB,EAAEH,EAAE6R,SACjB,EAEA,GAIX3rB,WAAa,SAASsb,GACpB,OAAIjvB,IAAIivB,KAAO/G,OAAOxmC,MAAQmyB,eAAe/T,KAAKmvB,KAEvCpb,eAAeob,GADjB,EAIA,GAUX1Z,YAAa,SAAS0Z,GACpB,GAAI3Z,SAAS2Z,GACX,OAAO,EAEP,KAAO9c,OAAO8c,IAAI,CAChB,GAAI1Z,YAAWvV,IAAIivB,IACjB,OAAO,EAETA,EAAIvuB,IAAIuuB,GAEV,OAAO,GAKX/b,gBAAkB,SAAS+b,GACzB,OAAOhc,UAAUgc,IAAMjvB,IAAIivB,KAAO/G,OAAO5zB,QAAU2e,UAAUnT,KAAKmvB,KAAOhc,UAAUpT,MAAMovB,KAG3Fpe,yBAA2B,SAASoe,GAClC,OAAOtc,WAAWsc,IAAMz8B,OAAOy8B,EAAErB,EAAEH,EAAE1yB,MAAO,IAG9CkZ,UAAY,SAASgb,GACnB,OAAOjvB,IAAIivB,KAAO/G,OAAO5zB,QAAUgf,WAAWzT,MAAMovB,KAGtDtc,WAAa,SAASsc,GACpB,OAAOA,EAAEjB,IAAMp6B,MAAQpB,OAAOy8B,EAAErB,EAAEF,EAAG,IAIvC9jB,OAAS,SAASqlB,EAAGhuC,GACnB,OAAQguC,EAAEjB,GACR,KAAKp6B,IACH,OAAOpB,OAAOy8B,EAAErB,EAAEH,EAAGxsC,IAAMuR,OAAOy8B,EAAErB,EAAEF,EAAG,GAC3C,KAAK7nC,OACH,OAAOopC,EAAElB,IAAM9sC,EACjB,QACE,OAAO,IAKb4oB,OAAS,SAASolB,EAAGxB,EAAGC,GACtB,OAAQuB,EAAEjB,GACR,KAAKp6B,IACH,OAAOpB,OAAOy8B,EAAErB,EAAEH,EAAGA,IAAMj7B,OAAOy8B,EAAErB,EAAEF,EAAGA,GAC3C,KAAK7nC,OACH,OAAOopC,EAAElB,IAAMN,EAAIC,EACrB,QACE,OAAO,IAKbvZ,aAAe,SAAS8a,GACtB,OAAOplB,OAAOolB,EAAG,EAAG,IAItBzb,kBAAoB,SAASyb,GAC3B,OAAOplB,OAAOolB,GAAI,EAAG,IAIvB/a,iBAAmB,SAAS+a,GAC1B,OAAOjvB,IAAIivB,KAAO/G,OAAO5zB,QAAUsV,OAAO9J,KAAKmvB,GAAI,IAAMplB,OAAOhK,MAAMovB,IAAK,EAAG,IAIhF1b,sBAAwB,SAAS0b,GAC/B,OAAOjvB,IAAIivB,KAAO/G,OAAOn1B,WAAa6W,OAAO9J,KAAKmvB,IAAK,IAAM/a,iBAAiBrU,MAAMovB,KAAqB,IAAd3wC,OAAO2wC,IAIpG7Z,mBAAqB,SAAS6Z,GAC5B,OAAOjvB,IAAIivB,KAAO/G,OAAOn1B,WAAaohB,aAAarU,KAAKmvB,KAAO9Z,YAAYtV,MAAMovB,KAAqB,IAAd3wC,OAAO2wC,IAIjGxb,wBAA0B,SAASwb,GACjC,OAAOjvB,IAAIivB,KAAO/G,OAAOn1B,WAAaygB,kBAAkB1T,KAAKmvB,KAAO9Z,YAAYtV,MAAMovB,KAAqB,IAAd3wC,OAAO2wC,IAItG9Z,YAAc,SAAS8Z,GACrB,OAAOjvB,IAAIivB,KAAO/G,OAAO5zB,QAAUsV,OAAO9J,KAAKmvB,GAAI,IAAM9a,aAAatU,MAAMovB,KAG9Evc,YAAa,SAASuc,GACpB,GAAIA,EAAEjB,IAAMnoC,QAAUopC,IAAM/G,OAAOl4B,QACjC,OAAO,EAET,KAAOmiB,OAAO8c,IAAI,CAChB,GAAIvc,YAAW1S,IAAIivB,IACjB,OAAO,EAETA,EAAIvuB,IAAIuuB,GAEV,OAAO,GAGTlc,gBAAkB,SAASkc,GACzB,OAAItlB,MAAMslB,EAAGpf,eACJ,EAEA,GAiBXmF,cAAgB,SAASia,GACvB,IAAIsQ,EAAWt+C,EAGf,GAFAA,EAAI,EACJs+C,EAAY,EACRv/B,IAAIivB,KAAO/G,OAAOn1B,UACpB,OAAO,EAET,GAAI4W,MAAM7J,KAAKmvB,GAAIpf,eACjB,OAAIhQ,MAAMovB,KAAO/G,OAAO9zB,KAGN,IAAd9V,OAAO2wC,GAFF,EAKF,EAET,IAAKne,cAAchR,KAAKmvB,IACtB,OAAO,EAET,IAAKtlB,MAAM9J,MAAMovB,GAAIpf,eACnB,OAAO,EAET,GAAIjQ,OAAOqvB,KAAO/G,OAAO9zB,IACvB,OAAO,EAET,GAAkB,IAAd9V,OAAO2wC,GACT,OAAO,EAMT,GAJA1uC,KAAKuf,KAAKmvB,IACVvN,aAAa,GACb9I,WACA33B,EAAI67B,cACA8U,MAAM3wC,GACR,OAAO,EAMT,OAJIA,EAAI,IACNs+C,EAAY,EACZt+C,GAAKA,GAECA,EAAI,GACV,KAAK,EACHA,EAAI,EACJ,MACF,KAAK,EAEDA,EADEs+C,EACE,EAEA,EAEN,MACF,KAAK,EACHt+C,EAAI,EACJ,MACF,KAAK,EAEDA,EADEs+C,EACE,EAEA,EAGV,OAAOt+C,GAUT8yB,MAAQ,SAASkb,GACf,IAAehuC,EAEf,OADAA,EAAI,EACAguC,IAAM/G,OAAO9zB,IACR,EAEL4L,IAAIivB,KAAO/G,OAAOn1B,WAAa+d,cAAchR,KAAKmvB,KAAOpvB,MAAMovB,KAAO/G,OAAO9zB,KAAqB,IAAd9V,OAAO2wC,IACjF,EAId1uC,KAAKuf,KAAKmvB,IACVvN,aAAa,GACb9I,WACA33B,EAAI67B,cACA8U,MAAM3wC,GACD,EAGPA,EADEA,EAAI,EACF,IAAMA,EAAK,EAEX,GAAKA,EAAI,GAAK,GAZX,GAiBXO,EAAE6vB,mBAAqBA,mBAEvB7vB,EAAEoyB,iBAAmBA,iBAErBpyB,EAAE4yB,UAAYA,UAEd5yB,EAAE8xB,WAAaA,WAEf9xB,EAAEyxB,UAAYA,UAEdzxB,EAAEsyB,qBAAuBA,qBAEzBtyB,EAAEqzB,SAAWA,SAEbrzB,EAAEqyB,eAAiBA,eAEnBryB,EAAEqxB,kBAAoBA,kBAEtBrxB,EAAEywB,gBAAkBA,gBAEpBzwB,EAAE+wB,cAAgBA,cAElB/wB,EAAEmyB,WAAaA,WAEfnyB,EAAE+zB,WAAaA,YAEf/zB,EAAE0xB,gBAAkBA,gBAEpB1xB,EAAEyyB,UAAYA,UAEdzyB,EAAEmxB,WAAaA,WAEfnxB,EAAE0yB,iBAAmBA,iBAErB1yB,EAAE+xB,sBAAwBA,sBAE1B/xB,EAAEkxB,WAAaA,YAEflxB,EAAEuxB,gBAAkBA,gBAEpBvxB,EAAEwzB,cAAgBA,cAElBxzB,EAAEuyB,MAAQA,MAEVtoB,aAAe,WAIb,OAHAlL,KAAKuf,KAAKwb,KACVt0B,OACAs0B,GAAKqB,MACD7I,qBAAqBwH,KAAOhD,OAAOgD,GAAGsS,EAAEH,GACnC/L,aAAa,GAEbA,aAAa,IAIxBh2B,cAAgB,WAgBd,OAdAnL,KAAKuf,KAAKwb,KACVt0B,OAEAzG,KAAKsf,MAAMyb,KACXt0B,OAEAzG,KAAKqf,OAAO0b,KACZt0B,QACAu0B,GAAKoB,SACMuL,OAAOh1B,KAChBwuB,aAAa,GAEbnhC,KAAKg7B,IAEAxF,YASTA,SAAW,WACT,IAAI90B,EAQJ,OAPI,EACJ4iC,OACArI,GAAKmB,MACLpB,GAAKoB,MACLrB,GAAKqB,MACLp8B,KAAKg7B,KACLt6B,EAAI67B,eACI,GAAK8U,MAAM3wC,IACjB2gC,YAAYxwB,UACZ7Q,KAAK+6B,IACL/6B,KAAKg7B,IACLh7B,KAAKi7B,IACLhF,KAAK,QACL4M,YAGE9N,SAASgG,IACXtF,UAAU/0B,IAEVw6B,GAAKH,GACLA,GAAK4M,OAAOpyB,SACZkgB,UAAU/0B,GACVq6B,GAAKG,GACLl7B,KAAK2nC,OAAOpyB,UACZvV,KAAK+6B,IACLwM,SACA9gC,QAEKo8B,YAGTpN,UAAY,SAAS/0B,GACnB,IAAI1C,EAAGwC,EAAGgiC,EAAKoL,EAMf,IALA5vC,EAAI,EACJmjC,aAAa,GACbA,aAAa,GACb/F,GAAKgB,MACLwR,EAAU,GACL5vC,EAAIwC,EAAI,EAAGgiC,EAAM9hC,EAAI,GAAK8hC,EAAMhiC,EAAIgiC,EAAMhiC,EAAIgiC,EAAMxkC,EAAI,GAAKwkC,IAAQhiC,IAAMA,EAC9E26B,GAAKC,GACLA,GAAKgB,MACL+E,aAAa,EAAInjC,EAAI,GACrBgC,KAAK+6B,IACLyM,WACAxnC,KAAKi7B,IACLrgB,MACA5a,KAAKo7B,IACL/C,WACA8I,aAAanjC,GACbgC,KAAKi7B,IACLrgB,MACA5a,KAAKm7B,IACL9C,WACAmP,WACArG,aAAanjC,EAAI,GACjB4vC,EAAQ5tC,KAAKkmB,UAEf,OAAO0nB,GAITxiC,SAAW,WACT,IAAIwiC,EAMJ,IALA7S,GAAK5a,IAAI4a,IACT/6B,KAAKyf,IAAIsb,KACTt0B,OACAs0B,GAAK5a,IAAI4a,IACT6S,EAAU,GACHhc,OAAOmJ,KACZ/6B,KAAKyf,IAAIsb,KACTt0B,OACAmvB,MACAgY,EAAQ5tC,KAAK+6B,GAAK5a,IAAI4a,KAExB,OAAO6S,GAGThY,IAAM,WACJ,IAAI0iB,EAKJ,OAJAA,EAAiBluB,UACjBkZ,OACA4I,QACArJ,UACOzY,UAAYkuB,GAGrBpM,MAAQ,WAWN,OAVA9hB,UAAY,EACZ4Q,GAAKoB,MACLrB,GAAKqB,MACLp8B,KAAK+6B,IACL/6B,KAAKg7B,IACL/N,MACAjtB,KAAK+6B,IACL7U,SACAlmB,KAAKg7B,IACL9U,SACOiK,WAGT9kB,aAAe,WAWb,OAVArL,KAAKuf,KAAKwb,KACVt0B,OACAzG,KAAKsf,MAAMyb,KACXt0B,QACAs0B,GAAKqB,SACMuL,OAAOh1B,KAChB8b,QAEAzuB,KAAK+6B,IAEAlF,WAMTA,QAAU,WAeR,OAdAyN,OACAtI,GAAKoB,MACLrB,GAAKqB,MACLp8B,KAAK+6B,IACL/6B,KAAKg7B,IACL7V,SACA8V,GAAKmB,MACLp8B,KAAK+6B,IACL/6B,KAAKg7B,IACLh7B,KAAKi7B,IACLuB,QACAtW,SACAlmB,KAAKg7B,IACLpP,SACOiX,WAGTv3B,cAAgB,WAgBd,OAdAtL,KAAKuf,KAAKwb,KACVt0B,OAEAzG,KAAKsf,MAAMyb,KACXt0B,OAEAzG,KAAKqf,OAAO0b,KACZt0B,QACAu0B,GAAKoB,SACMuL,OAAOh1B,KAChBwuB,aAAa,GAEbnhC,KAAKg7B,IAEAlF,YASTA,SAAW,WAGT,OAFAwN,OACAppB,aACO2oB,WAGT3oB,WAAa,WACX,IAAI0+B,EAAGl4C,EAUP,OATI,EACA,EACJu6B,GAAKmB,MACLpB,GAAKoB,MACLrB,GAAKqB,MACLp8B,KAAKg7B,IACLt6B,EAAI67B,cACJv8B,KAAKi7B,IACL2d,EAAIrc,cACA77B,EAAI,GAAK2wC,MAAM3wC,IAAMk4C,EAAI,GAAKvH,MAAMuH,IACtCvX,YAAY9vB,UACZvR,KAAK+6B,IACL/6B,KAAKg7B,IACLh7B,KAAKi7B,SACLhF,KAAK,KAGHlB,SAASgG,IACX5gB,YAAYzZ,EAAGk4C,IAEf1d,GAAKH,GACLA,GAAK4M,OAAOpyB,SACZ4E,YAAYzZ,EAAGk4C,GACf7d,GAAKG,GACLl7B,KAAK2nC,OAAOpyB,UACZvV,KAAK+6B,IACLwM,SACA9gC,QAEK2T,YAAYw+B,KAGrBz+B,YAAc,SAASzZ,EAAGk4C,GACxB,IAAI56C,EAAGoxB,EAAI5uB,EAAGgiC,EAAKC,EAAMmL,EAgBzB,IAfA5vC,EAAI,EACJmjC,aAAa,GACbA,aAAa,GACb/F,GAAKgB,MAYAp+B,EAAIwC,EAAI,EAAGgiC,EAAM9hC,EAAI,GAAK8hC,EAAMhiC,EAAIgiC,EAAMhiC,EAAIgiC,EAAMxkC,EAAI,GAAKwkC,IAAQhiC,IAAMA,EAC9E26B,GAAKC,GACLA,GAAKgB,MACL+E,aAAa,EAAInjC,EAAI,GACrBgC,KAAK+6B,IACL1C,WACAr4B,KAAKo7B,IACL/C,WACA8I,aAAanjC,GACbgC,KAAKm7B,IACL9C,WACAmP,WACArG,aAAanjC,EAAI,GACjBkoB,SAGF,IADA0nB,EAAU,GACL5vC,EAAIoxB,EAAK,EAAGqT,EAAOmW,EAAI,GAAKnW,EAAOrT,EAAKqT,EAAOrT,EAAKqT,EAAOzkC,EAAI,GAAKykC,IAASrT,IAAOA,EACvFpvB,KAAK+6B,IACL6S,EAAQ5tC,KAAKulB,cAEf,OAAOqoB,GAITxzB,YAAc,SAASw+B,GACrB,GAAU,IAANA,EAsBJ,OAnBIn5B,IAAIsb,MAAQ4M,OAAO/jC,MACrB5D,KAAKuf,KAAKwb,KACVwL,OACAK,UACSnnB,IAAIsb,MAAQ4M,OAAO7xB,MAC5B9V,KAAKuf,KAAKwb,KACV9X,SACA2jB,WAEAzF,aAAa,GACbnhC,KAAK+6B,IACL6L,SACAY,YAEFrG,aAAayX,GACbxX,cAAc,EAAG,GACjB/I,WACAmE,QACAnE,WACIugB,EAAI,EACC7f,cADT,GAQF9C,KAAO,SAASv1B,GACd,IAAkBF,EAAGgiC,EAAKoL,EAI1B,IAHe,EACf5tC,KAAK2nC,OAAOh1B,MACZi7B,EAAU,GACUptC,EAAI,EAAGgiC,EAAM9hC,EAAI,GAAK8hC,EAAMhiC,EAAIgiC,EAAMhiC,EAAIgiC,EAAqB,GAAKA,IAAQhiC,IAAMA,EACpGotC,EAAQ5tC,KAAK2iB,QAEf,OAAOirB,GAWTriC,SAAW,WAGT,OAFAvL,KAAKuf,KAAKwb,KACVt0B,OACO0vB,aAGTA,UAAY,WAGV,OAFAmN,OACA6I,QACOtJ,WAGTsJ,MAAQ,WACN,IAAIqB,EAGJ,GAFAA,EAAI,GACJzS,GAAKqB,SACMuL,OAAOjiC,GAIlB,GAAI2jB,OAAO0R,GAAI,GACboG,aAAa,OADf,CAIA,GAAI9N,iBAAiB0H,IAYnB,OAXA/6B,KAAK+6B,IACLhC,SACA5C,YACAn2B,KAAKsvB,eACD5F,mBACFqX,YAAYwN,KAAK16B,IAEjBwtB,YAAYxtB,IAEdwkB,gBACAzd,MAGF,GAAImX,SAASgJ,IAGX,OAFAyS,EAAIe,KAAKW,IAAInU,GAAGyS,QAChBzM,YAAYyM,GAId,GAAIpb,WAAW2I,IAQb,OAPA/6B,KAAK+6B,IACLV,aACAlE,YACAn2B,KAAK+6B,IACL3V,eACA+Q,iBACAqR,WAIF,GAAI/nB,IAAIsb,MAAQ4M,OAAO5zB,OAKrB,OAJA/T,KAAKsf,MAAMyb,KACX/6B,KAAKuf,KAAKwb,KACV5E,iBACAkC,WAIF,GAAI5Y,IAAIsb,MAAQ4M,OAAOn1B,UAavB,OAFA6uB,YAAY7vB,KACZxR,KAAK+6B,IACE9E,KAAK,GAVV,IAFAkL,aAAa,GACbpG,GAAK5a,IAAI4a,IACFnJ,OAAOmJ,KACZ/6B,KAAKyf,IAAIsb,KACT5E,YACAvb,MACAmgB,GAAK5a,IAAI4a,SArDXoG,aAAa,IA+KjB31B,YAAc,WAKZ,OAJAuvB,GAAKxb,KAAKwb,IACLnJ,OAAOmJ,KAAOxb,KAAKwb,IAAI0S,IAAMl3B,MAChCwkB,GAAKjN,YAAYiN,KAEZ/6B,KAAK+6B,KAOdxE,KAAO,SAAS2W,EAAGC,GACjB,OAAOD,EAAEtyB,IAAIuyB,IAGfjV,KAAO,SAASgV,EAAGC,GACjB,OAAOD,EAAE1F,SAAS2F,IAGpBhyB,KAAO,SAAS+xB,EAAGC,GACjB,OAAOD,EAAEtyB,IAAIuyB,IAGf7F,KAAO,SAAS4F,EAAGC,GACjB,OAAOD,EAAE1F,SAAS2F,IAIpBxD,KAAO,SAASuD,EAAGC,GACjB,OAAOD,EAAE+R,WAAW9R,IAoBtBlW,KAAO,SAAS2mB,EAAGsB,GACjB,OAAOlhC,OAAOiP,IAAI2wB,EAAGsB,IAMvB9lB,WAAa,SAASqW,GACpB,IAAI0P,EAIJ,OAHAA,EAAe,IAAIhmC,GACNs0B,EAAIr3B,IACjB+oC,EAAa5R,IAAMkC,EACZ0P,GAGTvkB,cAAgB,WACd,OAAOuM,KAAK,kBAId3F,iBAAmB,SAASxjC,EAAGqwC,GAI7B,OAHAruC,KAAKqb,aAAard,EAAIqwC,IACtBvH,MAAMqC,IAAM,GAAGZ,OAAOsF,KAAO,EAC7B/G,MAAMqC,IAAM,GAAGZ,OAAOoF,IAAI,GAAK3vC,EACxB8oC,MAAMqC,IAAM,GAAGZ,OAAOoF,IAAI,GAAKU,GAGxCnN,qBAAuB,SAASxgC,GAC9B,IAAI1C,EAAGwC,EAAGgiC,EAEV,IADAhB,iBAAiB9gC,EAAGA,GACf1C,EAAIwC,EAAI,EAAGgiC,EAAM9hC,EAAI,GAAK8hC,EAAMhiC,EAAIgiC,EAAMhiC,EAAIgiC,EAAMxkC,EAAI,GAAKwkC,IAAQhiC,IAAMA,EAC9EsmC,MAAMqC,IAAM,GAAGZ,OAAO3gB,KAAK5pB,EAAI0C,EAAI1C,GAAKu8B,IAE1C,OAAO5Z,wBAAwBmmB,MAAMqC,IAAM,KAG7CrI,UAAY,SAAS4N,GACnB,IAAId,EAEJ,IADAA,EAAU,GACHhc,OAAO8c,IACZ1uC,KAAKyf,IAAIivB,IACTd,EAAQ5tC,KAAK0uC,EAAIvuB,IAAIuuB,IAEvB,OAAOd,GAQTxkB,MAAQ,SAAS2R,EAAIC,GACnB,OAAyB,IAArBzZ,UAASwZ,EAAIC,GACR,EAEA,GAIXjF,MAAQ,SAASgF,EAAIC,GACnB,OAAIzZ,UAASwZ,EAAIC,GAAM,EACd,EAEA,GAIXsK,KAAO,SAAS5kC,GACd,OAAIA,EAAI,GACE,EACCA,EAAI,EACN,EAEA,GAiBX6gB,UAAW,SAASwZ,EAAIC,GACtB,IAAIt6B,EAEJ,GADAA,EAAI,EACAq6B,IAAOC,EACT,OAAO,EAET,GAAID,IAAO4M,OAAOh1B,KAChB,OAAQ,EAEV,GAAIqoB,IAAO2M,OAAOh1B,KAChB,OAAO,EAET,GAAI4d,cAAcwK,IAAOxK,cAAcyK,GACrC,OAAOsK,KAAKnjB,gBAAgB4Y,EAAIC,IAElC,GAAIzK,cAAcwK,GAChB,OAAQ,EAEV,GAAIxK,cAAcyK,GAChB,OAAO,EAET,GAAIlG,MAAMiG,IAAOjG,MAAMkG,GACrB,OAAOsK,KAAK8B,OAAOrM,EAAGwS,IAAKvS,EAAGuS,MAEhC,GAAIzY,MAAMiG,GACR,OAAQ,EAEV,GAAIjG,MAAMkG,GACR,OAAO,EAET,GAAIjG,SAASgG,IAAOhG,SAASiG,GAC3B,OAAOsK,KAAK8B,OAAOjZ,cAAc4M,GAAK5M,cAAc6M,KAEtD,GAAIjG,SAASgG,GACX,OAAQ,EAEV,GAAIhG,SAASiG,GACX,OAAO,EAET,GAAI/F,SAAS8F,IAAO9F,SAAS+F,GAC3B,OAAO3Y,gBAAgB0Y,EAAIC,GAE7B,GAAI/F,SAAS8F,GACX,OAAQ,EAEV,GAAI9F,SAAS+F,GACX,OAAO,EAGT,KAAOpJ,OAAOmJ,IAAOnJ,OAAOoJ,IAAK,CAE/B,GAAU,KADVt6B,EAAI6gB,UAAS9B,IAAIsb,GAAKtb,IAAIub,KAExB,OAAOt6B,EAETq6B,EAAK5a,IAAI4a,GACTC,EAAK7a,IAAI6a,GAEX,OAAIpJ,OAAOoJ,IACD,EAENpJ,OAAOmJ,GACF,EAEF,GAGTh9B,OAAS,SAAS2wC,GAChB,IAAIhuC,EAEJ,IADAA,EAAI,EACGkxB,OAAO8c,IACZA,EAAIvuB,IAAIuuB,GACRhuC,IAEF,OAAOA,GAGTmpC,OAAS,SAAS6E,GAUhB,OATApL,OACAvI,GAAK4M,OAAOh1B,KACZqoB,GAAK2M,OAAOh1B,KACZm3B,UAAS4E,GACL1T,KAAO2M,OAAOh1B,OAChBooB,GAAK4M,OAAOh1B,MAEd+7B,EAAI3T,GACJ8H,UACO6L,GAGT5E,UAAW,SAAS4E,GAClB,GAAI5Z,MAAM4Z,GACJ3T,KAAO4M,OAAOh1B,KAChBooB,GAAK2T,EACIA,IAAM3T,KACfC,GAAK0T,QAIT,KAAO9c,OAAO8c,IAAI,CAEhB,GADA5E,UAASrqB,IAAIivB,IACT1T,KAAO2M,OAAOh1B,KAChB,OAEF+7B,EAAIvuB,IAAIuuB,KAIZ7H,MAAQ,WAEN,OADAzF,cAAc,EAAG,GACV5E,SAGTmP,SAAW,WACT,IAAI2M,EAIJ,OAHAA,EAAiBluB,UACjBA,UAAY,EACZ3jB,OACO2jB,UAAYkuB,GAGrBhuB,YAAc,WAGZ,OAFA+W,YAAY37B,GACZgiC,OACOlL,SAGToK,OAAS,WAEP,OADAzF,aAAa,GACN3E,SAOTmK,WAAa,SAASjmC,GACpB,IAAIqtC,EAAGsB,EAKP,OAHAtB,EAAI5E,IAAMzoC,GACV2uC,EAAgBvI,MAAMlmC,MAAMmtC,EAAGA,EAAIrtC,IACrB4uC,KAAK/tB,WACZulB,MAAQA,MAAMlmC,MAAM,EAAGmtC,GAAGwB,OAAOF,GAAeE,OAAOzI,MAAMlmC,MAAMmtC,EAAIrtC,KAGhFO,EAAEmoB,MAAQA,MAEVnoB,EAAElD,OAASA,OAGXs5B,KAAO,SAAS6V,EAAGC,GACjB,OAAOD,EAAE7U,SAAS8U,IAGpBrW,KAAO,SAASoW,EAAGC,GACjB,OAAOD,EAAEhnB,OAAOinB,IAgDlB/V,KAAO,SAAS8V,EAAGC,GACjB,OAAOD,EAAE5V,IAAI6V,IAMfpW,QAAU,SAASmW,EAAGC,GACpB,IAAIiS,EAEJ,MAAO,EADPA,EAAWlS,EAAE8J,OAAO7J,IACH8J,SAAUmI,EAASlI,YAMtCzrC,SAAW,WAKT,OAJAzL,KAAKuf,KAAKwb,KACVt0B,OACAzG,KAAKsf,MAAMyb,KACXt0B,OACO6wB,OAGTA,IAAM,WACJ,IAAI52B,EAQJ,OAPAA,EAAI,EACJ4iC,OACAtI,GAAKoB,MACLrB,GAAKqB,MACDtL,mBAAmBkK,KACrBmM,KAAK,gCAEF5W,cAAcwK,KAAQxK,cAAcyK,KAQrCjJ,SAASgJ,MACX/6B,KAAK+6B,IACLr6B,EAAI67B,cACA8U,MAAM3wC,IACRymC,KAAK,uDAEPhG,aAAazgC,GACbq6B,GAAKqB,OAEHrK,SAASiJ,MACXh7B,KAAKg7B,IACLt6B,EAAI67B,cACA8U,MAAM3wC,IACRymC,KAAK,uDAEPhG,aAAazgC,GACbs6B,GAAKoB,OAEF1J,UAAUqI,KAAQrI,UAAUsI,KAC/BmM,KAAK,6CAEPlM,GAAK,IAAI9hB,GACNs0B,EAAIp6B,IACP4nB,GAAGoS,EAAEH,EAAI9V,KAAK2D,GAAGsS,EAAEH,EAAGlS,GAAGqS,EAAEH,GAC3BjS,GAAGoS,EAAEF,EAAIhW,KAAK,GACdn3B,KAAKi7B,IACE4H,YAjCLxB,YAAY/uB,KACZtS,KAAK+6B,IACL/6B,KAAKg7B,IACL/E,KAAK,QACL4M,YAmCJ/K,KAAO,SAASoV,EAAGxsC,GACjB,OAAOwsC,EAAEyD,IAAIjwC,IASfq3B,OAAS,SAASr3B,GAChB,OAAOA,EAAE2+C,mBAcXrnB,MAAQ,SAASt3B,EAAG4+C,GAClB,IAAIthD,EAAGqwC,EAAGZ,EAAGjtC,EAAGgiC,EAAKiM,EAAGuH,EAcxB,IATAt1C,EAAIA,EAAE8Z,MACNxc,EAAI,EACA,EACJyvC,EAAI,EACU,IAAV6R,GACFnY,KAAK,sBAGPsG,EAAI,EACG/sC,EAAEm3C,WAAWpK,GAAK,GACvBA,IAEF,GAAU,IAANA,EACF,OAAOtW,KAAK,GAMd,IAHAsW,EAAIc,KAAK+C,OAAO7D,EAAI,GAAK6R,GACzBjR,EAAIE,KAAK+C,MAAM7D,EAAI,GAAK,GACxBgB,EAAIzwB,OAAOqwB,GACNrwC,EAAIwC,EAAI,EAAGgiC,EAAM6L,EAAI,GAAK7L,EAAMhiC,EAAIgiC,EAAMhiC,EAAIgiC,EAAMxkC,EAAI,GAAKwkC,IAAQhiC,IAAMA,EAE9EiuC,EAAIA,EAAE8Q,IAAIvhC,OAAO,GAAGwhC,UAAUxhD,GAAGyhD,OAEnC,KAAOhS,GAAK,GAAG,CAIb,OAFAgB,EAAIA,EAAEiR,GAAG1hC,OAAO,GAAGwhC,UAAU/R,IAC7BuI,EAAIle,KAAK2W,EAAG6Q,GACJ1oB,KAAKof,EAAGt1C,IACd,KAAK,EACH,OAAO+tC,EACT,KAAK,EAGHA,EAAIA,EAAE8Q,IAAIvhC,OAAO,GAAGwhC,UAAU/R,GAAGgS,OAErChS,IAEF,OAAO,GAiBTppC,gBAAiB,EAEjBqH,cAAgB,WACd,IAAIkiC,EAKJ,IAJA5tC,KAAKuf,KAAKwb,KACVt0B,OACAs0B,GAAK7a,KAAK6a,IACV6S,EAAU,GACHhc,OAAOmJ,KACZ/6B,KAAKyf,IAAIsb,KACTt0B,OACA4xB,WACAuV,EAAQ5tC,KAAK+6B,GAAK5a,IAAI4a,KAExB,OAAO6S,GAMTvV,SAAW,WAIT,OAHI5O,UACF0d,KAAK,mBAEH5W,cAAcuW,MAAMqC,IAAM,KAAO5Y,cAAcuW,MAAMqC,IAAM,IACtDtQ,oBAEPyK,OACA8I,aACOvJ,YAIXuJ,WAAa,WACX,IAAI2B,EAAG/vC,EAAG0C,EAAGF,EAAGgiC,EAAKC,EASrB,GARI,EACJzkC,EAAI,EACA,EAEJg9B,GAAKoB,MACLrB,GAAKqB,MACL2R,EAAI5E,IAEAtY,WAAWkK,KAAOlK,WAAWmK,IAC3BtR,mBACFqX,YAAY,GAEZ/gC,KAAK6sC,WAOT,GAAIziB,WAAakH,MAAMyJ,IAOrB,IANAA,GAAK5a,IAAI4a,IACLrR,mBACFqX,YAAY,GAEZ/gC,KAAK6sC,MAEAjb,OAAOmJ,KACZ/6B,KAAKyf,IAAIsb,KACT/6B,KAAKg7B,IACL3C,WACAzd,MACAmgB,GAAK5a,IAAI4a,SAIb,GAAI3Q,WAAakH,MAAM0J,IAOrB,IANAA,GAAK7a,IAAI6a,IACLtR,mBACFqX,YAAY,GAEZ/gC,KAAK6sC,MAEAjb,OAAOoJ,KACZh7B,KAAK+6B,IACL/6B,KAAKyf,IAAIub,KACT3C,WACAzd,MACAogB,GAAK7a,IAAI6a,QAZb,CAgBA,IAAK/F,SAAS8F,KAAO9F,SAAS+F,IAI5B,OAHAh7B,KAAK+6B,IACL/6B,KAAKg7B,SACLwI,sBAIF,GAAIvO,SAAS8F,MAAQ9F,SAAS+F,IAI5B,OAHAh7B,KAAK+6B,IACL/6B,KAAKg7B,SACLyN,sBAwCF,IApCIhpB,IAAIsb,MAAQ4M,OAAOn1B,UACrBuoB,GAAK5a,IAAI4a,KAET/6B,KAAK+6B,IACL9E,KAAK,GACL8E,GAAKqB,OAEH3c,IAAIub,MAAQ2M,OAAOn1B,UACrBwoB,GAAK7a,IAAI6a,KAETh7B,KAAKg7B,IACL/E,KAAK,GACL+E,GAAKoB,OAGH7L,cAAc9Q,IAAIsb,MAAQxK,cAAc9Q,IAAIub,MAC9Ch7B,KAAKyf,IAAIsb,KACT/6B,KAAKyf,IAAIub,KACTnC,mBACAkC,GAAK5a,IAAI4a,IACTC,GAAK7a,IAAI6a,KACAzK,cAAc9Q,IAAIsb,MAC3B/6B,KAAKyf,IAAIsb,KACTA,GAAK5a,IAAI4a,KACAxK,cAAc9Q,IAAIub,MAC3Bh7B,KAAKyf,IAAIub,KACTA,GAAK7a,IAAI6a,KAELtR,mBACFqX,YAAY,GAEZ/gC,KAAKu6B,KAGTmB,WACAC,WACO/J,OAAOmJ,KAAOnJ,OAAOoJ,KAS1B,GAAInc,KAAKkc,MAAQ4M,OAAOn0B,WAAaqL,KAAKmc,MAAQ2M,OAAOn0B,UAYzD,OAAQ+N,UAAS0Z,GAAIC,KACnB,KAAM,EACJl7B,KAAKyf,IAAIsb,KACTA,GAAK5a,IAAI4a,IACTW,WACA,MACF,KAAK,EACH17B,KAAKyf,IAAIub,KACTA,GAAK7a,IAAI6a,IACTW,WACA,MACF,KAAK,EACH5Z,gBAAgBgsB,GAChBhT,GAAK5a,IAAI4a,IACTC,GAAK7a,IAAI6a,IACTU,WACAC,WACA,MACF,QACEwL,KAAK,yBA9BP9F,YAAY7tB,UACZxT,KAAK4f,KAAKmb,KACV/6B,KAAK4f,KAAKob,KACV2kB,SACAh9B,OACAoY,GAAK5a,IAAI4a,IACTC,GAAK7a,IAAI6a,IACTU,WACAC,WA0BJ,KAAO/J,OAAOmJ,KACZ/6B,KAAKyf,IAAIsb,KACTA,GAAK5a,IAAI4a,IAEX,KAAOnJ,OAAOoJ,KACZh7B,KAAKyf,IAAIub,KACTA,GAAK7a,IAAI6a,IAkBX,GATA3gB,4BAA4B0zB,GASxB3jB,UACF,IAAKpsB,EAAIwC,EAAIgiC,EAAMuL,EAAGtL,EAAO0G,IAAM3G,GAAOC,EAAOjiC,EAAIiiC,EAAOjiC,EAAIiiC,EAAOzkC,EAAIwkC,GAAOC,IAASjiC,IAAMA,EAC/F,GAAI8wB,MAAMwV,MAAM9oC,IAEd,YADAs6B,aAAa6Q,IAAM4E,GAOzB,GAAU,KADVrtC,EAAIyoC,IAAM4E,GACV,CAIA,IAAIrZ,WAAWoS,MAAMiH,MAAO1kB,OAAOyd,MAAMiH,GAAI,GAe7C,OAJA9X,KAAKv1B,GACL26B,GAAKe,MACLiF,YAAY7uB,UACZxS,KAAKq7B,IACE1Y,OAdK,IAANjiB,GACF26B,GAAKe,MACLA,MACAp8B,KAAKq7B,MAELyL,MAAMiH,GAAKpG,OAAOn1B,UAClByjB,KAAKv1B,OAkBXg7B,SAAW,WAGT,GAFAT,GAAKxb,IAAIsb,IACTI,GAAKzR,mBAAqB+Q,cAAgBF,IACtC9a,IAAIwb,MAAQ0M,OAAO5zB,OAErB,OADAonB,GAAK7b,MAAM2b,IACJA,GAAK1b,KAAK0b,KAWrBU,SAAW,WAGT,GAFAT,GAAKzb,IAAIub,IACTI,GAAK1R,mBAAqB+Q,cAAgBF,IACtC9a,IAAIyb,MAAQyM,OAAO5zB,OAErB,OADAqnB,GAAK9b,MAAM4b,IACJA,GAAK3b,KAAK2b,KAKrBnZ,gBAAkB,SAASgsB,GAOzB,OANA/tC,KAAKk7B,IACLl7B,KAAKm7B,IACLn7B,KAAKo7B,IACLxgB,MACA4hB,QACAnB,GAAKe,MACD7L,cAAc8K,KAChBr7B,KAAK8mC,MAAMiH,IACX/tC,KAAKq7B,IACLxC,mBACOiO,MAAMiH,GAAK3R,OACT3c,IAAI4b,MAAQsM,OAAOn1B,WAExB+d,cAAchR,KAAK8b,MAAQpb,MAAMob,MAAQsM,OAAOh1B,MAClD3S,KAAK8mC,MAAMiH,IACX/tC,KAAKuf,KAAK8b,KACVxC,mBACAiO,MAAMiH,GAAK3R,MACJp8B,KAAKsf,MAAM+b,MAKbr7B,KAAKq7B,KAIhB7M,GAAK,CAAC,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,CAAC,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,GAAI,IAAK,GAAI,EAAG,GAAI,IAAK,IAAK,CAAC,EAAG,EAAG,GAAI,GAAI,GAAI,IAAK,GAAI,GAAI,GAAI,IAAK,EAAG,GAAI,EAAG,IAAK,EAAG,GAAI,IAAK,CAAC,EAAG,EAAG,EAAG,IAAK,GAAI,EAAG,IAAK,GAAI,GAAI,EAAG,IAAK,GAAI,GAAI,EAAG,IAAK,GAAI,IAAK,CAAC,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,IAAK,GAAI,EAAG,EAAG,IAAK,IAAK,EAAG,EAAG,IAAK,IAAK,CAAC,EAAG,EAAG,EAAG,EAAG,IAAK,GAAI,EAAG,IAAK,GAAI,IAAK,EAAG,EAAG,GAAI,IAAK,EAAG,EAAG,GAAI,CAAC,EAAG,EAAG,GAAI,GAAI,EAAG,IAAK,GAAI,EAAG,EAAG,EAAG,IAAK,EAAG,GAAI,EAAG,IAAK,EAAG,IAAK,CAAC,EAAG,EAAG,EAAG,IAAK,GAAI,EAAG,IAAK,EAAG,GAAI,EAAG,EAAG,GAAI,IAAK,EAAG,EAAG,GAAI,IAAK,CAAC,EAAG,EAAG,GAAI,IAAK,EAAG,EAAG,IAAK,EAAG,GAAI,GAAI,GAAI,IAAK,GAAI,GAAI,GAAI,IAAK,GAAI,CAAC,EAAG,EAAG,GAAI,EAAG,IAAK,EAAG,EAAG,IAAK,EAAG,IAAK,GAAI,GAAI,EAAG,IAAK,GAAI,IAAK,GAAI,CAAC,EAAG,EAAG,IAAK,EAAG,EAAG,IAAK,EAAG,EAAG,IAAK,GAAI,GAAI,GAAI,GAAI,GAAI,IAAK,GAAI,GAAI,CAAC,EAAG,EAAG,IAAK,GAAI,IAAK,IAAK,IAAK,IAAK,IAAK,GAAI,GAAI,EAAG,GAAI,GAAI,GAAI,EAAG,GAAI,CAAC,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,CAAC,EAAG,EAAG,IAAK,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,IAAK,GAAI,GAAI,EAAG,IAAK,GAAI,EAAG,GAAI,CAAC,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAAK,GAAI,IAAK,EAAG,GAAI,GAAI,GAAI,EAAG,GAAI,CAAC,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,IAAK,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAKzlCxM,eAAiB,SAAS+rB,GACxB,IAAIrtC,EAQJ,IAPAA,EAAI8tB,GAAG+f,KAAK+C,MAAMvW,GAAGjO,QAAQyhB,KAAK+C,MAAMtW,GAAGlO,SACnC,IACNpsB,GAAKA,EACLV,KAAK8mC,MAAMiH,IACXhV,SACA+N,MAAMiH,GAAK3R,OAET17B,EAAI,EACN,OAAOV,KAAK4/C,OAAOl/C,KASvBk4B,kBAAoB,WAClB,IAAI0f,EAIJ,OAHAA,EAAiBluB,UACjBA,UAAY,EACZiO,WACOjO,UAAYkuB,GAMrBhgB,aAAe,SAAS53B,GACtB,IAAIqtC,EAAG/vC,EAAGwC,EAAGgiC,EAEb,GADAxkC,EAAI,EACM,IAAN0C,EAAJ,CAGA,GAAU,IAANA,EAAJ,CAMA,IADAV,KAAK8mC,MADLiH,EAAI5E,IAAMzoC,IAEL1C,EAAIwC,EAAI,EAAGgiC,EAAM9hC,EAAI,GAAK8hC,EAAMhiC,EAAIgiC,EAAMhiC,EAAIgiC,EAAMxkC,EAAI,GAAKwkC,IAAQhiC,IAAMA,EAC9ER,KAAK8mC,MAAMiH,EAAI/vC,IACfq6B,WAGF,OADAyO,MAAMiH,GAAK3R,MACJ3E,QAAQsW,EAAI,GAVjB/tC,KAAK0pB,mBAAqB+Q,cAAgBF,OAc9ChC,sBAAwB,SAAS73B,GAC/B,IAAI43C,EAIJ,OAHAA,EAAiBluB,UACjBA,UAAY,EACZkO,aAAa53B,GACN0pB,UAAYkuB,GAYrBpyB,OAAS,WACP,OAAIqK,cAAcuW,MAAMqC,IAAM,KAAO5Y,cAAcuW,MAAMqC,IAAM,IACtDhjB,kBAEPgK,UACOkI,aAKXlI,QAAU,WACR,OAAII,cAAcuW,MAAMqC,IAAM,IACrB/Y,iBAEP+Q,cAAc,GACP3E,UAIX4F,YAAc,WACZ,OAAOjS,WAGT4I,OAAS,WACP,OAAIxI,cAAcuW,MAAMqC,IAAM,IACrBjQ,iBAEHxP,mBACFqX,aAAa,GAEbI,cAAc,GAET9I,aAIXW,cAAgB,WACd,IAAIsf,EAIJ,OAHAA,EAAiBluB,UACjBA,UAAY,EACZ2O,SACO3O,UAAYkuB,GAGrBrf,gBAAkB,WAChB,IAAIqf,EAIJ,OAHAA,EAAiBluB,UACjBA,UAAY,EACZ2O,SACO3O,UAAYkuB,GAoCrBj+B,4BAA8B,SAAS0zB,GACrC,IAAI/vC,EAAGoxB,EAAImG,EAAI/0B,EAAGgiC,EAAKC,EAAMmN,EAAMC,EAAMC,EAAMC,EAG/C,GAFA/xC,EAAI,IAEA61B,UAAUiT,MAAMiH,KAAOhb,WAAW+T,MAAMiH,KAAOhc,SAAS+U,MAAMiH,KAAlE,CAIA,IAAK/vC,EAAIwC,EAAIgiC,EAAMuL,EAAI,EAAGtL,EAAO0G,KAAM3G,GAAOC,EAAOjiC,EAAIiiC,EAAOjiC,EAAIiiC,KAC9DzoB,oBAAoB8sB,MAAM9oC,IAD2CA,EAAIwkC,GAAOC,IAASjiC,IAAMA,GAKrG,GAAIxC,IAAMmrC,IAAV,CAYA,IARA7F,OAEAtjC,KAAK8mC,MAAMiH,IACXnW,eACIvzB,gBACF2qC,QAAQE,IAAI,0CAA4CpI,MAAMqC,IAAM,IAEtEpO,GAAKqB,MACAp+B,EAAIoxB,EAAKwgB,EAAO7B,EAAI,EAAG8B,EAAO1G,KAAMyG,GAAQC,EAAOzgB,EAAKygB,EAAOzgB,EAAKygB,MACnEhc,UAAUkH,MAAOhI,WAAWgI,KAD8C/8B,EAAI4xC,GAAQC,IAASzgB,IAAOA,EAIrGpV,oBAAoB8sB,MAAM9oC,MAG/Bi9B,GAAK1b,KAAKunB,MAAM9oC,IAChBk9B,GAAK5b,MAAMwnB,MAAM9oC,IACZq1B,iBAAiB6H,MAItBl7B,KAAK+6B,IACL/6B,KAAKi7B,IACL/U,SACAiV,GAAKiB,MACA1J,UAAUyI,MAIfJ,GAAKI,GACLkG,YAAYttB,OACZ/T,KAAKi7B,IACLj7B,KAAK0pB,mBAAqB+Q,cAAgBF,KAC1Cv6B,KAAKk7B,IACLtgB,MACAqb,KAAK,GACL6Q,MAAM9oC,GAAKo+B,SASb,IANAp8B,KAAK8mC,MAAMiH,IACXpW,iBACItzB,gBACF2qC,QAAQE,IAAI,4CAA8CpI,MAAMqC,IAAM,IAExEnO,GAAKoB,MACAp+B,EAAIu3B,EAAKua,EAAO/B,EAAI,EAAGgC,EAAO5G,KAAM2G,GAAQC,EAAOxa,EAAKwa,EAAOxa,EAAKwa,KACnElc,UAAUmH,IADgEh9B,EAAI8xC,GAAQC,IAASxa,IAAOA,EAI1G,GAAKvb,oBAAoB8sB,MAAM9oC,MAG/Bi9B,GAAK1b,KAAKunB,MAAM9oC,IAChBk9B,GAAK5b,MAAMwnB,MAAM9oC,KACbq1B,iBAAiB6H,MAIrBl7B,KAAKg7B,IACLh7B,KAAKi7B,IACL/U,SACAiV,GAAKiB,MACA1J,UAAUyI,MAAf,CAsBA,GAnBI92B,gBACF2qC,QAAQE,IAAI,qBAAuB/T,GAAGx6B,YAEpC0D,gBACF2qC,QAAQE,IAAI,4BAA8BpI,MAAMqC,IAAM,IAGxDnO,GAAKG,GACLkG,YAAYttB,OACZ/T,KAAKi7B,IACLj7B,KAAKk7B,IACD72B,gBACF2qC,QAAQE,IAAI,qBAAuBjU,GAAGt6B,YAEpC0D,gBACF2qC,QAAQE,IAAI,qBAAuBhU,GAAGv6B,YAExCX,KAAKu6B,KACLiN,WACI7gB,6DACE+L,UAAUuI,MAAQvI,UAAUoU,MAAMqC,IAAM,KAAO9V,iBAAiByT,MAAMqC,IAAM,IAAK,CAQnF/M,MACAA,MACAA,MACAp8B,KAAK+6B,IACL/6B,KAAKi7B,IACL/U,SACA6U,GAAKqB,MACL,MAGA/3B,gBACF2qC,QAAQE,IAAI,2BAA6BpI,MAAMqC,IAAM,IAEvDlT,KAAK,GACL6Q,MAAM9oC,GAAKo+B,MAOb,OAJAp8B,KAAK+6B,IACL/6B,KAAKg7B,IACL9U,SACA4gB,MAAMiH,GAAK3R,MACJyG,aAMT7oB,oBAAsB,SAAS00B,GAE7B,OAAOjvB,IAAIivB,KAAO/G,OAAO5zB,QAAUwc,cAAchR,KAAKmvB,KAAOtc,WAAW9S,MAAMovB,MAAQ3b,WAAWxT,KAAKmvB,KAsBxGx7B,YAAc,IAEdH,aAAe,KAEfC,eAAiB,KAEjBF,WAAa,SAASmjC,GACpB,OAAO1H,KAAKC,KAAKyH,EAAE4J,EAAI5J,EAAE4J,EAAI5J,EAAEj4C,EAAIi4C,EAAEj4C,IAIvC6qC,UAAY,EAEZ51B,cAAgB,WAGd,OAAO,EAAMs7B,KAAKuR,SAAW,GAG/BxlB,wBAA2B,WAAW,IAC9BA,EAD8B,mEAOpC,OAJAA,EAAwBl7B,UAAUygD,EAAI,EAEtCvlB,EAAwBl7B,UAAUpB,EAAI,EAE/Bs8B,GAENz6B,KAAKutC,MAER1T,SAAW,IAAIY,wBAEfX,SAAW,IAAIW,wBAEfL,SAAW,IAAIK,wBAEfJ,SAAW,IAAII,wBAEfP,UAAY,IAAIO,wBAEhBN,UAAY,IAAIM,wBAEhBR,UAAY,IAAIQ,wBAEhBT,UAAY,IAAIS,wBAEhBV,SAAW,GAENnK,WAAajvB,EAAI,EAAGgiC,IAAMtvB,YAAc,GAAKsvB,IAAMhiC,EAAIgiC,IAAMhiC,EAAIgiC,IAAM/S,WAAa,GAAK+S,MAAQhiC,IAAMA,EAC1Go5B,SAASnK,YAAc,IAAI6K,wBAg5F7B,IA74FAzuB,YAAc,WACZ,IAAIkiC,EAAG/vC,EAAGoxB,EAAImG,EAAIkY,EAAGiC,EAAIhvC,EAAG+hC,EAAYoN,EA4BxC,IA3BI,EACJ7xC,EAAI,EACJyvC,EAAI,EACJ/sC,EAAI,EACJV,KAAKuf,KAAKwb,KACVt0B,OACAzG,KAAKsf,MAAMyb,KACXt0B,QACAu0B,GAAKoB,SACMuL,OAAOh1B,KAChB8b,QAEAzuB,KAAKg7B,IAEPA,GAAKoB,MACLrB,GAAKqB,MACArI,mBAAmBgH,GAAIC,KAC1BmM,KAAK,uBAGP4G,EAAI5E,KAEJzoC,EAAIihB,MAAMqZ,GAAID,KACN7nB,aACNi0B,KAAK,mBAGFnpC,EAAIoxB,EAAK,EAAGqT,EAAO/hC,EAAI,GAAK+hC,EAAOrT,EAAKqT,EAAOrT,EAAKqT,EAAOzkC,EAAI,GAAKykC,IAASrT,IAAOA,EACvFpvB,KAAK8mC,MAAMiH,EAAI/vC,IACfmkC,OACA0J,WACAplC,OACAs0B,GAAKqB,MACLp8B,KAAK8mC,MAAMiH,EAAI/vC,IACfqxB,OACAwc,WACAplC,OACAu0B,GAAKoB,MACArK,SAASgJ,KAAQhJ,SAASiJ,KAC7BmM,KAAK,yBAEPvN,SAAS57B,GAAG6hD,EAAI9kB,GAAGyS,EACnB5T,SAAS57B,GAAGA,EAAIg9B,GAAGwS,EAMrB,IAHA/V,QAAQsW,GAERxW,MAAM72B,GACD+sC,EAAIlY,EAAY70B,EAAG60B,EAAK,EAAGkY,EAAIlY,IAAO,EACzCpJ,SAASshB,GACLc,KAAK/zB,IAAIkf,SAASmmB,GAAK9sC,eACzB2mB,SAASmmB,EAAI,GAEXtR,KAAK/zB,IAAIkf,SAAS17B,GAAK+U,eACzB2mB,SAAS17B,EAAI,GAEf+iC,YAAYrH,SAASmmB,GACrB9e,YAAYrH,SAAS17B,GACrBgC,KAAKsvB,eACL+I,WACAzd,MACAzH,eAAes6B,GAIjB,IADA/sC,EAAIyoC,IAAM4E,GACF,EAAG,CAKT,IAJApH,WAAWjmC,IACXq6B,GAAK1f,aAAa3a,IACf6nC,OAAOsF,KAAO,EACjB9S,GAAGwN,OAAOoF,IAAI,GAAKjtC,EACd1C,EAAI0xC,EAAK,EAAGG,EAAOnvC,EAAI,GAAKmvC,EAAOH,EAAKG,EAAOH,EAAKG,EAAO7xC,EAAI,GAAK6xC,IAASH,IAAOA,EACvF3U,GAAGwN,OAAO3gB,KAAK5pB,GAAK8oC,MAAMiH,EAAI/vC,GAGhC,OADAy5B,QAAQsW,GACD/tC,KAAK+6B,MAKhBxD,MAAQ,SAAS72B,GACf,IAAI0uB,EAAIqe,EAAGhL,EAAM+M,EAMjB,IALA/B,EAAI,EACA,EACJvT,SAAS2lB,EAAIjmB,SAASl5B,EAAI,GAAGm/C,EAC7B3lB,SAASl8B,EAAI47B,SAASl5B,EAAI,GAAG1C,EAC7BwxC,EAAItV,SAAS2lB,EAAI3lB,SAAS2lB,EAAI3lB,SAASl8B,EAAIk8B,SAASl8B,EAC/CyvC,EAAIre,EAAK,EAAGqT,EAAO/hC,EAAI,EAAI,GAAK+hC,EAAOrT,EAAKqT,EAAOrT,EAAKqT,EAAOgL,EAAI,GAAKhL,IAASrT,IAAOA,EAC3FwK,SAAS6T,GAAGoS,GAAKjmB,SAAS6T,GAAGoS,EAAI3lB,SAAS2lB,EAAIjmB,SAAS6T,GAAGzvC,EAAIk8B,SAASl8B,GAAKwxC,EAC5E5V,SAAS6T,GAAGzvC,GAAK47B,SAAS6T,GAAGzvC,EAAIk8B,SAAS2lB,EAAIjmB,SAAS6T,GAAGoS,EAAI3lB,SAASl8B,GAAKwxC,EAG9E,OADA5V,SAASl5B,EAAI,GAAGm/C,EAAI,EACbjmB,SAASl5B,EAAI,GAAG1C,EAAI,GAI7BmuB,SAAW,SAASzrB,GAClB,IAAI0uB,EAAOmG,EAAOwqB,EAAOvQ,EAIzB,GAHI,EACA,EACJA,EAAI,EACA18B,WAAW8mB,SAAS,IAAM7mB,aAG5B,OAFA2mB,SAASmmB,EAAI,OACbnmB,SAAS17B,EAAI,GAGf,IAASoxB,EAAK,EAAGA,EAAK,MAAWA,EAU/B,IATAsK,SAASmmB,EAAI5sC,gBACbymB,SAAS17B,EAAIiV,gBACbwP,WAAW/hB,GACXi5B,SAASkmB,EAAInmB,SAASmmB,EACtBlmB,SAAS37B,EAAI07B,SAAS17B,EACtBg8B,UAAU6lB,EAAI9lB,UAAU8lB,EACxB7lB,UAAUh8B,EAAI+7B,UAAU/7B,EACxB07B,SAASmmB,EAAI5sC,gBACbymB,SAAS17B,EAAIiV,gBACJsiB,EAAK,EAAGA,EAAK,MAAYA,EAAI,CAMpC,GALA9S,WAAW/hB,GACXq/C,EAAQjtC,WAAWinB,WACfh2B,OACFirC,QAAQE,IAAI,UAAY6Q,GAEtBA,EAAQ/sC,eACV,OAwBF,GAtBIF,WAAWinB,WAAajnB,WAAWknB,aACrCC,SAAS4lB,EAAInmB,SAASmmB,EACtB5lB,SAASj8B,EAAI07B,SAAS17B,EACtB07B,SAASmmB,EAAIlmB,SAASkmB,EACtBnmB,SAAS17B,EAAI27B,SAAS37B,EACtB27B,SAASkmB,EAAI5lB,SAAS4lB,EACtBlmB,SAAS37B,EAAIi8B,SAASj8B,EACtBi8B,SAAS4lB,EAAI9lB,UAAU8lB,EACvB5lB,SAASj8B,EAAI+7B,UAAU/7B,EACvB+7B,UAAU8lB,EAAI7lB,UAAU6lB,EACxB9lB,UAAU/7B,EAAIg8B,UAAUh8B,EACxBg8B,UAAU6lB,EAAI5lB,SAAS4lB,EACvB7lB,UAAUh8B,EAAIi8B,SAASj8B,GAGzB87B,UAAU+lB,EAAIlmB,SAASkmB,EAAInmB,SAASmmB,EACpC/lB,UAAU97B,EAAI27B,SAAS37B,EAAI07B,SAAS17B,EAEpC67B,UAAUgmB,EAAI7lB,UAAU6lB,EAAI9lB,UAAU8lB,EACtChmB,UAAU77B,EAAIg8B,UAAUh8B,EAAI+7B,UAAU/7B,EAG5B,KADVwxC,EAAI3V,UAAUgmB,EAAIhmB,UAAUgmB,EAAIhmB,UAAU77B,EAAI67B,UAAU77B,GAEtD,MAEFk8B,SAAS2lB,GAAK/lB,UAAU+lB,EAAIhmB,UAAUgmB,EAAI/lB,UAAU97B,EAAI67B,UAAU77B,GAAKwxC,EACvEtV,SAASl8B,GAAK87B,UAAU97B,EAAI67B,UAAUgmB,EAAI/lB,UAAU+lB,EAAIhmB,UAAU77B,GAAKwxC,EAEvE9V,SAASmmB,EAAIlmB,SAASkmB,GAAK3lB,SAAS2lB,EAAI7lB,UAAU6lB,EAAI3lB,SAASl8B,EAAIg8B,UAAUh8B,GAC7E07B,SAAS17B,EAAI27B,SAAS37B,GAAKk8B,SAAS2lB,EAAI7lB,UAAUh8B,EAAIk8B,SAASl8B,EAAIg8B,UAAU6lB,GAGjF,OAAO1Y,KAAK,8BAGd1kB,WAAa,SAAS/hB,GACpB,IAAI0uB,EAAIqe,EAAGhL,EAAMmL,EAAS4B,EAU1B,IATA/B,EAAI,EACJ+B,EAAI,EAEJvV,SAAS4lB,EAAInmB,SAASmmB,EACtB5lB,SAASj8B,EAAI07B,SAAS17B,EAEtB+7B,UAAU8lB,EAAIjmB,SAAS,GAAGimB,EAAIjmB,SAAS,GAAGimB,EAAI5lB,SAAS4lB,EAAIjmB,SAAS,GAAG57B,EAAIi8B,SAASj8B,EACpF+7B,UAAU/7B,EAAI47B,SAAS,GAAG57B,EAAI47B,SAAS,GAAGimB,EAAI5lB,SAASj8B,EAAI47B,SAAS,GAAG57B,EAAIi8B,SAAS4lB,EACpFjS,EAAU,GACLH,EAAIre,EAAK,EAAGqT,EAAO/hC,EAAI,GAAK+hC,EAAOrT,EAAKqT,EAAOrT,EAAKqT,EAAOgL,EAAI,GAAKhL,IAASrT,IAAOA,EAEvFogB,EAAI9V,SAASmmB,EAAI5lB,SAAS4lB,EAAInmB,SAAS17B,EAAIi8B,SAASj8B,EACpDi8B,SAASj8B,EAAI07B,SAASmmB,EAAI5lB,SAASj8B,EAAI07B,SAAS17B,EAAIi8B,SAAS4lB,EAC7D5lB,SAAS4lB,EAAIrQ,EAEbzV,UAAU8lB,GAAKjmB,SAAS6T,GAAGoS,EAAI5lB,SAAS4lB,EAAIjmB,SAAS6T,GAAGzvC,EAAIi8B,SAASj8B,EACrE4vC,EAAQ5tC,KAAK+5B,UAAU/7B,GAAK47B,SAAS6T,GAAGoS,EAAI5lB,SAASj8B,EAAI47B,SAAS6T,GAAGzvC,EAAIi8B,SAAS4lB,GAEpF,OAAOjS,GAITz6B,eAAiB,SAASzS,GACxB,IAAI0uB,EAAImG,EAAIkY,EAAGhL,EAAMmN,EAAMhC,EAE3B,IADAH,EAAI,EACCA,EAAIre,EAAKqT,EAAO/hC,EAAI,EAAI+hC,GAAQ,EAAIrT,EAAK,EAAIA,EAAK,EAAIqe,EAAIhL,GAAQ,IAAMrT,IAAOA,EAClFwK,SAAS6T,EAAI,GAAGoS,GAAKjmB,SAAS6T,GAAGoS,EAAInmB,SAASmmB,EAAIjmB,SAAS6T,GAAGzvC,EAAI07B,SAAS17B,EAC3E47B,SAAS6T,EAAI,GAAGzvC,GAAK47B,SAAS6T,GAAGzvC,EAAI07B,SAASmmB,EAAIjmB,SAAS6T,GAAGoS,EAAInmB,SAAS17B,EAM7E,IAJI8U,WAAW8mB,SAAS,IAAM7mB,cAC5Bo0B,KAAK,0BAEPyG,EAAU,GACLH,EAAIlY,EAAK,EAAGqa,EAAOlvC,EAAI,EAAI,GAAKkvC,EAAOra,EAAKqa,EAAOra,EAAKqa,EAAOnC,EAAI,GAAKmC,IAASra,IAAOA,EAC3FqE,SAAS6T,GAAGoS,EAAIjmB,SAAS6T,EAAI,GAAGoS,EAChCjS,EAAQ5tC,KAAK45B,SAAS6T,GAAGzvC,EAAI47B,SAAS6T,EAAI,GAAGzvC,GAE/C,OAAO4vC,GAGT7hC,eAAiB,WAGf,OAFA/L,KAAKuf,KAAKwb,KACVt0B,OACO4zB,cAGTA,WAAY,WACV,IAAI0T,EAAGgB,EAUP,GATAhB,EAAI,EACJgB,EAAc3S,MACV3c,IAAIsvB,KAAiBpH,OAAOxmC,OAC9BnB,KAAK+uC,GAEL9M,cACA8M,EAAc3S,OAGZ3c,IAAIsvB,KAAiBpH,OAAOn1B,WAAcqhB,UAAUpU,IAAIU,IAAI4uB,KAWzD,OAAIra,WAAWqa,IACpB/uC,KAAK+uC,GACEnX,gBACEnY,IAAIsvB,KAAiBpH,OAAO5zB,QAAUuf,eAAehU,MAAMyvB,IAC7D/uC,KAAKu6B,KAELv6B,KAAK+uC,GAZZ,IAJAhB,EAAI5E,IACJ4F,EAAc5uB,IAAI4uB,GAGXnd,OAAOmd,IACZ/uC,KAAKyf,IAAIsvB,IACT1U,aACA0U,EAAc5uB,IAAI4uB,GAEpB,OAAOzW,aAAa6Q,IAAM4E,IAY9B7hC,WAAa,WACX,IAAI0hC,EAMJ,IALA7S,GAAK5a,IAAI4a,IACT/6B,KAAKyf,IAAIsb,KACTt0B,OACAs0B,GAAK5a,IAAI4a,IACT6S,EAAU,GACHhc,OAAOmJ,KACZ/6B,KAAKyf,IAAIsb,KACTt0B,OACAo0B,QACA+S,EAAQ5tC,KAAK+6B,GAAK5a,IAAI4a,KAExB,OAAO6S,GAGT/S,MAAQ,WAiBN,OAhBAyI,OACAtI,GAAKoB,MACLrB,GAAKqB,MACDnH,SAAS8F,KAAO9F,SAAS+F,IAC3BqR,WAEArsC,KAAK+6B,IACL/6B,KAAKg7B,IACD/F,SAAS8F,IACX0N,sBACSxT,SAAS+F,IAClBwI,sBAEAnL,YAGGwK,WAGTwJ,QAAU,WACR,IAAIruC,EAAGoxB,EAAIif,EAAG9Y,EAAIkY,EAAGiC,EAAIC,EAAI9B,EAAMC,EAAOrL,EAAMmN,EAAMC,EAAMC,EAa5D,IAZA9xC,EAAI,EACJqwC,EAAI,EACJZ,EAAI,EACG,EACC,GACRI,EAAO9S,GAAGwN,OAAOsF,KAAO7S,GAAGuN,OAAOsF,MACvBl8B,QACTw1B,KAAK,yCAEP2G,EAAQ/S,GAAGwN,OAAOuF,MAAQ9S,GAAGuN,OAAOuF,OACpC7S,GAAK5f,aAAayyB,IACfvF,OAAOsF,KAAOA,EACZ7vC,EAAIoxB,EAAK,EAAGqT,EAAO1H,GAAGwN,OAAOsF,KAAO,GAAKpL,EAAOrT,EAAKqT,EAAOrT,EAAKqT,EAAOzkC,EAAI,GAAKykC,IAASrT,IAAOA,EACpG6L,GAAGsN,OAAOoF,IAAI3vC,GAAK+8B,GAAGwN,OAAOoF,IAAI3vC,GAGnC,IADAqwC,EAAIrwC,EACCA,EAAIu3B,EAAK,EAAGqa,EAAO5U,GAAGuN,OAAOsF,KAAO,GAAK+B,EAAOra,EAAKqa,EAAOra,EAAKqa,EAAO5xC,EAAI,GAAK4xC,IAASra,IAAOA,EACpG0F,GAAGsN,OAAOoF,IAAIU,EAAIrwC,GAAKg9B,GAAGuN,OAAOoF,IAAI3vC,GAGvC,IADAyvC,EAAI,EACCzvC,EAAI0xC,EAAK,EAAGG,EAAO9U,GAAGwN,OAAOuF,MAAQ,GAAK+B,EAAOH,EAAKG,EAAOH,EAAKG,EAAO7xC,EAAI,GAAK6xC,IAASH,IAAOA,EACrG,IAAKrB,EAAIsB,EAAK,EAAGG,EAAO9U,GAAGuN,OAAOuF,MAAQ,GAAKgC,EAAOH,EAAKG,EAAOH,EAAKG,EAAOzB,EAAI,GAAKyB,IAASH,IAAOA,EACrG3vC,KAAK+6B,GAAGwN,OAAO3gB,KAAK5pB,IACpBgC,KAAKg7B,GAAGuN,OAAO3gB,KAAKymB,IACpBhW,WACA4C,GAAGsN,OAAO3gB,KAAK6lB,KAAOrR,MAG1B,OAAOp8B,KAAKi7B,KAGdY,UAAY,WAQV,IAPAyH,OACAtI,GAAKoB,MACLrB,GAAKqB,MACL+E,aAAa,GACblG,GAAKmB,MACLlB,GAAKD,GACLF,GAAK5a,IAAI4a,IACFnJ,OAAOmJ,KACRjrB,MAAK2P,IAAIsb,IAAKC,KAChBh7B,KAAKk7B,IACLl7B,KAAKyf,IAAIsb,KACT1C,WACA6C,GAAKkB,QAELp8B,KAAKi7B,IACLj7B,KAAKyf,IAAIsb,KACT1C,WACA4C,GAAKmB,OAEPrB,GAAK5a,IAAI4a,IAIX,OAFA/6B,KAAKi7B,IACLj7B,KAAKk7B,IACE2H,WAaTl1B,mBAAqB,WAGnB,OAFAxB,eACAiwB,MACOiF,YAAY1uB,MAGrBxG,aAAe,WACb,IAAI6zC,EAAeC,EAAiBC,EAAgBC,EAAWC,EA2C/D,OA1CKxuB,OAAOzR,IAAI4a,MACdoM,KAAK,+DAEP6Y,EAAgBvgC,IAAIU,IAAI4a,MACxBmlB,EAAiBzgC,IAAIU,IAAIA,IAAI4a,SACN4M,OAAOh1B,MAC5Bw0B,KAAK,+DAKLiZ,EAHGxuB,OAAOzR,IAAIA,IAAI4a,MAGFtb,IAAIU,IAAIA,IAAIA,IAAI4a,OAFhB4M,OAAOh1B,KAIrByW,MAAM42B,EAAeE,IACvB/Y,KAAK,qBAMPgZ,EAAY,aAAetgB,YAAWmgB,GACtCG,GAAa,WAAatgB,YAAWugB,GACjCr8C,OACFirC,QAAQE,IAAI,sBAAwBiR,IAIb,KAFzBF,EAAkBhW,gCAAgC6N,QAAQqI,KAIxDlW,gCAAgCjqC,KAAKmgD,GACrCnW,8BAA8BhqC,KAAKmgB,IAAI4a,OAEnCh3B,OACFirC,QAAQE,IAAI,sCAAwC/uB,IAAI4a,KAE1DkP,gCAAgCgW,GAAmBE,EACnDnW,8BAA8BiW,GAAmB9/B,IAAI4a,KAIvDsG,YAAY1tB,SACZ3T,KAAKmgB,IAAI4a,KACF9E,KAAK,IAGdzP,iBAAmB,WAEjB,OADAwjB,8BAAgC,GACzBC,gCAAkC,IAG3ChiC,mBAAqB,WAOnB,OAHAue,mBAGO6a,YAAY1uB,MAGrBvG,kBAAoB,WAClB,IAAIi0C,EAEJ,MAAgC,MADhCA,EAA0BtkB,gBAEjB/7B,KAAKo5B,WAAWinB,IAEhBhf,YAAY1uB,MAIvBopB,aAAe,WACb,IAAO3M,EAAItxB,EAAKuiD,EAEhB,IADAA,EAA0B,GACrBjxB,EAAK,EAAGtxB,EAAMksC,8BAA8BjsC,OAAQqxB,EAAKtxB,EAAKsxB,IAC7D4a,8BAA8B5a,GAClCixB,GAA2BrW,8BAAgC,KAE7D,OAAOqW,GAGTh0C,WAAa,WAGX,OAFArM,KAAKuf,KAAKwb,KACVt0B,OACOw1B,SAGTA,MAAQ,WAiBN,OAZAtS,kBACA2Z,OACAvI,GAAKqB,MACLp8B,KAAK+6B,IACLvgB,MACAxa,KAAKsvB,eACLtvB,KAAK+6B,IACLxd,MACA8a,WACA/N,cACA+N,WACA1O,kBACOkZ,WAIT/J,gBAAkB,EAElBzN,cAAgB,WACd,IAAI0iB,EAKJ,OAJI,EACJzK,OACAvI,GAAKqB,MAED/S,OAAO0R,GAAI,IAAM1R,OAAO0R,GAAI,IAAM1R,OAAO0R,IAAK,IAChD/6B,KAAK+6B,SACL8H,YAGF/J,gBAAkBiC,GAAGsS,EAAEH,EACvBa,EAAI5E,IACJje,WACIie,IAAM4E,EAAI,IACZ9X,KAAKkT,IAAM4E,GACX1M,YAAY7uB,UACZk1B,OACA/kB,QAEKkgB,YAMT3X,SAAW,WACT,IAAIkE,EAAIqe,EAMR,IALAA,EAAI,EACA3U,gBAAgB0d,eAClB1d,gBAAkB+L,UAAU/L,gBAAiB,GAC7CqI,cAAc,IAEXsM,EAAIre,EAAK,EAAGA,EAAK,IAAOqe,IAAMre,EAGjC,GAFAqa,cAAcgE,GAEqB,IAA/B3U,gBAAgBwnB,QAAQ,GAC1B,OAGJ,OAAOl1B,YAGTqe,cAAgB,SAASgE,GACvB,IAAIrqB,EAAOoqB,EAAGH,EAId,IAHAjqB,EAAQ,EACRoqB,EAAIrW,KAAK2F,SAAS2Q,IAClBrqB,EAAQ,IACE,CAER,GAAmC,IAA/B0V,gBAAgBwnB,QAAQ,GAI1B,YAHIl9B,GACF4d,YAAYwM,EAAGpqB,IAJX,MAQC2T,QAAQ+B,gBAAiB0U,GAR1B,sBAUR,GAFCH,EARO,WAUFwB,SAIJ,MAHAzrB,IACA0V,gBAAkBuU,EAUtB,GALIjqB,GACF4d,YAAYwM,EAAGpqB,IAIG,IAAhBwT,KAAKyW,EAAGG,GAEV,OADAxM,YAAYlI,gBAAiB,GACtBA,gBAAkB3B,KAAK,IAKlC/L,SAAW,WACT,IAAIm1B,EAAYC,EAAG/S,EAAGkL,EAAGnJ,EAAGf,EAAGgS,EAQ/B,IAPAhT,EAAI,EACJkL,EAAI,EACJ4H,EAAappB,KAAK,GAClBsX,EAAItX,KAAK,GACTspB,EAAStpB,KAAK,GACdsW,EAAI,EACJkL,EAAI,IACM,CACR,GAAI5gB,OAAOe,iBAET,OADAkI,YAAYlI,gBAAiB,GACtB,EAET,OAAU,CAQR,GAPIrP,UACF0d,KAAK,OAGPqI,EAAItX,KAAKuoB,EAAQhS,GACjBe,EAAI3K,UAAU2K,EAAG,GACjBgR,EAAIvpB,KAAKuY,EAAG1W,kBACR7mB,OAAOuuC,EAAG,GAAd,CAcA,GADAxf,YAAYwf,EAAG,GACkB,IAA7B5pB,KAAK4pB,EAAG1nB,iBACV,OAAQ,EAGV0W,EAAI1Y,KAAKgC,gBAAiB0nB,GAI1B/R,EADAe,EAAIpY,KAAKqX,EAFT3V,gBAAkB0W,GAMlBiR,EADAjR,EAAIpY,KAAKqpB,EAAQ3nB,iBAEjB,MAzBc,MAAN2U,IACJgT,EAAShS,EAEThB,EADAkL,GAAK,GAIPnJ,EAAInY,KAAKoX,EAAGA,GACZA,EAAIlY,KAAKiZ,EAAG+Q,GAEZ9R,EADAe,EAAIpY,KAAKqX,EAAG3V,oBAsBpBkI,YAAc,SAASwM,EAAGpqB,GAMxB,IALA2X,GAAK,IAAI5hB,GACNs0B,EAAIp6B,IACP0nB,GAAGsS,EAAEH,EAAIM,EACTzS,GAAGsS,EAAEF,EAAIhW,KAAK,GACdn3B,KAAK+6B,IACD3X,EAAQ,EAQV,OAPAie,YAAYttB,OACZ2zB,QACA3M,GAAK,IAAI5hB,GACNs0B,EAAIp6B,IACP0nB,GAAGsS,EAAEH,EAAI/V,KAAK/T,GACd2X,GAAGsS,EAAEF,EAAIhW,KAAK,GACdn3B,KAAK+6B,IACE9E,KAAK,IAIhB3xB,aAAc,EAEdgI,WAAa,WAQX,OAJAtM,KAAKuf,KAAKwb,KACVt0B,OACAzG,KAAKsf,MAAMyb,KACXt0B,OACO+1B,SAGTA,MAAQ,WAGN,OAFA8G,OACAgJ,UACOzJ,WAGTyJ,QAAU,WACR,IAAIoU,EAA6BC,EAAqBC,EAAWC,EAAUC,EAAWC,EAAmBrgD,EAiBzG,GAbAA,EAAI,EACJs6B,GAAKoB,MACLrB,GAAKqB,MACLykB,EAAW7lB,GACX4lB,EAAY7lB,GAERz2B,aACF0qC,QAAQE,IAAI,UAAYnU,GAAK,MAAQC,IAMnC5R,MAAM2R,GAAIR,MAAQzJ,mBAAmBkK,IASvC,OARItR,mBACFqX,YAAY,GAEZ/gC,KAAKu6B,UAEHj2B,aACF0qC,QAAQE,IAAI,eAAiB0R,EAAY,MAAQC,EAAW,KAAO/Z,MAAMqC,IAAM,KAKnF,GAAI/f,MAAM4R,GAAIT,KAKZ,OAJAv6B,KAAK+6B,SACDz2B,aACF0qC,QAAQE,IAAI,eAAiB0R,EAAY,MAAQC,EAAW,KAAO/Z,MAAMqC,IAAM,KAKnF,GAAIpW,WAAWgI,KAAOhI,WAAWiI,IAU/B,OATItR,mBACFqX,YAAY,GAEZ/gC,KAAKu6B,KAEPxB,cACIz0B,aACF0qC,QAAQE,IAAI,eAAiB0R,EAAY,MAAQC,EAAW,KAAO/Z,MAAMqC,IAAM,KAKnF,GAAIpW,WAAWgI,KAAQnH,aAAaoH,IAKlC,OAJAh7B,KAAKsvB,oBACDhrB,aACF0qC,QAAQE,IAAI,eAAiB0R,EAAY,MAAQC,EAAW,KAAO/Z,MAAMqC,IAAM,KAKnF,GAAIpW,WAAWgI,KAAO9H,kBAAkB+H,IAMtC,OALAh7B,KAAKsvB,eACLyJ,cACIz0B,aACF0qC,QAAQE,IAAI,eAAiB0R,EAAY,MAAQC,EAAW,KAAO/Z,MAAMqC,IAAM,KAKnF,GAAIpW,WAAWgI,MAAQhJ,SAASgJ,KAAOrG,WAAWsG,MAAQtI,UAAUsI,KAAOzG,iBAAiByG,MAAQtR,mBA+BlG,OA9BIplB,aACF0qC,QAAQE,IAAI,2BAEV5qC,aACF0qC,QAAQE,IAAI,2BAA6BlU,GAAGqS,EAAEH,EAAI,MAAQlS,GAAGqS,EAAEF,GAE7DnS,GAAGqS,EAAEH,EAAIlS,GAAGqS,EAAEF,GAChB9L,YAAYttB,OACZ/T,KAAK+6B,IACL/6B,KAAKg7B,IACL/E,KAAK,KAELoL,YAAY7uB,UACZxS,KAAK+6B,IACLsG,YAAYttB,OACZ/T,KAAK+6B,IACLqG,cAAcpG,GAAGqS,EAAEH,EAAE5V,IAAI0D,GAAGqS,EAAEF,GAAInS,GAAGqS,EAAEF,GACvClX,KAAK,GACLA,KAAK,GACD3xB,aACF0qC,QAAQE,IAAI,oBAAsBpI,MAAMqC,IAAM,KAMlD9G,aACI/9B,aACF0qC,QAAQE,IAAI,eAAiB0R,EAAY,MAAQC,EAAW,KAAO/Z,MAAMqC,IAAM,KAKnF,GAAIzU,WAAWqG,KAAOrG,WAAWsG,IAU/B,OATI12B,aACF0qC,QAAQE,IAAI,8CAEdlvC,KAAK+6B,IACL/6B,KAAKg7B,IACL4G,YACIt9B,aACF0qC,QAAQE,IAAI,eAAiB0R,EAAY,MAAQC,EAAW,KAAO/Z,MAAMqC,IAAM,KAKnF,GAAI5Y,cAAcwK,KAAOxK,cAAcyK,IAarC,OAZI12B,aACF0qC,QAAQE,IAAI,mEAEV5qC,aACF0qC,QAAQE,IAAI,kDAEdlvC,KAAK+6B,IACL/6B,KAAKg7B,IACLlU,YACIxiB,aACF0qC,QAAQE,IAAI,eAAiB0R,EAAY,MAAQC,EAAW,KAAO/Z,MAAMqC,IAAM,KAInF,GAAIlU,SAAS8F,IAQX,OAPIz2B,aACF0qC,QAAQE,IAAI,2BAEdvS,oBACIr4B,aACF0qC,QAAQE,IAAI,eAAiB0R,EAAY,MAAQC,EAAW,KAAO/Z,MAAMqC,IAAM,KAMnF,GAAI1pB,IAAIsb,MAAQ4M,OAAOzmC,MAAQ8wB,cAAcgJ,MAAQlK,mBAAmBhD,YAAY6Z,OAAO7lC,yBAUzF,OATIwC,aACF0qC,QAAQE,IAAI,mDAEdlvC,KAAKuf,KAAKwb,KACV/6B,KAAKg7B,IACLwB,aACIl4B,aACF0qC,QAAQE,IAAI,eAAiB0R,EAAY,MAAQC,EAAW,KAAO/Z,MAAMqC,IAAM,KAKnF,GAAIpO,KAAO4M,OAAOjiC,IAAM+Z,IAAIub,MAAQ2M,OAAOn2B,KAKzC,OAJAxR,KAAKuf,KAAKyb,UACN12B,aACF0qC,QAAQE,IAAI,eAAiB0R,EAAY,MAAQC,EAAW,KAAO/Z,MAAMqC,IAAM,KAKnF,GAAIpO,KAAO4M,OAAOjiC,IAAMqsB,SAASiJ,IAQ/B,OAPI12B,aACF0qC,QAAQE,IAAI,8CAEdnO,YAAYwN,KAAKsL,IAAI7e,GAAGwS,SACpBlpC,aACF0qC,QAAQE,IAAI,eAAiB0R,EAAY,MAAQC,EAAW,KAAO/Z,MAAMqC,IAAM,KAOnF,GAAIpO,KAAO4M,OAAOjiC,IAAkC,IAA5BoK,MAAKkrB,GAAI1L,gBAAiD,IAAzBxf,MAAKkrB,GAAI2M,OAAO9zB,OAAe8V,kBACtF0X,YAAYttB,OACZ/T,KAAK+6B,IACL/6B,KAAKg7B,IACL/E,KAAK,GACD3xB,aACF0qC,QAAQE,IAAI,kDAAoDpI,MAAMqC,IAAM,IAE9E9G,QACAse,EAAsBvkB,MACwB,IAA1CtsB,MAAK6wC,EAAqBhZ,OAAO9zB,MAKnC,OAJIvP,aACF0qC,QAAQE,IAAI,iDAAmDyR,QAEjE3gD,KAAK2gD,GAST,GAAIlhC,IAAIsb,MAAQ4M,OAAOn1B,WAAakgB,UAAUsI,IAA9C,CASE,IARI12B,aACF0qC,QAAQE,IAAI,iDAEdnU,GAAK5a,IAAI4a,IACT/6B,KAAKyf,IAAIsb,KACT/6B,KAAKg7B,IACLwB,QACAzB,GAAK5a,IAAI4a,IACFnJ,OAAOmJ,KACZ/6B,KAAKyf,IAAIsb,KACT/6B,KAAKg7B,IACLwB,QACAnE,WACA0C,GAAK5a,IAAI4a,IAEPz2B,aACF0qC,QAAQE,IAAI,eAAiB0R,EAAY,MAAQC,EAAW,KAAO/Z,MAAMqC,IAAM,QAjBnF,CAgCA,GAJA4X,GAAoB,EAChBxwB,cAAchR,KAAKwb,OACrBgmB,EAAoBzb,KAAKnjB,gBAAgB5C,KAAKwb,IAAK8R,QAEjDptB,IAAIsb,MAAQ4M,OAAO5zB,SAAW2e,UAAUsI,KAAO+lB,GASjD,OARA/gD,KAAKuf,KAAKwb,KACV/6B,KAAKsf,MAAMyb,KACX/6B,KAAKg7B,IACL3C,WACAmE,aACIl4B,aACF0qC,QAAQE,IAAI,eAAiB0R,EAAY,MAAQC,EAAW,KAAO/Z,MAAMqC,IAAM,KAcnF,GAVAuX,GAA8B,EAC1B1uB,cAAc1S,MAAMyb,OACtB/6B,KAAKsf,MAAMyb,KACX/6B,KAAKg7B,IACL3C,WACAyoB,EAAY1kB,MACR3I,MAAMqtB,KACRJ,GAA8B,IAG9BjhC,IAAIsb,MAAQ4M,OAAO5zB,QAAU2sC,EAS/B,OARIp8C,aACF0qC,QAAQE,IAAI,sEAEdlvC,KAAKuf,KAAKwb,KACVvgB,WACIlW,aACF0qC,QAAQE,IAAI,eAAiB0R,EAAY,MAAQC,EAAW,KAAO/Z,MAAMqC,IAAM,KAMnF,GAAI/e,WAAakH,MAAMyJ,KAAOxK,cAAcyK,MAC1Ch7B,KAAKg7B,KACLt6B,EAAI67B,eACI,IAAM8U,MAAM3wC,IAQlB,OAPI4D,aACF0qC,QAAQE,IAAI,0DAEdxS,UAAUh8B,QACN4D,aACF0qC,QAAQE,IAAI,eAAiB0R,EAAY,MAAQC,EAAW,KAAO/Z,MAAMqC,IAAM,KAMrF,GAAiB,IAAbI,UAAkB9pB,IAAIsb,MAAQ4M,OAAO7xB,MAAQkc,cAAcgJ,IAiB7D,OAhBI12B,aACF0qC,QAAQE,IAAI,2EAEd/N,aAAa,GACbnhC,KAAKuf,KAAKwb,KACV9X,SACAke,aAAa,GACb3E,QACAgL,WACAxnC,KAAKg7B,IACLoG,cAAc,EAAG,GACjB/I,WACAmE,aACIl4B,aACF0qC,QAAQE,IAAI,eAAiB0R,EAAY,MAAQC,EAAW,KAAO/Z,MAAMqC,IAAM,KAKnF,GAAiB,IAAbI,UAAkB9pB,IAAIsb,MAAQ4M,OAAO/jC,MAAQouB,cAAcgJ,IAiB7D,OAhBI12B,aACF0qC,QAAQE,IAAI,2EAEd/N,aAAa,GACbnhC,KAAKuf,KAAKwb,KACVwL,OACApF,aAAa,GACb3E,QACAgL,WACAxnC,KAAKg7B,IACLoG,cAAc,EAAG,GACjB/I,WACAmE,aACIl4B,aACF0qC,QAAQE,IAAI,eAAiB0R,EAAY,MAAQC,EAAW,KAAO/Z,MAAMqC,IAAM,KAKnF,GAAIzX,gBAAgBqJ,IAAK,CAOvB,GANIz2B,aACF0qC,QAAQE,IAAI,2CAKVxc,UAAUsI,IAuBZ,OAjBAh7B,KAAK+6B,IACLrY,YACAuY,GAAKmB,MACLp8B,KAAKi7B,IAELj7B,KAAKi7B,IACLj7B,KAAK+6B,IACL1C,WACAnS,SACKuN,MAAMuH,MACTh7B,KAAKg7B,IACLjC,SACAyD,cAEEl4B,aACF0qC,QAAQE,IAAI,eAAiB0R,EAAY,MAAQC,EAAW,KAAO/Z,MAAMqC,IAAM,KAKnF,GAAI5Y,cAAcyK,IAwChB,OAvCAh7B,KAAK+6B,IACLvgB,MACAxa,KAAKg7B,IACLwB,QACA2E,cAAc,GACdnhC,KAAK+6B,IACLxd,MACAvd,KAAKg7B,IACL3C,WACI3O,oBAAuBiI,sBAAsBoJ,KAAOhJ,SAASiJ,IAK/D+F,YAAYwN,KAAK16B,IAGjB7T,KAAK2nC,OAAO9zB,KAEdqS,SACAsW,QACAnE,WAMI3a,mCACE5N,MAAKg3B,MAAMqC,IAAM,GAAIxB,OAAOhmC,WAC9By6B,MACAiF,YAAYttB,OACZ/T,KAAK+6B,IACL/6B,KAAKg7B,IACL/E,KAAK,SAGL3xB,aACF0qC,QAAQE,IAAI,eAAiB0R,EAAY,MAAQC,EAAW,KAAO/Z,MAAMqC,IAAM,KAoBrF,IAAInD,iBAaJ,OAPI1hC,aACF0qC,QAAQE,IAAI,kCAEd7N,YAAYttB,OACZ/T,KAAK+6B,IACL/6B,KAAKg7B,IACL/E,KAAK,GACD3xB,YACK0qC,QAAQE,IAAI,eAAiB0R,EAAY,MAAQC,EAAW,KAAO/Z,MAAMqC,IAAM,SADxF,EAZM7kC,aACF0qC,QAAQE,IAAI,oCAyClBxS,UAAY,SAASh8B,GACnB,IAAIwsC,EAAGlvC,EAAGoxB,EAAIif,EAAG9Y,EAAIkY,EAAGiC,EAAIjN,EAAMmN,EAAMC,EAWxC,IAVA3C,EAAI,GACJlvC,EAAI,EACJqwC,EAAI,EACA,EAEJZ,EAAI1vC,OAAOg9B,IAAM,EAEjBkG,WAAWwM,GAAK/sC,EAAI,IAEpBq6B,GAAK5a,IAAI4a,IACJ/8B,EAAIoxB,EAAK,EAAGqT,EAAOgL,EAAI,GAAKhL,EAAOrT,EAAKqT,EAAOrT,EAAKqT,EAAOzkC,EAAI,GAAKykC,IAASrT,IAAOA,EAAI,CAC3F,IAAKif,EAAI9Y,EAAK,EAAGqa,EAAOlvC,EAAI,GAAKkvC,EAAOra,GAAMqa,EAAOra,GAAMqa,EAAOvB,EAAI,GAAKuB,IAASra,IAAOA,EACzFv1B,KAAKyf,IAAIsb,KACToG,aAAakN,GACb7R,QACAsK,MAAMna,MAAQ3uB,GAAK0C,EAAI,GAAK2tC,GAAKjS,MAEnCrB,GAAK5a,IAAI4a,IAKX,IAHAoG,aAAazgC,GACb8qB,YACAuP,GAAKqB,MACAp+B,EAAI0xC,EAAK,EAAGG,EAAOpC,EAAI,GAAKoC,EAAOH,EAAKG,EAAOH,EAAKG,EAAO7xC,EAAI,GAAK6xC,IAASH,IAAOA,EACvFxC,EAAElvC,GAAK,EAIT,OAFAgC,KAAK6sC,MACLzU,iBAAgBqV,EAAG/sC,EAAGwsC,EAAG,EAAGxsC,GACrB47B,UAAUmR,GAAK/sC,EAAI,KA8B5B03B,iBAAkB,SAASqV,EAAG/sC,EAAGwsC,EAAGlvC,EAAG46C,GACrC,IAAIxpB,EAAIif,EAAG9Y,EAAIma,EAAIjN,EAAMmN,EAAMC,EAE/B,GADAxB,EAAI,IACArwC,EAAIyvC,EAAI,GAAZ,CAUA,IAHAP,EAAElvC,GAAK46C,EAEP54C,KAAK+6B,IACAsT,EAAI9Y,EAAK,EAAGqa,EAAOnC,EAAI,GAAKmC,EAAOra,EAAKqa,EAAOra,EAAKqa,EAAOvB,EAAI,GAAKuB,IAASra,IAAOA,EACvF4L,aAAa+L,EAAEmB,IACf7iB,YACAtF,SAGF,IAAKmoB,EAAIqB,EAAK,EAAGG,EAAOpC,EAAI,GAAKoC,EAAOH,EAAKG,EAAOH,EAAKG,EAAOxB,EAAI,GAAKwB,IAASH,IAAOA,EACvF1vC,KAAK8mC,MAAMna,MAAQ0hB,GAAK3tC,EAAI,GAAKwsC,EAAEmB,KACnChW,WAEF,OAAOzd,MAnBL,IAAKyzB,EAAIjf,EAAK,EAAGqT,EAAOmW,EAAI,GAAKnW,EAAOrT,GAAMqT,EAAOrT,GAAMqT,EAAO4L,EAAI,GAAK5L,IAASrT,IAAOA,EACzF8d,EAAElvC,GAAKqwC,EACPjW,iBAAgBqV,EAAG/sC,EAAGwsC,EAAGlvC,EAAI,EAAG46C,EAAIvK,IAyB1CrI,eAAiB,WACf,IAAetlC,EAGf,OAFAA,EAAI,EACJA,EAAI+zB,cAAcuG,KAEhB,KAAK,EACS,EACZ,MACF,KAAK,EAEH,OADAmG,aAAa,GACN,EACT,KAAK,EAEH,OADAA,cAAc,GACP,EACT,KAAK,EAEH,OADAnhC,KAAKsvB,eACE,EACT,KAAK,EAGH,OAFAtvB,KAAKsvB,eACLyJ,SACO,EAEX,GAAItZ,IAAIub,MAAQ2M,OAAOxmC,KAAM,CAE3B,IADA85B,GAAK9a,IAAI6a,IACFpJ,OAAOqJ,OACZv6B,EAAI+zB,cAAchV,IAAIwb,OAItBA,GAAK9a,IAAI8a,IAEX,OAAQv6B,GACN,KAAK,EACH,OAAO,EACT,KAAK,EACHygC,aAAa,GACb,MACF,KAAK,EACHA,cAAc,GACd,MACF,KAAK,EACHnhC,KAAKsvB,eACL,MACF,KAAK,EACHtvB,KAAKsvB,eACLyJ,SAOJ,OALA/4B,KAAKg7B,IACLh7B,KAAKyf,IAAIwb,KACTuM,WACAld,cACA+N,WACO,EAET,OAAO,GAYT7rB,WAAa,WAGX,OAFAxM,KAAKuf,KAAKwb,KACVt0B,OACOo2B,SAGTA,MAAQ,WACN,IAAIn8B,EAOJ,OANAA,EAAI,IACJA,EAAI67B,eACI,GAAK77B,EAAIkR,cACfu1B,KAAK,iCAEPzmC,EAAIo8B,SAASp8B,EAAI,GACVygC,aAAazgC,IAGtB+7B,UAAY,IAEZ/a,SAAU,EAIVjV,WAAa,WAEX,OADA46B,+BAAiC9sB,OAAO4F,IAAI4a,IAAKiC,WAC1Ch9B,KAAK2nC,OAAOh1B,OAKrBjG,kBAAoB,WAElB,OADA26B,+BAAiC9sB,OAAO4F,IAAI4a,IAAKzmB,mBAC1CtU,KAAK2nC,OAAOh1B,OAKrBhG,mBAAqB,WAEnB,OADA06B,+BAAiC9sB,OAAO4F,IAAI4a,IAAKxmB,oBAC1CvU,KAAK2nC,OAAOh1B,OAKrB9F,gBAAkB,WAEhB,OADAw6B,+BAAiC9sB,OAAO4F,IAAI4a,IAAKtmB,iBAC1CzU,KAAK2nC,OAAOh1B,OAKrB/F,gBAAkB,WAChB,IAAIo0C,EAQJ,OAJAA,EAAqBrY,UACrBA,UAAY,EACZtB,+BAAiC9sB,OAAO4F,IAAI4a,IAAKvmB,iBACjDm0B,UAAYqY,EACLhhD,KAAK2nC,OAAOh1B,OAKrB7F,eAAiB,WACf,IAAIm0C,EAGJ,OAFAA,EAAc1mC,OAAO4F,IAAI4a,IAAKrmB,gBAC9B2yB,+BAAiC4Z,EAC1BjhD,KAAK2nC,OAAOh1B,OAGrB4H,OAAS,SAASm0B,EAAGwS,GACnB,IAAI9J,EAAa+J,EAEjB,IADA/J,EAAc,GACPxlB,OAAO8c,IACZ1uC,KAAKyf,IAAIivB,IACTjoC,OACAu0B,GAAKoB,MACL+kB,EAAgBnkB,UACZkkB,IAAoB3sC,oBACtByoB,UAAYzoB,mBACZ6iC,EAAc1W,UAAU1F,IACxB0H,cAAc0U,EAAapmC,kBAClBkwC,IAAoB1sC,iBAC7BwoB,UAAYxoB,gBACZ4iC,EAAc1W,UAAU1F,IACxB0H,cAAc0U,EAAajmC,mBAClB+vC,IAAoB5sC,mBAC7B0oB,UAAY1oB,kBACZ8iC,EAAcra,aAAa/B,IAC3B0H,cAAc0U,EAAarmC,qBAClBmwC,IAAoBzsC,iBAC7BuoB,UAAYvoB,gBACZ2iC,EAAc1W,UAAU1F,IACxB0H,cAAc0U,EAAanmC,mBAClBiwC,IAAoBxsC,iBAC7BsoB,UAAYtoB,eACZ0iC,EAAcvX,YAAW7E,IACzB0H,cAAc0U,EAAalmC,kBAE7B8rB,UAAYmkB,EACZzS,EAAIvuB,IAAIuuB,GAKV,OAHI3qC,OACFirC,QAAQE,IAAI,8BAAgC7H,+BAEvC+P,GAGT1U,cAAgB,SAAS0e,EAAWC,GAClC,IAAIC,EAGJ,OAFA7d,KAAK,IAAM2d,EAAY,KACvBE,EAAellB,MACR0I,YAAY6C,OAAO0Z,GAAiBC,IAG7CrhB,UAAY,SAASwP,GAInB,OAHI1rC,OACFirC,QAAQE,IAAI,gCAAkC7H,+BAEzCoI,GAGTtQ,WAAa,SAASgU,GACpB,OAAOA,GAGTtxB,kCAAoC,SAAS6sB,GAC3C,IAAIyS,EAAeI,EAAiBC,EAapC,OAZAL,EAAgBnkB,UAChBA,UAAYvoB,gBACZ8sC,EAAkB7/B,QAClBA,SAAU,EAGV8/B,GAFAA,EAAiBhiB,WAAWkP,IAEI+S,QAAQ,KAAM,OAC9CzkB,UAAYmkB,EACZz/B,QAAU6/B,EACNx9C,OACFirC,QAAQE,IAAI,wDAA0D7H,+BAEjEma,GAGT9gB,UAAY,SAASgO,GACnB,IAAI0I,EAGJ,OAFAA,EAAc,GACdA,GAAe5X,WAAWkP,IAI5BxP,oBAAsB,SAASnE,GAC7B,IAAIqc,EASJ,OARAA,EAAc,GACVhlB,WAAW2I,IAAOtb,IAAIsb,KAAQ4M,OAAOxmC,MAAQse,IAAIsb,KAAQ4M,OAAOn1B,WAAaiN,IAAIsb,KAAQ4M,OAAO5zB,QAAUgiB,MAAMgF,EAAI8R,OACtHuK,GAAejY,WAAW,KAC1BiY,GAAe5X,WAAWzE,GAC1Bqc,GAAejY,WAAW,MAE1BiY,GAAe5X,WAAWzE,GAErBqc,GAGT9X,oBAAsB,SAAStE,GAC7B,IAAIoc,EASJ,OARAA,EAAc,GACVhlB,WAAW4I,IAAOvb,IAAIub,KAAQ2M,OAAOxmC,MAAQse,IAAIub,KAAQ2M,OAAOn1B,WAAaiN,IAAIub,KAAQ2M,OAAO5zB,QAClGqjC,GAAejY,WAAW,KAC1BiY,GAAe5X,WAAWxE,GAC1Boc,GAAejY,WAAW,MAE1BiY,GAAe5X,WAAWxE,GAErBoc,GASThY,YAAc,SAASsP,EAAGlB,GACxB,IAAI4J,EAKJ,OAJAA,EAAc,GACd9T,OACAvI,GAAKxb,KAAKmvB,GACV1T,GAAK1b,MAAMovB,GACP3b,WAAWiI,KACboc,GAAelY,oBAAoBnE,IACnC8H,UACOuU,IAEC,IAAN5J,IACF4J,GAAejY,WAAW,MAK5Bn/B,KAAKg7B,IACLjC,SACAiC,GAAKoB,MACLgb,GAAepX,aAAYjF,GAAIC,IACrB,IAANwS,IACF4J,GAAejY,WAAW,MAE5B0D,UACOuU,IAKTpY,eAAiB,SAAS0P,GACxB,IAAI0I,EAAa5J,EAAc9sC,EA8B/B,IA7BA02C,EAAc,GACd9qB,KAAO,EACP5rB,EAAI,EACJ8sC,EAAI,EACJlK,OAEA5iC,EAAI,EACJ8sC,EAAI,EACJzS,GAAK5a,IAAIuuB,GACT1T,GAAKvb,IAAIsb,IACLrG,WAAWsG,KACbh7B,KAAKg7B,IACLpD,eACAld,UACAugB,GAAKmB,MACLp8B,KAAKg7B,IACLrD,iBACAuD,GAAKkB,MACAvI,UAAUoH,KACbv6B,IAEGmzB,UAAUqH,KACbsS,IAEFzS,GAAK5a,IAAI4a,MAETE,GAAKV,IACLW,GAAKX,KAEA3I,OAAOmJ,KACZC,GAAKvb,IAAIsb,IACL9J,eAAe+J,IACjBwS,IAEA9sC,IAEFq6B,GAAK5a,IAAI4a,IAMX,GAHIiC,YAAcvoB,kBAChB2iC,GAAenX,UAAU,YAEjB,IAANv/B,EACF02C,GAAejY,WAAW,UAW1B,IATA7S,KAAO,EACPyO,GAAK5a,IAAIuuB,GACLha,WAAWjV,IAAIsb,OACjBA,GAAK5a,IAAI4a,KAENlH,UAAUoH,MACbmc,GAAe3X,cAAaxE,IAC5B3O,KAAO,GAEFsF,OAAOmJ,KACZC,GAAKvb,IAAIsb,IACL9J,eAAe+J,IACL,GAER1O,OACF8qB,GAAetX,uBAEjBsX,GAAe3X,cAAazE,IAC5B1O,KAAO,GAETyO,GAAK5a,IAAI4a,IAsBb,IAlBEqc,GAAenX,UADbjD,YAAcvoB,gBACS,KAChBuoB,YAAcxoB,iBAAoBm0B,UAGlB,IAFA,OAIvB6E,EAAI,GAAKxQ,YAAcvoB,kBACzB2iC,GAAejY,WAAW,MAE5B7S,KAAO,EACPyO,GAAK5a,IAAIuuB,GACLha,WAAWjV,IAAIsb,OACjBA,GAAK5a,IAAI4a,KAENlH,UAAUqH,MACbkc,GAAe3X,cAAavE,IAC5B5O,KAAO,GAEFsF,OAAOmJ,KACZC,GAAKvb,IAAIsb,IACL9J,eAAe+J,MACb1O,OACF8qB,GAAetX,uBAEjBsX,GAAehY,YAAYpE,GAAIwS,GAC/BlhB,KAAO,GAETyO,GAAK5a,IAAI4a,IASX,OAPIyS,EAAI,GAAKxQ,YAAcvoB,kBACzB2iC,GAAejY,WAAW,MAExBnC,YAAcvoB,kBAChB2iC,GAAenX,UAAU,MAE3B4C,UACOuU,GAGT5X,WAAa,SAASkP,GACpB,IAAI0I,EAEJ,GADAA,EAAc,GACV9lB,MAAMod,GAOR,IANAA,EAAIvuB,IAAIuuB,GACqB,MAAzBnJ,aAAa9lB,IAAIivB,MACnB0I,GAAenX,UAAU,MAE3BmX,GAAe7W,WAAW9gB,IAAIivB,IAC9BA,EAAIvuB,IAAIuuB,GACD9c,OAAO8c,IACiB,MAAzBnJ,aAAa9lB,IAAIivB,IAIjB0I,GAAenX,UAHbjD,YAAcxoB,iBAAoBm0B,UAGX,IAFA,OAQzByO,GAAenX,UAHbjD,YAAcxoB,iBAAoBm0B,UAGX,IAFA,OAK7ByO,GAAe7W,WAAW9gB,IAAIivB,IAC9BA,EAAIvuB,IAAIuuB,OAGc,MAApBnJ,aAAamJ,KACf0I,GAAenX,UAAU,MAE3BmX,GAAe7W,WAAWmO,GAE5B,OAAO0I,GAGT7R,aAAe,SAASmJ,GACtB,IAAI0I,EASJ,OARAA,EAAc,GACV33B,IAAIivB,KAAO/G,OAAOn1B,WAAa+d,cAAchR,KAAKmvB,KAAO3Y,MAAMxW,KAAKmvB,GAAI7B,OAEjEtc,cAAcme,IAAM3Y,MAAM2Y,EAAG7B,MADtCuK,GAAe,IAIfA,GAAe,IAEVA,GAGT7W,WAAa,SAASmO,GACpB,IAAI0I,EAAasK,EAAOC,EAAwBC,EAAiBC,EAEjE,GADAzK,EAAc,GACV33B,IAAIivB,KAAO/G,OAAOn1B,WAAa+I,iBAAiBmzB,GAElD,OADA0I,GAAepY,eAAe0P,GAGhC,GAAIjvB,IAAIivB,KAAO/G,OAAOn1B,UAAW,CAsC/B,IArCAk8B,EAAIvuB,IAAIuuB,GAEJ3b,WAAWtT,IAAIivB,MAEjBA,EAAIvuB,IAAIuuB,IAEVmT,GAA2B,EAEvBtxB,cAAc9Q,IAAIivB,MACpBmT,GAA2B,GAe7BF,GAAyB,EACrB3kB,YAAcvoB,iBAAmBmd,OAAOzR,IAAIuuB,KAAOpe,yBAAyB7Q,IAAIivB,MAClFiT,GAAyB,EACzBD,EAAQjiC,IAAIivB,GAAGrB,EAAEF,EAAExsC,YAEjBghD,GACFC,EAAkBxK,EAClBA,EAAc,IAEdA,GAAe3X,cAAahgB,IAAIivB,IAElCA,EAAIvuB,IAAIuuB,GAED9c,OAAO8c,IAKR1R,YAAcvoB,iBACZotC,GAOEhjC,KAAK6vB,KAAO/G,OAAO5zB,QACjBwc,cAAc9Q,IAAIU,IAAIV,IAAIivB,QACvBtc,WAAW3S,IAAIU,IAAIA,IAAIV,IAAIivB,SAC9B0I,GAAe,aAMzBA,GAAetX,sBACfsX,GAAe3X,cAAahgB,IAAIivB,IAAI,GAAO,GAC3CmT,GAA2B,EACvBtxB,cAAc9Q,IAAIivB,MACpBmT,GAA2B,GAE7BnT,EAAIvuB,IAAIuuB,GAENiT,IACFvK,EAAcwK,EAAkB,UAAYxK,EAAc,KAAOsK,EAAQ,UAG3EtK,GAAe3X,cAAaiP,GAE9B,OAAO0I,GAGTlX,cAAgB,SAASwO,GACvB,IAAI0I,EAKJ,OAJAA,EAAc,GACdA,GAAejY,WAAW,KAC1BiY,GAAe5X,WAAWkP,GAC1B0I,GAAejY,WAAW,MAI5BO,yBAA2B,SAASgP,GAClC,IAAI0I,EASJ,OARAA,EAAc,GACd1I,EAAInvB,KAAKmvB,GACLtc,WAAWsc,IAAMjvB,IAAIivB,KAAO/G,OAAOxmC,MAAQse,IAAIivB,KAAO/G,OAAOn1B,WAAaiN,IAAIivB,KAAO/G,OAAO5zB,QAAU0L,IAAIivB,KAAO/G,OAAOr4B,WAC1H8nC,GAAelX,cAAcwO,GAE7B0I,GAAe5X,WAAWkP,GAE5B0I,GAAejY,WAAW,MAI5BlC,gBAAkB,SAASyR,GACzB,IAAI0I,EAKJ,OAJAA,EAAc,GACdA,GAAenX,UAAU,YACzBmX,GAAe5X,WAAWjgB,KAAKmvB,IAC/B0I,GAAenX,UAAU,eAI3B5C,qBAAuB,SAASqR,GAC9B,IAAI0I,EAOJ,OANAA,EAAc,GACdA,GAAenX,UAAU,YACzBmX,GAAe5X,WAAWjgB,KAAKmvB,IAC/B0I,GAAenX,UAAU,MACzBmX,GAAe5X,WAAWlgB,MAAMovB,IAChC0I,GAAenX,UAAU,OAI3BxC,gBAAkB,SAASiR,GACzB,IAAI0I,EAKJ,OAJAA,EAAc,GACdA,GAAe5X,WAAWjgB,KAAKmvB,IAC/B0I,GAAenX,UAAU,YACzBmX,GAAe5X,WAAWlgB,MAAMovB,KAIlClR,kBAAoB,SAASkR,GAC3B,IAAI0I,EAMJ,OALAA,EAAc,OACdA,GAAe5X,WAAWjgB,KAAKmvB,IAC/B0I,GAAe,KACfA,GAAe5X,WAAWlgB,MAAMovB,IAChC0I,GAAe,KAIjBnZ,kBAAoB,SAASyQ,GAC3B,IAAI0I,EAIJ,OAHAA,EAAc,YACdA,GAAe5X,WAAWjgB,KAAKmvB,IAC/B0I,GAAe,KAIjB9Z,kBAAoB,SAASoR,GAC3B,IAAI0I,EAIJ,OAHAA,EAAc,YACdA,GAAe5X,WAAWjgB,KAAKmvB,IAC/B0I,GAAe,KAIjB/Y,kBAAoB,SAASqQ,GAC3B,IAAI0I,EAIJ,OAHAA,EAAc,YACdA,GAAe5X,WAAWjgB,KAAKmvB,IAC/B0I,GAAe,KAIjBja,qBAAuB,SAASuR,GAC9B,IAAI0I,EAIJ,OAHAA,EAAc,aACdA,GAAe5X,WAAWjgB,KAAKmvB,IAC/B0I,GAAe,KAIjBla,qBAAuB,SAASwR,GAC9B,IAAI0I,EAIJ,OAHAA,EAAc,aACdA,GAAe5X,WAAWjgB,KAAKmvB,IAC/B0I,GAAe,KAIjBha,qBAAuB,SAASsR,GAC9B,IAAI0I,EAIJ,OAHAA,EAAc,aACdA,GAAe5X,WAAWjgB,KAAKmvB,IAC/B0I,GAAe,KAIjBlZ,iBAAmB,SAASwQ,GAC1B,IAAI0I,EAKJ,OAJAA,EAAc,GACdA,GAAenX,UAAU,WACzBmX,GAAe5X,WAAWjgB,KAAKmvB,IAC/B0I,GAAenX,UAAU,OAI3BnB,sBAAwB,SAAS4P,GAC/B,IAAI0I,EAYJ,OAXAA,EAAc,GACdA,GAAenX,UAAU,KACrBrO,OAAOrS,KAAKmvB,MACd0I,GAAenX,UAAU,MAE3BmX,GAAe5X,WAAWjgB,KAAKmvB,IAC3B9c,OAAOrS,KAAKmvB,MACd0I,GAAenX,UAAU,MAE3BmX,GAAenX,UAAU,KACzBmX,GAAenX,UAAU,OAI3BpB,wBAA0B,SAAS6P,GACjC,IAAI0I,EAKJ,OAJAA,EAAc,GACdA,GAAenX,UAAU,cACzBmX,GAAe5X,WAAWjgB,KAAKmvB,IAC/B0I,GAAenX,UAAU,MAI3BlB,mBAAqB,SAAS2P,GAC5B,IAAI0I,EAKJ,OAJAA,EAAc,GACdA,GAAenX,UAAU,aACzBmX,GAAe5X,WAAWjgB,KAAKmvB,IAC/B0I,GAAenX,UAAU,MAI3BpC,gBAAkB,SAAS6Q,GACzB,IAAI0I,EAYJ,OAXAA,EAAc,GACdA,GAAenX,UAAU,KACrBrO,OAAOrS,KAAKmvB,MACd0I,GAAenX,UAAU,MAE3BmX,GAAe5X,WAAWjgB,KAAKmvB,IAC3B9c,OAAOrS,KAAKmvB,MACd0I,GAAenX,UAAU,MAE3BmX,GAAenX,UAAU,KACzBmX,GAAenX,UAAU,UAI3BrC,kBAAoB,SAAS8Q,GAC3B,IAAI0I,EAKJ,OAJAA,EAAc,GACdA,GAAenX,UAAU,QACzBmX,GAAe5X,WAAWjgB,KAAKmvB,IAC/B0I,GAAenX,UAAU,MAI3B1C,mBAAqB,SAASmR,GAC5B,IAAI0I,EAAa0K,EAAc9jD,EAAGoxB,EAAI2yB,EAAmBC,EAAkBvf,EAAMwf,EAAaC,EAM9F,IALA9K,EAAc,GACd0K,EAAeriC,IAAIU,IAAIuuB,IAEvBsT,EADAtT,EAAIvuB,IAAIuuB,GAERqT,EAAoB,EACbnwB,OAAOzR,IAAIA,IAAIuuB,MACpBqT,IACAE,EAAc9hC,IAAIA,IAAIuuB,IACtB0I,GAAenX,UAAU,WACzBmX,GAAe5X,WAAW/f,IAAIU,IAAI8hC,KAClC7K,GAAenX,UAAU,OACzBmX,GAAe5X,WAAW/f,IAAIwiC,IAC9B7K,GAAenX,UAAU,UACzByO,EAAIvuB,IAAI8hC,GAKV,IAHA7K,GAAe5X,WAAWsiB,GAC1B1K,GAAenX,UAAU,QACzByO,EAAIsT,EACChkD,EAAIoxB,EAAK,EAAGqT,EAAOsf,EAAoB,GAAKtf,EAAOrT,GAAMqT,EAAOrT,GAAMqT,EAAOzkC,EAAI,GAAKykC,IAASrT,IAAOA,EACzG8yB,EAAc/hC,IAAIuuB,GAClB0I,GAAenX,UAAU,iBACzBmX,GAAe5X,WAAW/f,IAAIyiC,IAC1BlkD,EAAI+jD,IACN3K,GAAenX,UAAU,UAE3ByO,EAAIvuB,IAAIA,IAAI+hC,IAEd,OAAO9K,GAGTjX,aAAe,SAASuO,GACtB,IAAI0I,EAGJ,OAFAA,EAAc,GACdA,GAAehX,qBAAmBsO,EAAG,EAAG,GAAG,IAO7CtO,qBAAqB,SAASsO,EAAGL,EAAGZ,GAClC,IAAI2J,EAAap5C,EAAGoxB,EAAImG,EAAIkN,EAAMmN,EAUlC,GATAwH,EAAc,GACdA,GAAenX,UAAU,KAQrBoO,EAAIK,EAAEnG,OAAOsF,KAAO,EACtB,IAAK7vC,EAAIoxB,EAAK,EAAGqT,EAAOiM,EAAEnG,OAAOoF,IAAIU,GAAK,GAAK5L,EAAOrT,EAAKqT,EAAOrT,EAAKqT,EAAOzkC,EAAI,GAAKykC,IAASrT,IAAOA,EAAI,OACxFgR,qBAAmBsO,EAAGL,EAAI,EAAGZ,GAD2D,sBACxGA,EADwG,KAEzG2J,GAFyG,KAKrGp5C,IAAM0wC,EAAEnG,OAAOoF,IAAIU,GAAK,IAC1B+I,GAAenX,UAAU,WAM7B,IAAKjiC,EAAIu3B,EAAK,EAAGqa,EAAOlB,EAAEnG,OAAOoF,IAAIU,GAAK,GAAKuB,EAAOra,EAAKqa,EAAOra,EAAKqa,EAAO5xC,EAAI,GAAK4xC,IAASra,IAAOA,EACrG6hB,GAAe5X,WAAWkP,EAAEnG,OAAO3gB,KAAK6lB,IAGpCzvC,IAAM0wC,EAAEnG,OAAOoF,IAAIU,GAAK,IAC1B+I,GAAenX,UAAU,MAE3BwN,IAIJ,MAAO,CAACA,EADR2J,GAAenX,UAAU,OAI3BK,mBAAqB,SAASoO,GAC5B,IAAI0I,EAKJ,OAJAA,EAAc,GACV1I,EAAEnG,OAAOsF,MAAQ,IACnBuJ,GAAe/W,2BAAyB,EAAMqO,EAAG,EAAG,GAAG,IAElD0I,GAYT/W,0BAA2B,SAAS8hB,EAAYzT,EAAGL,EAAGZ,GACpD,IAAI2J,EAAap5C,EAAGoxB,EAAImG,EAAIkN,EAAMmN,EAalC,GAZAwH,EAAc,GAEV+K,IACF/K,GAAe,qBASb/I,EAAIK,EAAEnG,OAAOsF,KAAO,EACtB,IAAK7vC,EAAIoxB,EAAK,EAAGqT,EAAOiM,EAAEnG,OAAOoF,IAAIU,GAAK,GAAK5L,EAAOrT,EAAKqT,EAAOrT,EAAKqT,EAAOzkC,EAAI,GAAKykC,IAASrT,IAAOA,EAAI,OACxFiR,0BAAyB,EAAGqO,EAAGL,EAAI,EAAGZ,GADkD,sBACxGA,EADwG,KAEzG2J,GAFyG,KAGrGp5C,IAAM0wC,EAAEnG,OAAOoF,IAAIU,GAAK,IAE1B+I,GAAenX,UAAU,gBAM7B,IAAKjiC,EAAIu3B,EAAK,EAAGqa,EAAOlB,EAAEnG,OAAOoF,IAAIU,GAAK,GAAKuB,EAAOra,EAAKqa,EAAOra,EAAKqa,EAAO5xC,EAAI,GAAK4xC,IAASra,IAAOA,EACrG6hB,GAAe5X,WAAWkP,EAAEnG,OAAO3gB,KAAK6lB,IAEpCzvC,IAAM0wC,EAAEnG,OAAOoF,IAAIU,GAAK,IAC1B+I,GAAenX,UAAU,QAE3BwN,IAOJ,OAHI0U,IACF/K,GAAe,mBAEV,CAAC3J,EAAG2J,IAGbhZ,gBAAkB,SAASsQ,GACzB,IAAI0I,EAUJ,OATAA,EAAc,UACdA,GAAe5X,WAAWlgB,MAAMovB,IAChC0I,GAAe,IACfA,GAAe5X,WAAWngB,OAAOqvB,IACjC0I,GAAe,MACfA,GAAe5X,WAAWpgB,QAAQsvB,IAClC0I,GAAe,KACfA,GAAe5X,WAAWjgB,KAAKmvB,IAC/B0I,GAAe,KAIjBjZ,kBAAoB,SAASuQ,GAC3B,IAAiB0T,EAAMC,EAAYC,EAAYrK,EAM/C,OALAmK,EAAO7iC,KAAKmvB,GACZuJ,EAAW34B,MAAMovB,GACjB2T,EAAahjC,OAAOqvB,GACpB4T,EAAaljC,QAAQsvB,GACP,oBAA2BuJ,EAA3B,2CAA6FzY,WAAW6iB,GAAxG,uBAAoJ7iB,WAAW8iB,GAA/J,WAA+LrK,EAAW,kBAAoBA,EAAW,kBAAoBA,EAA7P,yBAAwSzY,WAAW4iB,GAAnT,8BAIhBxjB,iBAAmB,SAAS8P,GAC1B,IAAI0I,EAGJ,IAFAA,EAAc,+BACd1I,EAAIvuB,IAAIuuB,GACD9c,OAAO8c,IAAI,CAIhB,GAAIvuB,IAAIuuB,KAAO/G,OAAOh1B,KAAM,CAC1BykC,GAAe,IACfA,GAAe5X,WAAW/f,IAAIivB,IAC9B0I,GAAe,iBACfA,GAAe,YACf,MAEFA,GAAe,IACfA,GAAe5X,WAAWjgB,KAAKmvB,IAC/B0I,GAAe,YACfA,GAAe5X,WAAW/f,IAAIivB,IAC9B0I,GAAe,YAGf1I,EAAIxuB,KAAKwuB,GAGX,OADA0I,EAAcA,EAAYI,UAAU,EAAGJ,EAAYr5C,OAAS,IACtC,yBAGxB4gC,mBAAqB,SAAS+P,GAC5B,IAAI0I,EAAamL,EAIjB,IAHAnL,EAAc,eACd1I,EAAIvuB,IAAIuuB,GACR6T,EAAa,EACN3wB,OAAO8c,IAAI,CAIhB,GAAIvuB,IAAIuuB,KAAO/G,OAAOh1B,KAAM,CAC1BykC,GAAe,SACfA,GAAe,WAAa5X,WAAW/f,IAAIivB,IAAM,KACjD0I,GAAe,IACf,MAEEmL,IACFnL,GAAe,UAEjBA,GAAe,OAAS5X,WAAW/f,IAAIivB,IAAM,KAC7C0I,GAAe,WAAa5X,WAAWjgB,KAAKmvB,IAAM,KAClD0I,GAAe,IAGfmL,IACA7T,EAAIxuB,KAAKwuB,GAGX,OADA0I,GAAe,QAIjB1Y,mBAAqB,SAASgQ,GAC5B,IAAI0I,EAOJ,OANAA,EAAc,IACdA,GAAe5X,WAAWjgB,KAAKmvB,IAC/B0I,GAAe,IACfA,GAAe,MACfA,GAAe,KACfA,GAAe5X,WAAWlgB,MAAMovB,KACV,KAGxBjQ,mBAAqB,SAASiQ,GAC5B,IAAI0I,EAOJ,OANAA,EAAc,IACdA,GAAe5X,WAAWjgB,KAAKmvB,IAC/B0I,GAAe,IACfA,GAAe,UACfA,GAAe,KACfA,GAAe5X,WAAWlgB,MAAMovB,KACV,KAGxBlQ,mBAAqB,SAASkQ,GAC5B,IAAI0I,EAOJ,OANAA,EAAc,IACdA,GAAe5X,WAAWjgB,KAAKmvB,IAC/B0I,GAAe,IACfA,GAAe,MACfA,GAAe,KACfA,GAAe5X,WAAWlgB,MAAMovB,KACV,KAGxBnQ,mBAAqB,SAASmQ,GAC5B,IAAI0I,EAOJ,OANAA,EAAc,IACdA,GAAe5X,WAAWjgB,KAAKmvB,IAC/B0I,GAAe,IACfA,GAAe,UACfA,GAAe,KACfA,GAAe5X,WAAWlgB,MAAMovB,KACV,KAGxBpQ,mBAAqB,SAASoQ,GAC5B,IAAI0I,EAOJ,OANAA,EAAc,IACdA,GAAe5X,WAAWjgB,KAAKmvB,IAC/B0I,GAAe,IACfA,GAAe,MACfA,GAAe,KACfA,GAAe5X,WAAWlgB,MAAMovB,KACV,KAGxB/Q,kBAAoB,SAAS+Q,GAC3B,IAAiB0T,EAAMC,EAAYC,EAAYrK,EAM/C,OALAmK,EAAO7iC,KAAKmvB,GACZuJ,EAAW34B,MAAMovB,GACjB2T,EAAahjC,OAAOqvB,GACpB4T,EAAaljC,QAAQsvB,GACP,oBAA2BuJ,EAA3B,uBAAoEzY,WAAW6iB,GAA/E,uBAA2H7iB,WAAW8iB,GAAtI,WAAsKrK,EAAW,kBAAoBA,EAAW,kBAAoBA,EAApO,YAAkQzY,WAAW4iB,GAA7Q,WAIhB1kB,iBAAmB,SAASgR,GAC1B,IAAI0I,EAGJ,IAFAA,EAAc,GACd1I,EAAIvuB,IAAIuuB,GACD9c,OAAO8c,IACZ0I,GAAe5X,WAAW/f,IAAIivB,IAC9BA,EAAIvuB,IAAIuuB,GAEV,OAAO0I,GAGTpZ,mBAAqB,SAAS0Q,GAC5B,IAAI0I,EAMJ,OALAA,EAAc,GACdA,GAAe5X,WAAWjgB,KAAKmvB,IAC/B0I,GAAe,MACfA,GAAe5X,WAAWlgB,MAAMovB,IAChC0I,GAAe,MAIjBrZ,oBAAsB,SAAS2Q,GAC7B,IAAI0I,EAUJ,OATAA,EAAc,WACdA,GAAe5X,WAAWlgB,MAAMovB,IAChC0I,GAAe,IACfA,GAAe5X,WAAWngB,OAAOqvB,IACjC0I,GAAe,MACfA,GAAe5X,WAAWpgB,QAAQsvB,IAClC0I,GAAe,KACfA,GAAe5X,WAAWjgB,KAAKmvB,IAC/B0I,GAAe,KAIjBtZ,sBAAwB,SAAS4Q,GAC/B,IAAiB0T,EAAMC,EAAYC,EAAYrK,EAM/C,OALAmK,EAAO7iC,KAAKmvB,GACZuJ,EAAW34B,MAAMovB,GACjB2T,EAAahjC,OAAOqvB,GACpB4T,EAAaljC,QAAQsvB,GACP,oBAA2BuJ,EAA3B,+CAAiGzY,WAAW6iB,GAA5G,uBAAwJ7iB,WAAW8iB,GAAnK,WAAmMrK,EAAW,kBAAoBA,EAAW,kBAAoBA,EAAjQ,6BAAgTzY,WAAW4iB,GAA3T,kCAIhBnjB,WAAa,SAASyP,GACpB,IAAI0I,EAaJ,OAZAA,EAAc,GACV9lB,MAAM/R,KAAKmvB,KAAO9vB,MAAM8vB,KAAO/G,OAAOn1B,WAAaoM,MAAM8vB,KAAO/G,OAAO5zB,QAAUsf,iBAAiB9T,KAAKmvB,KACzG0I,GAAenX,UAAU,KACzBmX,GAAe5X,WAAWjgB,KAAKmvB,IAC/B0I,GAAenX,UAAU,MAChB1P,cAAchR,KAAKmvB,MAAQ3Y,MAAMxW,KAAKmvB,GAAI7B,OAASza,WAAW7S,KAAKmvB,MAC5E0I,GAAenX,UAAU,KACzBmX,GAAe3X,cAAalgB,KAAKmvB,IACjC0I,GAAenX,UAAU,MAEzBmX,GAAe3X,cAAalgB,KAAKmvB,IAE5B0I,GAGT7X,eAAiB,SAASmP,GACxB,IAAI0I,EASJ,OARAA,EAAc,GACVxlB,OAAOtS,MAAMovB,KAAOtc,WAAW9S,MAAMovB,KAAQne,cAAcjR,MAAMovB,KAAO3Y,MAAMzW,MAAMovB,GAAI7B,OAC1FuK,GAAenX,UAAU,KACzBmX,GAAe5X,WAAWlgB,MAAMovB,IAChC0I,GAAenX,UAAU,MAEzBmX,GAAe3X,cAAangB,MAAMovB,IAE7B0I,GAGTpX,aAAc,SAASkZ,EAAMsJ,GAC3B,IAAIpL,EAAaqL,EAAeC,EAAaC,EAO7C,GANAvL,EAAc,GAEVrzC,OACFirC,QAAQE,IAAI,eAAiBgK,EAAjB,eAA8CsJ,GAGxD5uB,aAAa4uB,GACf,GAAIn5B,OAAO6vB,EAAM,IACf,GAAIx3B,QAEF,OADA01B,GAAenX,UAAU,kBAGtB,CACL,GAAIjD,YAAcvoB,gBAIhB,OAHA2iC,GAAenX,UAAU,WACzBmX,GAAe5X,WAAW0Z,GAC1B9B,GAAenX,UAAU,KAEpB,GAAIve,QAIT,OAHA01B,GAAenX,UAAU,cACzBmX,GAAe5X,WAAW0Z,GAC1B9B,GAAenX,UAAU,KAK/B,GAAK5W,OAAOyE,YAAY6Z,OAAO9yB,sBAAuB,IAAOqkC,IAASvR,OAAOjiC,GAC3E,OAAIgc,SACF01B,GAAenX,UAAU,aACzBmX,GAAe9X,oBAAoBkjB,GACnCpL,GAAenX,UAAU,OAGvBjD,YAAcvoB,iBAChB2iC,GAAenX,UAAU,OACzBmX,GAAe5X,WAAWgjB,GAC1BpL,GAAenX,UAAU,OAEzBmX,GAAenX,UAAU,QACzBmX,GAAe5X,WAAWgjB,GAC1BpL,GAAenX,UAAU,MAEpBmX,GAET,GAAI11B,QAMF,OALA01B,GAAenX,UAAU,aACzBmX,GAAelY,oBAAoBga,GACnC9B,GAAenX,UAAU,MACzBmX,GAAe9X,oBAAoBkjB,GACnCpL,GAAenX,UAAU,KAG3B,GAAK5W,OAAOyE,YAAY6Z,OAAO7yB,sBAAuB,IAA0B,MAAnBokC,EAAK5L,UAAmB,CAQnF,GAAI4L,IAASvR,OAAOjiC,GAAI,CACtB,GAAIqtB,WAAWyvB,GAkBb,OAhBEpL,GAAenX,UADbjD,YAAcvoB,gBACS,aAChBuoB,YAAcxoB,iBAAoBm0B,UAGlB,KAFA,QAIvB/W,OAAOsnB,IAASlc,YAAcvoB,iBAChC2iC,GAAenX,UAAU,KACzBmX,GAAe5X,WAAW0Z,GAC1B9B,GAAenX,UAAU,MAEzBmX,GAAe5X,WAAW0Z,GAExBlc,YAAcvoB,kBAChB2iC,GAAenX,UAAU,MAEpBmX,EAET,GAAI9jB,eAAekvB,GAsBjB,OApBEpL,GAAenX,UADbjD,YAAcvoB,gBACS,aAChBuoB,YAAcxoB,iBAAoBm0B,UAGlB,KAFA,QAI3B3oC,KAAKwiD,GACLrhB,cAAc,GACd9I,WACAqqB,EAActmB,MACVxK,OAAOsnB,IAASlc,YAAcvoB,iBAChC2iC,GAAenX,UAAU,KACzBmX,GAAepX,aAAYkZ,EAAMwJ,GACjCtL,GAAenX,UAAU,MAEzBmX,GAAepX,aAAYkZ,EAAMwJ,GAE/B1lB,YAAcvoB,kBAChB2iC,GAAenX,UAAU,MAEpBmX,EAGX,GAAIhlB,WAAWowB,IAAaxlB,YAAcvoB,gBAiBxC,OAhBA2iC,GAAenX,UAAU,UACzBjgC,KAAKwiD,GACLp9B,eACAq9B,EAAgBrmB,MACXtI,UAAU2uB,KACbrL,GAAenX,UAAU,KACzBmX,GAAe5X,WAAWijB,GAC1BrL,GAAenX,UAAU,MAE3BmX,GAAenX,UAAU,KACzBjgC,KAAKwiD,GACLnoB,aACAsoB,EAAcvmB,MAEdgb,GAAepX,aAAYkZ,EAD3BsJ,EAAWG,GAEXvL,GAAenX,UAAU,KA+D7B,OA3DIjD,YAAcvoB,iBAAmBof,UAAU2uB,GAO7CpL,GAAe5X,WAAW0Z,IAKtB5nB,MAAM4nB,IAAS7lB,iBAAiB6lB,IAClC9B,GAAenX,UAAU,KACzBmX,GAAe5X,WAAW0Z,GAC1B9B,GAAenX,UAAU,MAChBxgB,IAAIy5B,KAAUvR,OAAOn1B,WAAaiN,IAAIy5B,KAAUvR,OAAO5zB,QAC5DipB,YAAcvoB,kBAChB2iC,GAAenX,UAAU,MAE3BmX,GAAe3X,cAAayZ,GAAM,GAC9Blc,YAAcvoB,kBAChB2iC,GAAenX,UAAU,OAElB1P,cAAc2oB,KAAUnjB,MAAMmjB,EAAMrM,OAASza,WAAW8mB,KACjE9B,GAAenX,UAAU,KACzBmX,GAAe3X,cAAayZ,GAC5B9B,GAAenX,UAAU,MAEzBmX,GAAe3X,cAAayZ,GAQ5B9B,GAAenX,UAJbjD,YAAcxoB,iBAAoBm0B,UAIX,IAFAlM,WAKvBO,YAAcvoB,gBAIZ+qB,WAAWgjB,GAAUzkD,OAAS,GAChCq5C,GAAenX,UAAU,KACzBmX,GAAe5X,WAAWgjB,GAC1BpL,GAAenX,UAAU,MAEzBmX,GAAe5X,WAAWgjB,GAEnB5wB,OAAO4wB,IAAapwB,WAAWowB,IAAcjyB,cAAciyB,IAAazsB,MAAMysB,EAAU3V,OACjGuK,GAAenX,UAAU,KACzBmX,GAAe5X,WAAWgjB,GAC1BpL,GAAenX,UAAU,MAEzBmX,GAAe3X,cAAa+iB,IAGzBpL,GAGTxX,qBAAuB,SAAS8O,GAC9B,IAAI0I,EAUJ,GATAA,EAAc,GACd1I,EAAIvuB,IAAIuuB,GACJ7vB,KAAK6vB,KAAO/G,OAAOxmC,MAAQ0d,KAAK6vB,KAAO/G,OAAOn1B,WAAaqM,KAAK6vB,KAAO/G,OAAO5zB,QAAU8K,KAAK6vB,KAAO/G,OAAOr4B,WAC7G8nC,GAAelX,cAAczgB,IAAIivB,IAEjC0I,GAAe5X,WAAW/f,IAAIivB,IAEhC0I,GAAenX,UAAU,KACzByO,EAAIvuB,IAAIuuB,GACJ9c,OAAO8c,GAGT,IAFA0I,GAAe5X,WAAW/f,IAAIivB,IAC9BA,EAAIvuB,IAAIuuB,GACD9c,OAAO8c,IACZ0I,GAAenX,UAAU,KACzBmX,GAAe5X,WAAW/f,IAAIivB,IAC9BA,EAAIvuB,IAAIuuB,GAIZ,OADA0I,GAAenX,UAAU,MAI3BR,cAAe,SAASiP,EAAGkU,EAAYC,GACrC,IAAIzL,EAAa8B,EAAMsJ,EAAUM,EAAOC,EAGxC,GADA3L,EAAc,GACV7mB,cAAcme,GAkBhB,OAPImU,GAAmB9sB,MAAM2Y,EAAG7B,QAC9BuK,GAAe,KAEjBA,GAAerX,aAAa2O,EAAGmU,GAC3BA,GAAmB9sB,MAAM2Y,EAAG7B,QAC9BuK,GAAe,KAEVA,EAET,GAAItiB,MAAM4Z,GAIR,OAHA0I,GAAenX,UAAU,KACzBmX,GAAenX,UAAUyO,EAAEnB,KAC3B6J,GAAenX,UAAU,KAG3B,GAAIhL,SAASyZ,GAMX,OAJE0I,GADEpa,YAAcvoB,gBACD6rB,mBAAmBoO,GAEnBvO,aAAauO,GAIhC,GAAIjvB,IAAIivB,KAAO/G,OAAOn1B,UAoBpB,OAnBKowC,GACqB,MAApBrd,aAAamJ,IAAc1R,YAAcvoB,kBAEzC2iC,GAAenX,UADbjD,YAAcvoB,gBACS,YAEA,MAI/B2iC,GAAe5X,WAAWkP,GACrBkU,GACqB,MAApBrd,aAAamJ,IAAc1R,YAAcvoB,kBAEzC2iC,GAAenX,UADbjD,YAAcvoB,gBACS,cAEA,MAIxB2iC,EACF,GAAI9lB,MAAMod,GAQf,OAPKkU,IACHxL,GAAenX,UAAU,MAE3BmX,GAAe5X,WAAWkP,GACrBkU,IACHxL,GAAenX,UAAU,MAEpBmX,EAET,GAAI33B,IAAIivB,KAAO/G,OAAO5zB,OAIpB,OAHAmlC,EAAO35B,KAAKmvB,GACZ8T,EAAWljC,MAAMovB,GACjB0I,GAAepX,aAAYkZ,EAAMsJ,GAkBnC,GAAI/iC,IAAIivB,KAAO/G,OAAO93B,UAapB,OAZAizC,EAAQvjC,KAAKmvB,GACRhtB,UACHqhC,EAAazjC,MAAMovB,GACnB0I,GAAenX,UAAU,aACrBl8B,OACFirC,QAAQE,IAAI,mCAAqC7H,+BAGnD+P,GADWvX,YAAWkjB,GAEtB3L,GAAenX,UAAU,SAE3BmX,GAAe5X,WAAWsjB,GAG5B,GAAIrjC,IAAIivB,KAAO/G,OAAOh0B,SAYpB,OAXAyjC,GAAe5X,WAAW5gB,MAAM8vB,IAE9B0I,GAAenX,UADbjD,YAAcvoB,gBACS,iBAErBuoB,YAAcxoB,iBAAoBm0B,UAGX,KAFA,QAK7ByO,GAAe5X,WAAW/f,IAAIU,IAAIZ,KAAKmvB,MAGzC,GAAIjvB,IAAIivB,KAAO/G,OAAOv3B,QAAU2kB,SAASxV,KAAKmvB,IAE5C,OADA0I,GAAexX,qBAAqB8O,GAGtC,GAAIjvB,IAAIivB,KAAO/G,OAAOr4B,WAEpB,OADA8nC,GAAe1X,yBAAyBgP,GAEnC,GAAIjvB,IAAIivB,KAAO/G,OAAOzmC,MAAQ87B,YAAcvoB,gBAEjD,OADA2iC,GAAena,gBAAgByR,GAE1B,GAAIjvB,IAAIivB,KAAO/G,OAAOzxB,OAAS8mB,YAAcvoB,gBAGlD,OADA2iC,GAAelZ,iBAAiBwQ,GAE3B,GAAIjvB,IAAIivB,KAAO/G,OAAOpvB,WAAY,CACvC,GAAIykB,YAAcvoB,gBAEhB,OADA2iC,GAAetY,sBAAsB4P,GAEhC,GAAIhtB,QAET,OADA01B,GAAevY,wBAAwB6P,QAGpC,GAAIjvB,IAAIivB,KAAO/G,OAAOvuB,OAC3B,GAAIsI,QAEF,OADA01B,GAAerY,mBAAmB2P,QAG/B,GAAIjvB,IAAIivB,KAAO/G,OAAOp3B,KAAM,CACjC,GAAIysB,YAAcvoB,gBAEhB,OADA2iC,GAAevZ,gBAAgB6Q,GAE1B,GAAIhtB,QAET,OADA01B,GAAexZ,kBAAkB8Q,OAG9B,IAAIjvB,IAAIivB,KAAO/G,OAAOtlC,WAAa26B,YAAcvoB,gBAEtD,OADA2iC,GAAe/Z,qBAAqBqR,GAE/B,GAAIjvB,IAAIivB,KAAO/G,OAAOhjC,SAAWq4B,YAAcvoB,gBAEpD,OADA2iC,GAAe7Z,mBAAmBmR,GAE7B,GAAIjc,aAAaic,GAAI,CAC1B,GAAI1R,YAAcvoB,gBAEhB,OADA2iC,GAAe3Z,gBAAgBiR,GAE1B,GAAIhtB,QAET,OADA01B,GAAe5Z,kBAAkBkR,QAG9B,GAAIjvB,IAAIivB,KAAO/G,OAAO7xB,MAC3B,GAAI4L,QAEF,OADA01B,GAAenZ,kBAAkByQ,QAG9B,GAAIjvB,IAAIivB,KAAO/G,OAAO/jC,MAC3B,GAAI8d,QAEF,OADA01B,GAAe9Z,kBAAkBoR,QAG9B,GAAIjvB,IAAIivB,KAAO/G,OAAOjwB,MAC3B,GAAIgK,QAEF,OADA01B,GAAe/Y,kBAAkBqQ,QAG9B,GAAIjvB,IAAIivB,KAAO/G,OAAOlmC,SAC3B,GAAIigB,QAEF,OADA01B,GAAeja,qBAAqBuR,QAGjC,GAAIjvB,IAAIivB,KAAO/G,OAAOpmC,SAC3B,GAAImgB,QAEF,OADA01B,GAAela,qBAAqBwR,QAGjC,GAAIjvB,IAAIivB,KAAO/G,OAAOhmC,SAC3B,GAAI+f,QAEF,OADA01B,GAAeha,qBAAqBsR,QAGjC,GAAIjvB,IAAIivB,KAAO/G,OAAOrxB,KAAM,CACjC,GAAI0mB,YAAcvoB,gBAEhB,OADA2iC,GAAehZ,gBAAgBsQ,GAE1B,GAAIhtB,QAET,OADA01B,GAAejZ,kBAAkBuQ,QAO9B,GAAIjvB,IAAIivB,KAAO/G,OAAO5yB,SAAU,CACrC,GAAIioB,YAAcvoB,gBAEhB,OADA2iC,GAAerZ,oBAAoB2Q,GAE9B,GAAIhtB,QAET,OADA01B,GAAetZ,sBAAsB4Q,QAGlC,GAAIjvB,IAAIivB,KAAO/G,OAAOh4B,MAC3B,GAAI+R,QAEF,OADA01B,GAAezZ,kBAAkB+Q,QAG9B,GAAIjvB,IAAIivB,KAAO/G,OAAOviC,KAC3B,GAAIsc,QAEF,OADA01B,GAAe1Z,iBAAiBgR,QAG7B,GAAIjvB,IAAIivB,KAAO/G,OAAO7vB,MAAO,CAClC,GAAI4J,QAEF,OADA01B,GAAezY,mBAAmB+P,GAGpC,GAAI1R,YAAcvoB,gBAEhB,OADA2iC,GAAexY,iBAAiB8P,QAG7B,GAAIjvB,IAAIivB,KAAO/G,OAAOxvB,QAAS,CACpC,GAAIuJ,QAEF,OADA01B,GAAe,KAAO5X,WAAWjgB,KAAKmvB,IAAM,QAAUlP,WAAWlgB,MAAMovB,IAAM,KAG/E,GAAI1R,YAAcvoB,gBAEhB,OADA2iC,GAAe1Y,mBAAmBgQ,QAG/B,GAAIjvB,IAAIivB,KAAO/G,OAAOzvB,QAAS,CACpC,GAAIwJ,QAEF,OADA01B,GAAe,KAAO5X,WAAWjgB,KAAKmvB,IAAM,SAAWlP,WAAWlgB,MAAMovB,IAAM,KAGhF,GAAI1R,YAAcvoB,gBAEhB,OADA2iC,GAAe3Y,mBAAmBiQ,QAG/B,GAAIjvB,IAAIivB,KAAO/G,OAAO1vB,QAAS,CACpC,GAAIyJ,QAEF,OADA01B,GAAe,KAAO5X,WAAWjgB,KAAKmvB,IAAM,QAAUlP,WAAWlgB,MAAMovB,IAAM,KAG/E,GAAI1R,YAAcvoB,gBAEhB,OADA2iC,GAAe5Y,mBAAmBkQ,QAG/B,GAAIjvB,IAAIivB,KAAO/G,OAAO3vB,QAAS,CACpC,GAAI0J,QAEF,OADA01B,GAAe,KAAO5X,WAAWjgB,KAAKmvB,IAAM,SAAWlP,WAAWlgB,MAAMovB,IAAM,KAGhF,GAAI1R,YAAcvoB,gBAEhB,OADA2iC,GAAe7Y,mBAAmBmQ,QAG/B,GAAIjvB,IAAIivB,KAAO/G,OAAO5vB,QAAS,CACpC,GAAI2J,QAEF,OADA01B,GAAe,KAAO5X,WAAWjgB,KAAKmvB,IAAM,UAAYlP,WAAWlgB,MAAMovB,IAAM,KAGjF,GAAI1R,YAAcvoB,gBAEhB,OADA2iC,GAAe9Y,mBAAmBoQ,QAG/B,GAAIjvB,IAAIivB,KAAO/G,OAAOj4B,OAAQ,CACnC,GAAIgS,QAEF,OADA01B,GAAe,cAAgB5X,WAAWjgB,KAAKmvB,IAAM,IAGvD,GAAI1R,YAAcvoB,gBAEhB,OADA2iC,GAAe,cAAgB5X,WAAWjgB,KAAKmvB,IAAM,mBAGlD,GAAIjvB,IAAIivB,KAAO/G,OAAO7kC,SAAU,CACrC,GAAI4e,QAEF,OADA01B,GAAe,gBAAkB5X,WAAWjgB,KAAKmvB,IAAM,IAGzD,GAAI1R,YAAcvoB,gBAEhB,OADA2iC,GAAe,aAAe5X,WAAWjgB,KAAKmvB,IAAM,kBAGjD,GAAIjvB,IAAIivB,KAAO/G,OAAOryB,QAC3B,GAAIoM,QAEF,OADA01B,GAAe,cAAgB5X,WAAWjgB,KAAKmvB,IAAM,SAGlD,GAAIjvB,IAAIivB,KAAO/G,OAAOlyB,MAC3B,OAAIiM,QACF01B,GAAepZ,mBAAmB0Q,IAGlC0I,GAAe5X,WAAWjgB,KAAKmvB,IAC/B0I,GAAenX,UAAU,KACzBmX,GAAe5X,WAAWlgB,MAAMovB,KAIpC,GAAI9c,OAAO8c,GAAI,CAUb,GALA0I,GAAe3X,cAAahgB,IAAIivB,IAChCA,EAAIvuB,IAAIuuB,GACHkU,IACHxL,GAAenX,UAAU,MAEvBrO,OAAO8c,GAGT,IAFA0I,GAAe5X,WAAW/f,IAAIivB,IAC9BA,EAAIvuB,IAAIuuB,GACD9c,OAAO8c,IACZ0I,GAAenX,UAAU,KACzBmX,GAAe5X,WAAW/f,IAAIivB,IAC9BA,EAAIvuB,IAAIuuB,GAMZ,OAHKkU,IACHxL,GAAenX,UAAU,MAEpBmX,EAmBT,OAjBI1I,IAAM/G,OAAO7iC,YACfsyC,GAAejY,WAAW,KACjBuP,IAAM/G,OAAOjiC,GAEpB0xC,GAAenX,UADbve,QACuB,SAEA,KAElBgtB,IAAM/G,OAAO9zB,IAEpBujC,GAAenX,UADbjD,YAAcvoB,gBACS,OAEA,MAG3B2iC,GAAenX,UAAU9R,cAAcugB,IAElC0I,GAGTvX,YAAa,SAAS6O,GACpB,IAAI0I,EAEJ,OADAA,EAAc,GACN1I,EAAEjB,GACR,KAAK/pC,KAQH,IAPA0zC,GAAe,IACfA,GAAevX,YAAWpgB,IAAIivB,IAC1BA,IAAMvuB,IAAIuuB,IAAMA,IAAM/G,OAAOh1B,MAC/Bq8B,QAAQE,IAAI,oBAGdR,EAAIvuB,IAAIuuB,GACD9c,OAAO8c,IACZ0I,GAAe,IACfA,GAAevX,YAAWpgB,IAAIivB,KAC9BA,EAAIvuB,IAAIuuB,MACEvuB,IAAIuuB,IAAMA,IAAM/G,OAAOh1B,MAC/Bq8B,QAAQE,IAAI,oBAIZR,IAAM/G,OAAOh1B,OACfykC,GAAe,MACfA,GAAevX,YAAW6O,IAE5B0I,GAAe,IACf,MACF,KAAKhhC,IAEHghC,GAAe1I,EAAEnB,IACjB,MAEF,KAAKl6B,IACL,KAAK/N,OACH8xC,GAAerX,aAAa2O,GAAG,GAC/B,MACF,KAAKn4B,IACH6gC,GAAejpB,cAAcugB,GAC7B,MACF,QACE0I,GAAe,WAEnB,OAAOA,GAGTtX,oBAAsB,WACpB,IAAIsX,EAEJ,GADAA,EAAc,GACVpa,YAAcvoB,gBAAiB,CACjC,GAAIuoB,YAAcxoB,iBAAoBm0B,UAGpC,OAAOyO,EAFPA,GAAenX,UAAU,KAU7B,OAFEmX,GAAenX,UAHbjD,YAAcxoB,iBAAoBm0B,WAAcjnB,QAGzB,IAFA,MAO7BuP,eAAiB,SAASyd,GACxB,OAAIjvB,IAAIivB,KAAO/G,OAAO5zB,QAAUwL,KAAKmvB,KAAO/G,OAAOjiC,IAAM4tB,eAAehU,MAAMovB,IACrE,EAEA,GAMXnzB,iBAAmB,SAASmzB,GAC1B,IAAIrB,EAIJ,IAHAqB,EAAIvuB,IAAIuuB,GAGD9c,OAAO8c,IAAI,CAEhB,GADArB,EAAI5tB,IAAIivB,GACJzd,eAAeoc,GACjB,OAAO,EAETqB,EAAIvuB,IAAIuuB,GAEV,OAAO,GA0CTn1B,KAAO,IAEPgV,MAAS,WAAW,IACZA,EADY,mEASlB,OANAA,EAAMnvB,UAAU+zC,EAAI,EAEpB5kB,EAAMnvB,UAAUqvC,EAAI,EAEpBlgB,EAAMnvB,UAAU42C,EAAI,EAEbznB,GAEN1uB,KAAKutC,MAGR7sB,QAAU,GAELD,aAAe8O,GAAK,EAAGqT,KAAOlpB,KAAO,GAAKkpB,KAAOrT,GAAKqT,KAAOrT,GAAKqT,KAAOniB,aAAe,GAAKmiB,OAASrT,KAAOA,GAChH7O,QAAQD,cAAgB,IAAIiO,MAy8B9B,IAt8BAqc,OAAS,EAET5U,MAAQ,EAER7M,OAAS,EAEToB,WAAa,EAEbvE,aAAe,EAKfya,iBAAmB,SAASuiB,GAC1B,IAAI5L,EAGJ,OAFAA,EAAc,GACdA,GAAe4L,GAIjBxiB,UAAY,SAASwiB,GACnB,OAAOviB,iBAAiBuiB,IAG1BjmB,aAAe,SAAS2R,GACtB,IAAIuS,EAAgBjT,EAIpB1K,OACAsH,OAAS,EACT5U,MAAQ,EACR7M,OAAS,EACTF,cAAcylB,GATW,MAWbtgB,SAAS,EAAGwc,QAXC,sBAYzB,OAZyB,KAWrBoD,EAXqB,UAYrBA,EAAI,KACNtN,UAAUgO,QACV7L,YAGFoe,EAActhB,eACdkD,UACOoe,IAGTh4B,cAAgB,SAASylB,GACvB,OAAIjvB,IAAIivB,KAAO/G,OAAOlyB,OACpBsS,UAAUxI,KAAKmvB,IACf90B,WAAW,YACXmO,UAAUzI,MAAMovB,KAGdzZ,SAASyZ,GACJ5lB,YAAY4lB,GAEZ3mB,UAAU2mB,IAIrBrE,8BAAgC,SAASqE,GACvC,GAAI1Y,MAAQ,EACV,OAAO,EAET,GAAI5D,WAAWsc,GACb,OAAO,EAET,GAAIjvB,IAAIivB,KAAO/G,OAAOn1B,UACpB,OAAO,EAET,GAAI4f,WAAW7S,KAAKmvB,IAClB,OAAO,EAET,KAAO9c,OAAO8c,IAAI,CAChB,GAAI7c,cAAcpS,IAAIivB,IACpB,OAAO,EAETA,EAAIvuB,IAAIuuB,GAEV,OAAO,GAGT3mB,UAAY,SAAS2mB,GAMnB,GADAnkB,aACI9K,IAAIivB,KAAO/G,OAAOxmC,KAUpB,IATAutC,EAAIvuB,IAAIuuB,GACJ30B,cAAc0F,IAAIivB,MACpB/0B,YAAY,KACR0wB,8BAA8B5qB,IAAIivB,KACpC/0B,YAAY,MAGhBqP,UAAUvJ,IAAIivB,IACdA,EAAIvuB,IAAIuuB,GACD9c,OAAO8c,IACR30B,cAAc0F,IAAIivB,KACpB/0B,YAAY,KACZA,YAAY,KACZA,YAAY,OAEZA,YAAY,KACZA,YAAY,KACZA,YAAY,MAEdqP,UAAUvJ,IAAIivB,IACdA,EAAIvuB,IAAIuuB,QAGN30B,cAAc20B,KAChB/0B,YAAY,KACR0wB,8BAA8BqE,IAChC/0B,YAAY,MAGhBqP,UAAU0lB,GAEZ,OAAOnkB,cAGTrB,mBAAqB,SAASwlB,GAC5B,IAAId,EACJ,GAAInuB,IAAIivB,KAAO/G,OAAOxmC,KAAM,CAO1B,IANAutC,EAAIvuB,IAAIuuB,GAGR1lB,UAAUvJ,IAAIivB,IACdA,EAAIvuB,IAAIuuB,GACRd,EAAU,GACHhc,OAAO8c,IACR30B,cAAc0F,IAAIivB,KACpB/0B,YAAY,KACZA,YAAY,KACZA,YAAY,OAEZA,YAAY,KACZA,YAAY,KACZA,YAAY,MAEdqP,UAAUvJ,IAAIivB,IACdd,EAAQ5tC,KAAK0uC,EAAIvuB,IAAIuuB,IAEvB,OAAOd,EAIP,OAAO5kB,UAAU0lB,IAIrB30B,cAAgB,SAAS20B,GACvB,OAAIrb,iBAAiBqb,IAGjBjvB,IAAIivB,KAAO/G,OAAOn1B,WAAa6gB,iBAAiB9T,KAAKmvB,IAFhD,EAKF,GAGT1lB,UAAY,SAAS0lB,GACnB,IAAIhuC,EACJ,OAAI+e,IAAIivB,KAAO/G,OAAOn1B,WACpB9R,EAAI4iB,mBAAmBorB,KACJ,IAAV1Y,MACA7N,cAAcumB,EAAGhuC,GAEjB4nB,cAAcomB,EAAGhuC,GAGnBsnB,YAAY0mB,IAIvB7c,cAAgB,SAAS6c,GACvB,OAAIjvB,IAAIivB,KAAO/G,OAAO5zB,QAAUwL,KAAKmvB,KAAO/G,OAAOjiC,IAAMqU,cAAcuF,MAAMovB,IACpE,EAEA,GAIXprB,mBAAqB,SAASorB,GAC5B,IAAItrB,EAAOiqB,EAOX,IANAjqB,EAAQ,EACRsrB,EAAIvuB,IAAIuuB,GAKD9c,OAAO8c,IACZrB,EAAI5tB,IAAIivB,GACJ7c,cAAcwb,IAChBjqB,IAEFsrB,EAAIvuB,IAAIuuB,GAEV,OAAOtrB,GAITkF,cAAgB,SAASomB,EAAGhuC,GAC1B,IAAIktC,EACJ,GAAU,IAANltC,EAAS,CAQX,IAPAguC,EAAIvuB,IAAIuuB,IACJ7a,UAAUpU,IAAIivB,KAAO3b,WAAWtT,IAAIivB,OACtCA,EAAIvuB,IAAIuuB,IAEV1mB,YAAYvI,IAAIivB,IAChBA,EAAIvuB,IAAIuuB,GACRd,EAAU,GACHhc,OAAO8c,IACZ/0B,YAAY,KACZqO,YAAYvI,IAAIivB,IAChBd,EAAQ5tC,KAAK0uC,EAAIvuB,IAAIuuB,IAEvB,OAAOd,EAKP,OAHAplB,gBAAgBkmB,GAChB/0B,YAAY,KAERjZ,EAAI,GAAK0xB,WAAW7S,KAAKmvB,KAC3B/0B,YAAY,KACZmO,kBAAkB4mB,GACX/0B,YAAY,MAEZmO,kBAAkB4mB,IAS/BvmB,cAAgB,SAASumB,EAAGlB,GAC1B,IAAIpqB,EAAkB6/B,EAAIC,EAAIxiD,EAAG+tC,EAkCjC,IAjCArrB,EAAQ,EACH,EACA,EACL1iB,EAAI,EACA,EACJ4iC,OACArI,GAAKV,IACLW,GAAKX,IACD7F,WAAWnV,KAAKmvB,MAClB1uC,KAAKuf,KAAKmvB,IACV9W,eACAld,UACAugB,GAAKmB,MACLp8B,KAAKuf,KAAKmvB,IACV/W,iBACAuD,GAAKkB,OAEHrK,SAASxS,KAAKmvB,MAChB1uC,KAAKuf,KAAKmvB,IACVh0B,UACAugB,GAAKmB,OAKL17B,EADEmzB,UAAUoH,IACR,EAEA,EAENF,GAAK5a,IAAIuuB,GACLne,cAAc9Q,IAAIsb,OACpBA,GAAK5a,IAAI4a,KAEJnJ,OAAOmJ,KACZC,GAAKvb,IAAIsb,IACLlJ,cAAcmJ,IACJ,EAEZt6B,IAEFq6B,GAAK5a,IAAI4a,IAgBX,IAbA0T,EAAItlB,OACJ85B,EAAKrY,OACLxnB,EAAQ,EACHyQ,UAAUoH,MACb1S,YAAY0S,GAAI,GAChB7X,KAGF2X,GAAK5a,IAAIuuB,GAELne,cAAc9Q,IAAIsb,OACpBA,GAAK5a,IAAI4a,KAEJnJ,OAAOmJ,KACZC,GAAKvb,IAAIsb,IACLlJ,cAAcmJ,IACJ,GAER5X,EAAQ,GACVzJ,YAAY,KAEJ,IAANjZ,EACFqnB,UAAUiT,IAEVhT,YAAYgT,IAEd5X,KAEF2X,GAAK5a,IAAI4a,IAiBX,IAfc,IAAV3X,GACFzJ,YAAY,KAGdupC,EAAKtY,OACLxnB,EAAQ,EACHyQ,UAAUqH,MACb3S,YAAY2S,GAAI,GAChB9X,IACAoqB,KAEFzS,GAAK5a,IAAIuuB,GACLha,WAAWjV,IAAIsb,OACjBA,GAAK5a,IAAI4a,KAEJnJ,OAAOmJ,KACZC,GAAKvb,IAAIsb,IACLlJ,cAAcmJ,MACZ5X,EAAQ,GACVzJ,YAAY,KAEdkO,iBAAiBmT,GAAIwS,GACrBpqB,KAEF2X,GAAK5a,IAAI4a,IAGX,OADA3O,eAAeqiB,EAAGwU,EAAIC,GACfrgB,WAITra,gBAAkB,SAASkmB,GACzB,IAAehuC,EAsBf,IArBA4iC,OACA5iC,EAAI,EACJq6B,GAAKR,IACLmU,EAAIvuB,IAAIuuB,GACJha,WAAWjV,IAAIivB,KACjB1uC,KAAKyf,IAAIivB,IACT9W,eACAld,UACAqgB,GAAKqB,MACLsS,EAAIvuB,IAAIuuB,IACC3c,SAAStS,IAAIivB,MACtB1uC,KAAKyf,IAAIivB,IACTh0B,UACAqgB,GAAKqB,MACLsS,EAAIvuB,IAAIuuB,IAEVhuC,EAAI,EACCmzB,UAAUkH,MACbxS,YAAYwS,GAAI,GAChBr6B,KAEKkxB,OAAO8c,IACR7c,cAAcpS,IAAIivB,IACR,GAERhuC,EAAI,GACNiZ,YAAY,KAEdqO,YAAYvI,IAAIivB,IAChBhuC,KAEFguC,EAAIvuB,IAAIuuB,GAKV,OAHU,IAANhuC,GACFiZ,YAAY,KAEPkpB,WAIT/a,kBAAoB,SAAS4mB,GAC3B,IAAIhuC,EAYJ,IAXA4iC,OACA5iC,EAAI,EACJguC,EAAIvuB,IAAIuuB,GACJtc,WAAW3S,IAAIivB,MACjB1uC,KAAKyf,IAAIivB,IACT/W,iBACAoD,GAAKqB,MACL7T,YAAYwS,GAAI,GAChBr6B,IACAguC,EAAIvuB,IAAIuuB,IAEH9c,OAAO8c,IACR7c,cAAcpS,IAAIivB,MAChBhuC,EAAI,GACNiZ,YAAY,KAEdkO,iBAAiBpI,IAAIivB,GAAI,GACzBhuC,KAEFguC,EAAIvuB,IAAIuuB,GAEV,OAAO7L,WAGT7a,YAAc,SAAS0mB,GACjBzZ,SAASyZ,GAGTxmB,iBAAiBwmB,GAMjB3c,SAAS2c,GACXnmB,YAAYmmB,EAAG,GAGbjvB,IAAIivB,KAAO/G,OAAOxmC,MAAQse,IAAIivB,KAAO/G,OAAOn1B,UAI5CiN,IAAIivB,KAAO/G,OAAO5zB,OAIlB6d,OAAO8c,GAITtmB,cAAcsmB,GAGZne,cAAcme,GACF,IAAV1Y,MACFvN,wBAAwBimB,GAExBnmB,YAAYmmB,EAAG,GAIf3Z,SAAS2Z,GACX7lB,YAAY6lB,GAGV5Z,MAAM4Z,IACR/lB,YAAY+lB,GAvBZhmB,WAAWgmB,GAJX9lB,aAAa8lB,IA+BjBjmB,wBAA0B,SAASimB,GACjC,IAAIuU,EAAIC,EAAIzU,EAYZ,OAXK,EACA,EACD,EACJnL,OACAtjC,KAAK0uC,GACL9W,eACAld,UACAugB,GAAKmB,MACLp8B,KAAK0uC,GACL/W,iBACAuD,GAAKkB,MACDvI,UAAUqH,KACZ3S,YAAY0S,GAAI,QAChB4H,YAGF4L,EAAItlB,OACJ85B,EAAKrY,OACLriB,YAAY0S,GAAI,GAChBioB,EAAKtY,OACLriB,YAAY2S,GAAI,GAChB9O,eAAeqiB,EAAGwU,EAAIC,GACfrgB,YAIT5Q,SAAW,SAASyc,GAClB,OAAI9c,OAAO8c,IAAMjvB,IAAIivB,KAAO/G,OAAOxmC,MAAQse,IAAIivB,KAAO/G,OAAOn1B,WAAaiN,IAAIivB,KAAO/G,OAAO5zB,QAGxFghB,SAAS2Z,GAFJ,EAKLtc,WAAWsc,IAGXrb,iBAAiBqb,GAFZ,EAKLne,cAAcme,GACT,EAEF,GAGThmB,WAAa,SAASgmB,GACpB,IAAIuU,EAAIC,EAAIzU,EAIZ,OAHAwU,EAAK,EACLC,EAAK,EACLzU,EAAI,EACAlvB,KAAKmvB,KAAO/G,OAAOjiC,IACrBkU,WAAW,QACXmO,UAAUzI,MAAMovB,SAChB/0B,YAAY,MAGVqc,MAAQ,OACNjD,WAAWzT,MAAMovB,KACnB/0B,YAAY,KACZA,YAAY,KACRsY,SAAS1S,KAAKmvB,IAChB1mB,YAAYzI,KAAKmvB,IAEjB9lB,aAAarJ,KAAKmvB,MAGhBzc,SAAS1S,KAAKmvB,IAChB1mB,YAAYzI,KAAKmvB,IAEjB9lB,aAAarJ,KAAKmvB,IAEpB/0B,YAAY,KACRsY,SAAS3S,MAAMovB,IACjB1mB,YAAY1I,MAAMovB,IAElB9lB,aAAatJ,MAAMovB,MAMrB30B,cAAcuF,MAAMovB,KACtBD,EAAItlB,OACJ85B,EAAKrY,OACLjxB,YAAY,KACZupC,EAAKtY,OAEL/iB,iBAAiB6mB,EAAG,QAEpBtiB,eAAeqiB,EAAGwU,EAAIC,KAGxBD,EAAKrY,OACD3Y,SAAS1S,KAAKmvB,IAChB1mB,YAAYzI,KAAKmvB,IAEjB9lB,aAAarJ,KAAKmvB,IAEpBwU,EAAKtY,OACL5U,QACAjO,UAAUzI,MAAMovB,IAChB1Y,QACO3J,YAAY42B,EAAIC,KAMzBr7B,iBAAmB,SAAS6mB,EAAGhuC,GAC7B,IAAIuiD,EAAIC,EAIR,GAHK,EACA,GAEDnwB,WAAWzT,MAAMovB,IAoBrB,OAZAuU,EAAKrY,OAED3Y,SAAS1S,KAAKmvB,IAChB1mB,YAAYzI,KAAKmvB,IAEjB9lB,aAAarJ,KAAKmvB,IAEpBwU,EAAKtY,OAEL5U,QACA9M,mBAAmB5J,MAAMovB,IACzB1Y,QACO3J,YAAY42B,EAAIC,GAnBX,IAANxiD,EACFqnB,UAAUxI,KAAKmvB,IAEf1mB,YAAYzI,KAAKmvB,KAmBvBtmB,cAAgB,SAASsmB,GACvB,GAAIjvB,IAAIivB,KAAO/G,OAAOv3B,QAAU2kB,SAASxV,KAAKmvB,IAC5CrmB,oBAAoBqmB,OADtB,CAIA,GAAIjvB,IAAIivB,KAAO/G,OAAOr4B,WAAtB,CAWA,GAPImQ,IAAIivB,KAAO/G,OAAO7iC,YACpB6U,YAAY,KAEZkP,YAAYpJ,IAAIivB,IAElB/0B,YAAY,KACZ+0B,EAAIvuB,IAAIuuB,GACJ9c,OAAO8c,GAGT,IAFA3mB,UAAUtI,IAAIivB,IACdA,EAAIvuB,IAAIuuB,GACD9c,OAAO8c,IACZ/0B,YAAY,KAEZoO,UAAUtI,IAAIivB,IACdA,EAAIvuB,IAAIuuB,GAGZ,OAAO/0B,YAAY,KApBjBsO,wBAAwBymB,KAuB5BrmB,oBAAsB,SAASqmB,GAS7B,GARAA,EAAIvuB,IAAIuuB,GACJ7vB,KAAK6vB,KAAO/G,OAAOxmC,MAAQ0d,KAAK6vB,KAAO/G,OAAOn1B,WAAaqM,KAAK6vB,KAAO/G,OAAO5zB,QAAU8K,KAAK6vB,KAAO/G,OAAOr4B,WAC7GsZ,aAAanJ,IAAIivB,IAEjB3mB,UAAUtI,IAAIivB,IAEhB/0B,YAAY,KACZ+0B,EAAIvuB,IAAIuuB,GACJ9c,OAAO8c,GAGT,IAFA3mB,UAAUtI,IAAIivB,IACdA,EAAIvuB,IAAIuuB,GACD9c,OAAO8c,IACZ/0B,YAAY,KACZoO,UAAUtI,IAAIivB,IACdA,EAAIvuB,IAAIuuB,GAGZ,OAAO/0B,YAAY,MAGrBsO,wBAA0B,SAASymB,GAOjC,OANAA,EAAInvB,KAAKmvB,GACLtc,WAAWsc,IAAMjvB,IAAIivB,KAAO/G,OAAOxmC,MAAQse,IAAIivB,KAAO/G,OAAOn1B,WAAaiN,IAAIivB,KAAO/G,OAAO5zB,QAAU0L,IAAIivB,KAAO/G,OAAOr4B,WAC1HsZ,aAAa8lB,GAEb3mB,UAAU2mB,GAEL/0B,YAAY,MAGrBiP,aAAe,SAAS8lB,GAGtB,OAFA/0B,YAAY,KACZoO,UAAU2mB,GACH/0B,YAAY,MAGrBkP,YAAc,SAAS6lB,GACrB,IAAI1wC,EAAGu3B,EAAI4tB,EAAYvT,EAAMhC,EAE7B,GADA5vC,EAAI,EACA0wC,IAAM/G,OAAOjiC,GAAjB,CAMA,IADAkoC,EAAU,GACL5vC,EAAIu3B,EAAK,EAAGqa,GAFjBuT,EAAah1B,cAAcugB,IAEQ3wC,OAAS,GAAK6xC,EAAOra,EAAKqa,EAAOra,EAAKqa,EAAO5xC,EAAI,GAAK4xC,IAASra,IAAOA,EACvGqY,EAAQ5tC,KAAK2Z,YAAYwpC,EAAWnlD,KAEtC,OAAO4vC,EARLh0B,WAAW,WAWf+O,YAAc,SAAS+lB,GACrB,IAAI1wC,EAAGu3B,EAAI6tB,EAASxT,EAIpB,IAHA5xC,EAAI,EACJolD,EAAU1U,EAAEnB,IACZ5zB,YAAY,KACP3b,EAAIu3B,EAAK,EAAGqa,EAAOwT,EAAQrlD,OAAS,GAAK6xC,EAAOra,EAAKqa,EAAOra,EAAKqa,EAAO5xC,EAAI,GAAK4xC,IAASra,IAAOA,EACpG5b,YAAYypC,EAAQplD,IAEtB,OAAO2b,YAAY,MAGrByS,eAAiB,SAASqiB,EAAGwU,EAAIC,GAC/B,IAAIG,EAAQC,EAAW/tB,EAAIqa,EAAMhC,EAASI,EAAGuV,EAAIC,EAAOC,EAAIC,EAC5DL,EAAK,EAGLrV,EAAI,EAL+B,MAapB5f,SAAS60B,EAAIC,GAbO,sBAalCI,EAbkC,KAa9BC,EAb8B,KAa1BE,EAb0B,WAcpBr1B,SAAS80B,EAAItY,QAdO,sBAyCnC,IAzCmC,KAc9B4Y,EAd8B,KAc1BE,EAd0B,KAgBjCL,EADEG,EAAKD,GACDC,EAAKD,GAAM,EAEZ,EAEPF,IAIA7rB,KAAKyrB,EAAIC,EAAIG,IAFTI,EAAKH,EAAK,GACJ,GAGRD,EADEG,EAAKD,GACDA,GAEMA,EAAKC,GAAM,EAAjBD,EAERF,IAEA7rB,KAAK0rB,EAAItY,OAAQyY,EADN,EAALK,GAGJ1V,EADEwV,EAAKD,EACHC,EAEAD,EAGNp6B,OAASslB,EACTb,EAAU,GACDrY,EAAK,EAAGqa,EAHjB5B,GAAK,EAGuB,GAAK4B,EAAOra,EAAKqa,EAAOra,EAAKqa,EAAW,GAAKA,IAASra,IAAOA,EACvFqY,EAAQ5tC,KAAK2Z,YAAY,MAE3B,OAAOi0B,GAGTvhB,YAAc,SAAS42B,EAAIC,GACzB,IAAIS,EAAQC,EAAYH,EACxBE,EAAK,EAFwB,MASdv1B,SAAS60B,EAAIC,GATC,gCASpBO,EAToB,WAUdr1B,SAAS80B,EAAItY,QAVC,sBAe7B,OALCgZ,EAV4B,UAY7BD,GAZ6B,KAYlBC,EAAK,EAGTpsB,KAAK0rB,EAAItY,OAAQ,EADxB+Y,GAAMF,EAAK,IAIbjsB,KAAO,SAAS6W,EAAGZ,EAAG4V,EAAIM,GACxB,IAAI3lD,EAAGu3B,EAAIqa,EAAMC,EAAMjC,EAGvB,IAFA5vC,EAAI,EACJ4vC,EAAU,GACL5vC,EAAIu3B,EAAKqa,EAAOvB,EAAGwB,EAAOpC,EAAImC,GAAQC,EAAOta,EAAKsa,EAAOta,EAAKsa,EAAO7xC,EAAI4xC,GAAQC,IAASta,IAAOA,EACpGhV,QAAQviB,GAAGywC,GAAK4U,EAChBzV,EAAQ5tC,KAAKugB,QAAQviB,GAAGg4C,GAAK2N,GAE/B,OAAO/V,GAITxf,SAAW,SAASigB,EAAGZ,GACrB,IAAOzvC,EAAGu3B,EAAIsuB,EAAOC,EAAOC,EAAOC,EAAOpU,EAAMC,EAMhD,IALA7xC,EAAI,EACJ+lD,EAAQxjC,QAAQ8tB,GAAGI,EACnBoV,EAAQtjC,QAAQ8tB,GAAGI,EACnBuV,EAAQzjC,QAAQ8tB,GAAG2H,EACnB8N,EAAQvjC,QAAQ8tB,GAAG2H,EACdh4C,EAAIu3B,EAAKqa,EAAOvB,EAAI,EAAGwB,EAAOpC,EAAImC,GAAQC,EAAOta,EAAKsa,EAAOta,EAAKsa,EAAO7xC,EAAI4xC,GAAQC,IAASta,IAAOA,EACpGhV,QAAQviB,GAAGywC,EAAIsV,IACjBA,EAAQxjC,QAAQviB,GAAGywC,GAEjBluB,QAAQviB,GAAGywC,EAAIoV,IACjBA,EAAQtjC,QAAQviB,GAAGywC,GAEjBluB,QAAQviB,GAAGg4C,EAAIgO,IACjBA,EAAQzjC,QAAQviB,GAAGg4C,GAEjBz1B,QAAQviB,GAAGg4C,EAAI8N,IACjBA,EAAQvjC,QAAQviB,GAAGg4C,GAMvB,MAAO,CAHH8N,EAAQE,EAAQ,EAChBH,EAAQE,EAAQ,EAChBC,IAIN/9B,YAAc,SAASktB,GACrB,OAAOx5B,YAAYw5B,IAGrBx5B,YAAc,SAASw5B,GACrB,GAAIvI,SAAWrxB,KAUf,OAPIgH,QAAQqqB,QAGZrqB,QAAQqqB,QAAQuI,EAAIA,EACpB5yB,QAAQqqB,QAAQ6D,EAAItlB,OACpB5I,QAAQqqB,QAAQoL,EAAI,EACpBpL,SACOzhB,UAGTvP,WAAa,SAAS61B,GACpB,IAAIzxC,EAAGu3B,EAAIqa,EAAMhC,EAGjB,IAFA5vC,EAAI,EACJ4vC,EAAU,GACL5vC,EAAIu3B,EAAK,EAAGqa,EAAOH,EAAE1xC,OAAS,GAAK6xC,EAAOra,EAAKqa,EAAOra,EAAKqa,EAAO5xC,EAAI,GAAK4xC,IAASra,IAAOA,EAC9FqY,EAAQ5tC,KAAK2Z,YAAY81B,EAAEzxC,KAE7B,OAAO4vC,GAGTrlB,YAAc,SAASmmB,EAAGuV,GACxB,IAAIjmD,EAAGu3B,EAAIma,EAAIC,EAAIC,EAAMC,EAAMC,EAAMlC,EAAS6L,EAAUyK,EAGxD,OAFAA,EAAY,GACZlmD,EAAI,EACI0wC,EAAEjB,GACR,KAAKp6B,IAKH,IAHqB,OADrB6wC,EAAYxV,EAAErB,EAAEH,EAAEvsC,YACJ,IAA4B,IAAdsjD,IAC1BC,EAAYA,EAAU1M,UAAU,IAE7Bx5C,EAAIu3B,EAAK,EAAGqa,EAAOsU,EAAUnmD,OAAS,GAAK6xC,EAAOra,EAAKqa,EAAOra,EAAKqa,EAAO5xC,EAAI,GAAK4xC,IAASra,IAAOA,EACtG5b,YAAYuqC,EAAUlmD,IAGxB,GAAkB,OADlBkmD,EAAYxV,EAAErB,EAAEF,EAAExsC,YAEhB,MAIF,IAFAgZ,YAAY,KACZi0B,EAAU,GACL5vC,EAAI0xC,EAAK,EAAGG,EAAOqU,EAAUnmD,OAAS,GAAK8xC,EAAOH,EAAKG,EAAOH,EAAKG,EAAO7xC,EAAI,GAAK6xC,IAASH,IAAOA,EACtG9B,EAAQ5tC,KAAK2Z,YAAYuqC,EAAUlmD,KAErC,OAAO4vC,EAET,KAAKtoC,OAMH,IAJqB,OADrB4+C,EAAYr9B,yBAAyB6nB,EAAElB,IACzB,IAA4B,IAAdyW,IAC1BC,EAAYA,EAAU1M,UAAU,IAElCiC,EAAW,GACNz7C,EAAI2xC,EAAK,EAAGG,EAAOoU,EAAUnmD,OAAS,GAAK+xC,EAAOH,EAAKG,EAAOH,EAAKG,EAAO9xC,EAAI,GAAK8xC,IAASH,IAAOA,EACtG8J,EAASz5C,KAAK2Z,YAAYuqC,EAAUlmD,KAEtC,OAAOy7C,IAKbp4B,UAAY,SAAS6rB,EAAGC,GACtB,OAAID,EAAE8I,EAAI7I,EAAE6I,GACF,EAEN9I,EAAE8I,EAAI7I,EAAE6I,EACH,EAEL9I,EAAEuB,EAAItB,EAAEsB,GACF,EAENvB,EAAEuB,EAAItB,EAAEsB,EACH,EAEF,GAGT9O,aAAe,WACb,IAAIyX,EAAap5C,EAAGu3B,EAAIqa,EAAMP,EAAeZ,EAAGuH,EAchD,IAbAh4C,EAAI,EACJo5C,EAAc,IAOd/H,EAAgB9uB,QAAQ3f,MAAM,EAAGgqC,SACnB0E,KAAKjuB,WAEnBotB,EAAI,EACJuH,GAFAz1B,QAAU,GAAGgvB,OAAOF,GAAeE,OAAOhvB,QAAQ3f,MAAMgqC,UAE5C,GAAGoL,EACVh4C,EAAIu3B,EAAK,EAAGqa,EAAOhF,OAAS,GAAKgF,EAAOra,EAAKqa,EAAOra,EAAKqa,EAAO5xC,EAAI,GAAK4xC,IAASra,IAAOA,EAAI,CAChG,KAAOhV,QAAQviB,GAAGg4C,EAAIA,GACpBoB,GAAe5W,UAAU,MACzBiO,EAAI,EACJuH,IAEF,KAAOz1B,QAAQviB,GAAGywC,EAAIA,GACpB2I,GAAe3W,iBAAiB,KAChCgO,IAEF2I,GAAe3W,iBAAiBlgB,QAAQviB,GAAGm1C,GAC3C1E,IAEF,OAAO2I,GAGT34B,OAAS,GAET6P,cAAgB,WAMd,OALAsc,OAAS,EACT5U,MAAQ,EACR7M,OAAS,EACTpB,UAAUqU,OACVzQ,WACOlN,QAGTkN,SAAW,WACT,IAAI3tB,EAAGu3B,EAAIqa,EAAMuU,EAAQ9U,EAAe+U,EAAW3V,EAAGuH,EAUtD,IATAoO,EAAY3lC,OACZ0lC,EAAS,EACTnmD,EAAI,GAEJqxC,EAAgB9uB,QAAQ3f,MAAM,EAAGgqC,SACnB0E,KAAKjuB,WAEnBotB,EAAI,EACJuH,GAFAz1B,QAAU,GAAGgvB,OAAOF,GAAeE,OAAOhvB,QAAQ3f,MAAMgqC,UAE5C,GAAGoL,EACVh4C,EAAIu3B,EAAK,EAAGqa,EAAOhF,OAAS,GAAKgF,EAAOra,EAAKqa,EAAOra,EAAKqa,EAAO5xC,EAAI,GAAK4xC,IAASra,IAAOA,EAAI,CAChG,KAAOhV,QAAQviB,GAAGg4C,EAAIA,GACpBoO,EAAUD,KAAY,KACtB1V,EAAI,EACJuH,IAEF,KAAOz1B,QAAQviB,GAAGywC,EAAIA,GACpB2V,EAAUD,KAAY,IACtB1V,IAEF2V,EAAUD,KAAY5jC,QAAQviB,GAAGm1C,EACjC1E,IAEF,OAAO2V,EAAUD,KAAY,MAG/BzxC,EAAI,IAEJ8nB,WAAc,WAAW,IACjBA,EADiB,mEAevB,OAZAA,EAAWp7B,UAAUqvC,EAAI,EAEzBjU,EAAWp7B,UAAU42C,EAAI,EAEzBxb,EAAWp7B,UAAU2uC,EAAI,EAEzBvT,EAAWp7B,UAAU4uC,EAAI,EAEzBxT,EAAWp7B,UAAUkgD,MAAQ,EAE7B9kB,EAAWp7B,UAAUgkB,MAAQ,EAEtBoX,GAEN36B,KAAKutC,MAERxlB,KAAO,GAEFD,WAAa4N,GAAK,EAAGA,GAAK,IAAO5N,aAAe4N,GACnD3N,KAAKD,YAAc,IAAI6S,WAGzBxkB,sBAAwB,EAExBC,mBAAqB,EAErB6S,YAAc,SAAS4lB,GACrB,IAAI8J,EAAK6K,EAAIM,EAAIU,EAAIC,EAAOtmD,EAAG0xC,EAAIC,EAAIjvC,EAAG0zC,EAAImQ,EAAMC,EAAMlQ,EAAI1E,EAAMC,EAAMC,EAAMC,EAAMwI,EAAKvK,EAAGS,EAAGuH,EAejG,GAdAh4C,EAAI,EACA,EACG,EACPumD,EAAO,EACH,EACA,EACA,EACA,EACJlB,EAAK,EACLM,EAAK,EACLU,EAAK,EACLC,EAAK,EACL/L,EAAM,EACNC,EAAM,EACF9J,EAAEnG,OAAOsF,KAAO,EAClB3lB,iBAAiBwmB,OADnB,CAWA,MADAhuC,GANA8jD,EAAO9V,EAAEnG,OAAOoF,IAAI,KAElB4W,EADoB,IAAlB7V,EAAEnG,OAAOsF,KACJa,EAAEnG,OAAOoF,IAAI,GAEb,IAGDj7B,GAAR,CAWA,IAFA+7B,EAAItlB,OAECnrB,EAAI0xC,EAAK,EAAGE,EAAOlvC,EAAI,GAAKkvC,EAAOF,EAAKE,EAAOF,EAAKE,EAAO5xC,EAAI,GAAK4xC,IAASF,IAAOA,EAAI,CAC3F9nB,KAAK5pB,GAAGshD,MAAQ1U,OAChBhjB,KAAK5pB,GAAGywC,EAAItlB,OACZpB,UAAU2mB,EAAEnG,OAAO3gB,KAAK5pB,IACxB4pB,KAAK5pB,GAAGolB,MAAQwnB,OAAShjB,KAAK5pB,GAAGshD,MAJ0D,MAKvDlxB,SAASxG,KAAK5pB,GAAGshD,MAAO1U,QAL+B,sBAK1FhjB,KAAK5pB,GAAG+vC,EALkF,KAK/EnmB,KAAK5pB,GAAGgwC,EALuE,KAKpEpmB,KAAK5pB,GAAGg4C,EAL4D,KAU7F,IAFAqO,EAAK,EACLC,EAAK,EACAtmD,EAAI2xC,EAAK,EAAGE,EAAOnvC,EAAI,GAAKmvC,EAAOF,EAAKE,EAAOF,EAAKE,EAAO7xC,EAAI,GAAK6xC,IAASF,IAAOA,EACnF/nB,KAAK5pB,GAAG+vC,EAAIsW,IACdA,EAAKz8B,KAAK5pB,GAAG+vC,GAEXnmB,KAAK5pB,GAAGgwC,EAAIsW,IACdA,EAAK18B,KAAK5pB,GAAGgwC,GAUjB,IAJAA,EAAIuW,EAAOD,GAAMC,EAAO,GAAKvuC,sBAE7BggC,IAJIwO,EAAOH,GAAMG,EAAO,GAAKvuC,oBAInB,EAELsiC,EAAMnE,EAAK,EAAGtE,EAAO0U,EAAO,GAAK1U,EAAOsE,EAAKtE,EAAOsE,EAAKtE,EAAOyI,EAAM,GAAKzI,IAASsE,IAAOA,EAC9F,IAAKoE,EAAMlE,EAAK,EAAGvE,EAAOwU,EAAO,GAAKxU,EAAOuE,EAAKvE,EAAOuE,EAAKvE,EAAOyI,EAAM,GAAKzI,IAASuE,IAAOA,EAG9F+O,EAAK5U,EAAI7mB,KAFT5pB,EAAIu6C,EAAMgM,EAAO/L,GAEA/J,EACjBkV,EAAK3N,EAAIpuB,KAAK5pB,GAAGg4C,EACjBxe,KAAK5P,KAAK5pB,GAAGshD,MAAO13B,KAAK5pB,GAAGshD,MAAQ13B,KAAK5pB,GAAGolB,MAAOigC,EAAIM,GAEvDN,EAAK,EACD7K,EAAM,IACR6K,EAAK7K,GAAO8L,EAAKtuC,wBAEnB2tC,EAAK,EACDpL,EAAM,IACRoL,EAAKpL,GAAO8L,EAAKpuC,qBAGnBotC,IAAOiB,EAAK18B,KAAK5pB,GAAGgwC,GAAK,EAEzB2V,IAAOU,EAAKz8B,KAAK5pB,GAAG+vC,GAAK,EACzBvW,KAAK5P,KAAK5pB,GAAGshD,MAAO13B,KAAK5pB,GAAGshD,MAAQ13B,KAAK5pB,GAAGolB,MAAOigC,EAAIM,GAG3D,OAAOx6B,OAASslB,EAAIT,EA1DlB9lB,iBAAiBwmB,KA6DrBxmB,iBAAmB,SAASwmB,GAC1B,OAAO3lB,mBAAkB2lB,EAAG,EAAG,IAGjC3lB,mBAAoB,SAAS2lB,EAAGL,EAAGZ,GACjC,IAAIzvC,EAAG0xC,EAAIE,EAGX,IAFA5xC,EAAI,EACJ2b,YAAY,KACP3b,EAAI0xC,EAAK,EAAGE,EAAOlB,EAAEnG,OAAOoF,IAAIU,GAAK,GAAKuB,EAAOF,EAAKE,EAAOF,EAAKE,EAAO5xC,EAAI,GAAK4xC,IAASF,IAAOA,EACjGrB,EAAI,IAAMK,EAAEnG,OAAOsF,MACrB9lB,UAAU2mB,EAAEnG,OAAO3gB,KAAK6lB,IACxBA,GAAQ,GAERA,EAAI1kB,mBAAkB2lB,EAAGL,EAAI,EAAGZ,GAE9BzvC,EAAI,EAAI0wC,EAAEnG,OAAOoF,IAAIU,IACvB10B,YAAY,KAIhB,OADAA,YAAY,KACL8zB,GAWT1gC,aAAe,WACb,IAAIq1C,EAAMpkD,EAAGymD,EAAepW,EAAGZ,EAAGiC,EAAIgV,EAAuB9U,EAAMC,EAenE,GAdA7xC,EAAI,EACA,EACA,EAEJokD,EAAO7iC,KAAKwb,IAEZ0pB,EAAgBnlC,MAAMyb,IACjBhG,SAAS0vB,IACZtd,KAAK,iBAGPnnC,KAAKqf,OAAO0b,KACZt0B,OACA4nC,EAAI9R,cACA8U,MAAMhD,GACRruC,KAAK+6B,QADP,CAQA,GAHA/6B,KAAKof,QAAQ2b,KACbt0B,OACAgnC,EAAIlR,eACA8U,MAAM5D,GAAV,CAQA,IAFAiX,EAAwB52B,YAAY22B,GACpCtjB,aAAa,GACRnjC,EAAI0xC,EAAKE,EAAOvB,EAAGwB,EAAOpC,EAAImC,GAAQC,EAAOH,GAAMG,EAAOH,GAAMG,EAAO7xC,EAAI4xC,GAAQC,IAASH,IAAOA,EACtGvO,aAAanjC,GACbm9B,GAAKiB,MACL0I,YAAY2f,EAAetpB,IAC3Bn7B,KAAKoiD,GACL37C,OACI1C,QACFirC,QAAQE,IAAI,uBAAyBpI,MAAMqC,IAAM,GAAGxoC,YACpDquC,QAAQE,IAAI,uBAAyBpI,MAAMqC,IAAM,GAAGxoC,aAEtD03B,WACIt0B,OACFirC,QAAQE,IAAI,qBAAuBpI,MAAMqC,IAAM,GAAGxoC,YAItD,OAAOmkC,YAAY2f,EAAeC,GAvBhC1kD,KAAK+6B,MAiCT0G,KAAO,WACL,IAAIkjB,EAAmCC,EAASC,EAASC,EAAkBC,EAAYC,EAAYC,EAAgBC,EAanH,GATAF,EAAa5oB,MACb2oB,EAAa3oB,MACbwoB,EAAUvtB,KAAK0tB,EAAW1X,EAAEH,EAAG8X,EAAW3X,EAAEF,GAC5C0X,EAAUxtB,KAAK0tB,EAAW1X,EAAEF,EAAG6X,EAAW3X,EAAEH,GAC5C+X,EAAiB1uB,KAAKquB,EAASC,IAK3BpyC,MAAMwyC,GAsBV,OAhBAH,EAAmBztB,KAAK0tB,EAAW1X,EAAEF,EAAG6X,EAAW3X,EAAEF,GACrDwX,EAAoC1tB,KAAKguB,EAAgBH,GAEzDH,EAAoCluB,eAAekuB,EAAmCG,IAGtFI,EAAY,IAAI/rC,GACNs0B,EAAIp6B,IACd6xC,EAAU7X,EAAEH,EAAIpW,KAAKmuB,EAAgBN,GACrCO,EAAU7X,EAAEF,EAAIrW,KAAKguB,EAAkBH,GAOhC3kD,KAAKklD,GAnBVllD,KAAK6sC,OA+BTnL,KAAO,WACL,IAAIyjB,EAAIC,EAAIjS,EAQZ,OAPA7P,OACAtI,GAAKoB,MACLrB,GAAKqB,MAED3pB,MAAMuoB,GAAGqS,EAAEH,IACb/F,KAAK,kBAEH10B,MAAMsoB,GAAGsS,EAAEH,IACbltC,KAAK6sC,WACLhK,YAGFsiB,EAAK9tB,KAAK0D,GAAGsS,EAAEH,EAAGlS,GAAGqS,EAAEF,GACvBiY,EAAK/tB,KAAK0D,GAAGsS,EAAEF,EAAGnS,GAAGqS,EAAEH,GACvBiG,EAAIlc,KAAKkuB,EAAIC,GACbjS,EAAI1c,eAAe0c,EAAGiS,IACtBrqB,GAAK,IAAI5hB,GACNs0B,EAAIp6B,IACP0nB,GAAGsS,EAAEH,EAAIpW,KAAKquB,EAAIhS,GAClBpY,GAAGsS,EAAEF,EAAIrW,KAAKsuB,EAAIjS,GAClBnzC,KAAK+6B,IACE8H,YAUTlB,KAAO,WACL,IAAIwjB,EAAIC,EAAIjS,EAKZ,OAJA7P,OACAtI,GAAKoB,MACLrB,GAAKqB,MAED3pB,MAAMsoB,GAAGsS,EAAEH,IAAMz6B,MAAMuoB,GAAGqS,EAAEH,IAC9BltC,KAAK6sC,WACLhK,YAGFsiB,EAAK9tB,KAAK0D,GAAGsS,EAAEH,EAAGlS,GAAGqS,EAAEH,GACvBkY,EAAK/tB,KAAK0D,GAAGsS,EAAEF,EAAGnS,GAAGqS,EAAEF,GACvBgG,EAAIlc,KAAKkuB,EAAIC,GACbjS,EAAI1c,eAAe0c,EAAGiS,IACtBrqB,GAAK,IAAI5hB,GACNs0B,EAAIp6B,IACP0nB,GAAGsS,EAAEH,EAAIpW,KAAKquB,EAAIhS,GAClBpY,GAAGsS,EAAEF,EAAIrW,KAAKsuB,EAAIjS,GAGlBnzC,KAAK+6B,IACE8H,YAITjB,KAAO,WAGL,OAFA0B,OACAzB,QACOgB,WAKThB,MAAQ,WACN,IAAIqL,EAAGC,EAAG0J,EAAMrH,EAAGf,EAAGuH,EAKtB,GAJAa,EAAO,EAEP7b,GAAKoB,MACLrB,GAAKqB,MACDvI,UAAUkH,KAAOjK,mBAAmBkK,IACtCmG,aAAa,QAIf,GAAIpO,WAAWgI,KAAOnH,aAAaoH,IACjCh7B,KAAKsvB,mBADP,CAKA,GAAIwB,mBAAmBiK,IAKrB,OAJI1H,iBAAiB2H,KACnBmM,KAAK,uBAEPnnC,KAAK6sC,MAIP,IAAIhZ,UAAUmH,IAKd,OAAItI,UAAUsI,KACZh7B,KAAKg7B,IACL6b,EAAOta,cACH8U,MAAMwF,IAERxV,YAAYttB,OACZ/T,KAAK+6B,IACL/6B,KAAKg7B,SACL/E,KAAK,KAGPwY,EAAI3W,KAAKiD,GAAGsS,EAAEH,EAAGqB,KAAK/zB,IAAIq8B,IAC1Bb,EAAIle,KAAKiD,GAAGsS,EAAEF,EAAGoB,KAAK/zB,IAAIq8B,IACtBA,EAAO,IACTrH,EAAIf,EAGJA,EAAIhY,eAFJgY,EAAIuH,EACJA,EAAIxG,GAEJwG,EAAIxf,aAAawf,KAEnB/a,GAAK,IAAI9hB,GACNs0B,EAAIp6B,IACP4nB,GAAGoS,EAAEH,EAAIuB,EACTxT,GAAGoS,EAAEF,EAAI6I,OACTh2C,KAAKi7B,MAMHlI,WAAWgI,KACb/6B,KAAKg7B,SACLvB,mBAIEpG,iBAAiB0H,KACnB/6B,KAAK+6B,IACLhC,SACA/4B,KAAKg7B,IACL4G,OACAT,cAAc,GACdnhC,KAAKg7B,IACL4G,YACAvJ,YAGG3F,UAAUqI,IAgBX5J,iBAAiB4J,KACnB/6B,KAAK+6B,IACL/6B,KAAKg7B,SACL8G,eAGGpR,QAAQsK,GAAGqS,EAAEH,IAAOxc,QAAQsK,GAAGqS,EAAEF,IAOtCD,EAAIlS,GAAGqS,EAAEH,EACTC,EAAInS,GAAGqS,EAAEF,EAEC,KADVsB,EAAIzW,MAAM+C,GAAGsS,EAAEH,EAAGC,KAEhB9L,YAAYttB,OACZ/T,KAAK+6B,IACL/6B,KAAKg7B,SACL/E,KAAK,KAGP+f,EAAIle,KAAK2W,EAAGvB,IAEZjS,GAAK,IAAI9hB,GACNs0B,EAAIp6B,IACH2nB,GAAGqS,EAAEH,EAAEsJ,cACTvb,GAAGoS,EAAEH,EAAIlvB,OAAO,GAChBid,GAAGoS,EAAEF,EAAI6I,IAET/a,GAAGoS,EAAEH,EAAI8I,EACT/a,GAAGoS,EAAEF,EAAInvB,OAAO,IAEXhe,KAAKi7B,OA3BVoG,YAAYttB,OACZ/T,KAAK+6B,IACL/6B,KAAKg7B,SACL/E,KAAK,KAzBLj2B,KAAK+6B,IACLnD,eACA53B,KAAKg7B,IACL4G,OACA5hC,KAAK+6B,IACLpD,iBACA33B,KAAKg7B,IACLjC,SACA6I,YACAvJ,YA7DAr4B,KAAK+6B,MA0ITtB,gBAAkB,WAGhB,OAFA6J,OACAvI,GAAKqB,MACD1J,UAAUqI,KACRA,GAAGsS,EAAEH,EAAEmY,QACTlkB,cAAc,GAEdA,aAAa,QAEf0B,YAIF7iC,KAAK+6B,IACLzc,kBACA0c,GAAKoB,MACD/I,iBAAiB0H,MACnB/6B,KAAKg7B,IACLmG,cAAc,GACdvmB,MACAogB,GAAKoB,OAIPp8B,KAAK+6B,IACL/6B,KAAKg7B,IACLwM,WACAvM,GAAKmB,MACLiF,YAAYttB,OACZotB,cAAc,GACdnhC,KAAKi7B,IACLhF,KAAK,GAED+E,GAAGqS,EAAEH,EAAEmY,SACTtsB,SAEK8J,YAGT1R,iBAAmB,SAASud,GAC1B,OAAOhe,QAAQge,EAAErB,EAAEH,IAiBrBpL,YAAc,WACZ,IAAIiM,EAAG/vC,EAAG0xC,EAAIhvC,EAAGkvC,EAAM0V,EAUvB,IATAtnD,EAAI,EACJslC,OACAtI,GAAKoB,MACLrB,GAAKqB,MACL2R,EAAI5E,IACJnpC,KAAK+6B,IACLzP,sBAEAg6B,EAAavX,EACR/vC,EAAI0xC,EAAK,EAAGE,EAFjBlvC,EAAIyoC,IAAM4E,EAEiB2B,EAAKE,EAAM5xC,EAAI0xC,GAAM,EAC9C1vC,KAAK8mC,MAAMwe,EAAatnD,IACxBgC,KAAK8mC,MAAMwe,EAAatnD,EAAI,IAC5BgC,KAAKg7B,IACL3C,WACA0J,aAWF,OAJAzJ,aAAa6Q,IAAM4E,EAAIrtC,GACvBq6B,GAAKqB,MACL3E,QAAQsW,GACR/tC,KAAK+6B,IACE8H,WAITd,WAAa,WACX,IAAI8U,EAoBJ,OAnBO,EACPvT,OACAtI,GAAKoB,MACLrB,GAAKqB,MACLp8B,KAAKg7B,IACL1c,kBACA2c,GAAKmB,MACLp8B,KAAKg7B,IACLh7B,KAAKi7B,IACLuM,WACAtM,GAAKkB,MACAtL,mBAAmBoK,MACtBmG,YAAYttB,OACZ/T,KAAK+6B,IACL/6B,KAAKk7B,IACLjF,KAAK,IAEPj2B,KAAKi7B,IACL4b,EAAOta,cACH8U,MAAMwF,IACRxV,YAAYttB,OACZ/T,KAAK+6B,IACL/6B,KAAKi7B,IACLhF,KAAK,QACL4M,WAGW,IAATgU,GAIJ72C,KAAK+6B,IACL5c,oBAAoB04B,GACbhU,gBALLA,WAWJ51B,cAAgB,WAYd,OAXAjN,KAAKuf,KAAKwb,KACVt0B,OACAzG,KAAKsf,MAAMyb,KACXt0B,OACAzG,KAAKqf,OAAO0b,KACZt0B,QACAs0B,GAAKqB,SACMuL,OAAOh1B,OAChBooB,GAAK4M,OAAOrwB,WAEdtX,KAAK+6B,IACEzU,WAsBTA,QAAU,WACR,IAAIs0B,EAAU2K,EAASxX,EAAG/vC,EAAG0xC,EAAIkJ,EAAGl4C,EAAGkvC,EAAMnB,EAmB7C,IAlBI,EACJzwC,EAAI,EACJ46C,EAAI,EACA,EACJnK,EAAI,EAEJnL,OACArI,GAAKmB,MACLpB,GAAKoB,MACLrB,GAAKqB,MACL2R,EAAI5E,IACJyR,EAAWzR,IACXyP,EAAIj3B,MAAMsZ,GAAIF,IAAM,EACpBwqB,EAAUpc,IAEVsF,EAAImK,GADJl4C,EAAIihB,MAAMsZ,GAAID,IAAM,GAEpBmG,aAAa,GACbhG,GAAKiB,MACEqS,GAAK,GAAG,CAKb,IAJAzuC,KAAK8mC,MAAM8T,EAAWhC,IACtB54C,KAAK8mC,MAAMye,EAAU7kD,IACrBwlB,SACAgV,GAAKkB,MACAp+B,EAAI0xC,EAAK,EAAGE,EAAOlvC,EAAI,GAAKkvC,EAAOF,GAAME,EAAOF,GAAME,EAAO5xC,EAAI,GAAK4xC,IAASF,IAAOA,EACzF1vC,KAAK8mC,MAAM8T,EAAWnM,EAAIzwC,IAC1BgC,KAAK8mC,MAAMye,EAAUvnD,IACrBgC,KAAKk7B,IACL7C,WACAmP,WACAV,MAAM8T,EAAWnM,EAAIzwC,GAAKo+B,MAE5Bp8B,KAAKm7B,IACLn7B,KAAKk7B,IACLl7B,KAAKi7B,IACLkG,aAAasN,GACbjS,QACAnE,WACAzd,MACAugB,GAAKiB,MACLwc,IACAnK,IAIF,OAFAhX,QAAQsW,GACR/tC,KAAKm7B,IACE0H,WAGTt+B,mBAAoB,EAEpB4I,iBAAmB,WAGjB,OAFAnN,KAAKuf,KAAKwb,KACVt0B,OACOw7B,eAGTA,YAAc,WACZ,IAAIwM,EAGJ,OAFAA,EAAIrkB,UACJmiB,gBACOniB,UAAYqkB,GAGrBlC,cAAgB,WACd,IAAIiZ,EAAmBC,EAAU1W,EAEjC,GADAA,EAAc3S,MACVnH,SAAS8Z,GACXz0B,qBAAqBy0B,OADvB,CAKA,GADA3kB,UAAY,EACR3K,IAAIsvB,KAAiBpH,OAAOxmC,KAAhC,CAiBA,IAbIoD,mBACFyqC,QAAQE,IAAI,wCAA0CH,GAGxD/uC,KAAKu6B,KACL9B,sBAAsBsW,GACtByW,EAAoBppB,MAChB73B,mBACFyqC,QAAQE,IAAI,6CAA+CsW,GAG7DxlD,KAAK6sC,MACL4Y,EAAWtlC,IAAI4uB,GACRnd,OAAO6zB,IACRlhD,mBACFyqC,QAAQE,IAAI,SAAWzvB,IAAIgmC,IAE7BzlD,KAAKwlD,GACLxlD,KAAKyf,IAAIgmC,IACTptB,WACAzd,MACA6qC,EAAWtlC,IAAIslC,GAajB,OAXIlhD,mBACFyqC,QAAQE,IAAI,sDAAwDpI,MAAMqC,IAAM,IAGlFrlC,WACIS,mBACFyqC,QAAQE,IAAI,iCAAmCpI,MAAMqC,IAAM,IAG7DnpC,KAAKwlD,GACLt/B,SACI3hB,kBACKyqC,QAAQE,IAAI,+DAAiEpI,MAAMqC,IAAM,SADlG,EArCEnpC,KAAK+uC,KA0CTtW,sBAAwB,SAASiW,GAC/B,IAAId,EACJ,GAAInuB,IAAIivB,KAAO/G,OAAOxmC,KAAM,CAG1B,IAFAutC,EAAIvuB,IAAIuuB,GACRd,EAAU,GACHhc,OAAO8c,IACZ/V,2BAA2BlZ,IAAIivB,IAC/Bd,EAAQ5tC,KAAK0uC,EAAIvuB,IAAIuuB,IAEvB,OAAOd,EAEP,OAAOjV,2BAA2B+V,IAItC/V,2BAA6B,SAAS+V,GACpC,IAAId,EACJ,GAAInuB,IAAIivB,KAAO/G,OAAOn1B,UAAW,CAG/B,IAFAk8B,EAAIvuB,IAAIuuB,GACRd,EAAU,GACHhc,OAAO8c,IACZhW,6BAA6BjZ,IAAIivB,IACjCd,EAAQ5tC,KAAK0uC,EAAIvuB,IAAIuuB,IAEvB,OAAOd,EAEP,OAAOlV,6BAA6BgW,IAIxChW,6BAA+B,SAASgW,GACtC,GAAIjvB,IAAIivB,KAAO/G,OAAO5zB,OAMtB,OAHA/T,KAAK0uC,GACLA,EAAIpvB,MAAMovB,GAENrb,iBAAiBqb,IAMjBjvB,IAAIivB,KAAO/G,OAAOn1B,WAAa6gB,iBAAiB9T,KAAKmvB,KALvDve,eACAlW,SAUKmiB,OAGT9hB,qBAAuB,SAASigC,GAC9B,IAAIv8C,EAAG0xC,EAAOE,EAKd,GAJA5xC,EAAI,EACJgC,KAAKu6C,GACL9zC,OACA8zC,EAAYne,MACPnH,SAASslB,GAAd,CAKA,IAAKv8C,EAAI0xC,EAAK,EAAGE,EADb2K,EAAUhS,OAAOuF,MACO,GAAK8B,EAAOF,EAAKE,EAAOF,EAAKE,EAAO5xC,EAAI,GAAK4xC,IAASF,IAAOA,EACvF1vC,KAAKu6C,EAAUhS,OAAO3gB,KAAK5pB,IAC3BikC,cACAsY,EAAUhS,OAAO3gB,KAAK5pB,GAAKo+B,MAG7B,OADAzb,wBAAwB45B,GACjBv6C,KAAKu6C,GAVVv6C,KAAKu6C,IAaTtgC,MAAQ,WAWN,OAVAqpB,OACAvI,GAAKqB,MACLpB,GAAKoB,MACLp8B,KAAK+6B,IACL/6B,KAAKg7B,IACL3C,WACAr4B,KAAK+6B,IACL/6B,KAAKg7B,IACL/N,MACA/G,SACO2c,WAGTz1B,UAAY,WAGV,OAFApN,KAAKuf,KAAKwb,KACVt0B,OACO07B,QAGTA,KAAO,WAUL,OATAmB,OACAjB,QACAtH,GAAKqB,MACLp8B,KAAK+6B,IACL/6B,KAAK+6B,IACLrY,YACA9H,MACAumB,aAAa,GACbjb,SACO2c,WAGTr+B,YAAa,EAEb6I,UAAY,WAGV,OAFArN,KAAKuf,KAAKwb,KACVt0B,OACO47B,SAGTA,MAAO,WACL,IAAI+M,EAcJ,GAbA9L,OAEA8L,EADArU,GAAKqB,MAED53B,YACFwqC,QAAQE,IAAI,WAAaE,GAEvB5qC,YACFwqC,QAAQE,IAAI,wBAA0BE,EAAQ,MAAQnjB,uBAAsBmjB,IAM1Era,SAASgG,IACPv2B,YACFwqC,QAAQE,IAAI,yBAA2BE,GAEpCte,mBAAmBhD,YAAY6Z,OAAO7lC,0BAGzCu/B,YAAY5nB,QACZzZ,KAAK+6B,IACL9E,KAAK,IAJLj2B,KAAK+6B,SAMF,GAAKjK,mBAAmBhD,YAAY6Z,OAAO7lC,0BAA6BoqB,6BAA4B6O,KAAQ9O,uBAAsB8O,KAASjrB,MAAKirB,GAAI4M,OAAO7xB,OAAShG,MAAKirB,GAAI4M,OAAO/jC,OAASkM,MAAKirB,GAAIzL,eAMtM,GAAI7P,IAAIsb,MAAQ4M,OAAOn1B,WAAaggB,gBAAgBjT,KAAKwb,OAASjK,mBAAmBhD,YAAY6Z,OAAO7lC,yBAC7G9B,KAAK+6B,SAEA,GAAItb,IAAIsb,MAAQ4M,OAAOxmC,KAM5B,IALIqD,YACFwqC,QAAQE,IAAI,WAAaE,EAAQ,cAEnCjO,aAAa,GACbpG,GAAK5a,IAAI4a,IACFnJ,OAAOmJ,KACZ/6B,KAAKyf,IAAIsb,KACTsH,QACAznB,MACAmgB,GAAK5a,IAAI4a,SAMPv2B,YACFwqC,QAAQE,IAAI,WAAaE,EAAQ,kBAEnCpvC,KAAK+6B,IACLvgB,MACIhW,YACFwqC,QAAQE,IAAI,WAAaE,EAAQ,SAAWtI,MAAMqC,IAAM,GAAGxoC,YAE7DX,KAAK+6B,IACLxd,MACI/Y,YACFwqC,QAAQE,IAAI,WAAaE,EAAQ,WAAarU,GAAK,MAAQ+L,MAAMqC,IAAM,GAAGxoC,YAE5Eo6B,GAAKqB,MACLp8B,KAAK+6B,IACL9X,SACIze,YACFwqC,QAAQE,IAAI,WAAaE,EAAQ,YAActI,MAAMqC,IAAM,GAAGxoC,YAEhEX,KAAKsvB,eACLtvB,KAAK+6B,IACLwL,OACI/hC,YACFwqC,QAAQE,IAAI,WAAaE,EAAQ,UAAYtI,MAAMqC,IAAM,GAAGxoC,YAE9D03B,WACI7zB,YACFwqC,QAAQE,IAAI,WAAaE,EAAQ,cAAgBtI,MAAMqC,IAAM,GAAGxoC,YAElEia,MACIpW,YACFwqC,QAAQE,IAAI,WAAaE,EAAQ,oBAAsBtI,MAAMqC,IAAM,GAAGxoC,YAExE03B,gBAzDI7zB,YACFwqC,QAAQE,IAAI,yBAA2BE,GAEzCpvC,KAAK+6B,IAyDP,GADA8H,UACIr+B,WACF,OAAOwqC,QAAQE,IAAI,WAAaE,EAAQ,MAAQtI,MAAMqC,IAAM,KAUhE9D,kBAAmB,EAEnBrJ,kBAAmB,EAEnB1uB,WAAa,WA0CX,OArCA0tB,GAAKzb,KAAKwb,IACNtb,IAAIub,MAAQ2M,OAAOlyB,OAASgK,IAAIub,MAAQ2M,OAAO5vB,SACjD/X,KAAKuf,KAAKyb,KACVv0B,OACAzG,KAAKsf,MAAM0b,KACXv0B,OACA+gC,aAEAxnC,KAAKg7B,IACLv0B,OACAu0B,GAAKoB,MACD3c,IAAIub,MAAQ2M,OAAOlyB,OAASgK,IAAIub,MAAQ2M,OAAO5vB,SACjD/X,KAAKuf,KAAKyb,KACVv0B,OACAzG,KAAKsf,MAAM0b,KACXv0B,OACA+gC,YAEAxnC,KAAKg7B,KAITh7B,KAAKsf,MAAMyb,KACXt0B,QACAu0B,GAAKoB,SACMuL,OAAOh1B,KAChB8b,QAEAzuB,KAAKg7B,IAEPA,GAAKoB,MACLrB,GAAKqB,MACArI,mBAAmBgH,GAAIC,KAC1BmM,KAAK,2DAA6DnM,IAEpEh7B,KAAK+6B,IACL/6B,KAAKg7B,IACEiI,SAGTvU,kBAAoB,SAAS+e,GAC3B,IAAOzvC,EAAG0nD,EAAuBhW,EAIjC,IAFAgW,GAAwB,EACpBvc,IACCnrC,EAAI0xC,EAAYjC,EAAGiC,EAAK,EAAG1xC,EAAI0xC,IAAO,EAEzC,GAAIhe,gBAAgBoV,MAAMqC,IAAMnrC,IAAK,CACnC0nD,GAAwB,EACxB,MAGJ,OAAOA,GAGTj1B,aAAe,SAASgd,GACtB,IAAOzvC,EAAG2nD,EAAwBjW,EAKlC,GAAIjC,EAAI,GAMN,IALAkY,GAAyB,EACrBxc,IACArY,mBAAmBgW,MAAMqC,IAAMsE,MACjCkY,GAAyB,GAEtB3nD,EAAI0xC,EAAYjC,EAAI,EAAGiC,EAAK,EAAG1xC,EAAI0xC,IAAO,EAC7C,IAAK5e,mBAAmBgW,MAAMqC,IAAMnrC,IAAK,CACvC2nD,GAAyB,EACzB,YAIJA,GAAyB,EAE3B,OAAOA,GAGTnsB,gBAAkB,SAASye,EAAUC,GACnC,IAAI0N,EAAU5nD,EAAGyvC,EAAGiC,EAAIC,EAAIkW,EAAWjW,EAAMC,EAK7C,IAJApC,EAAI9rB,MAAMs2B,EAAUC,GAEpB0N,EAAW9e,MAAMqC,IAAM,GACvB0c,EAAY,GACP7nD,EAAI0xC,EAAK,EAAGE,EAAOnC,EAAI,GAAKmC,EAAOF,GAAME,EAAOF,GAAME,EAAO5xC,EAAI,GAAK4xC,IAASF,IAAOA,EACzFmW,EAAU7lD,KAAKo8B,OAGjB,IAAKp+B,EAAI2xC,EAAKE,EAAOpC,EAAI,EAAIoC,GAAQ,EAAIF,GAAM,EAAIA,GAAM,EAAI3xC,EAAI6xC,GAAQ,IAAMF,IAAOA,EACpF3vC,KAAK6lD,EAAU7nD,IACfgC,KAAK4lD,GACL1/B,SAGF,OAAOunB,GAKTxK,MAAQ,WACN,IAAI8K,EAAG/vC,EAAGyvC,EAAGiC,EAAIoW,EAAWC,EAAcrlD,EAAGkvC,EAc7C,GAbI,EACJ5xC,EAAI,EACA,EACA+F,OACFirC,QAAQE,IAAI,UAAYpI,MAAMqC,IAAM,GAAGxoC,WAAa,IAAMmmC,MAAMqC,IAAM,GAAGxoC,YAE3E2iC,OAOIhB,oCAAsC,EAKxC,OAJAlG,MACAA,MACAp8B,KAAK2nC,OAAOh1B,WACZkwB,UA+BF,GA5BA7G,kBAAmB,EACnB+R,EAAI5E,IAAM,EACNplC,OACFirC,QAAQE,IAAI,qBAAuBpI,MAAMqC,IAAM,GAAGxoC,WAAa,8BAEjEq6B,GAAKoB,MACLrB,GAAKqB,MACLp8B,KAAK+6B,IACL/6B,KAAKg7B,IACLyS,EAAIjU,gBAAgBwB,GAAID,IACpBtK,aAAagd,IACX1pC,OACFirC,QAAQE,IAAI,QAAUpI,MAAMqC,IAAM,GAAGxoC,WAAa,8BAEpDmlD,EAAYhf,MAAMqC,IAAMsE,GACxBsY,EAAejf,MAAMqC,IAAM,GAC3B1R,QAAQ0R,IAAMsE,GACdrR,MACAA,MACAxO,eAAe6f,EAAGsY,EAAcD,KAEhCruB,QAAQ0R,IAAMsE,GACdvK,UAGQ,KADVxiC,EAAIyoC,IAAM4E,IAER5G,KAAK,uDAEG,IAANzmC,EAGF,OAFAs7B,kBAAmB,OACnB6G,UAOF,IAJA8D,WAAWjmC,IACXq6B,GAAK1f,aAAa3a,IACf6nC,OAAOsF,KAAO,EACjB9S,GAAGwN,OAAOoF,IAAI,GAAKjtC,EACd1C,EAAI0xC,EAAK,EAAGE,EAAOlvC,EAAI,GAAKkvC,EAAOF,EAAKE,EAAOF,EAAKE,EAAO5xC,EAAI,GAAK4xC,IAASF,IAAOA,EACvF3U,GAAGwN,OAAO3gB,KAAK5pB,GAAK8oC,MAAMiH,EAAI/vC,GAKhC,OAHAy5B,QAAQsW,GACR/tC,KAAK+6B,IACL8H,UACO7G,kBAAmB,GAS5BpO,eAAiB,SAASltB,EAAGqlD,EAAcD,GACzC,IAAIE,EAAMC,EAAYvW,EAAIC,EAAIC,EAAMC,EAAMqW,EAgB1C,GAfIniD,OACFirC,QAAQE,IAAI,kBAEd5L,OAGA5iC,GAAQ,EACRV,KAAK8lD,GACL1kB,cAAc,EAAG1gC,GACjB87B,QACAx8B,KAAK+lD,GACL3kB,cAAc,EAAG1gC,GACjB87B,QACAtW,SACA+/B,EAAa7pB,MACT17B,EAAI,IAAM,EACZ,IAAKwlD,EAAaxW,EAAK,EAAGE,EAAOlvC,EAAGgvC,GAAME,EAAMsW,EAAaxW,GAAM,EACjE1vC,KAAKimD,GACL9kB,cAAc,GACdC,cAAc8kB,EAAYxlD,GAC1B87B,QACAnE,WACA2tB,EAAO5pB,MACPp8B,KAAKgmD,GACLhmD,KAAKgmD,GACLjtB,cAGF,IAAKmtB,EAAavW,EAAK,EAAGE,EAAOnvC,EAAI,GAAKmvC,EAAOF,GAAME,EAAOF,GAAME,EAAOqW,EAAa,GAAKrW,IAASF,IAAOA,EAC3G3vC,KAAKimD,GACL9kB,cAAc,GACdC,cAAc8kB,EAAYxlD,GAC1B87B,QACAnE,WACI6tB,EAAa,IAAM,GACrBntB,SAIN,OAAO8J,WAGTK,OAAS,WACP,IAAIuK,EAmBJ,GAlBAnK,OACIv/B,OACFirC,QAAQE,IAAI,WAAapI,MAAMqC,IAAM,GAAGxoC,WAAa,IAAMmmC,MAAMqC,IAAM,GAAGxoC,YAE5Eq6B,GAAKoB,MACLrB,GAAKqB,MACLp8B,KAAK+6B,IACL/6B,KAAKg7B,IACLyS,EAAIjU,gBAAgBwB,GAAID,IACnBrM,kBAAkB+e,IAKrBhW,QAAQ0R,IAAMsE,GACdrR,MACAA,QANA3E,QAAQ0R,IAAMsE,GACdhiB,aACAsP,GAAKqB,OAMH3c,IAAIsb,MAAQ4M,OAAOn1B,UAIrB,IAHAuoB,GAAK5a,IAAI4a,IAGFnJ,OAAOmJ,KACZ/6B,KAAKyf,IAAIsb,KACT/6B,KAAKg7B,IACLmI,SACApI,GAAK5a,IAAI4a,SAGX/6B,KAAK+6B,IACL/6B,KAAKg7B,IACLmI,SAEF,OAAON,WAGTM,OAAS,WACP,IAAIziC,EAWJ,OAVA4iC,OACAtI,GAAKoB,MACLrB,GAAKqB,MACD3c,IAAIsb,MAAQ4M,OAAO5zB,QAAUggB,mBAAmBxU,KAAKwb,IAAKC,KAAO1G,SAAShV,MAAMyb,MAClFr6B,EAAI84B,gBAAgBwB,GAAIzb,KAAKwb,KAC7B7D,WAAWx2B,IACFqzB,mBAAmBgH,GAAIC,MAChCt6B,EAAI84B,gBAAgBwB,GAAID,IACxB7D,WAAWx2B,IAENmiC,WAmBT3L,WAAa,SAASx2B,GACpB,IAAIylD,EAA8CC,EAAcC,EAAWC,EAAQC,EAAOC,EAASC,EAASC,EAAoBC,EAASC,EAAKC,EAAaC,EAA8BC,EAA6CC,EAA4BC,EAAUC,EAAsEC,EAAMC,EAAQC,EAASC,EAAMC,EAASC,EAAWC,EAAOC,EAAMC,EAASC,EAAMC,EAAQC,EAAMC,EAAMC,EAAMC,EAAuDC,EAAMC,EAAMC,EAAKC,EAAaC,EAAWC,EAAWC,EAAYC,EAAwDC,EAA2BC,EAAiBC,EAA4BC,EAAcC,EAA2EC,EAAQC,EAAQC,EAAQC,EAAoBC,EAAcC,EAAwDC,EAAS3Z,EAAI5xC,EAAKm0C,GAAM2B,GAAMjE,GAAIyE,GAAIkV,GAAmBC,GAAkB3Z,GAAMC,GAAMC,GAAM0Z,GAAyBC,GAAeC,GAAaC,GAI7gC,GAFArmB,OAEU,IAAN5iC,EASF,OAPAu6B,GAAKmB,MACLlB,GAAKkB,MACLp8B,KAAKk7B,IACLl7B,KAAKi7B,IACL/U,SACA6S,cACA8J,UAIF,GAAU,IAANniC,EAsDF,OApDAu6B,GAAKmB,MACLlB,GAAKkB,MACLjB,GAAKiB,MAGLp8B,KAAKk7B,IACLiG,aAAa,GACb3E,QAEA2E,aAAa,GACbnhC,KAAKi7B,IACL5C,WACAr4B,KAAKm7B,IACL9C,WAEAmP,WAEApG,cAAc,EAAG,GACjB5E,QAEApB,GAAKgB,MACLp8B,KAAKo7B,IACLp7B,KAAKk7B,IACLsM,WAGAxnC,KAAKi7B,IACLkG,aAAa,GACb9I,WACAnS,SAIAlmB,KAAKo7B,IACLp7B,KAAKk7B,IACLtgB,MAGAme,SAKA/4B,KAAKi7B,IACL/U,SACAkb,cAAc,EAAG,GACjB/I,gBAKAwK,UAIF,GAAU,IAANniC,GAAiB,IAANA,EAAS,CAkHtB,GAjHAu6B,GAAKmB,MACLlB,GAAKkB,MACLjB,GAAKiB,MACLhB,GAAKgB,MAGLp8B,KAAKm7B,IACLn7B,KAAKm7B,IACL9C,WACAyvB,EAAO1rB,MACPp8B,KAAK8nD,GACL9nD,KAAKm7B,IACL9C,WACA0vB,EAAO3rB,MAEPp8B,KAAKk7B,IACLl7B,KAAKk7B,IACL7C,WACAqvB,EAAOtrB,MACPp8B,KAAK0nD,GACL1nD,KAAKk7B,IACL7C,WACAuvB,EAAOxrB,MACPp8B,KAAK4nD,GACL5nD,KAAKo7B,IACL/C,WACAwvB,EAASzrB,MACTp8B,KAAK6nD,GACL1mB,cAAc,GACd9I,WACAkwB,EAAYnsB,MACZp8B,KAAK4nD,GACLzmB,aAAa,GACb9I,WACAiuB,EAASlqB,MAETp8B,KAAKi7B,IACLj7B,KAAKi7B,IACL5C,WACA8uB,EAAO/qB,MACPp8B,KAAKmnD,GACLnnD,KAAKi7B,IACL5C,WACAivB,EAAOlrB,MACP+E,aAAa,GACbnhC,KAAKi7B,IACL5C,WACAkuB,EAAQnqB,MACRp8B,KAAKmnD,GACLnnD,KAAKo7B,IACL/C,WACA+uB,EAAShrB,MACTp8B,KAAKonD,GACLpnD,KAAKo7B,IACL/C,WACAgvB,EAAUjrB,MACVp8B,KAAKonD,GACLjmB,aAAa,IACb9I,WACAguB,EAAYjqB,MACZp8B,KAAKqnD,GACLlmB,cAAc,IACd9I,WACAgwB,EAAcjsB,MACdp8B,KAAKumD,GACLplB,aAAa,GACb9I,WACQ+D,MAERp8B,KAAKi7B,IACLj7B,KAAKm7B,IACL9C,WACAovB,EAAQrrB,MACRp8B,KAAKynD,GACLznD,KAAKk7B,IACL7C,WACAkvB,EAAUnrB,MACVp8B,KAAKunD,GACLvnD,KAAKo7B,IACL/C,WACAmvB,EAAYprB,MACZp8B,KAAKynD,GACLtmB,aAAa,GACb9I,WACAouB,EAAUrqB,MACV+E,cAAc,GACdnhC,KAAKi7B,IACLj7B,KAAK+nD,GACL1vB,WACAA,WACAiwB,EAAYlsB,MACZp8B,KAAKunD,GACLpmB,aAAa,GACb9I,WACAU,SACAyvB,EAAapsB,MACbp8B,KAAKwnD,GACLrmB,aAAa,IACb9I,WACA+tB,EAAehqB,MACfp8B,KAAK0nD,GACL1nD,KAAKymD,GACLjf,WACAuf,EAAW3qB,MACXp8B,KAAK0nD,GACL1nD,KAAK8nD,GACLzvB,WACAsvB,EAAUvrB,MACVp8B,KAAKk7B,IACLnC,SACA/4B,KAAKumD,GACLrgC,SACAuiC,EAAgBrsB,MACN,IAAN17B,EAAS,CA+DX,GA9DIqD,OACFirC,QAAQE,IAAI,kEAMVnrC,OACFirC,QAAQE,IAAI,cAAgB6X,EAASpmD,YAEvCX,KAAK+mD,GACL5lB,aAAa,GACb3E,QACA2E,aAAa,GACb9I,WACAquB,EAActqB,MACdp8B,KAAK+mD,GACLphB,WACAlrB,cACAusC,EAA6B5qB,MACzBr4B,OACFirC,QAAQE,IAAI,uBAAyB8X,EAA2BrmD,YAMlEX,KAAKomD,GACLpmD,KAAKuoD,GACLvoD,KAAK2nD,GACL3nD,KAAKsoD,GACLtoD,KAAKqoD,GACLztC,MACAA,MACAA,MACAA,MACA+qB,WACAlrB,cACAwtC,EAAgB7rB,MACZr4B,OACFirC,QAAQE,IAAI,uBAAyB+Y,EAActnD,YAGrDX,KAAKsmD,GACLtmD,KAAKwoD,GACLxoD,KAAKqmD,GACLzrC,MACAA,MACAqsC,EAAW7qB,MACPr4B,OACFirC,QAAQE,IAAI,cAAgB+X,EAAStmD,YAGvCX,KAAKinD,GACL9lB,aAAa,GACb3E,QACAx8B,KAAK0mD,GACLlf,WACApG,cAAc,EAAG,GACjB5E,QACAmJ,WACAuhB,EAAM9qB,MACFtL,mBAAmBm3B,GACrB,OAAIn3B,mBAAmBk2B,IACjBjjD,OACFirC,QAAQE,IAAI,kDAEdlvC,KAAKyoD,QACL5lB,YAGI9+B,OACFirC,QAAQE,IAAI,sDAEdlvC,KAAKi7B,IACLj7B,KAAKo7B,IACL+F,aAAa,GACb9I,WACAA,WACAr4B,KAAKk7B,IACLl7B,KAAKm7B,IACL9C,WACAmP,WACAxnC,KAAK+mD,GACL5lB,aAAa,GACb9I,WACAnS,SACAujC,GAAgBrtB,MAChBp8B,KAAKypD,IACLzpD,KAAKypD,IAGLzpD,KAAKunD,GACLpmB,aAAa,GACb9I,WAEAr4B,KAAKi7B,IACLj7B,KAAKi7B,IACLj7B,KAAKo7B,IACL+F,aAAa,GACb9I,WACAA,WACAA,WACAU,SAEA/4B,KAAK4nD,GACL7uB,SAEAne,MACAA,MAEA5a,KAAKi7B,IACLj7B,KAAK+mD,GACL1uB,WAEAnS,cACA2c,WAMJ,IAFAsjB,GAAwB,EACxBiD,GAA0B,GAClBjD,GAENnmD,KAAKknD,GACDkC,GACFrwB,SAEF/4B,KAAKinD,GACLrsC,MACAwmB,cAAc,EAAG,GACjB/I,WACA+I,cAAc,EAAG,GACjB5E,QACAmJ,WACAihB,EAAMxqB,MACFr4B,OACFirC,QAAQE,IAAI,aAAe0X,EAAIjmD,YAEjCX,KAAK4mD,GACLjhB,WACAlrB,cACAqsC,EAA+B1qB,MAC3Br4B,OACFirC,QAAQE,IAAI,iCAAmC4X,EAA6BnmD,YAE1EmwB,mBAAmBg2B,IACjB/iD,OACFirC,QAAQE,IAAI,uCAEdka,GAA0B,GAE1BjD,GAAwB,EA2E5B,OAxEAnmD,KAAK4mD,GACL5mD,KAAKumD,GACLluB,WACAmuB,EAAUpqB,MACVp8B,KAAKwmD,GACLrlB,aAAa,GACb9I,WACAsuB,EAAUvqB,MAEVp8B,KAAKsvB,eACL6R,aAAa,GACbC,cAAc,EAAG,GACjB5E,QACAnE,WACAgxB,EAAUjtB,MACV+E,aAAa,GACbnhC,KAAKqpD,GACLzuC,MACA2uC,GAAmBntB,MACnB+E,aAAa,GACbnhC,KAAKqpD,GACL7hB,WACA8hB,GAAoBltB,MACpBp8B,KAAK4mD,GACL5mD,KAAKumD,GACLrgC,SACA2gC,EAAczqB,MAEdp8B,KAAKyoD,GACLzoD,KAAK6mD,GACL9tB,SACA/4B,KAAK+mD,GACL/mD,KAAKwmD,GACLtgC,SACA6S,SAEAne,MACAA,MACA+qB,WAEA3lC,KAAKyoD,GACLzoD,KAAK6mD,GACL7mD,KAAKupD,IACLlxB,WACA8I,aAAa,GACbjb,SACAlmB,KAAKspD,IACLtpD,KAAK+mD,GACL1uB,WACAr4B,KAAK2mD,GACLzgC,SAEAtL,MACAA,MACA+qB,WAEA3lC,KAAKyoD,GACLzoD,KAAK6mD,GACL7mD,KAAKspD,IACLjxB,WACA8I,aAAa,GACbjb,SACAlmB,KAAKupD,IACLvpD,KAAK+mD,GACL1uB,WACAr4B,KAAK2mD,GACLzgC,SAEAtL,MACAA,MACA+qB,gBACA9C,UAKF,GAAU,IAANniC,EAAS,CAKX,GAJIqD,OACFirC,QAAQE,IAAI,oEAEd7T,GAAKe,MACDtL,mBAAmBoK,KAAOpK,mBAAmBsK,MAAQtK,mBAAmBqK,MAAQrK,mBAAmBuK,IAAK,CAmB1G,IAlBIt3B,OACFirC,QAAQE,IAAI,oBAEdlvC,KAAKi7B,IACLj7B,KAAK2nC,OAAOpyB,UACZ4rB,aAAa,GACb3E,QACAnE,WACAr4B,KAAKm7B,IACLn7B,KAAK2nC,OAAOpyB,UACZ8iB,WACAr4B,KAAKq7B,IACLzgB,MACAA,MACA5a,KAAK2nC,OAAOpyB,UACZ0tB,QAGKyM,EAAK,EAAG5xC,GADb8xC,GADuBxT,MACKmM,OAAO3gB,MACX7pB,OAAQ2xC,EAAK5xC,EAAK4xC,IACxCyZ,EAAevZ,GAAKF,GACpB1vC,KAAKmpD,GACL/nB,cAAc,EAAG,GACjB5E,QACAmJ,WACA3lC,KAAKmpD,GACL/nB,cAAc,EAAG,GACjB5E,QACAzD,SACA4M,WAGF,YADA9C,UAsOF,GAlOA7iC,KAAKo7B,IACLp7B,KAAKo7B,IACL/C,WACA2vB,EAAO5rB,MAEPp8B,KAAKq7B,IACLr7B,KAAKq7B,IACLhD,WACA6vB,EAAO9rB,MACPp8B,KAAKkoD,GACLloD,KAAKq7B,IACLhD,WACA8vB,EAAO/rB,MAEP+E,aAAa,KACbnhC,KAAKsnD,GACLtnD,KAAKmoD,GACL9vB,WACAA,WACA8I,cAAc,KACdnhC,KAAKonD,GACLpnD,KAAKkoD,GACLloD,KAAKk7B,IACL7C,WACAA,WACAA,WACA8I,cAAc,KACdnhC,KAAKmnD,GACLnnD,KAAK8nD,GACL9nD,KAAKkoD,GACL7vB,WACAA,WACAA,WACA8I,aAAa,KACbnhC,KAAKqnD,GACLrnD,KAAKm7B,IACLn7B,KAAKq7B,IACLhD,WACAA,WACAA,WACAr4B,KAAKqoD,GACLroD,KAAKgoD,GACL3vB,WACA8I,aAAa,KACbnhC,KAAKunD,GACLvnD,KAAKk7B,IACLl7B,KAAKkoD,GACL7vB,WACAA,WACAA,WACA8I,cAAc,GACdnhC,KAAKi7B,IACLj7B,KAAK0nD,GACL1nD,KAAKgoD,GACLhoD,KAAKq7B,IACLhD,WACAA,WACAA,WACAA,WACA8I,cAAc,IACdnhC,KAAKwnD,GACLxnD,KAAKm7B,IACLn7B,KAAKq7B,IACLhD,WACAA,WACAA,WACA8I,aAAa,IACbnhC,KAAKwnD,GACLxnD,KAAKgoD,GACL3vB,WACAA,WACA8I,aAAa,IACbnhC,KAAKynD,GACLznD,KAAK+nD,GACL/nD,KAAKq7B,IACLhD,WACAA,WACAA,WACA8I,cAAc,GACdnhC,KAAKynD,GACLznD,KAAK8nD,GACL9nD,KAAKgoD,GACL3vB,WACAA,WACAA,WACA8I,cAAc,IACdnhC,KAAK4nD,GACL5nD,KAAKk7B,IACLl7B,KAAKkoD,GACL7vB,WACAA,WACAA,WACA8I,aAAa,IACbnhC,KAAK6nD,GACL7nD,KAAKm7B,IACLn7B,KAAKq7B,IACLhD,WACAA,WACAA,WACAr4B,KAAKuoD,GACLvoD,KAAKgoD,GACL3vB,WACA8I,cAAc,GACdnhC,KAAK2nD,GACL3nD,KAAKm7B,IACLn7B,KAAKq7B,IACLhD,WACAA,WACAA,WACAr4B,KAAK2nD,GACL3nD,KAAKgoD,GACL3vB,WAIAzd,MACAA,MACAA,MACAA,MACAA,MACAA,MACAA,MACAA,MACAA,MACAA,MACAA,MACAA,MACAA,MACAA,MACAA,MACAqtC,EAAgB7rB,MACZr4B,OACFirC,QAAQE,IAAI,k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","sources":["../node_modules/@babel/runtime/helpers/arrayLikeToArray.js","../node_modules/@babel/runtime/helpers/arrayWithHoles.js","../node_modules/@babel/runtime/helpers/classCallCheck.js","../node_modules/@babel/runtime/helpers/createClass.js","../node_modules/@babel/runtime/helpers/iterableToArrayLimit.js","../node_modules/@babel/runtime/helpers/nonIterableRest.js","../node_modules/@babel/runtime/helpers/slicedToArray.js","../node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js","../node_modules/algebrite/dist/algebrite.js","../node_modules/big-integer/BigInteger.js","../javascript/esm|/home/py/projects/react/lnctrl/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js","../javascript/esm|/home/py/projects/react/lnctrl/node_modules/@babel/runtime/helpers/esm/typeof.js","../javascript/esm|/home/py/projects/react/lnctrl/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","../javascript/esm|/home/py/projects/react/lnctrl/node_modules/@babel/runtime/helpers/esm/createSuper.js","../javascript/esm|/home/py/projects/react/lnctrl/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","../javascript/esm|/home/py/projects/react/lnctrl/node_modules/@babel/runtime/helpers/esm/inherits.js","../javascript/esm|/home/py/projects/react/lnctrl/node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js","../javascript/esm|/home/py/projects/react/lnctrl/node_modules/@babel/runtime/helpers/esm/construct.js","../javascript/esm|/home/py/projects/react/lnctrl/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js","../javascript/esm|/home/py/projects/react/lnctrl/node_modules/@babel/runtime/helpers/esm/isNativeFunction.js"],"sourcesContent":["function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nmodule.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nmodule.exports = _arrayWithHoles, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nmodule.exports = _classCallCheck, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\n\nmodule.exports = _createClass, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","function _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nmodule.exports = _iterableToArrayLimit, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nmodule.exports = _nonIterableRest, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var arrayWithHoles = require(\"./arrayWithHoles.js\");\n\nvar iterableToArrayLimit = require(\"./iterableToArrayLimit.js\");\n\nvar unsupportedIterableToArray = require(\"./unsupportedIterableToArray.js\");\n\nvar nonIterableRest = require(\"./nonIterableRest.js\");\n\nfunction _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}\n\nmodule.exports = _slicedToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var arrayLikeToArray = require(\"./arrayLikeToArray.js\");\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}\n\nmodule.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","// Generated by CoffeeScript 2.5.1\n(function() {\n\n  /* arg =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  z\n\n  General description\n  -------------------\n  Returns the angle of complex z.\n\n  */\n  /*\n   Argument (angle) of complex z\n\n    z    arg(z)\n    -    ------\n\n    a    0\n\n    -a    -pi      See note 3 below\n\n    (-1)^a    a pi\n\n    exp(a + i b)  b\n\n    a b    arg(a) + arg(b)\n\n    a + i b    arctan(b/a)\n\n  Result by quadrant\n\n    z    arg(z)\n    -    ------\n\n    1 + i    1/4 pi\n\n    1 - i    -1/4 pi\n\n    -1 + i    3/4 pi\n\n    -1 - i    -3/4 pi\n\n  Notes\n\n    1. Handles mixed polar and rectangular forms, e.g. 1 + exp(i pi/3)\n\n    2. Symbols in z are assumed to be positive and real.\n\n    3. Negative direction adds -pi to angle.\n\n       Example: z = (-1)^(1/3), abs(z) = 1/3 pi, abs(-z) = -2/3 pi\n\n    4. jean-francois.debroux reports that when z=(a+i*b)/(c+i*d) then\n\n      arg(numerator(z)) - arg(denominator(z))\n\n       must be used to get the correct answer. Now the operation is\n       automatic.\n  */\n  /*\n   Returns the coefficient of the imaginary part of complex z\n\n    z    imag(z)\n    -    -------\n\n    a + i b    b\n\n    exp(i a)  sin(a)\n  */\n  /* Power function\n\n    Input:    push  Base\n\n        push  Exponent\n\n    Output:    Result on stack\n  */\n  /*\n  Convert complex z to rectangular form\n\n    Input:    push  z\n\n    Output:    Result on stack\n  */\n  /* det =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  m\n\n  General description\n  -------------------\n  Returns the determinant of matrix m.\n  Uses Gaussian elimination for numerical matrices.\n\n  Example:\n\n    det(((1,2),(3,4)))\n    > -2\n\n  */\n  /* adj =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  m\n\n  General description\n  -------------------\n  Returns the adjunct of matrix m. The inverse of m is equal to adj(m) divided by det(m).\n\n  */\n  /*\n   Guesses a rational for each float in the passed expression\n  */\n  /* arccos =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  x\n\n  General description\n  -------------------\n  Returns the inverse cosine of x.\n\n  */\n  /* arccosh =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  x\n\n  General description\n  -------------------\n  Returns the inverse hyperbolic cosine of x.\n\n  */\n  /* arcsin =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  x\n\n  General description\n  -------------------\n  Returns the inverse sine of x.\n\n  */\n  /* arcsinh =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  x\n\n  General description\n  -------------------\n  Returns the inverse hyperbolic sine of x.\n\n  */\n  /* arctan =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  x\n\n  General description\n  -------------------\n  Returns the inverse tangent of x.\n\n  */\n  /* arctanh =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  x\n\n  General description\n  -------------------\n  Returns the inverse hyperbolic tangent of x.\n\n  */\n  /* besselj =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  x,n\n\n  General description\n  -------------------\n\n  Returns a solution to the Bessel differential equation (Bessel function of first kind).\n\n  Recurrence relation:\n\n    besselj(x,n) = (2/x) (n-1) besselj(x,n-1) - besselj(x,n-2)\n\n    besselj(x,1/2) = sqrt(2/pi/x) sin(x)\n\n    besselj(x,-1/2) = sqrt(2/pi/x) cos(x)\n\n  For negative n, reorder the recurrence relation as:\n\n    besselj(x,n-2) = (2/x) (n-1) besselj(x,n-1) - besselj(x,n)\n\n  Substitute n+2 for n to obtain\n\n    besselj(x,n) = (2/x) (n+1) besselj(x,n+1) - besselj(x,n+2)\n\n  Examples:\n\n    besselj(x,3/2) = (1/x) besselj(x,1/2) - besselj(x,-1/2)\n\n    besselj(x,-3/2) = -(1/x) besselj(x,-1/2) - besselj(x,1/2)\n\n  */\n  /* bessely =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  x,n\n\n  General description\n  -------------------\n\n  Bessel function of second kind.\n\n  */\n  /* ceiling =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  x\n\n  General description\n  -------------------\n\n  Returns the smallest integer not less than x.\n\n  */\n  /* check =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  p\n\n  General description\n  -------------------\n  Returns whether the predicate p is true/false or unknown:\n  0 if false, 1 if true or remains unevaluated if unknown.\n  Note that if \"check\" is passed an assignment, it turns it into a test,\n  i.e. check(a = b) is turned into check(a==b) \n  so \"a\" is not assigned anything.\n  Like in many programming languages, \"check\" also gives truthyness/falsyness\n  for numeric values. In which case, \"true\" is returned for non-zero values.\n  Potential improvements: \"check\" can't evaluate strings yet.\n\n  */\n  /* choose =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  n,k\n\n  General description\n  -------------------\n\n  Returns the number of combinations of n items taken k at a time.\n\n  For example, the number of five card hands is choose(52,5)\n\n  ```\n                            n!\n        choose(n,k) = -------------\n                       k! (n - k)!\n  ```\n  */\n  /* circexp =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  x\n\n  General description\n  -------------------\n\n  Returns expression x with circular and hyperbolic functions converted to exponential forms. Sometimes this will simplify an expression.\n\n  */\n  /* clear =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  x\n\n  General description\n  -------------------\n\n  Completely wipes a variable from the environment (while doing x = quote(x) just unassigns it).\n\n  */\n  /* clearall =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  General description\n  -------------------\n\n  Completely wipes all variables from the environment.\n\n  */\n  /* cofactor =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  m,i,j\n\n  General description\n  -------------------\n  Cofactor of a matrix component.\n  Let c be the cofactor matrix of matrix m, i.e. tranpose(c) = adj(m).\n  This function returns c[i,j].\n\n  */\n  /* conj =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  z\n\n  General description\n  -------------------\n  Returns the complex conjugate of z.\n\n  */\n  /* contract =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  a,i,j\n\n  General description\n  -------------------\n  Contract across tensor indices i.e. returns \"a\" summed over indices i and j.\n  If i and j are omitted then 1 and 2 are used.\n  contract(m) is equivalent to the trace of matrix m.\n\n  */\n  /* cosh =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  x\n\n  General description\n  -------------------\n  Returns the hyperbolic cosine of x\n\n  ```\n              exp(x) + exp(-x)\n    cosh(x) = ----------------\n                     2\n  ```\n\n  */\n  /* deg =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  p,x\n\n  General description\n  -------------------\n  Returns the degree of polynomial p(x).\n\n  */\n  /* denominator =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  x\n\n  General description\n  -------------------\n  Returns the denominator of expression x.\n\n  */\n  /* dim =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  m,n\n\n  General description\n  -------------------\n  Returns the cardinality of the nth index of tensor \"m\".\n\n  */\n  /* do =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  a,b,...\n\n  General description\n  -------------------\n  Evaluates each argument from left to right. Returns the result of the last argument.\n\n  */\n  /* eigenval =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  m\n\n  General description\n  -------------------\n  Compute eigenvalues of m. See \"eigen\" for more info.\n\n  */\n  /* eigenvec =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  m\n\n  General description\n  -------------------\n  Compute eigenvectors of m. See \"eigen\" for more info.\n\n  */\n  /* erf =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Authors\n  -------\n  philippe.billet@noos.fr\n\n  Parameters\n  ----------\n  x\n\n  General description\n  -------------------\n  Error function erf(x).\n  erf(-x)=erf(x)\n\n  */\n  /*\n  Remove terms that involve a given symbol or expression. For example...\n\n    filter(x^2 + x + 1, x)    =>  1\n\n    filter(x^2 + x + 1, x^2)  =>  x + 1\n  */\n  /* dot =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  a,b,...\n\n  General description\n  -------------------\n\n  The inner (or dot) operator gives products of vectors,\n  matrices, and tensors.\n\n  Note that for Algebrite, the elements of a vector/matrix\n  can only be scalars. This allows for example to flesh out\n  matrix multiplication using the usual multiplication.\n  So for example block-representations are not allowed.\n\n  There is an aweful lot of confusion between sw packages on\n  what dot and inner do.\n\n  First off, the \"dot\" operator is different from the\n  mathematical notion of dot product, which can be\n  slightly confusing.\n\n  The mathematical notion of dot product is here:\n    http://mathworld.wolfram.com/DotProduct.html\n\n  However, \"dot\" does that and a bunch of other things,\n  i.e. in Algebrite\n  dot/inner does what the dot of Mathematica does, i.e.:\n\n  scalar product of vectors:\n\n    inner((a, b, c), (x, y, z))\n    > a x + b y + c z\n\n  products of matrices and vectors:\n\n    inner(((a, b), (c,d)), (x, y))\n    > (a x + b y,c x + d y)\n\n    inner((x, y), ((a, b), (c,d)))\n    > (a x + c y,b x + d y)\n\n    inner((x, y), ((a, b), (c,d)), (r, s))\n    > a r x + b s x + c r y + d s y\n\n  matrix product:\n\n    inner(((a,b),(c,d)),((r,s),(t,u)))\n    > ((a r + b t,a s + b u),(c r + d t,c s + d u))\n\n  the \"dot/inner\" operator is associative and\n  distributive but not commutative.\n\n  In Mathematica, Inner is a generalisation of Dot where\n  the user can specify the multiplication and the addition\n  operators.\n  But here in Algebrite they do the same thing.\n\n   https://reference.wolfram.com/language/ref/Dot.html\n   https://reference.wolfram.com/language/ref/Inner.html\n\n   http://uk.mathworks.com/help/matlab/ref/dot.html\n   http://uk.mathworks.com/help/matlab/ref/mtimes.html\n\n  */\n  /*\n   Laguerre function\n\n  Example\n\n    laguerre(x,3)\n\n  Result\n\n       1   3    3   2\n    - --- x  + --- x  - 3 x + 1\n       6        2\n\n  The computation uses the following recurrence relation.\n\n    L(x,0,k) = 1\n\n    L(x,1,k) = -x + k + 1\n\n    n*L(x,n,k) = (2*(n-1)+1-x+k)*L(x,n-1,k) - (n-1+k)*L(x,n-2,k)\n\n  In the \"for\" loop i = n-1 so the recurrence relation becomes\n\n    (i+1)*L(x,n,k) = (2*i+1-x+k)*L(x,n-1,k) - (i+k)*L(x,n-2,k)\n  */\n  /*\n   Return the leading coefficient of a polynomial.\n\n  Example\n\n    leading(5x^2+x+1,x)\n\n  Result\n\n    5\n\n  The result is undefined if P is not a polynomial.\n  */\n  /*\n   Legendre function\n\n  Example\n\n    legendre(x,3,0)\n\n  Result\n\n     5   3    3\n    --- x  - --- x\n     2        2\n\n  The computation uses the following recurrence relation.\n\n    P(x,0) = 1\n\n    P(x,1) = x\n\n    n*P(x,n) = (2*(n-1)+1)*x*P(x,n-1) - (n-1)*P(x,n-2)\n\n  In the \"for\" loop we have i = n-1 so the recurrence relation becomes\n\n    (i+1)*P(x,n) = (2*i+1)*x*P(x,n-1) - i*P(x,n-2)\n\n  For m > 0\n\n    P(x,n,m) = (-1)^m * (1-x^2)^(m/2) * d^m/dx^m P(x,n)\n  */\n  /*\n  Convert complex z to polar form\n\n    Input:    push  z\n\n    Output:    Result on stack\n\n    polar(z) = abs(z) * exp(i * arg(z))\n  */\n  /*\n   Returns the real part of complex z\n\n    z    real(z)\n    -    -------\n\n    a + i b    a\n\n    exp(i a)  cos(a)\n  */\n  /*\n  Taylor expansion of a function\n\n    push(F)\n    push(X)\n    push(N)\n    push(A)\n    taylor()\n  */\n  /*\n  // up to 100 blocks of 100,000 atoms\n\n  #define M 100\n  #define N 100000\n\n  U *mem[M]\n  int mcount\n\n  U *free_list\n  int free_count\n\n  U *\n  alloc(void)\n  {\n    U *p\n    if (free_count == 0) {\n      if (mcount == 0)\n        alloc_mem()\n      else {\n        gc()\n        if (free_count < N * mcount / 2)\n          alloc_mem()\n      }\n      if (free_count == 0)\n        stop(\"atom space exhausted\")\n    }\n    p = free_list\n    free_list = free_list->u.cons.cdr\n    free_count--\n    return p\n  }\n   */\n  /*\n   Compare adjacent terms in s[] and combine if possible.\n\n    Returns the number of terms remaining in s[].\n\n    n  number of terms in s[] initially\n  */\n  /* cross =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept, script_defined\n\n  Parameters\n  ----------\n  u,v\n\n  General description\n  -------------------\n  Returns the cross product of vectors u and v.\n\n  */\n  /* curl =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept, script_defined\n\n  Parameters\n  ----------\n  u\n\n  General description\n  -------------------\n  Returns the curl of vector u.\n\n  */\n  /*\n    Clear all patterns\n  */\n  /*\n  if 0\n\n   * left brace\n\n    for (i = 0; i < h; i++) {\n      if (yindex == YMAX)\n        break\n      chartab[yindex].c = '|'\n      chartab[yindex].x = x - 2\n      chartab[yindex].y = y + i\n      yindex++\n    }\n\n   * right brace\n\n    emit_x++\n\n    for (i = 0; i < h; i++) {\n      if (yindex == YMAX)\n        break\n      chartab[yindex].c = '|'\n      chartab[yindex].x = emit_x\n      chartab[yindex].y = y + i\n      yindex++\n    }\n\n    emit_x++\n\n  endif\n   */\n  /*\n   For example...\n\n    push(F)\n    push(X)\n    filter()\n    F = pop()\n  */\n  /*\n   Symbolic addition\n\n    Terms in a sum are combined if they are identical modulo rational\n    coefficients.\n\n    For example, A + 2A becomes 3A.\n\n    However, the sum A + sqrt(2) A is not modified.\n\n    Combining terms can lead to second-order effects.\n\n    For example, consider the case of\n\n      1/sqrt(2) A + 3/sqrt(2) A + sqrt(2) A\n\n    The first two terms are combined to yield 2 sqrt(2) A.\n\n    This result can now be combined with the third term to yield\n\n      3 sqrt(2) A\n  */\n  /*\n   Table of integrals\n\n  The symbol f is just a dummy symbol for creating a list f(A,B,C,C,...) where\n\n    A  is the template expression\n\n    B  is the result expression\n\n    C  is an optional list of conditional expressions\n  */\n  /*\n   Partition a term\n\n    Input stack:\n\n      term (factor or product of factors)\n\n      free variable\n\n    Output stack:\n\n      constant expression\n\n      variable expression\n  */\n  /*\n    Substitute new expr for old expr in expr.\n\n    Input:  push  expr\n\n      push  old expr\n\n      push  new expr\n\n    Output:  Result on stack\n  */\n  var $, ABS, ADD, ADJ, AND, APPROXRATIO, ARCCOS, ARCCOSH, ARCSIN, ARCSINH, ARCTAN, ARCTANH, ARG, ASSUME_REAL_VARIABLES, ATOMIZE, AUTOEXPAND, BAKE, BESSELJ, BESSELY, BINDING, BINOMIAL, BINOM_check_args, BUF, C1, C2, C3, C4, C5, C6, CEILING, CHECK, CHOOSE, CIRCEXP, CLEAR, CLEARALL, CLEARPATTERNS, CLOCK, COEFF, COFACTOR, CONDENSE, CONJ, CONS, CONTRACT, COS, COSH, Condense, DEBUG, DEBUG_ABS, DEBUG_ARG, DEBUG_CLOCKFORM, DEBUG_IMAG, DEBUG_IS, DEBUG_MULTIPLY, DEBUG_POWER, DEBUG_RATIONALIZE, DEBUG_RECT, DEBUG_SIMPLIFY, DECOMP, DEFINT, DEGREE, DENOMINATOR, DERIVATIVE, DET, DET_check_arg, DIM, DIRAC, DIVISORS, DO, DOT, DOUBLE, DRAW, DRAWX, DSOLVE, E, EIGEN, EIGENVAL, EIGENVEC, EIG_N, EIG_check_arg, EIG_yydd, EIG_yyqq, ERF, ERFC, EVAL, EXP, EXPAND, EXPCOS, EXPSIN, Eval, Eval_Eval, Eval_abs, Eval_add, Eval_adj, Eval_and, Eval_approxratio, Eval_arccos, Eval_arccosh, Eval_arcsin, Eval_arcsinh, Eval_arctan, Eval_arctanh, Eval_arg, Eval_besselj, Eval_bessely, Eval_binding, Eval_binomial, Eval_ceiling, Eval_check, Eval_choose, Eval_circexp, Eval_clear, Eval_clearall, Eval_clearpatterns, Eval_clock, Eval_coeff, Eval_cofactor, Eval_condense, Eval_conj, Eval_cons, Eval_contract, Eval_cos, Eval_cosh, Eval_decomp, Eval_defint, Eval_degree, Eval_denominator, Eval_derivative, Eval_det, Eval_dim, Eval_dirac, Eval_divisors, Eval_do, Eval_dsolve, Eval_eigen, Eval_eigenval, Eval_eigenvec, Eval_erf, Eval_erfc, Eval_exp, Eval_expand, Eval_expcos, Eval_expsin, Eval_factor, Eval_factorial, Eval_factorpoly, Eval_filter, Eval_float, Eval_floor, Eval_for, Eval_function_reference, Eval_gamma, Eval_gcd, Eval_hermite, Eval_hilbert, Eval_imag, Eval_index, Eval_inner, Eval_integral, Eval_inv, Eval_invg, Eval_isinteger, Eval_isprime, Eval_laguerre, Eval_lcm, Eval_leading, Eval_legendre, Eval_log, Eval_lookup, Eval_mod, Eval_multiply, Eval_noexpand, Eval_not, Eval_nroots, Eval_number, Eval_numerator, Eval_operator, Eval_or, Eval_outer, Eval_pattern, Eval_patternsinfo, Eval_polar, Eval_power, Eval_predicate, Eval_prime, Eval_print, Eval_print2dascii, Eval_printcomputer, Eval_printhuman, Eval_printlatex, Eval_printlist, Eval_product, Eval_quote, Eval_quotient, Eval_rank, Eval_rationalize, Eval_real, Eval_rect, Eval_roots, Eval_round, Eval_setq, Eval_sgn, Eval_shape, Eval_silentpattern, Eval_simfac, Eval_simplify, Eval_sin, Eval_sinh, Eval_sqrt, Eval_stop, Eval_subst, Eval_sum, Eval_sym, Eval_symbolsinfo, Eval_tan, Eval_tanh, Eval_taylor, Eval_tensor, Eval_test, Eval_testeq, Eval_testge, Eval_testgt, Eval_testle, Eval_testlt, Eval_transpose, Eval_unit, Eval_user_function, Eval_zero, Evalpoly, FACTOR, FACTORIAL, FACTORPOLY, FILTER, FLOATF, FLOOR, FOR, FORCE_FIXED_PRINTOUT, FUNCTION, Find, GAMMA, GCD, HERMITE, HILBERT, IMAG, INDEX, INNER, INTEGRAL, INV, INVG, INV_check_arg, INV_decomp, ISINTEGER, ISPRIME, LAGUERRE, LAST, LAST_2DASCII_PRINT, LAST_FULL_PRINT, LAST_LATEX_PRINT, LAST_LIST_PRINT, LAST_PLAIN_PRINT, LAST_PRINT, LCM, LEADING, LEGENDRE, LOG, LOOKUP, M, MAXDIM, MAXPRIMETAB, MAX_CONSECUTIVE_APPLICATIONS_OF_ALL_RULES, MAX_CONSECUTIVE_APPLICATIONS_OF_SINGLE_RULE, MAX_FIXED_PRINTOUT_DIGITS, MAX_PROGRAM_SIZE, MEQUAL, METAA, METAB, METAX, MLENGTH, MOD, MSIGN, MULTIPLY, MZERO, N, NIL, NOT, NROOTS, NROOTS_ABS, NROOTS_DELTA, NROOTS_EPSILON, NROOTS_RANDOM, NROOTS_YMAX, NROOTS_divpoly, NSYM, NUM, NUMBER, NUMERATOR, OPERATOR, OR, OUTER, PATTERN, PATTERNSINFO, PI, POLAR, POWER, PRIME, PRINT, PRINT2DASCII, PRINTFULL, PRINTLATEX, PRINTLIST, PRINTMODE_2DASCII, PRINTMODE_COMPUTER, PRINTMODE_HUMAN, PRINTMODE_LATEX, PRINTMODE_LIST, PRINTOUTRESULT, PRINTPLAIN, PRINT_LEAVE_E_ALONE, PRINT_LEAVE_X_ALONE, PRODUCT, QUOTE, QUOTIENT, RANK, RATIONALIZE, REAL, ROOTS, ROUND, SECRETX, SELFTEST, SETQ, SGN, SHAPE, SILENTPATTERN, SIMPLIFY, SIN, SINH, SPACE_BETWEEN_COLUMNS, SPACE_BETWEEN_ROWS, SQRT, STOP, STR, SUBST, SUM, SYM, SYMBOLSINFO, SYMBOL_A, SYMBOL_A_UNDERSCORE, SYMBOL_B, SYMBOL_B_UNDERSCORE, SYMBOL_C, SYMBOL_D, SYMBOL_I, SYMBOL_IDENTITY_MATRIX, SYMBOL_J, SYMBOL_N, SYMBOL_R, SYMBOL_S, SYMBOL_T, SYMBOL_X, SYMBOL_X_UNDERSCORE, SYMBOL_Y, SYMBOL_Z, TAN, TANH, TAYLOR, TENSOR, TEST, TESTEQ, TESTGE, TESTGT, TESTLE, TESTLT, TIMING_DEBUGS, TOS, TRACE, TRANSPOSE, T_DOUBLE, T_EQ, T_FUNCTION, T_GTEQ, T_INTEGER, T_LTEQ, T_NEQ, T_NEWLINE, T_QUOTASSIGN, T_STRING, T_SYMBOL, U, UNIT, USR_SYMBOLS, VERSION, YMAX, YYE, YYRECT, ZERO, __emit_char, __emit_str, __factor_add, __factorial, __is_negative, __is_radical_number, __lcm, __legendre, __legendre2, __legendre3, __normalize_radical_factors, __rationalize_tensor, _print, abs, absValFloat, absval, absval_tensor, add, addSymbolLeftOfAssignment, addSymbolRightOfAssignment, add_all, add_factor_to_accumulator, add_numbers, add_terms, addf, adj, alloc_tensor, allocatedId, any_denominators, approxAll, approxLogs, approxLogsOfRationals, approxOneRatioOnly, approxRadicals, approxRadicalsOfRationals, approxRationalsOfLogs, approxRationalsOfPowersOfE, approxRationalsOfPowersOfPI, approxRationalsOfRadicals, approxSineOfRationalMultiplesOfPI, approxSineOfRationals, approxTrigonometric, approx_just_an_integer, approx_logarithmsOfRationals, approx_nothingUseful, approx_radicalOfRatio, approx_ratioOfRadical, approx_rationalOfE, approx_rationalOfPi, approx_rationalsOfLogarithms, approx_sine_of_pi_times_rational, approx_sine_of_rational, approxratioRecursive, arccos, arccosh, arcsin, arcsinh, arctan, arctanh, areunivarpolysfactoredorexpandedform, arg, arglist, assignmentFound, avoidCalculatingPowersIntoArctans, bake, bake_poly, bake_poly_term, besselj, bessely, bigInt, bignum_factorial, bignum_float, bignum_power_number, bignum_scan_float, bignum_scan_integer, bignum_truncate, binding, binomial, buffer, build_tensor, caaddr, caadr, caar, cadaddr, cadadr, cadar, caddaddr, caddadr, caddar, caddddr, cadddr, caddr, cadr, called_from_Algebra_block, car, cdaddr, cdadr, cdar, cddaddr, cddar, cdddaddr, cddddr, cdddr, cddr, cdr, ceiling, chainOfUserSymbolsNotFunctionsBeingEvaluated, charTabIndex, chartab, checkFloatHasWorkedOutCompletely, check_esc_flag, check_stack, check_tensor_dimensions, choose, choose_check_args, circexp, clearAlgebraEnvironment, clearRenamedVariablesToAvoidBindingToExternalScope, clear_symbols, clear_term, clearall, clockform, cmpGlyphs, cmp_args, cmp_expr, cmp_terms, cmp_terms_count, codeGen, coeff, cofactor, collectLatexStringFromReturnValue, collectUserSymbols, combine_factors, combine_gammas, combine_terms, compareState, compare_numbers, compare_rationals, compare_tensors, compatible, computeDependenciesFromAlgebra, computeResultsAndJavaScriptFromAlgebra, compute_fa, conjugate, cons, consCount, contract, convert_bignum_to_double, convert_rational_to_double, copy_tensor, cosine, cosine_of_angle, cosine_of_angle_sum, count, countOccurrencesOfSymbol, count_denominators, counter, countsize, d_scalar_scalar, d_scalar_scalar_1, d_scalar_tensor, d_tensor_scalar, d_tensor_tensor, dabs, darccos, darccosh, darcsin, darcsinh, darctan, darctanh, dbesselj0, dbesseljn, dbessely0, dbesselyn, dcos, dcosh, dd, decomp, decomp_product, decomp_sum, defineSomeHandyConstants, define_user_function, defn, defn_str, degree, denominator, derf, derfc, derivative, derivative_of_integral, det, determinant, detg, dfunction, dhermite, dirac, display, display_flag, displaychar, divide, divide_numbers, divisors, divisors_onstack, divpoly, dlog, do_clearPatterns, do_clearall, do_simplify_nested_radicals, dontCreateNewRadicalsInDenominatorWhenEvalingMultiplication, dotprod_unicode, doubleToReasonableString, dpow, dpower, dproduct, draw_flag, draw_stop_return, dsgn, dsin, dsinh, dsum, dtan, dtanh, dupl, eigen, elelmIndex, elem, emit_denominator, emit_denominators, emit_expr, emit_factor, emit_factorial_function, emit_flat_tensor, emit_fraction, emit_function, emit_index_function, emit_multiply, emit_number, emit_numerators, emit_numerical_fraction, emit_power, emit_string, emit_subexpr, emit_symbol, emit_tensor, emit_tensor_inner, emit_term, emit_top_expr, emit_unsigned_expr, emit_x, equal, equaln, equalq, erfc, errorMessage, esc_flag, evaluatingAsFloats, evaluatingPolar, exec, expand, expand_get_A, expand_get_AF, expand_get_B, expand_get_C, expand_get_CF, expand_tensor, expanding, expcos, exponential, expr_level, expsin, f1, f10, f2, f3, f4, f5, f9, f_equals_a, factor, factor_a, factor_again, factor_b, factor_number, factor_small_number, factor_term, factorial, factorpoly, factors, fill_buf, filter, filter_main, filter_sum, filter_tensor, findDependenciesInScript, findPossibleClockForm, findPossibleExponentialForm, findroot, fixup_fraction, fixup_power, flag, floatToRatioRoutine, fmt_index, fmt_level, fmt_x, frame, freeze, functionInvokationsScanningStack, gamma, gamma_of_sum, gammaf, gcd, gcd_main, gcd_numbers, gcd_polys, gcd_powers_with_same_base, gcd_product_product, gcd_product_sum, gcd_sum, gcd_sum_product, gcd_sum_sum, gen, getSimpleRoots, getStateHash, get_binding, get_factor_from_complex_root, get_factor_from_real_root, get_innerprod_factors, get_next_token, get_printname, get_size, get_token, getdisplaystr, glyph, gp, guess, hasImaginaryCoeff, hasNegativeRationalExponent, hash_addition, hash_function, hash_multiplication, hash_power, hashcode_values, hashed_itab, hermite, hilbert, i1, imag, imaginaryunit, index_function, init, initNRoots, inited, inner, inner_f, input_str, integral, integral_of_form, integral_of_product, integral_of_sum, inv, inverse, invert_number, invg, isNumberOneOverSomething, isNumericAtom, isNumericAtomOrTensor, isSimpleRoot, isSmall, isSymbolLeftOfAssignment, isSymbolReclaimable, isZeroAtom, isZeroAtomOrTensor, isZeroLikeOrNonZeroLikeOrUndetermined, isZeroTensor, is_denominator, is_factor, is_small_integer, is_square_matrix, is_usr_symbol, isadd, isalnumorunderscore, isalpha, isalphaOrUnderscore, iscomplexnumber, iscomplexnumberdouble, iscons, isdenominator, isdigit, isdouble, iseveninteger, isfactor, isfactorial, isfloating, isfraction, isidentitymatrix, isimaginarynumber, isimaginarynumberdouble, isimaginaryunit, isinnerordot, isinteger, isintegerfactor, isintegerorintegerfloat, isinv, iskeyword, isminusone, isminusoneoversqrttwo, isminusoneovertwo, isminussqrtthreeovertwo, ismultiply, isnegative, isnegativenumber, isnegativeterm, isnonnegativeinteger, isnpi, isone, isoneover, isoneoversqrttwo, isoneovertwo, isplusone, isplustwo, ispolyexpandedform, ispolyexpandedform_expr, ispolyexpandedform_factor, ispolyexpandedform_term, ispolyfactoredorexpandedform, ispolyfactoredorexpandedform_factor, ispolyfactoredorexpandedform_power, isposint, ispositivenumber, ispower, isquarterturn, isrational, isspace, issqrtthree, issqrtthreeovertwo, isstr, issymbol, issymbolic, istensor, istranspose, isunderscore, isunivarpolyfactoredorexpandedform, itab, italu_hashcode, j1, laguerre, laguerre2, lastFoundSymbol, latexErrorSign, lcm, leading, legendre, length, lessp, level, list, listLength, logarithm, logbuf, lookupsTotal, lu_decomp, madd, makePositive, makeSignSameAs, make_hashed_itab, mask, mcmp, mcmpint, mdiv, mdivrem, meta_mode, mgcd, mini_solve, mint, mmod, mmul, mod, monic, move, moveTos, mp_clr_bit, mp_denominator, mp_numerator, mp_set_bit, mpow, mprime, mroot, mshiftright, msub, mtotal, multinomial_sum, multiply, multiply_all, multiply_all_noexpand, multiply_consecutive_constants, multiply_denominators, multiply_denominators_factor, multiply_denominators_term, multiply_noexpand, multiply_numbers, n_factor_number, negate, negate_expand, negate_noexpand, negate_number, new_integer, new_string, newline_flag, nil_symbols, normaliseDots, normalisedCoeff, normalize_angle, nroots_a, nroots_b, nroots_c, nroots_df, nroots_dx, nroots_fa, nroots_fb, nroots_x, nroots_y, nterms, nthCadr, numerator, numericRootOfPolynomial, o, one, oneElement, one_as_double, out_buf, out_count, out_of_memory, outer, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, parse, parse_internal, parse_p1, parse_p2, parse_time_simplifications, partition, patternHasBeenFound, patternsinfo, performing_roots, polar, polarRectAMinusOneBase, polyform, pop, pop_double, pop_frame, pop_integer, power, power_str, power_sum, power_tensor, predefinedSymbolsInGlobalScope_doNotTrackInDependencies, prime, primetab, print2dascii, printMode, print_ABS_latex, print_ARCCOS_codegen, print_ARCSIN_codegen, print_ARCTAN_codegen, print_BINOMIAL_latex, print_COS_codegen, print_DEFINT_latex, print_DOT_codegen, print_DOT_latex, print_DO_codegen, print_FOR_codegen, print_INV_codegen, print_INV_latex, print_PRODUCT_codegen, print_PRODUCT_latex, print_SETQ_codegen, print_SIN_codegen, print_SQRT_latex, print_SUM_codegen, print_SUM_latex, print_TAN_codegen, print_TESTEQ_latex, print_TESTGE_latex, print_TESTGT_latex, print_TESTLE_latex, print_TESTLT_latex, print_TEST_codegen, print_TEST_latex, print_TRANSPOSE_codegen, print_TRANSPOSE_latex, print_UNIT_codegen, print_a_over_b, print_base, print_base_of_denom, print_char, print_denom, print_double, print_expo_of_denom, print_exponent, print_expr, print_factor, print_factorial_function, print_glyphs, print_index_function, print_list, print_multiply_sign, print_number, print_power, print_str, print_subexpr, print_tensor, print_tensor_inner, print_tensor_inner_latex, print_tensor_latex, print_term, printchar, printchar_nowrap, printline, program_buf, promote_tensor, push, pushTryNotToDuplicate, push_cars, push_double, push_factor, push_frame, push_identity_matrix, push_integer, push_rational, push_symbol, push_term_factors, push_terms, push_zero_matrix, qadd, qdiv, qmul, qpow, qpowf, quickfactor, quickpower, rational, rationalize, rationalize_coefficients, real, reciprocate, rect, recursionLevelNestedRadicalsRemoval, recursiveDependencies, ref, ref1, rememberPrint, remove_negative_exponents, reset_after_error, restore, restoreMetaBindings, rewrite_args, rewrite_args_tensor, roots, roots2, roots3, run, runUserDefinedSimplifications, save, saveMetaBindings, scalar_times_tensor, scan, scan_error, scan_expression, scan_factor, scan_function_call_with_function_name, scan_function_call_without_function_name, scan_index, scan_meta, scan_power, scan_relation, scan_stmt, scan_str, scan_string, scan_subexpr, scan_symbol, scan_tensor, scan_term, scanned, scanningParameters, setM, setSignTo, set_binding, set_component, setq_indexed, sfac_product, sfac_product_f, sgn, shape, show_power_debug, sign, sign_of_term, simfac, simfac_term, simpleComplexityMeasure, simplify, simplifyForCodeGeneration, simplify_1_in_products, simplify_main, simplify_nested_radicals, simplify_polar, simplify_polarRect, simplify_rational_expressions, simplify_rectToClock, simplify_tensor, simplify_trig, simplifyfactorials, sine, sine_of_angle, sine_of_angle_sum, skipRootVariableToBeSolved, sort_stack, square, ssqrt, stack, stackAddsCount, std_symbol, step, step2, stop, strcmp, stringsEmittedByUserPrintouts, subf, subst, subtract, subtract_numbers, swap, symbol, symbolsDependencies, symbolsHavingReassignments, symbolsInExpressionsWithoutAssignments, symbolsLeftOfAssignment, symbolsRightOfAssignment, symbolsinfo, symnum, symtab, take_care_of_nested_radicals, tangent, taylor, tensor, tensor_plus_tensor, tensor_times_scalar, testApprox, test_flag, text_metric, theRandom, token, token_buf, token_str, top, top_level_eval, tos, transform, transpose, transpose_unicode, trigmode, trivial_divide, try_kth_prime, turnErrorMessageToLatex, ucmp, unfreeze, unique, unique_f, update_token_buf, userSimplificationsInListForm, userSimplificationsInStringForm, usr_symbol, verbosing, version, will_be_displayed_as_fraction, ybinomial, ycosh, ydirac, yerf, yerfc, yfloor, yindex, yround, ysinh, yyarg, yybesselj, yybessely, yyceiling, yycondense, yycontract, yycosh, yydegree, yydetg, yydivpoly, yyerf, yyerfc, yyexpand, yyfactorpoly, yyfloat, yyfloor, yyhermite, yyhermite2, yyinvg, yylcm, yylog, yymultiply, yyouter, yypower, yyrationalize, yyround, yysgn, yysimfac, yysinh, yytangent, zero, zzfloat,\n    hasProp = {}.hasOwnProperty;\n\n  bigInt = require('big-integer');\n\n  // also change the version in the package.json file\n  version = \"1.4.0\";\n\n  SELFTEST = 1;\n\n  // size of the symbol table\n  NSYM = 1000;\n\n  DEBUG = false;\n\n  PRINTOUTRESULT = false;\n\n  // printing-related constants\n  PRINTMODE_LATEX = \"PRINTMODE_LATEX\";\n\n  PRINTMODE_2DASCII = \"PRINTMODE_2DASCII\";\n\n  PRINTMODE_COMPUTER = \"PRINTMODE_COMPUTER\";\n\n  PRINTMODE_HUMAN = \"PRINTMODE_HUMAN\";\n\n  PRINTMODE_LIST = \"PRINTMODE_LIST\";\n\n  // when the user uses the generic \"print\" statement\n  // this setting kicks-in.\n  printMode = PRINTMODE_COMPUTER;\n\n  dontCreateNewRadicalsInDenominatorWhenEvalingMultiplication = true;\n\n  recursionLevelNestedRadicalsRemoval = 0;\n\n  do_simplify_nested_radicals = true;\n\n  avoidCalculatingPowersIntoArctans = true;\n\n  rational = (function() {\n    // Symbolic expressions are built by connecting U structs.\n\n    // For example, (a b + c) is built like this:\n\n    //           _______      _______                                _______\n    //          |CONS   |--->|CONS   |----------------------------->|CONS   |\n    //          |       |    |       |                              |       |\n    //          |_______|    |_______|                              |_______|\n    //              |            |                                      |\n    //           ___v___      ___v___      _______      _______      ___v___\n    //          |ADD    |    |CONS   |--->|CONS   |--->|CONS   |    |SYM c  |\n    //          |       |    |       |    |       |    |       |    |       |\n    //          |_______|    |_______|    |_______|    |_______|    |_______|\n    //                           |            |            |\n    //                        ___v___      ___v___      ___v___\n    //                       |MUL    |    |SYM a  |    |SYM b  |\n    //                       |       |    |       |    |       |\n    //                       |_______|    |_______|    |_______|\n    class rational {};\n\n    rational.prototype.a = null; // a bigInteger\n\n    rational.prototype.b = null; // a bigInteger\n\n    return rational;\n\n  }).call(this);\n\n  U = (function() {\n    class U {\n      toString() {\n        return print_expr(this);\n      }\n\n      toLatexString() {\n        return collectLatexStringFromReturnValue(this);\n      }\n\n      constructor() {\n        this.cons = {};\n        this.cons.car = null;\n        this.cons.cdr = null;\n        this.q = new rational();\n      }\n\n    };\n\n    U.prototype.cons = null; // will have a car and cdr\n\n    U.prototype.printname = \"\";\n\n    U.prototype.str = \"\";\n\n    U.prototype.tensor = null;\n\n    // rational number a over b\n    U.prototype.q = null; // will point to a rational\n\n    U.prototype.d = 0.0; // a double\n\n    U.prototype.k = 0;\n\n    U.prototype.tag = 0;\n\n    return U;\n\n  }).call(this);\n\n  errorMessage = \"\";\n\n  // the following enum is for struct U, member k\n  CONS = 0;\n\n  NUM = 1;\n\n  DOUBLE = 2;\n\n  STR = 3;\n\n  TENSOR = 4;\n\n  SYM = 5;\n\n  // the following enum is for indexing the symbol table\n\n  // standard functions first, then nil, then everything else\n  counter = 0;\n\n  ABS = counter++;\n\n  ADD = counter++;\n\n  ADJ = counter++;\n\n  AND = counter++;\n\n  APPROXRATIO = counter++;\n\n  ARCCOS = counter++;\n\n  ARCCOSH = counter++;\n\n  ARCSIN = counter++;\n\n  ARCSINH = counter++;\n\n  ARCTAN = counter++;\n\n  ARCTANH = counter++;\n\n  ARG = counter++;\n\n  ATOMIZE = counter++;\n\n  BESSELJ = counter++;\n\n  BESSELY = counter++;\n\n  BINDING = counter++;\n\n  BINOMIAL = counter++;\n\n  CEILING = counter++;\n\n  CHECK = counter++;\n\n  CHOOSE = counter++;\n\n  CIRCEXP = counter++;\n\n  CLEAR = counter++;\n\n  CLEARALL = counter++;\n\n  CLEARPATTERNS = counter++;\n\n  CLOCK = counter++;\n\n  COEFF = counter++;\n\n  COFACTOR = counter++;\n\n  CONDENSE = counter++;\n\n  CONJ = counter++;\n\n  CONTRACT = counter++;\n\n  COS = counter++;\n\n  COSH = counter++;\n\n  DECOMP = counter++;\n\n  DEFINT = counter++;\n\n  DEGREE = counter++;\n\n  DENOMINATOR = counter++;\n\n  DERIVATIVE = counter++;\n\n  DET = counter++;\n\n  DIM = counter++;\n\n  DIRAC = counter++;\n\n  DIVISORS = counter++;\n\n  DO = counter++;\n\n  DOT = counter++;\n\n  DRAW = counter++;\n\n  DSOLVE = counter++;\n\n  EIGEN = counter++;\n\n  EIGENVAL = counter++;\n\n  EIGENVEC = counter++;\n\n  ERF = counter++;\n\n  ERFC = counter++;\n\n  EVAL = counter++;\n\n  EXP = counter++;\n\n  EXPAND = counter++;\n\n  EXPCOS = counter++;\n\n  EXPSIN = counter++;\n\n  FACTOR = counter++;\n\n  FACTORIAL = counter++;\n\n  FACTORPOLY = counter++;\n\n  FILTER = counter++;\n\n  FLOATF = counter++;\n\n  FLOOR = counter++;\n\n  FOR = counter++;\n\n  FUNCTION = counter++;\n\n  GAMMA = counter++;\n\n  GCD = counter++;\n\n  HERMITE = counter++;\n\n  HILBERT = counter++;\n\n  IMAG = counter++;\n\n  INDEX = counter++;\n\n  INNER = counter++;\n\n  INTEGRAL = counter++;\n\n  INV = counter++;\n\n  INVG = counter++;\n\n  ISINTEGER = counter++;\n\n  ISPRIME = counter++;\n\n  LAGUERRE = counter++;\n\n  //  LAPLACE = counter++\n  LCM = counter++;\n\n  LEADING = counter++;\n\n  LEGENDRE = counter++;\n\n  LOG = counter++;\n\n  LOOKUP = counter++;\n\n  MOD = counter++;\n\n  MULTIPLY = counter++;\n\n  NOT = counter++;\n\n  NROOTS = counter++;\n\n  NUMBER = counter++;\n\n  NUMERATOR = counter++;\n\n  OPERATOR = counter++;\n\n  OR = counter++;\n\n  OUTER = counter++;\n\n  PATTERN = counter++;\n\n  PATTERNSINFO = counter++;\n\n  POLAR = counter++;\n\n  POWER = counter++;\n\n  PRIME = counter++;\n\n  PRINT_LEAVE_E_ALONE = counter++;\n\n  PRINT_LEAVE_X_ALONE = counter++;\n\n  PRINT = counter++;\n\n  PRINT2DASCII = counter++;\n\n  PRINTFULL = counter++;\n\n  PRINTLATEX = counter++;\n\n  PRINTLIST = counter++;\n\n  PRINTPLAIN = counter++;\n\n  PRODUCT = counter++;\n\n  QUOTE = counter++;\n\n  QUOTIENT = counter++;\n\n  RANK = counter++;\n\n  RATIONALIZE = counter++;\n\n  REAL = counter++;\n\n  ROUND = counter++;\n\n  YYRECT = counter++;\n\n  ROOTS = counter++;\n\n  SETQ = counter++;\n\n  SGN = counter++;\n\n  SILENTPATTERN = counter++;\n\n  SIMPLIFY = counter++;\n\n  SIN = counter++;\n\n  SINH = counter++;\n\n  SHAPE = counter++;\n\n  SQRT = counter++;\n\n  STOP = counter++;\n\n  SUBST = counter++;\n\n  SUM = counter++;\n\n  SYMBOLSINFO = counter++;\n\n  TAN = counter++;\n\n  TANH = counter++;\n\n  TAYLOR = counter++;\n\n  TEST = counter++;\n\n  TESTEQ = counter++;\n\n  TESTGE = counter++;\n\n  TESTGT = counter++;\n\n  TESTLE = counter++;\n\n  TESTLT = counter++;\n\n  TRANSPOSE = counter++;\n\n  UNIT = counter++;\n\n  ZERO = counter++;\n\n  // ALL THE SYMBOLS ABOVE NIL ARE KEYWORDS,\n  // WHICH MEANS THAT USER CANNOT REDEFINE THEM\n  NIL = counter++; // nil goes here, after standard functions\n\n  LAST = counter++;\n\n  LAST_PRINT = counter++;\n\n  LAST_2DASCII_PRINT = counter++;\n\n  LAST_FULL_PRINT = counter++;\n\n  LAST_LATEX_PRINT = counter++;\n\n  LAST_LIST_PRINT = counter++;\n\n  LAST_PLAIN_PRINT = counter++;\n\n  AUTOEXPAND = counter++;\n\n  BAKE = counter++;\n\n  ASSUME_REAL_VARIABLES = counter++;\n\n  TRACE = counter++;\n\n  FORCE_FIXED_PRINTOUT = counter++;\n\n  MAX_FIXED_PRINTOUT_DIGITS = counter++;\n\n  YYE = counter++;\n\n  DRAWX = counter++; // special purpose internal symbols\n\n  METAA = counter++;\n\n  METAB = counter++;\n\n  METAX = counter++;\n\n  SECRETX = counter++;\n\n  VERSION = counter++;\n\n  PI = counter++;\n\n  SYMBOL_A = counter++;\n\n  SYMBOL_B = counter++;\n\n  SYMBOL_C = counter++;\n\n  SYMBOL_D = counter++;\n\n  SYMBOL_I = counter++;\n\n  SYMBOL_J = counter++;\n\n  SYMBOL_N = counter++;\n\n  SYMBOL_R = counter++;\n\n  SYMBOL_S = counter++;\n\n  SYMBOL_T = counter++;\n\n  SYMBOL_X = counter++;\n\n  SYMBOL_Y = counter++;\n\n  SYMBOL_Z = counter++;\n\n  SYMBOL_IDENTITY_MATRIX = counter++;\n\n  SYMBOL_A_UNDERSCORE = counter++;\n\n  SYMBOL_B_UNDERSCORE = counter++;\n\n  SYMBOL_X_UNDERSCORE = counter++;\n\n  C1 = counter++;\n\n  C2 = counter++;\n\n  C3 = counter++;\n\n  C4 = counter++;\n\n  C5 = counter++;\n\n  C6 = counter++;\n\n  USR_SYMBOLS = counter++; // this must be last\n\n  E = YYE;\n\n  // TOS cannot be arbitrarily large because the OS seg faults on deep recursion.\n  // For example, a circular evaluation like x=x+1 can cause a seg fault.\n  // At this setting (100,000) the evaluation stack overruns before seg fault.\n  TOS = 100000;\n\n  BUF = 10000;\n\n  MAX_PROGRAM_SIZE = 100001;\n\n  MAXPRIMETAB = 10000;\n\n  MAX_CONSECUTIVE_APPLICATIONS_OF_ALL_RULES = 5;\n\n  MAX_CONSECUTIVE_APPLICATIONS_OF_SINGLE_RULE = 10;\n\n  //define _USE_MATH_DEFINES // for MS C++\n  MAXDIM = 24;\n\n  // needed for the mechanism to\n  // find all dependencies between variables\n  // in a script\n  symbolsDependencies = {};\n\n  symbolsHavingReassignments = [];\n\n  symbolsInExpressionsWithoutAssignments = [];\n\n  patternHasBeenFound = false;\n\n  predefinedSymbolsInGlobalScope_doNotTrackInDependencies = [\"rationalize\", \"abs\", \"e\", \"i\", \"pi\", \"sin\", \"ceiling\", \"cos\", \"roots\", \"integral\", \"derivative\", \"defint\", \"sqrt\", \"eig\", \"cov\", \"deig\", \"dcov\", \"float\", \"floor\", \"product\", \"root\", \"round\", \"sum\", \"test\", \"unit\"];\n\n  // you can do some little simplifications\n  // at parse time, such as calculating away\n  // immediately simple operations on\n  // constants, removing 1s from products\n  // etc.\n  parse_time_simplifications = true;\n\n  chainOfUserSymbolsNotFunctionsBeingEvaluated = [];\n\n  stringsEmittedByUserPrintouts = \"\";\n\n  // flag use to potentially switch on/off some quirks \"deep\"\n  // in the code due to call from Algebra block.\n  // Currently not used.\n  called_from_Algebra_block = false;\n\n  tensor = (function() {\n    class tensor {\n      constructor() {\n        this.dim = (function() {\n          var o, ref, results;\n          results = [];\n          for (o = 0, ref = MAXDIM; (0 <= ref ? o <= ref : o >= ref); 0 <= ref ? o++ : o--) {\n            results.push(0);\n          }\n          return results;\n        })();\n        this.elem = [];\n      }\n\n    };\n\n    tensor.prototype.ndim = 0; // number of dimensions\n\n    tensor.prototype.dim = null; // dimension length, for each dimension\n\n    tensor.prototype.nelem = 0; // total number of elements\n\n    tensor.prototype.elem = null; // an array containing all the data\n\n    return tensor;\n\n  }).call(this);\n\n  display = (function() {\n    class display {};\n\n    display.prototype.h = 0;\n\n    display.prototype.w = 0;\n\n    display.prototype.n = 0;\n\n    display.prototype.a = []; // will contain an array of c,x,y (color,x,y)\n\n    return display;\n\n  }).call(this);\n\n  text_metric = (function() {\n    class text_metric {};\n\n    text_metric.prototype.ascent = 0;\n\n    text_metric.prototype.descent = 0;\n\n    text_metric.prototype.width = 0;\n\n    return text_metric;\n\n  }).call(this);\n\n  tos = 0; // top of stack\n\n  expanding = 0;\n\n  evaluatingAsFloats = 0;\n\n  evaluatingPolar = 0;\n\n  fmt_x = 0;\n\n  fmt_index = 0;\n\n  fmt_level = 0;\n\n  verbosing = 0;\n\n  primetab = (function() {\n    var ceil, i, j, primes;\n    primes = [2];\n    i = 3;\n    while (primes.length < MAXPRIMETAB) {\n      j = 0;\n      ceil = Math.sqrt(i);\n      while (j < primes.length && primes[j] <= ceil) {\n        if (i % primes[j] === 0) {\n          j = -1;\n          break;\n        }\n        j++;\n      }\n      if (j !== -1) {\n        primes.push(i);\n      }\n      i += 2;\n    }\n    primes[MAXPRIMETAB] = 0;\n    return primes;\n  })();\n\n  esc_flag = 0;\n\n  draw_flag = 0;\n\n  mtotal = 0;\n\n  trigmode = 0;\n\n  logbuf = \"\";\n\n  program_buf = \"\";\n\n  // will contain the variable names\n  symtab = [];\n\n  // will contain the contents of the variable\n  // in the corresponding position in symtab array\n  binding = [];\n\n  isSymbolReclaimable = [];\n\n  arglist = []; // will contain U\n\n  stack = []; // will contain *U\n\n  frame = 0;\n\n  p0 = null; // will contain U\n\n  p1 = null; // will contain U\n\n  p2 = null; // will contain U\n\n  p3 = null; // will contain U\n\n  p4 = null; // will contain U\n\n  p5 = null; // will contain U\n\n  p6 = null; // will contain U\n\n  p7 = null; // will contain U\n\n  p8 = null; // will contain U\n\n  p9 = null; // will contain U\n\n  zero = null; // will contain U\n\n  one = null; // will contain U\n\n  one_as_double = null;\n\n  imaginaryunit = null; // will contain U\n\n  out_buf = \"\";\n\n  out_count = 0;\n\n  test_flag = 0;\n\n  codeGen = false;\n\n  draw_stop_return = null; // extern jmp_buf ?????\n\n  userSimplificationsInListForm = [];\n\n  userSimplificationsInStringForm = [];\n\n  transpose_unicode = 7488;\n\n  dotprod_unicode = 183;\n\n  symbol = function(x) {\n    return symtab[x];\n  };\n\n  iscons = function(p) {\n    return p.k === CONS;\n  };\n\n  isrational = function(p) {\n    return p.k === NUM;\n  };\n\n  isdouble = function(p) {\n    return p.k === DOUBLE;\n  };\n\n  isNumericAtom = function(p) {\n    return isrational(p) || isdouble(p);\n  };\n\n  isstr = function(p) {\n    return p.k === STR;\n  };\n\n  istensor = function(p) {\n    if (p == null) {\n      debugger;\n    } else {\n      return p.k === TENSOR;\n    }\n  };\n\n  // because of recursion, we consider a scalar to be\n  // a tensor, so a numeric scalar will return true\n  isNumericAtomOrTensor = function(p) {\n    var a, i, n, o, ref;\n    if (isNumericAtom(p) || p === symbol(SYMBOL_IDENTITY_MATRIX)) {\n      return 1;\n    }\n    if (!istensor(p) && !isNumericAtom(p)) {\n      //console.log \"p not an atom nor a tensor: \" + p\n      return 0;\n    }\n    n = p.tensor.nelem;\n    a = p.tensor.elem;\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      if (!isNumericAtomOrTensor(a[i])) {\n        //console.log \"non-numeric element: \" + a[i]\n        return 0;\n      }\n    }\n    return 1;\n  };\n\n  issymbol = function(p) {\n    return p.k === SYM;\n  };\n\n  iskeyword = function(p) {\n    return issymbol(p) && symnum(p) < NIL;\n  };\n\n  car = function(p) {\n    if (iscons(p)) {\n      return p.cons.car;\n    } else {\n      return symbol(NIL);\n    }\n  };\n\n  cdr = function(p) {\n    if (iscons(p)) {\n      return p.cons.cdr;\n    } else {\n      return symbol(NIL);\n    }\n  };\n\n  caar = function(p) {\n    return car(car(p));\n  };\n\n  cadr = function(p) {\n    return car(cdr(p));\n  };\n\n  cdar = function(p) {\n    return cdr(car(p));\n  };\n\n  cddr = function(p) {\n    return cdr(cdr(p));\n  };\n\n  caadr = function(p) {\n    return car(car(cdr(p)));\n  };\n\n  caddr = function(p) {\n    return car(cdr(cdr(p)));\n  };\n\n  cadar = function(p) {\n    return car(cdr(car(p)));\n  };\n\n  cdadr = function(p) {\n    return cdr(car(cdr(p)));\n  };\n\n  cddar = function(p) {\n    return cdr(cdr(car(p)));\n  };\n\n  cdddr = function(p) {\n    return cdr(cdr(cdr(p)));\n  };\n\n  caaddr = function(p) {\n    return car(car(cdr(cdr(p))));\n  };\n\n  cadadr = function(p) {\n    return car(cdr(car(cdr(p))));\n  };\n\n  caddar = function(p) {\n    return car(cdr(cdr(car(p))));\n  };\n\n  cdaddr = function(p) {\n    return cdr(car(cdr(cdr(p))));\n  };\n\n  cadddr = function(p) {\n    return car(cdr(cdr(cdr(p))));\n  };\n\n  cddddr = function(p) {\n    return cdr(cdr(cdr(cdr(p))));\n  };\n\n  caddddr = function(p) {\n    return car(cdr(cdr(cdr(cdr(p)))));\n  };\n\n  cadaddr = function(p) {\n    return car(cdr(car(cdr(cdr(p)))));\n  };\n\n  cddaddr = function(p) {\n    return cdr(cdr(car(cdr(cdr(p)))));\n  };\n\n  caddadr = function(p) {\n    return car(cdr(cdr(car(cdr(p)))));\n  };\n\n  cdddaddr = function(p) {\n    return cdr(cdr(cdr(car(cdr(cdr(p))))));\n  };\n\n  caddaddr = function(p) {\n    return car(cdr(cdr(car(cdr(cdr(p))))));\n  };\n\n  // not used yet\n  listLength = function(p) {\n    var startCount;\n    startCount = -1;\n    while (iscons(p)) {\n      p = cdr(p);\n      startCount++;\n    }\n    return startCount;\n  };\n\n  // not used yet\n  nthCadr = function(p, n) {\n    var startCount;\n    startCount = 0;\n    while (startCount <= n) {\n      p = cdr(p);\n      startCount++;\n    }\n    return car(p);\n  };\n\n  isadd = function(p) {\n    return car(p) === symbol(ADD);\n  };\n\n  ismultiply = function(p) {\n    return car(p) === symbol(MULTIPLY);\n  };\n\n  ispower = function(p) {\n    return car(p) === symbol(POWER);\n  };\n\n  isfactorial = function(p) {\n    return car(p) === symbol(FACTORIAL);\n  };\n\n  isinnerordot = function(p) {\n    return (car(p) === symbol(INNER)) || (car(p) === symbol(DOT));\n  };\n\n  istranspose = function(p) {\n    return car(p) === symbol(TRANSPOSE);\n  };\n\n  isinv = function(p) {\n    return car(p) === symbol(INV);\n  };\n\n  // TODO this is a bit of a shallow check, we should\n  // check when we are passed an actual tensor and possibly\n  // cache the test result.\n  isidentitymatrix = function(p) {\n    return p === symbol(SYMBOL_IDENTITY_MATRIX);\n  };\n\n  MSIGN = function(p) {\n    if (p.isPositive()) {\n      return 1;\n    } else if (p.isZero()) {\n      return 0;\n    } else {\n      return -1;\n    }\n  };\n\n  MLENGTH = function(p) {\n    return p.toString().length;\n  };\n\n  MZERO = function(p) {\n    return p.isZero();\n  };\n\n  MEQUAL = function(p, n) {\n    if (p == null) {\n      debugger;\n    }\n    return p.equals(n);\n  };\n\n  reset_after_error = function() {\n    moveTos(0);\n    esc_flag = 0;\n    draw_flag = 0;\n    frame = TOS;\n    evaluatingAsFloats = 0;\n    return evaluatingPolar = 0;\n  };\n\n  $ = typeof exports !== \"undefined\" && exports !== null ? exports : this;\n\n  $.version = version;\n\n  $.isadd = isadd;\n\n  $.ismultiply = ismultiply;\n\n  $.ispower = ispower;\n\n  $.isfactorial = isfactorial;\n\n  $.car = car;\n\n  $.cdr = cdr;\n\n  $.caar = caar;\n\n  $.cadr = cadr;\n\n  $.cdar = cdar;\n\n  $.cddr = cddr;\n\n  $.caadr = caadr;\n\n  $.caddr = caddr;\n\n  $.cadar = cadar;\n\n  $.cdadr = cdadr;\n\n  $.cddar = cddar;\n\n  $.cdddr = cdddr;\n\n  $.caaddr = caaddr;\n\n  $.cadadr = cadadr;\n\n  $.caddar = caddar;\n\n  $.cdaddr = cdaddr;\n\n  $.cadddr = cadddr;\n\n  $.cddddr = cddddr;\n\n  $.caddddr = caddddr;\n\n  $.cadaddr = cadaddr;\n\n  $.cddaddr = cddaddr;\n\n  $.caddadr = caddadr;\n\n  $.cdddaddr = cdddaddr;\n\n  $.caddaddr = caddaddr;\n\n  $.symbol = symbol;\n\n  $.iscons = iscons;\n\n  $.isrational = isrational;\n\n  $.isdouble = isdouble;\n\n  $.isNumericAtom = isNumericAtom;\n\n  $.isstr = isstr;\n\n  $.istensor = istensor;\n\n  $.issymbol = issymbol;\n\n  $.iskeyword = iskeyword;\n\n  $.CONS = CONS;\n\n  $.NUM = NUM;\n\n  $.DOUBLE = DOUBLE;\n\n  $.STR = STR;\n\n  $.TENSOR = TENSOR;\n\n  $.SYM = SYM;\n\n  \n  //(docs are generated from top-level comments, keep an eye on the formatting!)\n  /* abs =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  x\n\n  General description\n  -------------------\n  Returns the absolute value of a real number, the magnitude of a complex number, or the vector length.\n\n  */\n  /*\n   Absolute value of a number,or magnitude of complex z, or norm of a vector\n\n    z    abs(z)\n    -    ------\n\n    a    a\n\n    -a    a\n\n    (-1)^a    1\n\n    exp(a + i b)  exp(a)\n\n    a b    abs(a) abs(b)\n\n    a + i b    sqrt(a^2 + b^2)\n\n  Notes\n\n    1. Handles mixed polar and rectangular forms, e.g. 1 + exp(i pi/3)\n\n    2. jean-francois.debroux reports that when z=(a+i*b)/(c+i*d) then\n\n      abs(numerator(z)) / abs(denominator(z))\n\n       must be used to get the correct answer. Now the operation is\n       automatic.\n  */\n  DEBUG_ABS = false;\n\n  Eval_abs = function() {\n    push(cadr(p1));\n    Eval();\n    return abs();\n  };\n\n  absValFloat = function() {\n    Eval();\n    absval();\n    Eval();\n    return zzfloat();\n  };\n\n  // zzfloat of an abs doesn't necessarily result in a double\n  // , for example if there are variables. But\n  // in many of the tests there should be indeed\n  // a float, these two lines come handy to highlight\n  // when that doesn't happen for those tests.\n  //if !isdouble(stack[tos-1])\n  //  stop(\"absValFloat should return a double and instead got: \" + stack[tos-1])\n  abs = function() {\n    var theArgument;\n    theArgument = top();\n    if (DEBUG_ABS) {\n      console.trace(\">>>>  ABS of \" + theArgument);\n    }\n    numerator();\n    if (DEBUG_ABS) {\n      console.log(\"ABS numerator \" + stack[tos - 1]);\n    }\n    absval();\n    if (DEBUG_ABS) {\n      console.log(\"ABSVAL numerator: \" + stack[tos - 1]);\n    }\n    push(theArgument);\n    denominator();\n    if (DEBUG_ABS) {\n      console.log(\"ABS denominator: \" + stack[tos - 1]);\n    }\n    absval();\n    if (DEBUG_ABS) {\n      console.log(\"ABSVAL denominator: \" + stack[tos - 1]);\n    }\n    divide();\n    if (DEBUG_ABS) {\n      console.log(\"ABSVAL divided: \" + stack[tos - 1]);\n    }\n    if (DEBUG_ABS) {\n      return console.log(\"<<<<<<<  ABS\");\n    }\n  };\n\n  absval = function() {\n    var anyFactorsYet, input;\n    save();\n    p1 = pop();\n    input = p1;\n    if (DEBUG_ABS) {\n      console.log(\"ABS of \" + p1);\n    }\n    // handle all the \"number\" cases first -----------------------------------------\n    if (isZeroAtomOrTensor(p1)) {\n      if (DEBUG_ABS) {\n        console.log(\" abs: \" + p1 + \" just zero\");\n      }\n      push(zero);\n      if (DEBUG_ABS) {\n        console.log(\" --> ABS of \" + input + \" : \" + stack[tos - 1]);\n      }\n      restore();\n      return;\n    }\n    if (isnegativenumber(p1)) {\n      if (DEBUG_ABS) {\n        console.log(\" abs: \" + p1 + \" just a negative\");\n      }\n      push(p1);\n      negate();\n      restore();\n      return;\n    }\n    if (ispositivenumber(p1)) {\n      if (DEBUG_ABS) {\n        console.log(\" abs: \" + p1 + \" just a positive\");\n      }\n      push(p1);\n      if (DEBUG_ABS) {\n        console.log(\" --> ABS of \" + input + \" : \" + stack[tos - 1]);\n      }\n      restore();\n      return;\n    }\n    if (p1 === symbol(PI)) {\n      if (DEBUG_ABS) {\n        console.log(\" abs: \" + p1 + \" of PI\");\n      }\n      push(p1);\n      if (DEBUG_ABS) {\n        console.log(\" --> ABS of \" + input + \" : \" + stack[tos - 1]);\n      }\n      restore();\n      return;\n    }\n    // ??? should there be a shortcut case here for the imaginary unit?\n\n    // now handle decomposition cases ----------------------------------------------\n\n    // we catch the \"add\", \"power\", \"multiply\" cases first,\n    // before falling back to the\n    // negative/positive cases because there are some\n    // simplification thay we might be able to do.\n    // Note that for this routine to give a correct result, this\n    // must be a sum where a complex number appears.\n    // If we apply this to \"a+b\", we get an incorrect result.\n    if (car(p1) === symbol(ADD) && (findPossibleClockForm(p1) || findPossibleExponentialForm(p1) || Find(p1, imaginaryunit))) {\n      if (DEBUG_ABS) {\n        console.log(\" abs: \" + p1 + \" is a sum\");\n      }\n      if (DEBUG_ABS) {\n        console.log(\"abs of a sum\");\n      }\n      // sum\n      push(p1);\n      rect(); // convert polar terms, if any\n      p1 = pop();\n      push(p1);\n      real();\n      push_integer(2);\n      power();\n      push(p1);\n      imag();\n      push_integer(2);\n      power();\n      add();\n      push_rational(1, 2);\n      power();\n      simplify_trig();\n      if (DEBUG_ABS) {\n        console.log(\" --> ABS of \" + input + \" : \" + stack[tos - 1]);\n      }\n      restore();\n      return;\n    }\n    if (car(p1) === symbol(POWER) && equaln(cadr(p1), -1)) {\n      if (DEBUG_ABS) {\n        console.log(\" abs: \" + p1 + \" is -1 to any power\");\n      }\n      // -1 to any power\n      if (evaluatingAsFloats) {\n        if (DEBUG_ABS) {\n          console.log(\" abs: numeric, so result is 1.0\");\n        }\n        push_double(1.0);\n      } else {\n        if (DEBUG_ABS) {\n          console.log(\" abs: symbolic, so result is 1\");\n        }\n        push_integer(1);\n      }\n      if (DEBUG_ABS) {\n        console.log(\" --> ABS of \" + input + \" : \" + stack[tos - 1]);\n      }\n      restore();\n      return;\n    }\n    // abs(a^b) is equal to abs(a)^b IF b is positive\n    if (car(p1) === symbol(POWER) && ispositivenumber(caddr(p1))) {\n      if (DEBUG_ABS) {\n        console.log(\" abs: \" + p1 + \" is something to the power of a positive number\");\n      }\n      push(cadr(p1));\n      abs();\n      push(caddr(p1));\n      power();\n      if (DEBUG_ABS) {\n        console.log(\" --> ABS of \" + input + \" : \" + stack[tos - 1]);\n      }\n      restore();\n      return;\n    }\n    // abs(e^something)\n    if (car(p1) === symbol(POWER) && cadr(p1) === symbol(E)) {\n      if (DEBUG_ABS) {\n        console.log(\" abs: \" + p1 + \" is an exponential\");\n      }\n      // exponential\n      push(caddr(p1));\n      real();\n      exponential();\n      if (DEBUG_ABS) {\n        console.log(\" --> ABS of \" + input + \" : \" + stack[tos - 1]);\n      }\n      restore();\n      return;\n    }\n    if (car(p1) === symbol(MULTIPLY)) {\n      if (DEBUG_ABS) {\n        console.log(\" abs: \" + p1 + \" is a product\");\n      }\n      // product\n      anyFactorsYet = false;\n      p1 = cdr(p1);\n      while (iscons(p1)) {\n        push(car(p1));\n        absval();\n        if (anyFactorsYet) {\n          multiply();\n        }\n        anyFactorsYet = true;\n        p1 = cdr(p1);\n      }\n      if (DEBUG_ABS) {\n        console.log(\" --> ABS of \" + input + \" : \" + stack[tos - 1]);\n      }\n      restore();\n      return;\n    }\n    if (car(p1) === symbol(ABS)) {\n      if (DEBUG_ABS) {\n        console.log(\" abs: \" + p1 + \" is abs of a abs\");\n      }\n      // abs of a abs\n      push_symbol(ABS);\n      push(cadr(p1));\n      list(2);\n      if (DEBUG_ABS) {\n        console.log(\" --> ABS of \" + input + \" : \" + stack[tos - 1]);\n      }\n      restore();\n      return;\n    }\n    /*\n     * Evaluation via zzfloat()\n     * ...while this is in theory a powerful mechanism, I've commented it\n     * out because I've refined this method enough to not need this.\n     * Evaling via zzfloat() is in principle more problematic because it could\n     * require further evaluations which could end up in further \"abs\" which\n     * would end up in infinite loops. Better not use it if not necessary.\n\n     * we look directly at the float evaluation of the argument\n     * to see if we end up with a number, which would mean that there\n     * is no imaginary component and we can just return the input\n     * (or its negation) as the result.\n    push p1\n    zzfloat()\n    floatEvaluation = pop()\n\n    if (isnegativenumber(floatEvaluation))\n      if DEBUG_ABS then console.log \" abs: \" + p1 + \" just a negative\"\n      push(p1)\n      negate()\n      restore()\n      return\n\n    if (ispositivenumber(floatEvaluation))\n      if DEBUG_ABS then console.log \" abs: \" + p1 + \" just a positive\"\n      push(p1)\n      if DEBUG_ABS then console.log \" --> ABS of \" + input + \" : \" + stack[tos-1]\n      restore()\n      return\n     */\n    if (istensor(p1)) {\n      absval_tensor();\n      restore();\n      return;\n    }\n    if (isnegativeterm(p1) || (car(p1) === symbol(ADD) && isnegativeterm(cadr(p1)))) {\n      push(p1);\n      negate();\n      p1 = pop();\n    }\n    if (DEBUG_ABS) {\n      console.log(\" abs: \" + p1 + \" is nothing decomposable\");\n    }\n    push_symbol(ABS);\n    push(p1);\n    list(2);\n    if (DEBUG_ABS) {\n      console.log(\" --> ABS of \" + input + \" : \" + stack[tos - 1]);\n    }\n    return restore();\n  };\n\n  // also called the \"norm\" of a vector\n  absval_tensor = function() {\n    if (p1.tensor.ndim !== 1) {\n      stop(\"abs(tensor) with tensor rank > 1\");\n    }\n    push(p1);\n    push(p1);\n    conjugate();\n    inner();\n    push_rational(1, 2);\n    power();\n    simplify();\n    return Eval();\n  };\n\n  flag = 0;\n\n  Eval_add = function() {\n    var h;\n    h = tos;\n    p1 = cdr(p1);\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n      p2 = pop();\n      push_terms(p2);\n      p1 = cdr(p1);\n    }\n    return add_terms(tos - h);\n  };\n\n  // Add n terms, returns one expression on the stack.\n  stackAddsCount = 0;\n\n  add_terms = function(n) {\n    var h, i, i1, j1, o, ref, ref1, results, s, subsetOfStack;\n    stackAddsCount++;\n    i = 0;\n    h = tos - n;\n    s = h;\n    // ensure no infinite loop, use \"for\"\n    if (DEBUG) {\n      console.log(\"stack before adding terms #\" + stackAddsCount);\n    }\n    //if stackAddsCount == 137\n    //  debugger\n    if (DEBUG) {\n      for (i = o = 0, ref = tos; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n        console.log(print_list(stack[i]));\n      }\n    }\n    for (i = i1 = 0; i1 < 10; i = ++i1) {\n      if (n < 2) {\n        break;\n      }\n      flag = 0;\n      //qsort(s, n, sizeof (U *), cmp_terms)\n      subsetOfStack = stack.slice(h, h + n);\n      subsetOfStack.sort(cmp_terms);\n      stack = stack.slice(0, h).concat(subsetOfStack).concat(stack.slice(h + n));\n      if (flag === 0) {\n        break;\n      }\n      n = combine_terms(h, n);\n    }\n    moveTos(h + n);\n    switch (n) {\n      case 0:\n        if (evaluatingAsFloats) {\n          push_double(0.0);\n        } else {\n          push(zero);\n        }\n        break;\n      case 1:\n        break;\n      default:\n        list(n);\n        p1 = pop();\n        push_symbol(ADD);\n        push(p1);\n        cons();\n    }\n    if (DEBUG) {\n      console.log(\"stack after adding terms #\" + stackAddsCount);\n    }\n    //if stackAddsCount == 5\n    //  debugger\n    if (DEBUG) {\n      results = [];\n      for (i = j1 = 0, ref1 = tos; (0 <= ref1 ? j1 < ref1 : j1 > ref1); i = 0 <= ref1 ? ++j1 : --j1) {\n        results.push(console.log(print_list(stack[i])));\n      }\n      return results;\n    }\n  };\n\n  // Compare terms for order, clobbers p1 and p2.\n  cmp_terms_count = 0;\n\n  cmp_terms = function(p1, p2) {\n    var i, o, ref, t;\n    cmp_terms_count++;\n    //if cmp_terms_count == 52\n    //  debugger\n    i = 0;\n    // numbers can be combined\n    if (isNumericAtom(p1) && isNumericAtom(p2)) {\n      flag = 1;\n      //if DEBUG then console.log \"cmp_terms #\" + cmp_terms_count + \" returns 0\"\n      return 0;\n    }\n    // congruent tensors can be combined\n    if (istensor(p1) && istensor(p2)) {\n      if (p1.tensor.ndim < p2.tensor.ndim) {\n        //if DEBUG then console.log \"cmp_terms #\" + cmp_terms_count + \" returns -1\"\n        return -1;\n      }\n      if (p1.tensor.ndim > p2.tensor.ndim) {\n        //if DEBUG then console.log \"cmp_terms #\" + cmp_terms_count + \" returns 1\"\n        return 1;\n      }\n      for (i = o = 0, ref = p1.tensor.ndim; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n        if (p1.tensor.dim[i] < p2.tensor.dim[i]) {\n          //if DEBUG then console.log \"cmp_terms #\" + cmp_terms_count + \" returns -1\"\n          return -1;\n        }\n        if (p1.tensor.dim[i] > p2.tensor.dim[i]) {\n          //if DEBUG then console.log \"cmp_terms #\" + cmp_terms_count + \" returns 1\"\n          return 1;\n        }\n      }\n      flag = 1;\n      //if DEBUG then console.log \"cmp_terms #\" + cmp_terms_count + \" returns 0\"\n      return 0;\n    }\n    if (car(p1) === symbol(MULTIPLY)) {\n      p1 = cdr(p1);\n      if (isNumericAtom(car(p1))) {\n        p1 = cdr(p1);\n        if (cdr(p1) === symbol(NIL)) {\n          p1 = car(p1);\n        }\n      }\n    }\n    if (car(p2) === symbol(MULTIPLY)) {\n      p2 = cdr(p2);\n      if (isNumericAtom(car(p2))) {\n        p2 = cdr(p2);\n        if (cdr(p2) === symbol(NIL)) {\n          p2 = car(p2);\n        }\n      }\n    }\n    t = cmp_expr(p1, p2);\n    if (t === 0) {\n      flag = 1;\n    }\n    //if DEBUG then console.log \"cmp_terms #\" + cmp_terms_count + \" returns \" + t\n    return t;\n  };\n\n  combine_terms = function(s, n) {\n    var i, i1, j, j1, l1, m1, o, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, t;\n    //debugger\n\n    // I had to turn the coffeescript for loop into\n    // a more mundane while loop because the i\n    // variable was changed from within the body,\n    // which is something that is not supposed to\n    // happen in the coffeescript 'vector' form.\n    // Also this means I had to add a 'i++' jus before\n    // the end of the body and before the \"continue\"s\n    i = 0;\n    while (i < (n - 1)) {\n      check_esc_flag();\n      p3 = stack[s + i];\n      p4 = stack[s + i + 1];\n      if (istensor(p3) && istensor(p4)) {\n        push(p3);\n        push(p4);\n        tensor_plus_tensor();\n        p1 = pop();\n        if (p1 !== symbol(NIL)) {\n          stack[s + i] = p1;\n          for (j = o = ref = i + 1, ref1 = n - 1; (ref <= ref1 ? o < ref1 : o > ref1); j = ref <= ref1 ? ++o : --o) {\n            stack[s + j] = stack[s + j + 1];\n          }\n          n--;\n          i--;\n        }\n        i++;\n        continue;\n      }\n      if (istensor(p3) || istensor(p4)) {\n        i++;\n        continue;\n      }\n      if (isNumericAtom(p3) && isNumericAtom(p4)) {\n        push(p3);\n        push(p4);\n        add_numbers();\n        p1 = pop();\n        if (isZeroAtomOrTensor(p1)) {\n          for (j = i1 = ref2 = i, ref3 = n - 2; (ref2 <= ref3 ? i1 < ref3 : i1 > ref3); j = ref2 <= ref3 ? ++i1 : --i1) {\n            stack[s + j] = stack[s + j + 2];\n          }\n          n -= 2;\n        } else {\n          stack[s + i] = p1;\n          for (j = j1 = ref4 = i + 1, ref5 = n - 1; (ref4 <= ref5 ? j1 < ref5 : j1 > ref5); j = ref4 <= ref5 ? ++j1 : --j1) {\n            stack[s + j] = stack[s + j + 1];\n          }\n          n--;\n        }\n        i--;\n        i++;\n        continue;\n      }\n      if (isNumericAtom(p3) || isNumericAtom(p4)) {\n        i++;\n        continue;\n      }\n      if (evaluatingAsFloats) {\n        p1 = one_as_double;\n        p2 = one_as_double;\n      } else {\n        p1 = one;\n        p2 = one;\n      }\n      t = 0;\n      if (car(p3) === symbol(MULTIPLY)) {\n        p3 = cdr(p3);\n        t = 1;\n        if (isNumericAtom(car(p3))) {\n          p1 = car(p3);\n          p3 = cdr(p3);\n          if (cdr(p3) === symbol(NIL)) {\n            p3 = car(p3);\n            t = 0;\n          }\n        }\n      }\n      if (car(p4) === symbol(MULTIPLY)) {\n        p4 = cdr(p4);\n        if (isNumericAtom(car(p4))) {\n          p2 = car(p4);\n          p4 = cdr(p4);\n          if (cdr(p4) === symbol(NIL)) {\n            p4 = car(p4);\n          }\n        }\n      }\n      if (!equal(p3, p4)) {\n        i++;\n        continue;\n      }\n      push(p1);\n      push(p2);\n      add_numbers();\n      p1 = pop();\n      if (isZeroAtomOrTensor(p1)) {\n        for (j = l1 = ref6 = i, ref7 = n - 2; (ref6 <= ref7 ? l1 < ref7 : l1 > ref7); j = ref6 <= ref7 ? ++l1 : --l1) {\n          stack[s + j] = stack[s + j + 2];\n        }\n        n -= 2;\n        i--;\n        i++;\n        continue;\n      }\n      push(p1);\n      if (t) {\n        push(symbol(MULTIPLY));\n        push(p3);\n        cons();\n      } else {\n        push(p3);\n      }\n      multiply();\n      stack[s + i] = pop();\n      for (j = m1 = ref8 = i + 1, ref9 = n - 1; (ref8 <= ref9 ? m1 < ref9 : m1 > ref9); j = ref8 <= ref9 ? ++m1 : --m1) {\n        stack[s + j] = stack[s + j + 1];\n      }\n      n--;\n      i--;\n      // this i++ is to match the while\n      i++;\n    }\n    return n;\n  };\n\n  push_terms = function(p) {\n    var results;\n    if (car(p) === symbol(ADD)) {\n      p = cdr(p);\n      results = [];\n      while (iscons(p)) {\n        push(car(p));\n        results.push(p = cdr(p));\n      }\n      return results;\n    } else if (!isZeroAtom(p)) {\n      return push(p);\n    }\n  };\n\n  // add two expressions\n  add = function() {\n    var h;\n    save();\n    p2 = pop();\n    p1 = pop();\n    h = tos;\n    push_terms(p1);\n    push_terms(p2);\n    add_terms(tos - h);\n    return restore();\n  };\n\n  add_all = function(k) {\n    var h, i, o, ref, s;\n    i = 0;\n    save();\n    s = tos - k;\n    h = tos;\n    for (i = o = 0, ref = k; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      push_terms(stack[s + i]);\n    }\n    add_terms(tos - h);\n    p1 = pop();\n    moveTos(tos - k);\n    push(p1);\n    return restore();\n  };\n\n  subtract = function() {\n    negate();\n    return add();\n  };\n\n  Eval_adj = function() {\n    push(cadr(p1));\n    Eval();\n    return adj();\n  };\n\n  adj = function() {\n    var doNothing, i, i1, j, n, o, ref, ref1;\n    i = 0;\n    j = 0;\n    n = 0;\n    save();\n    p1 = pop();\n    if (istensor(p1) && p1.tensor.ndim === 2 && p1.tensor.dim[0] === p1.tensor.dim[1]) {\n      doNothing = 1;\n    } else {\n      stop(\"adj: square matrix expected\");\n    }\n    n = p1.tensor.dim[0];\n    p2 = alloc_tensor(n * n);\n    p2.tensor.ndim = 2;\n    p2.tensor.dim[0] = n;\n    p2.tensor.dim[1] = n;\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      for (j = i1 = 0, ref1 = n; (0 <= ref1 ? i1 < ref1 : i1 > ref1); j = 0 <= ref1 ? ++i1 : --i1) {\n        cofactor(p1, n, i, j);\n        p2.tensor.elem[n * j + i] = pop(); // transpose\n      }\n    }\n    push(p2);\n    return restore();\n  };\n\n  Eval_approxratio = function() {\n    var theArgument;\n    theArgument = cadr(p1);\n    push(theArgument);\n    return approxratioRecursive();\n  };\n\n  approxratioRecursive = function() {\n    var i, i1, o, ref, ref1;\n    i = 0;\n    save();\n    p1 = pop();\n    if (istensor(p1)) {\n      p4 = alloc_tensor(p1.tensor.nelem);\n      p4.tensor.ndim = p1.tensor.ndim;\n      for (i = o = 0, ref = p1.tensor.ndim; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n        p4.tensor.dim[i] = p1.tensor.dim[i];\n      }\n      for (i = i1 = 0, ref1 = p1.tensor.nelem; (0 <= ref1 ? i1 < ref1 : i1 > ref1); i = 0 <= ref1 ? ++i1 : --i1) {\n        push(p1.tensor.elem[i]);\n        approxratioRecursive();\n        p4.tensor.elem[i] = pop();\n        check_tensor_dimensions(p4);\n      }\n      push(p4);\n    } else if (p1.k === DOUBLE) {\n      push(p1);\n      approxOneRatioOnly();\n    } else if (iscons(p1)) {\n      push(car(p1));\n      approxratioRecursive();\n      push(cdr(p1));\n      approxratioRecursive();\n      cons();\n    } else {\n      push(p1);\n    }\n    return restore();\n  };\n\n  approxOneRatioOnly = function() {\n    var numberOfDigitsAfterTheDot, precision, splitBeforeAndAfterDot, supposedlyTheFloat, theFloat, theRatio;\n    zzfloat();\n    supposedlyTheFloat = pop();\n    if (supposedlyTheFloat.k === DOUBLE) {\n      theFloat = supposedlyTheFloat.d;\n      splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n      if (splitBeforeAndAfterDot.length === 2) {\n        numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n        precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n        theRatio = floatToRatioRoutine(theFloat, precision);\n        push_rational(theRatio[0], theRatio[1]);\n      } else {\n        push_integer(theFloat);\n      }\n      return;\n    }\n    // we didn't manage, just leave unexpressed\n    push_symbol(APPROXRATIO);\n    push(theArgument);\n    return list(2);\n  };\n\n  // original routine by John Kennedy, see\n  // https://web.archive.org/web/20111027100847/http://homepage.smc.edu/kennedy_john/DEC2FRAC.PDF\n  // courtesy of Michael Borcherds\n  // who ported this to JavaScript under MIT licence\n  // also see\n  // https://github.com/geogebra/geogebra/blob/master/common/src/main/java/org/geogebra/common/kernel/algos/AlgoFractionText.java\n  // potential other ways to do this:\n  //   https://rosettacode.org/wiki/Convert_decimal_number_to_rational\n  //   http://www.homeschoolmath.net/teaching/rational_numbers.php\n  //   http://stackoverflow.com/questions/95727/how-to-convert-floats-to-human-readable-fractions\n  floatToRatioRoutine = function(decimal, AccuracyFactor) {\n    var DecimalSign, FractionDenominator, FractionNumerator, PreviousDenominator, ScratchValue, Z, ret;\n    FractionNumerator = void 0;\n    FractionDenominator = void 0;\n    DecimalSign = void 0;\n    Z = void 0;\n    PreviousDenominator = void 0;\n    ScratchValue = void 0;\n    ret = [0, 0];\n    if (isNaN(decimal)) {\n      return ret;\n    }\n    // return 0/0 \n    if (decimal === 2e308) {\n      ret[0] = 1;\n      ret[1] = 0;\n      // 1/0\n      return ret;\n    }\n    if (decimal === -2e308) {\n      ret[0] = -1;\n      ret[1] = 0;\n      // -1/0\n      return ret;\n    }\n    if (decimal < 0.0) {\n      DecimalSign = -1.0;\n    } else {\n      DecimalSign = 1.0;\n    }\n    decimal = Math.abs(decimal);\n    if (Math.abs(decimal - Math.floor(decimal)) < AccuracyFactor) {\n      // handles exact integers including 0 \n      FractionNumerator = decimal * DecimalSign;\n      FractionDenominator = 1.0;\n      ret[0] = FractionNumerator;\n      ret[1] = FractionDenominator;\n      return ret;\n    }\n    if (decimal < 1.0e-19) {\n      // X = 0 already taken care of \n      FractionNumerator = DecimalSign;\n      FractionDenominator = 9999999999999999999.0;\n      ret[0] = FractionNumerator;\n      ret[1] = FractionDenominator;\n      return ret;\n    }\n    if (decimal > 1.0e19) {\n      FractionNumerator = 9999999999999999999.0 * DecimalSign;\n      FractionDenominator = 1.0;\n      ret[0] = FractionNumerator;\n      ret[1] = FractionDenominator;\n      return ret;\n    }\n    Z = decimal;\n    PreviousDenominator = 0.0;\n    FractionDenominator = 1.0;\n    while (true) {\n      Z = 1.0 / (Z - Math.floor(Z));\n      ScratchValue = FractionDenominator;\n      FractionDenominator = FractionDenominator * Math.floor(Z) + PreviousDenominator;\n      PreviousDenominator = ScratchValue;\n      FractionNumerator = Math.floor(decimal * FractionDenominator + 0.5);\n      // Rounding Function\n      if (!(Math.abs(decimal - (FractionNumerator / FractionDenominator)) > AccuracyFactor && Z !== Math.floor(Z))) {\n        break;\n      }\n    }\n    FractionNumerator = DecimalSign * FractionNumerator;\n    ret[0] = FractionNumerator;\n    ret[1] = FractionDenominator;\n    return ret;\n  };\n\n  approx_just_an_integer = 0;\n\n  approx_sine_of_rational = 1;\n\n  approx_sine_of_pi_times_rational = 2;\n\n  approx_rationalOfPi = 3;\n\n  approx_radicalOfRatio = 4;\n\n  approx_nothingUseful = 5;\n\n  approx_ratioOfRadical = 6;\n\n  approx_rationalOfE = 7;\n\n  approx_logarithmsOfRationals = 8;\n\n  approx_rationalsOfLogarithms = 9;\n\n  approxRationalsOfRadicals = function(theFloat) {\n    var bestResultSoFar, complexity, error, hypothesis, i, i1, j, len, likelyMultiplier, minimumComplexity, numberOfDigitsAfterTheDot, o, precision, ratio, ref, result, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n    console.log(\"precision: \" + precision);\n    // simple radicals.\n    bestResultSoFar = null;\n    minimumComplexity = Number.MAX_VALUE;\n    ref = [2, 3, 5, 6, 7, 8, 10];\n    for (o = 0, len = ref.length; o < len; o++) {\n      i = ref[o];\n      for (j = i1 = 1; i1 <= 10; j = ++i1) {\n        //console.log  \"i,j: \" + i + \",\" + j\n        hypothesis = Math.sqrt(i) / j;\n        //console.log  \"hypothesis: \" + hypothesis\n        if (Math.abs(hypothesis) > 1e-10) {\n          ratio = theFloat / hypothesis;\n          likelyMultiplier = Math.round(ratio);\n          //console.log  \"ratio: \" + ratio\n          error = Math.abs(1 - ratio / likelyMultiplier);\n        } else {\n          ratio = 1;\n          likelyMultiplier = 1;\n          error = Math.abs(theFloat - hypothesis);\n        }\n        //console.log  \"error: \" + error\n        if (error < 2 * precision) {\n          complexity = simpleComplexityMeasure(likelyMultiplier, i, j);\n          if (complexity < minimumComplexity) {\n            //console.log \"MINIMUM MULTIPLIER SO FAR\"\n            minimumComplexity = complexity;\n            result = likelyMultiplier + \" * sqrt( \" + i + \" ) / \" + j;\n            //console.log result + \" error: \" + error\n            bestResultSoFar = [result, approx_ratioOfRadical, likelyMultiplier, i, j];\n          }\n        }\n      }\n    }\n    return bestResultSoFar;\n  };\n\n  approxRadicalsOfRationals = function(theFloat) {\n    var bestResultSoFar, complexity, error, hypothesis, i, i1, j, len, len1, likelyMultiplier, minimumComplexity, numberOfDigitsAfterTheDot, o, precision, ratio, ref, ref1, result, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n    console.log(\"precision: \" + precision);\n    // simple radicals.\n    bestResultSoFar = null;\n    minimumComplexity = Number.MAX_VALUE;\n    ref = [1, 2, 3, 5, 6, 7, 8, 10];\n    // this one catches things like Math.sqrt(3/4), but\n    // things like Math.sqrt(1/2) are caught by the paragraph\n    // above (and in a better form)\n    for (o = 0, len = ref.length; o < len; o++) {\n      i = ref[o];\n      ref1 = [1, 2, 3, 5, 6, 7, 8, 10];\n      for (i1 = 0, len1 = ref1.length; i1 < len1; i1++) {\n        j = ref1[i1];\n        //console.log  \"i,j: \" + i + \",\" + j\n        hypothesis = Math.sqrt(i / j);\n        //console.log  \"hypothesis: \" + hypothesis\n        if (Math.abs(hypothesis) > 1e-10) {\n          ratio = theFloat / hypothesis;\n          likelyMultiplier = Math.round(ratio);\n          //console.log  \"ratio: \" + ratio\n          error = Math.abs(1 - ratio / likelyMultiplier);\n        } else {\n          ratio = 1;\n          likelyMultiplier = 1;\n          error = Math.abs(theFloat - hypothesis);\n        }\n        //console.log  \"error: \" + error\n        if (error < 2 * precision) {\n          complexity = simpleComplexityMeasure(likelyMultiplier, i, j);\n          if (complexity < minimumComplexity) {\n            //console.log \"MINIMUM MULTIPLIER SO FAR\"\n            minimumComplexity = complexity;\n            result = likelyMultiplier + \" * (sqrt( \" + i + \" / \" + j + \" )\";\n            //console.log result + \" error: \" + error\n            bestResultSoFar = [result, approx_radicalOfRatio, likelyMultiplier, i, j];\n          }\n        }\n      }\n    }\n    return bestResultSoFar;\n  };\n\n  approxRadicals = function(theFloat) {\n    var approxRadicalsOfRationalsResult, approxRationalsOfRadicalsResult, numberOfDigitsAfterTheDot, precision, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n    console.log(\"precision: \" + precision);\n    // simple radicals.\n\n    // we always prefer a rational of a radical of an integer\n    // to a radical of a rational. Radicals of rationals generate\n    // radicals at the denominator which we'd rather avoid\n    approxRationalsOfRadicalsResult = approxRationalsOfRadicals(theFloat);\n    if (approxRationalsOfRadicalsResult != null) {\n      return approxRationalsOfRadicalsResult;\n    }\n    approxRadicalsOfRationalsResult = approxRadicalsOfRationals(theFloat);\n    if (approxRadicalsOfRationalsResult != null) {\n      return approxRadicalsOfRationalsResult;\n    }\n    return null;\n  };\n\n  approxLogs = function(theFloat) {\n    var approxLogsOfRationalsResult, approxRationalsOfLogsResult, numberOfDigitsAfterTheDot, precision, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n    console.log(\"precision: \" + precision);\n    // we always prefer a rational of a log to a log of\n    // a rational\n    approxRationalsOfLogsResult = approxRationalsOfLogs(theFloat);\n    if (approxRationalsOfLogsResult != null) {\n      return approxRationalsOfLogsResult;\n    }\n    approxLogsOfRationalsResult = approxLogsOfRationals(theFloat);\n    if (approxLogsOfRationalsResult != null) {\n      return approxLogsOfRationalsResult;\n    }\n    return null;\n  };\n\n  approxRationalsOfLogs = function(theFloat) {\n    var bestResultSoFar, complexity, error, hypothesis, i, i1, j, likelyMultiplier, minimumComplexity, numberOfDigitsAfterTheDot, o, precision, ratio, result, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n    console.log(\"precision: \" + precision);\n    bestResultSoFar = null;\n    minimumComplexity = Number.MAX_VALUE;\n// simple rationals of logs\n    for (i = o = 2; o <= 5; i = ++o) {\n      for (j = i1 = 1; i1 <= 5; j = ++i1) {\n        //console.log  \"i,j: \" + i + \",\" + j\n        hypothesis = Math.log(i) / j;\n        //console.log  \"hypothesis: \" + hypothesis\n        if (Math.abs(hypothesis) > 1e-10) {\n          ratio = theFloat / hypothesis;\n          likelyMultiplier = Math.round(ratio);\n          //console.log  \"ratio: \" + ratio\n          error = Math.abs(1 - ratio / likelyMultiplier);\n        } else {\n          ratio = 1;\n          likelyMultiplier = 1;\n          error = Math.abs(theFloat - hypothesis);\n        }\n        //console.log  \"error: \" + error\n\n        // it does happen that due to roundings \n        // a \"higher multiple\" is picked, which is obviously\n        // unintended.\n        // E.g. 1 * log(1 / 3 ) doesn't match log( 3 ) BUT\n        // it matches -5 * log( 3 ) / 5\n        // so we avoid any case where the multiplier is a multiple\n        // of the divisor.\n        if (likelyMultiplier !== 1 && Math.abs(Math.floor(likelyMultiplier / j)) === Math.abs(likelyMultiplier / j)) {\n          continue;\n        }\n        if (error < 2.2 * precision) {\n          complexity = simpleComplexityMeasure(likelyMultiplier, i, j);\n          if (complexity < minimumComplexity) {\n            //console.log \"MINIMUM MULTIPLIER SO FAR\"\n            minimumComplexity = complexity;\n            result = likelyMultiplier + \" * log( \" + i + \" ) / \" + j;\n            //console.log result + \" error: \" + error\n            bestResultSoFar = [result, approx_rationalsOfLogarithms, likelyMultiplier, i, j];\n          }\n        }\n      }\n    }\n    return bestResultSoFar;\n  };\n\n  approxLogsOfRationals = function(theFloat) {\n    var bestResultSoFar, complexity, error, hypothesis, i, i1, j, likelyMultiplier, minimumComplexity, numberOfDigitsAfterTheDot, o, precision, ratio, result, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n    console.log(\"precision: \" + precision);\n    bestResultSoFar = null;\n    minimumComplexity = Number.MAX_VALUE;\n// simple logs of rationals\n    for (i = o = 1; o <= 5; i = ++o) {\n      for (j = i1 = 1; i1 <= 5; j = ++i1) {\n        //console.log  \"i,j: \" + i + \",\" + j\n        hypothesis = Math.log(i / j);\n        //console.log  \"hypothesis: \" + hypothesis\n        if (Math.abs(hypothesis) > 1e-10) {\n          ratio = theFloat / hypothesis;\n          likelyMultiplier = Math.round(ratio);\n          //console.log  \"ratio: \" + ratio\n          error = Math.abs(1 - ratio / likelyMultiplier);\n        } else {\n          ratio = 1;\n          likelyMultiplier = 1;\n          error = Math.abs(theFloat - hypothesis);\n        }\n        //console.log  \"error: \" + error\n        if (error < 1.96 * precision) {\n          complexity = simpleComplexityMeasure(likelyMultiplier, i, j);\n          if (complexity < minimumComplexity) {\n            //console.log \"MINIMUM MULTIPLIER SO FAR\"\n            minimumComplexity = complexity;\n            result = likelyMultiplier + \" * log( \" + i + \" / \" + j + \" )\";\n            //console.log result + \" error: \" + error\n            bestResultSoFar = [result, approx_logarithmsOfRationals, likelyMultiplier, i, j];\n          }\n        }\n      }\n    }\n    return bestResultSoFar;\n  };\n\n  approxRationalsOfPowersOfE = function(theFloat) {\n    var bestResultSoFar, complexity, error, hypothesis, i, i1, j, likelyMultiplier, minimumComplexity, numberOfDigitsAfterTheDot, o, precision, ratio, result, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n    console.log(\"precision: \" + precision);\n    bestResultSoFar = null;\n    minimumComplexity = Number.MAX_VALUE;\n// simple rationals of a few powers of e\n    for (i = o = 1; o <= 2; i = ++o) {\n      for (j = i1 = 1; i1 <= 12; j = ++i1) {\n        //console.log  \"i,j: \" + i + \",\" + j\n        hypothesis = Math.pow(Math.E, i) / j;\n        //console.log  \"hypothesis: \" + hypothesis\n        if (Math.abs(hypothesis) > 1e-10) {\n          ratio = theFloat / hypothesis;\n          likelyMultiplier = Math.round(ratio);\n          //console.log  \"ratio: \" + ratio\n          error = Math.abs(1 - ratio / likelyMultiplier);\n        } else {\n          ratio = 1;\n          likelyMultiplier = 1;\n          error = Math.abs(theFloat - hypothesis);\n        }\n        //console.log  \"error: \" + error\n        if (error < 2 * precision) {\n          complexity = simpleComplexityMeasure(likelyMultiplier, i, j);\n          if (complexity < minimumComplexity) {\n            //console.log \"MINIMUM MULTIPLIER SO FAR\"\n            minimumComplexity = complexity;\n            result = likelyMultiplier + \" * (e ^ \" + i + \" ) / \" + j;\n            //console.log result + \" error: \" + error\n            bestResultSoFar = [result, approx_rationalOfE, likelyMultiplier, i, j];\n          }\n        }\n      }\n    }\n    return bestResultSoFar;\n  };\n\n  approxRationalsOfPowersOfPI = function(theFloat) {\n    var bestResultSoFar, complexity, error, hypothesis, i, i1, j, likelyMultiplier, minimumComplexity, numberOfDigitsAfterTheDot, o, precision, ratio, result, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n    console.log(\"precision: \" + precision);\n    bestResultSoFar = null;\n    // here we do somethng a little special: since\n    // the powers of pi can get quite big, there might\n    // be multiple hypothesis where more of the\n    // magnitude is shifted to the multiplier, and some\n    // where more of the magnitude is shifted towards the\n    // exponent of pi. So we prefer the hypotheses with the\n    // lower multiplier since it's likely to insert more\n    // information.\n    minimumComplexity = Number.MAX_VALUE;\n// simple rationals of a few powers of PI\n    for (i = o = 1; o <= 5; i = ++o) {\n      for (j = i1 = 1; i1 <= 12; j = ++i1) {\n        //console.log  \"i,j: \" + i + \",\" + j\n        hypothesis = Math.pow(Math.PI, i) / j;\n        //console.log  \"hypothesis: \" + hypothesis\n        if (Math.abs(hypothesis) > 1e-10) {\n          ratio = theFloat / hypothesis;\n          likelyMultiplier = Math.round(ratio);\n          //console.log  \"ratio: \" + ratio\n          error = Math.abs(1 - ratio / likelyMultiplier);\n        } else {\n          ratio = 1;\n          likelyMultiplier = 1;\n          error = Math.abs(theFloat - hypothesis);\n        }\n        //console.log  \"error: \" + error\n        if (error < 2 * precision) {\n          complexity = simpleComplexityMeasure(likelyMultiplier, i, j);\n          if (complexity < minimumComplexity) {\n            //console.log \"MINIMUM MULTIPLIER SO FAR\"\n            minimumComplexity = complexity;\n            result = likelyMultiplier + \" * (pi ^ \" + i + \" ) / \" + j + \" )\";\n            //console.log result + \" error: \" + error\n            bestResultSoFar = [result, approx_rationalOfPi, likelyMultiplier, i, j];\n          }\n        }\n      }\n    }\n    //console.log \"approxRationalsOfPowersOfPI returning: \" + bestResultSoFar\n    return bestResultSoFar;\n  };\n\n  approxTrigonometric = function(theFloat) {\n    var approxSineOfRationalMultiplesOfPIResult, approxSineOfRationalsResult, numberOfDigitsAfterTheDot, precision, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n    console.log(\"precision: \" + precision);\n    // we always prefer a sin of a rational without the PI\n    approxSineOfRationalsResult = approxSineOfRationals(theFloat);\n    if (approxSineOfRationalsResult != null) {\n      return approxSineOfRationalsResult;\n    }\n    approxSineOfRationalMultiplesOfPIResult = approxSineOfRationalMultiplesOfPI(theFloat);\n    if (approxSineOfRationalMultiplesOfPIResult != null) {\n      return approxSineOfRationalMultiplesOfPIResult;\n    }\n    return null;\n  };\n\n  approxSineOfRationals = function(theFloat) {\n    var bestResultSoFar, complexity, error, fraction, hypothesis, i, i1, j, likelyMultiplier, minimumComplexity, numberOfDigitsAfterTheDot, o, precision, ratio, result, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n    console.log(\"precision: \" + precision);\n    bestResultSoFar = null;\n    minimumComplexity = Number.MAX_VALUE;\n// we only check very simple rationals because they begin to get tricky\n// quickly, also they collide often with the \"rational of pi\" hypothesis.\n// For example sin(11) is veeery close to 1 (-0.99999020655)\n// (see: http://mathworld.wolfram.com/AlmostInteger.html )\n// we stop at rationals that mention up to 10\n    for (i = o = 1; o <= 4; i = ++o) {\n      for (j = i1 = 1; i1 <= 4; j = ++i1) {\n        //console.log  \"i,j: \" + i + \",\" + j\n        fraction = i / j;\n        hypothesis = Math.sin(fraction);\n        //console.log  \"hypothesis: \" + hypothesis\n        if (Math.abs(hypothesis) > 1e-10) {\n          ratio = theFloat / hypothesis;\n          likelyMultiplier = Math.round(ratio);\n          //console.log  \"ratio: \" + ratio\n          error = Math.abs(1 - ratio / likelyMultiplier);\n        } else {\n          ratio = 1;\n          likelyMultiplier = 1;\n          error = Math.abs(theFloat - hypothesis);\n        }\n        //console.log  \"error: \" + error\n        if (error < 2 * precision) {\n          complexity = simpleComplexityMeasure(likelyMultiplier, i, j);\n          if (complexity < minimumComplexity) {\n            //console.log \"MINIMUM MULTIPLIER SO FAR\"\n            minimumComplexity = complexity;\n            result = likelyMultiplier + \" * sin( \" + i + \"/\" + j + \" )\";\n            //console.log result + \" error: \" + error\n            bestResultSoFar = [result, approx_sine_of_rational, likelyMultiplier, i, j];\n          }\n        }\n      }\n    }\n    return bestResultSoFar;\n  };\n\n  approxSineOfRationalMultiplesOfPI = function(theFloat) {\n    var bestResultSoFar, complexity, error, fraction, hypothesis, i, i1, j, likelyMultiplier, minimumComplexity, numberOfDigitsAfterTheDot, o, precision, ratio, result, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n    console.log(\"precision: \" + precision);\n    bestResultSoFar = null;\n    minimumComplexity = Number.MAX_VALUE;\n// check rational multiples of pi\n    for (i = o = 1; o <= 13; i = ++o) {\n      for (j = i1 = 1; i1 <= 13; j = ++i1) {\n        //console.log  \"i,j: \" + i + \",\" + j\n        fraction = i / j;\n        hypothesis = Math.sin(Math.PI * fraction);\n        //console.log  \"hypothesis: \" + hypothesis\n        if (Math.abs(hypothesis) > 1e-10) {\n          ratio = theFloat / hypothesis;\n          likelyMultiplier = Math.round(ratio);\n          //console.log  \"ratio: \" + ratio\n          error = Math.abs(1 - ratio / likelyMultiplier);\n        } else {\n          ratio = 1;\n          likelyMultiplier = 1;\n          error = Math.abs(theFloat - hypothesis);\n        }\n        //console.log  \"error: \" + error\n        // magic number 23 comes from the case sin(pi/10)\n        if (error < 23 * precision) {\n          complexity = simpleComplexityMeasure(likelyMultiplier, i, j);\n          if (complexity < minimumComplexity) {\n            //console.log \"MINIMUM MULTIPLIER SO FAR\"\n            minimumComplexity = complexity;\n            result = likelyMultiplier + \" * sin( \" + i + \"/\" + j + \" * pi )\";\n            //console.log result + \" error: \" + error\n            bestResultSoFar = [result, approx_sine_of_pi_times_rational, likelyMultiplier, i, j];\n          }\n        }\n      }\n    }\n    return bestResultSoFar;\n  };\n\n  approxAll = function(theFloat) {\n    var LOG_EXPLANATIONS, approxLogsResult, approxRadicalsResult, approxRationalsOfPowersOfEResult, approxRationalsOfPowersOfPIResult, approxTrigonometricResult, bestApproxSoFar, constantsSum, constantsSumMin, numberOfDigitsAfterTheDot, precision, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n    console.log(\"precision: \" + precision);\n    constantsSumMin = Number.MAX_VALUE;\n    constantsSum = 0;\n    bestApproxSoFar = null;\n    LOG_EXPLANATIONS = true;\n    approxRadicalsResult = approxRadicals(theFloat);\n    if (approxRadicalsResult != null) {\n      constantsSum = simpleComplexityMeasure(approxRadicalsResult);\n      if (constantsSum < constantsSumMin) {\n        if (LOG_EXPLANATIONS) {\n          console.log(\"better explanation by approxRadicals: \" + approxRadicalsResult + \" complexity: \" + constantsSum);\n        }\n        constantsSumMin = constantsSum;\n        bestApproxSoFar = approxRadicalsResult;\n      } else {\n        if (LOG_EXPLANATIONS) {\n          console.log(\"subpar explanation by approxRadicals: \" + approxRadicalsResult + \" complexity: \" + constantsSum);\n        }\n      }\n    }\n    approxLogsResult = approxLogs(theFloat);\n    if (approxLogsResult != null) {\n      constantsSum = simpleComplexityMeasure(approxLogsResult);\n      if (constantsSum < constantsSumMin) {\n        if (LOG_EXPLANATIONS) {\n          console.log(\"better explanation by approxLogs: \" + approxLogsResult + \" complexity: \" + constantsSum);\n        }\n        constantsSumMin = constantsSum;\n        bestApproxSoFar = approxLogsResult;\n      } else {\n        if (LOG_EXPLANATIONS) {\n          console.log(\"subpar explanation by approxLogs: \" + approxLogsResult + \" complexity: \" + constantsSum);\n        }\n      }\n    }\n    approxRationalsOfPowersOfEResult = approxRationalsOfPowersOfE(theFloat);\n    if (approxRationalsOfPowersOfEResult != null) {\n      constantsSum = simpleComplexityMeasure(approxRationalsOfPowersOfEResult);\n      if (constantsSum < constantsSumMin) {\n        if (LOG_EXPLANATIONS) {\n          console.log(\"better explanation by approxRationalsOfPowersOfE: \" + approxRationalsOfPowersOfEResult + \" complexity: \" + constantsSum);\n        }\n        constantsSumMin = constantsSum;\n        bestApproxSoFar = approxRationalsOfPowersOfEResult;\n      } else {\n        if (LOG_EXPLANATIONS) {\n          console.log(\"subpar explanation by approxRationalsOfPowersOfE: \" + approxRationalsOfPowersOfEResult + \" complexity: \" + constantsSum);\n        }\n      }\n    }\n    approxRationalsOfPowersOfPIResult = approxRationalsOfPowersOfPI(theFloat);\n    if (approxRationalsOfPowersOfPIResult != null) {\n      constantsSum = simpleComplexityMeasure(approxRationalsOfPowersOfPIResult);\n      if (constantsSum < constantsSumMin) {\n        if (LOG_EXPLANATIONS) {\n          console.log(\"better explanation by approxRationalsOfPowersOfPI: \" + approxRationalsOfPowersOfPIResult + \" complexity: \" + constantsSum);\n        }\n        constantsSumMin = constantsSum;\n        bestApproxSoFar = approxRationalsOfPowersOfPIResult;\n      } else {\n        if (LOG_EXPLANATIONS) {\n          console.log(\"subpar explanation by approxRationalsOfPowersOfPI: \" + approxRationalsOfPowersOfPIResult + \" complexity: \" + constantsSum);\n        }\n      }\n    }\n    approxTrigonometricResult = approxTrigonometric(theFloat);\n    if (approxTrigonometricResult != null) {\n      constantsSum = simpleComplexityMeasure(approxTrigonometricResult);\n      if (constantsSum < constantsSumMin) {\n        if (LOG_EXPLANATIONS) {\n          console.log(\"better explanation by approxTrigonometric: \" + approxTrigonometricResult + \" complexity: \" + constantsSum);\n        }\n        constantsSumMin = constantsSum;\n        bestApproxSoFar = approxTrigonometricResult;\n      } else {\n        if (LOG_EXPLANATIONS) {\n          console.log(\"subpar explanation by approxTrigonometric: \" + approxTrigonometricResult + \" complexity: \" + constantsSum);\n        }\n      }\n    }\n    return bestApproxSoFar;\n  };\n\n  simpleComplexityMeasure = function(aResult, b, c) {\n    var theSum;\n    theSum = null;\n    if (aResult instanceof Array) {\n      // we want PI and E to somewhat increase the\n      // complexity of the expression, so basically they count\n      // more than any integer lower than 3, i.e. we consider\n      // 1,2,3 to be more fundamental than PI or E.\n      switch (aResult[1]) {\n        case approx_sine_of_pi_times_rational:\n          theSum = 4;\n          break;\n        // exponents of PI and E need to be penalised as well\n        // otherwise they come to explain any big number\n        // so we count them just as much as the multiplier\n        case approx_rationalOfPi:\n          theSum = Math.pow(4, Math.abs(aResult[3])) * Math.abs(aResult[2]);\n          break;\n        case approx_rationalOfE:\n          theSum = Math.pow(3, Math.abs(aResult[3])) * Math.abs(aResult[2]);\n          break;\n        default:\n          theSum = 0;\n      }\n      theSum += Math.abs(aResult[2]) * (Math.abs(aResult[3]) + Math.abs(aResult[4]));\n    } else {\n      theSum += Math.abs(aResult) * (Math.abs(b) + Math.abs(c));\n    }\n    \n    // heavily discount unit constants\n    if (aResult[2] === 1) {\n      theSum -= 1;\n    } else {\n      theSum += 1;\n    }\n    if (aResult[3] === 1) {\n      theSum -= 1;\n    } else {\n      theSum += 1;\n    }\n    if (aResult[4] === 1) {\n      theSum -= 1;\n    } else {\n      theSum += 1;\n    }\n    if (theSum < 0) {\n      theSum = 0;\n    }\n    return theSum;\n  };\n\n  testApprox = function() {\n    var error, fraction, i, i1, i2, i3, j, j1, j2, j3, k3, l1, l2, l3, len, len1, len2, len3, len4, len5, len6, len7, m1, m2, m3, n1, n2, o, o1, o2, originalValue, q1, q2, r1, r2, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, returned, returnedFraction, returnedValue, s1, s2, t1, t2, u1, u2, v1, v2, value, x1, x2, z1, z2;\n    ref = [2, 3, 5, 6, 7, 8, 10];\n    for (o = 0, len = ref.length; o < len; o++) {\n      i = ref[o];\n      ref1 = [2, 3, 5, 6, 7, 8, 10];\n      for (i1 = 0, len1 = ref1.length; i1 < len1; i1++) {\n        j = ref1[i1];\n        if (i === j) {\n          continue; // this is just 1\n        }\n        console.log(\"testapproxRadicals testing: \" + \"1 * sqrt( \" + i + \" ) / \" + j);\n        fraction = i / j;\n        value = Math.sqrt(i) / j;\n        returned = approxRadicals(value);\n        returnedValue = returned[2] * Math.sqrt(returned[3]) / returned[4];\n        if (Math.abs(value - returnedValue) > 1e-15) {\n          console.log(\"fail testapproxRadicals: \" + \"1 * sqrt( \" + i + \" ) / \" + j + \" . obtained: \" + returned);\n        }\n      }\n    }\n    ref2 = [2, 3, 5, 6, 7, 8, 10];\n    for (j1 = 0, len2 = ref2.length; j1 < len2; j1++) {\n      i = ref2[j1];\n      ref3 = [2, 3, 5, 6, 7, 8, 10];\n      for (l1 = 0, len3 = ref3.length; l1 < len3; l1++) {\n        j = ref3[l1];\n        if (i === j) {\n          continue; // this is just 1\n        }\n        console.log(\"testapproxRadicals testing with 4 digits: \" + \"1 * sqrt( \" + i + \" ) / \" + j);\n        fraction = i / j;\n        originalValue = Math.sqrt(i) / j;\n        value = originalValue.toFixed(4);\n        returned = approxRadicals(value);\n        returnedValue = returned[2] * Math.sqrt(returned[3]) / returned[4];\n        if (Math.abs(originalValue - returnedValue) > 1e-15) {\n          console.log(\"fail testapproxRadicals with 4 digits: \" + \"1 * sqrt( \" + i + \" ) / \" + j + \" . obtained: \" + returned);\n        }\n      }\n    }\n    ref4 = [2, 3, 5, 6, 7, 8, 10];\n    for (m1 = 0, len4 = ref4.length; m1 < len4; m1++) {\n      i = ref4[m1];\n      ref5 = [2, 3, 5, 6, 7, 8, 10];\n      for (n1 = 0, len5 = ref5.length; n1 < len5; n1++) {\n        j = ref5[n1];\n        if (i === j) {\n          continue; // this is just 1\n        }\n        console.log(\"testapproxRadicals testing: \" + \"1 * sqrt( \" + i + \" / \" + j + \" )\");\n        fraction = i / j;\n        value = Math.sqrt(i / j);\n        returned = approxRadicals(value);\n        if (returned != null) {\n          returnedValue = returned[2] * Math.sqrt(returned[3] / returned[4]);\n          if (returned[1] === approx_radicalOfRatio && Math.abs(value - returnedValue) > 1e-15) {\n            console.log(\"fail testapproxRadicals: \" + \"1 * sqrt( \" + i + \" / \" + j + \" ) . obtained: \" + returned);\n          }\n        }\n      }\n    }\n    ref6 = [1, 2, 3, 5, 6, 7, 8, 10];\n    for (o1 = 0, len6 = ref6.length; o1 < len6; o1++) {\n      i = ref6[o1];\n      ref7 = [1, 2, 3, 5, 6, 7, 8, 10];\n      for (q1 = 0, len7 = ref7.length; q1 < len7; q1++) {\n        j = ref7[q1];\n        if (i === 1 && j === 1) {\n          continue;\n        }\n        console.log(\"testapproxRadicals testing with 4 digits:: \" + \"1 * sqrt( \" + i + \" / \" + j + \" )\");\n        fraction = i / j;\n        originalValue = Math.sqrt(i / j);\n        value = originalValue.toFixed(4);\n        returned = approxRadicals(value);\n        returnedValue = returned[2] * Math.sqrt(returned[3] / returned[4]);\n        if (returned[1] === approx_radicalOfRatio && Math.abs(originalValue - returnedValue) > 1e-15) {\n          console.log(\"fail testapproxRadicals with 4 digits:: \" + \"1 * sqrt( \" + i + \" / \" + j + \" ) . obtained: \" + returned);\n        }\n      }\n    }\n    for (i = r1 = 1; r1 <= 5; i = ++r1) {\n      for (j = s1 = 1; s1 <= 5; j = ++s1) {\n        console.log(\"testApproxAll testing: \" + \"1 * log(\" + i + \" ) / \" + j);\n        fraction = i / j;\n        value = Math.log(i) / j;\n        returned = approxAll(value);\n        returnedValue = returned[2] * Math.log(returned[3]) / returned[4];\n        if (Math.abs(value - returnedValue) > 1e-15) {\n          console.log(\"fail testApproxAll: \" + \"1 * log(\" + i + \" ) / \" + j + \" . obtained: \" + returned);\n        }\n      }\n    }\n    for (i = t1 = 1; t1 <= 5; i = ++t1) {\n      for (j = u1 = 1; u1 <= 5; j = ++u1) {\n        console.log(\"testApproxAll testing with 4 digits: \" + \"1 * log(\" + i + \" ) / \" + j);\n        fraction = i / j;\n        originalValue = Math.log(i) / j;\n        value = originalValue.toFixed(4);\n        returned = approxAll(value);\n        returnedValue = returned[2] * Math.log(returned[3]) / returned[4];\n        if (Math.abs(originalValue - returnedValue) > 1e-15) {\n          console.log(\"fail testApproxAll with 4 digits: \" + \"1 * log(\" + i + \" ) / \" + j + \" . obtained: \" + returned);\n        }\n      }\n    }\n    for (i = v1 = 1; v1 <= 5; i = ++v1) {\n      for (j = x1 = 1; x1 <= 5; j = ++x1) {\n        console.log(\"testApproxAll testing: \" + \"1 * log(\" + i + \" / \" + j + \" )\");\n        fraction = i / j;\n        value = Math.log(i / j);\n        returned = approxAll(value);\n        returnedValue = returned[2] * Math.log(returned[3] / returned[4]);\n        if (Math.abs(value - returnedValue) > 1e-15) {\n          console.log(\"fail testApproxAll: \" + \"1 * log(\" + i + \" / \" + j + \" )\" + \" . obtained: \" + returned);\n        }\n      }\n    }\n    for (i = z1 = 1; z1 <= 5; i = ++z1) {\n      for (j = i2 = 1; i2 <= 5; j = ++i2) {\n        console.log(\"testApproxAll testing with 4 digits: \" + \"1 * log(\" + i + \" / \" + j + \" )\");\n        fraction = i / j;\n        originalValue = Math.log(i / j);\n        value = originalValue.toFixed(4);\n        returned = approxAll(value);\n        returnedValue = returned[2] * Math.log(returned[3] / returned[4]);\n        if (Math.abs(originalValue - returnedValue) > 1e-15) {\n          console.log(\"fail testApproxAll with 4 digits: \" + \"1 * log(\" + i + \" / \" + j + \" )\" + \" . obtained: \" + returned);\n        }\n      }\n    }\n    for (i = j2 = 1; j2 <= 2; i = ++j2) {\n      for (j = l2 = 1; l2 <= 12; j = ++l2) {\n        console.log(\"testApproxAll testing: \" + \"1 * (e ^ \" + i + \" ) / \" + j);\n        fraction = i / j;\n        value = Math.pow(Math.E, i) / j;\n        returned = approxAll(value);\n        returnedValue = returned[2] * Math.pow(Math.E, returned[3]) / returned[4];\n        if (Math.abs(value - returnedValue) > 1e-15) {\n          console.log(\"fail testApproxAll: \" + \"1 * (e ^ \" + i + \" ) / \" + j + \" . obtained: \" + returned);\n        }\n      }\n    }\n    for (i = m2 = 1; m2 <= 2; i = ++m2) {\n      for (j = n2 = 1; n2 <= 12; j = ++n2) {\n        console.log(\"approxRationalsOfPowersOfE testing with 4 digits: \" + \"1 * (e ^ \" + i + \" ) / \" + j);\n        fraction = i / j;\n        originalValue = Math.pow(Math.E, i) / j;\n        value = originalValue.toFixed(4);\n        returned = approxRationalsOfPowersOfE(value);\n        returnedValue = returned[2] * Math.pow(Math.E, returned[3]) / returned[4];\n        if (Math.abs(originalValue - returnedValue) > 1e-15) {\n          console.log(\"fail approxRationalsOfPowersOfE with 4 digits: \" + \"1 * (e ^ \" + i + \" ) / \" + j + \" . obtained: \" + returned);\n        }\n      }\n    }\n    for (i = o2 = 1; o2 <= 2; i = ++o2) {\n      for (j = q2 = 1; q2 <= 12; j = ++q2) {\n        console.log(\"testApproxAll testing: \" + \"1 * pi ^ \" + i + \" / \" + j);\n        fraction = i / j;\n        value = Math.pow(Math.PI, i) / j;\n        returned = approxAll(value);\n        returnedValue = returned[2] * Math.pow(Math.PI, returned[3]) / returned[4];\n        if (Math.abs(value - returnedValue) > 1e-15) {\n          console.log(\"fail testApproxAll: \" + \"1 * pi ^ \" + i + \" / \" + j + \" ) . obtained: \" + returned);\n        }\n      }\n    }\n    for (i = r2 = 1; r2 <= 2; i = ++r2) {\n      for (j = s2 = 1; s2 <= 12; j = ++s2) {\n        console.log(\"approxRationalsOfPowersOfPI testing with 4 digits: \" + \"1 * pi ^ \" + i + \" / \" + j);\n        fraction = i / j;\n        originalValue = Math.pow(Math.PI, i) / j;\n        value = originalValue.toFixed(4);\n        returned = approxRationalsOfPowersOfPI(value);\n        returnedValue = returned[2] * Math.pow(Math.PI, returned[3]) / returned[4];\n        if (Math.abs(originalValue - returnedValue) > 1e-15) {\n          console.log(\"fail approxRationalsOfPowersOfPI with 4 digits: \" + \"1 * pi ^ \" + i + \" / \" + j + \" ) . obtained: \" + returned);\n        }\n      }\n    }\n    for (i = t2 = 1; t2 <= 4; i = ++t2) {\n      for (j = u2 = 1; u2 <= 4; j = ++u2) {\n        console.log(\"testApproxAll testing: \" + \"1 * sin( \" + i + \"/\" + j + \" )\");\n        fraction = i / j;\n        value = Math.sin(fraction);\n        returned = approxAll(value);\n        returnedFraction = returned[3] / returned[4];\n        returnedValue = returned[2] * Math.sin(returnedFraction);\n        if (Math.abs(value - returnedValue) > 1e-15) {\n          console.log(\"fail testApproxAll: \" + \"1 * sin( \" + i + \"/\" + j + \" ) . obtained: \" + returned);\n        }\n      }\n    }\n// 5 digits create no problem\n    for (i = v2 = 1; v2 <= 4; i = ++v2) {\n      for (j = x2 = 1; x2 <= 4; j = ++x2) {\n        console.log(\"testApproxAll testing with 5 digits: \" + \"1 * sin( \" + i + \"/\" + j + \" )\");\n        fraction = i / j;\n        originalValue = Math.sin(fraction);\n        value = originalValue.toFixed(5);\n        returned = approxAll(value);\n        if (returned == null) {\n          console.log(\"fail testApproxAll with 5 digits: \" + \"1 * sin( \" + i + \"/\" + j + \" ) . obtained:  undefined \");\n        }\n        returnedFraction = returned[3] / returned[4];\n        returnedValue = returned[2] * Math.sin(returnedFraction);\n        error = Math.abs(originalValue - returnedValue);\n        if (error > 1e-14) {\n          console.log(\"fail testApproxAll with 5 digits: \" + \"1 * sin( \" + i + \"/\" + j + \" ) . obtained: \" + returned + \" error: \" + error);\n        }\n      }\n    }\n// 4 digits create two collisions\n    for (i = z2 = 1; z2 <= 4; i = ++z2) {\n      for (j = i3 = 1; i3 <= 4; j = ++i3) {\n        console.log(\"testApproxAll testing with 4 digits: \" + \"1 * sin( \" + i + \"/\" + j + \" )\");\n        fraction = i / j;\n        originalValue = Math.sin(fraction);\n        value = originalValue.toFixed(4);\n        returned = approxAll(value);\n        if (returned == null) {\n          console.log(\"fail testApproxAll with 4 digits: \" + \"1 * sin( \" + i + \"/\" + j + \" ) . obtained:  undefined \");\n        }\n        returnedFraction = returned[3] / returned[4];\n        returnedValue = returned[2] * Math.sin(returnedFraction);\n        error = Math.abs(originalValue - returnedValue);\n        if (error > 1e-14) {\n          console.log(\"fail testApproxAll with 4 digits: \" + \"1 * sin( \" + i + \"/\" + j + \" ) . obtained: \" + returned + \" error: \" + error);\n        }\n      }\n    }\n    value = 0;\n    if (approxAll(value)[0] !== \"0\") {\n      console.log(\"fail testApproxAll: 0\");\n    }\n    value = 0.0;\n    if (approxAll(value)[0] !== \"0\") {\n      console.log(\"fail testApproxAll: 0.0\");\n    }\n    value = 0.00;\n    if (approxAll(value)[0] !== \"0\") {\n      console.log(\"fail testApproxAll: 0.00\");\n    }\n    value = 0.000;\n    if (approxAll(value)[0] !== \"0\") {\n      console.log(\"fail testApproxAll: 0.000\");\n    }\n    value = 0.0000;\n    if (approxAll(value)[0] !== \"0\") {\n      console.log(\"fail testApproxAll: 0.0000\");\n    }\n    value = 1;\n    if (approxAll(value)[0] !== \"1\") {\n      console.log(\"fail testApproxAll: 1\");\n    }\n    value = 1.0;\n    if (approxAll(value)[0] !== \"1\") {\n      console.log(\"fail testApproxAll: 1.0\");\n    }\n    value = 1.00;\n    if (approxAll(value)[0] !== \"1\") {\n      console.log(\"fail testApproxAll: 1.00\");\n    }\n    value = 1.000;\n    if (approxAll(value)[0] !== \"1\") {\n      console.log(\"fail testApproxAll: 1.000\");\n    }\n    value = 1.0000;\n    if (approxAll(value)[0] !== \"1\") {\n      console.log(\"fail testApproxAll: 1.0000\");\n    }\n    value = 1.00000;\n    if (approxAll(value)[0] !== \"1\") {\n      console.log(\"fail testApproxAll: 1.00000\");\n    }\n    value = Math.sqrt(2);\n    if (approxAll(value)[0] !== \"1 * sqrt( 2 ) / 1\") {\n      console.log(\"fail testApproxAll: Math.sqrt(2)\");\n    }\n    value = 1.41;\n    if (approxAll(value)[0] !== \"1 * sqrt( 2 ) / 1\") {\n      console.log(\"fail testApproxAll: 1.41\");\n    }\n    // if we narrow down to a particular family then we can get\n    // an OK guess even with few digits, expecially for really \"famous\" numbers\n    value = 1.4;\n    if (approxRadicals(value)[0] !== \"1 * sqrt( 2 ) / 1\") {\n      console.log(\"fail approxRadicals: 1.4\");\n    }\n    value = 0.6;\n    if (approxLogs(value)[0] !== \"1 * log( 2 ) / 1\") {\n      console.log(\"fail approxLogs: 0.6\");\n    }\n    value = 0.69;\n    if (approxLogs(value)[0] !== \"1 * log( 2 ) / 1\") {\n      console.log(\"fail approxLogs: 0.69\");\n    }\n    value = 0.7;\n    if (approxLogs(value)[0] !== \"1 * log( 2 ) / 1\") {\n      console.log(\"fail approxLogs: 0.7\");\n    }\n    value = 1.09;\n    if (approxLogs(value)[0] !== \"1 * log( 3 ) / 1\") {\n      console.log(\"fail approxLogs: 1.09\");\n    }\n    value = 1.09;\n    if (approxAll(value)[0] !== \"1 * log( 3 ) / 1\") {\n      console.log(\"fail approxAll: 1.09\");\n    }\n    value = 1.098;\n    if (approxAll(value)[0] !== \"1 * log( 3 ) / 1\") {\n      console.log(\"fail approxAll: 1.098\");\n    }\n    value = 1.1;\n    if (approxAll(value)[0] !== \"1 * log( 3 ) / 1\") {\n      console.log(\"fail approxAll: 1.1\");\n    }\n    value = 1.11;\n    if (approxAll(value)[0] !== \"1 * log( 3 ) / 1\") {\n      console.log(\"fail approxAll: 1.11\");\n    }\n    value = Math.sqrt(3);\n    if (approxAll(value)[0] !== \"1 * sqrt( 3 ) / 1\") {\n      console.log(\"fail testApproxAll: Math.sqrt(3)\");\n    }\n    value = 1.0000;\n    if (approxAll(value)[0] !== \"1\") {\n      console.log(\"fail testApproxAll: 1.0000\");\n    }\n    value = 3.141592;\n    if (approxAll(value)[0] !== \"1 * (pi ^ 1 ) / 1 )\") {\n      console.log(\"fail testApproxAll: 3.141592\");\n    }\n    value = 31.41592;\n    if (approxAll(value)[0] !== \"10 * (pi ^ 1 ) / 1 )\") {\n      console.log(\"fail testApproxAll: 31.41592\");\n    }\n    value = 314.1592;\n    if (approxAll(value)[0] !== \"100 * (pi ^ 1 ) / 1 )\") {\n      console.log(\"fail testApproxAll: 314.1592\");\n    }\n    value = 31415926.53589793;\n    if (approxAll(value)[0] !== \"10000000 * (pi ^ 1 ) / 1 )\") {\n      console.log(\"fail testApproxAll: 31415926.53589793\");\n    }\n    value = Math.sqrt(2);\n    if (approxTrigonometric(value)[0] !== \"2 * sin( 1/4 * pi )\") {\n      console.log(\"fail approxTrigonometric: Math.sqrt(2)\");\n    }\n    value = Math.sqrt(3);\n    if (approxTrigonometric(value)[0] !== \"2 * sin( 1/3 * pi )\") {\n      console.log(\"fail approxTrigonometric: Math.sqrt(3)\");\n    }\n    value = (Math.sqrt(6) - Math.sqrt(2)) / 4;\n    if (approxAll(value)[0] !== \"1 * sin( 1/12 * pi )\") {\n      console.log(\"fail testApproxAll: (Math.sqrt(6) - Math.sqrt(2))/4\");\n    }\n    value = Math.sqrt(2 - Math.sqrt(2)) / 2;\n    if (approxAll(value)[0] !== \"1 * sin( 1/8 * pi )\") {\n      console.log(\"fail testApproxAll: Math.sqrt(2 - Math.sqrt(2))/2\");\n    }\n    value = (Math.sqrt(6) + Math.sqrt(2)) / 4;\n    if (approxAll(value)[0] !== \"1 * sin( 5/12 * pi )\") {\n      console.log(\"fail testApproxAll: (Math.sqrt(6) + Math.sqrt(2))/4\");\n    }\n    value = Math.sqrt(2 + Math.sqrt(3)) / 2;\n    if (approxAll(value)[0] !== \"1 * sin( 5/12 * pi )\") {\n      console.log(\"fail testApproxAll: Math.sqrt(2 + Math.sqrt(3))/2\");\n    }\n    value = (Math.sqrt(5) - 1) / 4;\n    if (approxAll(value)[0] !== \"1 * sin( 1/10 * pi )\") {\n      console.log(\"fail testApproxAll: (Math.sqrt(5) - 1)/4\");\n    }\n    value = Math.sqrt(10 - 2 * Math.sqrt(5)) / 4;\n    if (approxAll(value)[0] !== \"1 * sin( 1/5 * pi )\") {\n      console.log(\"fail testApproxAll: Math.sqrt(10 - 2*Math.sqrt(5))/4\");\n    }\n    // this has a radical form but it's too long to write\n    value = Math.sin(Math.PI / 7);\n    if (approxAll(value)[0] !== \"1 * sin( 1/7 * pi )\") {\n      console.log(\"fail testApproxAll: Math.sin(Math.PI/7)\");\n    }\n    // this has a radical form but it's too long to write\n    value = Math.sin(Math.PI / 9);\n    if (approxAll(value)[0] !== \"1 * sin( 1/9 * pi )\") {\n      console.log(\"fail testApproxAll: Math.sin(Math.PI/9)\");\n    }\n    value = 1836.15267;\n    if (approxRationalsOfPowersOfPI(value)[0] !== \"6 * (pi ^ 5 ) / 1 )\") {\n      console.log(\"fail approxRationalsOfPowersOfPI: 1836.15267\");\n    }\n    for (i = j3 = 1; j3 <= 13; i = ++j3) {\n      for (j = k3 = 1; k3 <= 13; j = ++k3) {\n        console.log(\"approxTrigonometric testing: \" + \"1 * sin( \" + i + \"/\" + j + \" * pi )\");\n        fraction = i / j;\n        value = Math.sin(Math.PI * fraction);\n        // we specifically search for sines of rational multiples of PI\n        // because too many of them would be picked up as simple\n        // rationals.\n        returned = approxTrigonometric(value);\n        returnedFraction = returned[3] / returned[4];\n        returnedValue = returned[2] * Math.sin(Math.PI * returnedFraction);\n        if (Math.abs(value - returnedValue) > 1e-15) {\n          console.log(\"fail approxTrigonometric: \" + \"1 * sin( \" + i + \"/\" + j + \" * pi ) . obtained: \" + returned);\n        }\n      }\n    }\n    for (i = l3 = 1; l3 <= 13; i = ++l3) {\n      for (j = m3 = 1; m3 <= 13; j = ++m3) {\n        // with four digits, there are two collisions with the\n        // \"simple fraction\" argument hypotesis, which we prefer since\n        // it's a simpler expression, so let's skip those\n        // two tests\n        if (i === 5 && j === 11 || i === 6 && j === 11) {\n          continue;\n        }\n        console.log(\"approxTrigonometric testing with 4 digits: \" + \"1 * sin( \" + i + \"/\" + j + \" * pi )\");\n        fraction = i / j;\n        originalValue = Math.sin(Math.PI * fraction);\n        value = originalValue.toFixed(4);\n        // we specifically search for sines of rational multiples of PI\n        // because too many of them would be picked up as simple\n        // rationals.\n        returned = approxTrigonometric(value);\n        returnedFraction = returned[3] / returned[4];\n        returnedValue = returned[2] * Math.sin(Math.PI * returnedFraction);\n        error = Math.abs(originalValue - returnedValue);\n        if (error > 1e-14) {\n          console.log(\"fail approxTrigonometric with 4 digits: \" + \"1 * sin( \" + i + \"/\" + j + \" * pi ) . obtained: \" + returned + \" error: \" + error);\n        }\n      }\n    }\n    return console.log(\"testApprox done\");\n  };\n\n  $.approxRadicals = approxRadicals;\n\n  $.approxRationalsOfLogs = approxRationalsOfLogs;\n\n  $.approxAll = approxAll;\n\n  $.testApprox = testApprox;\n\n  Eval_arccos = function() {\n    push(cadr(p1));\n    Eval();\n    return arccos();\n  };\n\n  arccos = function() {\n    var d, errno, n;\n    n = 0;\n    d = 0.0;\n    save();\n    p1 = pop();\n    if (car(p1) === symbol(COS)) {\n      push(cadr(p1));\n      restore();\n      return;\n    }\n    if (isdouble(p1)) {\n      errno = 0;\n      d = Math.acos(p1.d);\n      if (errno) {\n        stop(\"arccos function argument is not in the interval [-1,1]\");\n      }\n      push_double(d);\n      restore();\n      return;\n    }\n    // if p1 == 1/sqrt(2) then return 1/4*pi (45 degrees)\n    // second if catches the other way of saying it, sqrt(2)/2\n    if ((isoneoversqrttwo(p1)) || (car(p1) === symbol(MULTIPLY) && equalq(car(cdr(p1)), 1, 2) && car(car(cdr(cdr(p1)))) === symbol(POWER) && equaln(car(cdr(car(cdr(cdr(p1))))), 2) && equalq(car(cdr(cdr(car(cdr(cdr(p1)))))), 1, 2))) {\n      if (evaluatingAsFloats) {\n        push_double(Math.PI / 4.0);\n      } else {\n        push_rational(1, 4);\n        push_symbol(PI);\n        multiply();\n      }\n      restore();\n      return;\n    }\n    // if p1 == -1/sqrt(2) then return 3/4*pi (135 degrees)\n    // second if catches the other way of saying it, -sqrt(2)/2\n    if ((isminusoneoversqrttwo(p1)) || (car(p1) === symbol(MULTIPLY) && equalq(car(cdr(p1)), -1, 2) && car(car(cdr(cdr(p1)))) === symbol(POWER) && equaln(car(cdr(car(cdr(cdr(p1))))), 2) && equalq(car(cdr(cdr(car(cdr(cdr(p1)))))), 1, 2))) {\n      if (evaluatingAsFloats) {\n        push_double(Math.PI * 3.0 / 4.0);\n      } else {\n        push_rational(3, 4);\n        push_symbol(PI);\n        multiply();\n      }\n      restore();\n      return;\n    }\n    // if p1 == sqrt(3)/2 then return 1/6*pi (30 degrees)\n    if (issqrtthreeovertwo(p1)) {\n      if (evaluatingAsFloats) {\n        push_double(Math.PI / 6.0);\n      } else {\n        push_rational(1, 6);\n        push_symbol(PI);\n        multiply();\n      }\n      restore();\n      return;\n    }\n    // if p1 == -sqrt(3)/2 then return 5/6*pi (150 degrees)\n    if (isminussqrtthreeovertwo(p1)) {\n      if (evaluatingAsFloats) {\n        push_double(5.0 * Math.PI / 6.0);\n      } else {\n        push_rational(5, 6);\n        push_symbol(PI);\n        multiply();\n      }\n      restore();\n      return;\n    }\n    if (!isrational(p1)) {\n      push_symbol(ARCCOS);\n      push(p1);\n      list(2);\n      restore();\n      return;\n    }\n    push(p1);\n    push_integer(2);\n    multiply();\n    n = pop_integer();\n    switch (n) {\n      case -2:\n        if (evaluatingAsFloats) {\n          push_double(Math.PI);\n        } else {\n          push_symbol(PI);\n        }\n        break;\n      case -1:\n        if (evaluatingAsFloats) {\n          push_double(Math.PI * 2.0 / 3.0);\n        } else {\n          push_rational(2, 3);\n          push_symbol(PI);\n          multiply();\n        }\n        break;\n      case 0:\n        if (evaluatingAsFloats) {\n          push_double(Math.PI / 2.0);\n        } else {\n          push_rational(1, 2);\n          push_symbol(PI);\n          multiply();\n        }\n        break;\n      case 1:\n        if (evaluatingAsFloats) {\n          push_double(Math.PI / 3.0);\n        } else {\n          push_rational(1, 3);\n          push_symbol(PI);\n          multiply();\n        }\n        break;\n      case 2:\n        if (evaluatingAsFloats) {\n          push_double(0.0);\n        } else {\n          push(zero);\n        }\n        break;\n      default:\n        push_symbol(ARCCOS);\n        push(p1);\n        list(2);\n    }\n    return restore();\n  };\n\n  Eval_arccosh = function() {\n    push(cadr(p1));\n    Eval();\n    return arccosh();\n  };\n\n  arccosh = function() {\n    var d;\n    d = 0.0;\n    save();\n    p1 = pop();\n    if (car(p1) === symbol(COSH)) {\n      push(cadr(p1));\n      restore();\n      return;\n    }\n    if (isdouble(p1)) {\n      d = p1.d;\n      if (d < 1.0) {\n        stop(\"arccosh function argument is less than 1.0\");\n      }\n      d = Math.log(d + Math.sqrt(d * d - 1.0));\n      push_double(d);\n      restore();\n      return;\n    }\n    if (isplusone(p1)) {\n      push(zero);\n      restore();\n      return;\n    }\n    push_symbol(ARCCOSH);\n    push(p1);\n    list(2);\n    return restore();\n  };\n\n  Eval_arcsin = function() {\n    push(cadr(p1));\n    Eval();\n    return arcsin();\n  };\n\n  arcsin = function() {\n    var d, errno, n;\n    n = 0;\n    d = 0;\n    save();\n    p1 = pop();\n    if (car(p1) === symbol(SIN)) {\n      push(cadr(p1));\n      restore();\n      return;\n    }\n    if (isdouble(p1)) {\n      errno = 0;\n      d = Math.asin(p1.d);\n      if (errno) {\n        stop(\"arcsin function argument is not in the interval [-1,1]\");\n      }\n      push_double(d);\n      restore();\n      return;\n    }\n    // if p1 == 1/sqrt(2) then return 1/4*pi (45 degrees)\n    // second if catches the other way of saying it, sqrt(2)/2\n    if ((isoneoversqrttwo(p1)) || (car(p1) === symbol(MULTIPLY) && equalq(car(cdr(p1)), 1, 2) && car(car(cdr(cdr(p1)))) === symbol(POWER) && equaln(car(cdr(car(cdr(cdr(p1))))), 2) && equalq(car(cdr(cdr(car(cdr(cdr(p1)))))), 1, 2))) {\n      push_rational(1, 4);\n      push_symbol(PI);\n      multiply();\n      restore();\n      return;\n    }\n    // if p1 == -1/sqrt(2) then return -1/4*pi (-45 degrees)\n    // second if catches the other way of saying it, -sqrt(2)/2\n    if ((isminusoneoversqrttwo(p1)) || (car(p1) === symbol(MULTIPLY) && equalq(car(cdr(p1)), -1, 2) && car(car(cdr(cdr(p1)))) === symbol(POWER) && equaln(car(cdr(car(cdr(cdr(p1))))), 2) && equalq(car(cdr(cdr(car(cdr(cdr(p1)))))), 1, 2))) {\n      if (evaluatingAsFloats) {\n        push_double(-Math.PI / 4.0);\n      } else {\n        push_rational(-1, 4);\n        push_symbol(PI);\n        multiply();\n      }\n      restore();\n      return;\n    }\n    // if p1 == sqrt(3)/2 then return 1/3*pi (60 degrees)\n    if (issqrtthreeovertwo(p1)) {\n      if (evaluatingAsFloats) {\n        push_double(Math.PI / 3.0);\n      } else {\n        push_rational(1, 3);\n        push_symbol(PI);\n        multiply();\n      }\n      restore();\n      return;\n    }\n    // if p1 == -sqrt(3)/2 then return -1/3*pi (-60 degrees)\n    if (isminussqrtthreeovertwo(p1)) {\n      if (evaluatingAsFloats) {\n        push_double(-Math.PI / 3.0);\n      } else {\n        push_rational(-1, 3);\n        push_symbol(PI);\n        multiply();\n      }\n      restore();\n      return;\n    }\n    if (!isrational(p1)) {\n      push_symbol(ARCSIN);\n      push(p1);\n      list(2);\n      restore();\n      return;\n    }\n    push(p1);\n    push_integer(2);\n    multiply();\n    n = pop_integer();\n    switch (n) {\n      case -2:\n        if (evaluatingAsFloats) {\n          push_double(-Math.PI / 2.0);\n        } else {\n          push_rational(-1, 2);\n          push_symbol(PI);\n          multiply();\n        }\n        break;\n      case -1:\n        if (evaluatingAsFloats) {\n          push_double(-Math.PI / 6.0);\n        } else {\n          push_rational(-1, 6);\n          push_symbol(PI);\n          multiply();\n        }\n        break;\n      case 0:\n        if (evaluatingAsFloats) {\n          push_double(0.0);\n        } else {\n          push(zero);\n        }\n        break;\n      case 1:\n        if (evaluatingAsFloats) {\n          push_double(Math.PI / 6.0);\n        } else {\n          push_rational(1, 6);\n          push_symbol(PI);\n          multiply();\n        }\n        break;\n      case 2:\n        if (evaluatingAsFloats) {\n          push_double(Math.PI / 2.0);\n        } else {\n          push_rational(1, 2);\n          push_symbol(PI);\n          multiply();\n        }\n        break;\n      default:\n        push_symbol(ARCSIN);\n        push(p1);\n        list(2);\n    }\n    return restore();\n  };\n\n  Eval_arcsinh = function() {\n    push(cadr(p1));\n    Eval();\n    return arcsinh();\n  };\n\n  arcsinh = function() {\n    var d;\n    d = 0.0;\n    save();\n    p1 = pop();\n    if (car(p1) === symbol(SINH)) {\n      push(cadr(p1));\n      restore();\n      return;\n    }\n    if (isdouble(p1)) {\n      d = p1.d;\n      d = Math.log(d + Math.sqrt(d * d + 1.0));\n      push_double(d);\n      restore();\n      return;\n    }\n    if (isZeroAtomOrTensor(p1)) {\n      push(zero);\n      restore();\n      return;\n    }\n    push_symbol(ARCSINH);\n    push(p1);\n    list(2);\n    return restore();\n  };\n\n  Eval_arctan = function() {\n    push(cadr(p1));\n    Eval();\n    return arctan();\n  };\n\n  arctan = function() {\n    var d, errno;\n    d = 0;\n    save();\n    p1 = pop();\n    if (car(p1) === symbol(TAN)) {\n      push(cadr(p1));\n      restore();\n      return;\n    }\n    if (isdouble(p1)) {\n      errno = 0;\n      d = Math.atan(p1.d);\n      if (errno) {\n        stop(\"arctan function error\");\n      }\n      push_double(d);\n      restore();\n      return;\n    }\n    if (isZeroAtomOrTensor(p1)) {\n      push(zero);\n      restore();\n      return;\n    }\n    if (isnegative(p1)) {\n      push(p1);\n      negate();\n      arctan();\n      negate();\n      restore();\n      return;\n    }\n    // arctan(sin(a) / cos(a)) ?\n    if (Find(p1, symbol(SIN)) && Find(p1, symbol(COS))) {\n      push(p1);\n      numerator();\n      p2 = pop();\n      push(p1);\n      denominator();\n      p3 = pop();\n      if (car(p2) === symbol(SIN) && car(p3) === symbol(COS) && equal(cadr(p2), cadr(p3))) {\n        push(cadr(p2));\n        restore();\n        return;\n      }\n    }\n    // arctan(1/sqrt(3)) -> pi/6\n    // second if catches the other way of saying it, sqrt(3)/3\n    if ((car(p1) === symbol(POWER) && equaln(cadr(p1), 3) && equalq(caddr(p1), -1, 2)) || (car(p1) === symbol(MULTIPLY) && equalq(car(cdr(p1)), 1, 3) && car(car(cdr(cdr(p1)))) === symbol(POWER) && equaln(car(cdr(car(cdr(cdr(p1))))), 3) && equalq(car(cdr(cdr(car(cdr(cdr(p1)))))), 1, 2))) {\n      push_rational(1, 6);\n      if (evaluatingAsFloats) {\n        push_double(Math.PI);\n      } else {\n        push(symbol(PI));\n      }\n      multiply();\n      restore();\n      return;\n    }\n    // arctan(1) -> pi/4\n    if (equaln(p1, 1)) {\n      push_rational(1, 4);\n      if (evaluatingAsFloats) {\n        push_double(Math.PI);\n      } else {\n        push(symbol(PI));\n      }\n      multiply();\n      restore();\n      return;\n    }\n    // arctan(sqrt(3)) -> pi/3\n    if (car(p1) === symbol(POWER) && equaln(cadr(p1), 3) && equalq(caddr(p1), 1, 2)) {\n      push_rational(1, 3);\n      if (evaluatingAsFloats) {\n        push_double(Math.PI);\n      } else {\n        push(symbol(PI));\n      }\n      multiply();\n      restore();\n      return;\n    }\n    push_symbol(ARCTAN);\n    push(p1);\n    list(2);\n    return restore();\n  };\n\n  Eval_arctanh = function() {\n    push(cadr(p1));\n    Eval();\n    return arctanh();\n  };\n\n  arctanh = function() {\n    var d;\n    d = 0.0;\n    save();\n    p1 = pop();\n    if (car(p1) === symbol(TANH)) {\n      push(cadr(p1));\n      restore();\n      return;\n    }\n    if (isdouble(p1)) {\n      d = p1.d;\n      if (d < -1.0 || d > 1.0) {\n        stop(\"arctanh function argument is not in the interval [-1,1]\");\n      }\n      d = Math.log((1.0 + d) / (1.0 - d)) / 2.0;\n      push_double(d);\n      restore();\n      return;\n    }\n    if (isZeroAtomOrTensor(p1)) {\n      push(zero);\n      restore();\n      return;\n    }\n    push_symbol(ARCTANH);\n    push(p1);\n    list(2);\n    return restore();\n  };\n\n  DEBUG_ARG = false;\n\n  Eval_arg = function() {\n    push(cadr(p1));\n    Eval();\n    return arg();\n  };\n\n  arg = function() {\n    save();\n    p1 = pop();\n    push(p1);\n    numerator();\n    yyarg();\n    push(p1);\n    denominator();\n    yyarg();\n    subtract();\n    return restore();\n  };\n\n  //define RE p2\n  //define IM p3\n  yyarg = function() {\n    save();\n    p1 = pop();\n    // case of plain number\n    if (ispositivenumber(p1) || p1 === symbol(PI)) {\n      if (isdouble(p1) || evaluatingAsFloats) {\n        push_double(0);\n      } else {\n        push_integer(0);\n      }\n    } else if (isnegativenumber(p1)) {\n      if (isdouble(p1) || evaluatingAsFloats) {\n        push_double(Math.PI);\n      } else {\n        push(symbol(PI));\n      }\n      negate();\n    // you'd think that something like\n    // arg(a) is always 0 when a is real but no,\n    // arg(a) is pi when a is negative so we have\n    // to leave unexpressed\n    } else if (issymbol(p1)) {\n      push_symbol(ARG);\n      push(p1);\n      list(2);\n    } else if (car(p1) === symbol(POWER) && equaln(cadr(p1), -1)) {\n      // -1 to a power\n      if (evaluatingAsFloats) {\n        push_double(Math.PI);\n      } else {\n        push(symbol(PI));\n      }\n      push(caddr(p1));\n      multiply();\n    } else if (car(p1) === symbol(POWER) && cadr(p1) === symbol(E)) {\n      // exponential\n      push(caddr(p1));\n      imag();\n    // arg(a^(1/2)) is always equal to 1/2 * arg(a)\n    // this can obviously be made more generic TODO\n    } else if (car(p1) === symbol(POWER) && isoneovertwo(caddr(p1))) {\n      if (DEBUG_ARG) {\n        console.log(\"arg of a sqrt: \" + p1);\n      }\n      if (DEBUG_ARG) {\n        debugger;\n      }\n      push(cadr(p1));\n      arg();\n      if (DEBUG_ARG) {\n        console.log(\" = 1/2 * \" + stack[tos - 1]);\n      }\n      push(caddr(p1));\n      multiply();\n    } else if (car(p1) === symbol(MULTIPLY)) {\n      // product of factors\n      push_integer(0);\n      p1 = cdr(p1);\n      while (iscons(p1)) {\n        push(car(p1));\n        arg();\n        add();\n        p1 = cdr(p1);\n      }\n    } else if (car(p1) === symbol(ADD)) {\n      // sum of terms\n      push(p1);\n      rect();\n      p1 = pop();\n      push(p1);\n      real();\n      p2 = pop();\n      push(p1);\n      imag();\n      p3 = pop();\n      if (isZeroAtomOrTensor(p2)) {\n        if (evaluatingAsFloats) {\n          push_double(Math.PI);\n        } else {\n          push(symbol(PI));\n        }\n        if (isnegative(p3)) {\n          negate();\n        }\n      } else {\n        push(p3);\n        push(p2);\n        divide();\n        arctan();\n        if (isnegative(p2)) {\n          if (evaluatingAsFloats) {\n            push_double(Math.PI);\n          } else {\n            push_symbol(PI);\n          }\n          if (isnegative(p3)) {\n            subtract(); // quadrant 1 -> 3\n          } else {\n            add(); // quadrant 4 -> 2\n          }\n        }\n      }\n    } else {\n      if (!isZeroAtomOrTensor(get_binding(symbol(ASSUME_REAL_VARIABLES)))) {\n        // if we assume all passed values are real\n        push_integer(0);\n      } else {\n        // if we don't assume all passed values are real, all\n        // we con do is to leave unexpressed\n        push_symbol(ARG);\n        push(p1);\n        list(2);\n      }\n    }\n    return restore();\n  };\n\n  // pretty print\n  bake = function() {\n    var h, s, t, x, y, z;\n    h = 0;\n    s = 0;\n    t = 0;\n    x = 0;\n    y = 0;\n    z = 0;\n    expanding++;\n    save();\n    p1 = pop();\n    s = ispolyexpandedform(p1, symbol(SYMBOL_S));\n    t = ispolyexpandedform(p1, symbol(SYMBOL_T));\n    x = ispolyexpandedform(p1, symbol(SYMBOL_X));\n    y = ispolyexpandedform(p1, symbol(SYMBOL_Y));\n    z = ispolyexpandedform(p1, symbol(SYMBOL_Z));\n    if (s === 1 && t === 0 && x === 0 && y === 0 && z === 0) {\n      p2 = symbol(SYMBOL_S);\n      bake_poly();\n    } else if (s === 0 && t === 1 && x === 0 && y === 0 && z === 0) {\n      p2 = symbol(SYMBOL_T);\n      bake_poly();\n    } else if (s === 0 && t === 0 && x === 1 && y === 0 && z === 0) {\n      p2 = symbol(SYMBOL_X);\n      bake_poly();\n    } else if (s === 0 && t === 0 && x === 0 && y === 1 && z === 0) {\n      p2 = symbol(SYMBOL_Y);\n      bake_poly();\n    } else if (s === 0 && t === 0 && x === 0 && y === 0 && z === 1) {\n      p2 = symbol(SYMBOL_Z);\n      bake_poly();\n    // don't bake the contents of some constructs such as \"for\"\n    // because we don't want to evaluate the body of\n    // such constructs \"statically\", i.e. without fully running\n    // the loops.\n    } else if ((iscons(p1)) && car(p1) !== symbol(FOR)) {\n      h = tos;\n      push(car(p1));\n      p1 = cdr(p1);\n      while (iscons(p1)) {\n        push(car(p1));\n        bake();\n        p1 = cdr(p1);\n      }\n      list(tos - h);\n    } else {\n      push(p1);\n    }\n    restore();\n    return expanding--;\n  };\n\n  polyform = function() {\n    var h;\n    h = 0;\n    save();\n    p2 = pop();\n    p1 = pop();\n    if (ispolyexpandedform(p1, p2)) {\n      bake_poly();\n    } else if (iscons(p1)) {\n      h = tos;\n      push(car(p1));\n      p1 = cdr(p1);\n      while (iscons(p1)) {\n        push(car(p1));\n        push(p2);\n        polyform();\n        p1 = cdr(p1);\n      }\n      list(tos - h);\n    } else {\n      push(p1);\n    }\n    return restore();\n  };\n\n  bake_poly = function() {\n    var a, h, i, k, n, o, ref;\n    h = 0;\n    i = 0;\n    k = 0;\n    n = 0;\n    //U **a\n    a = tos;\n    k = coeff(p2, p1);\n    h = tos;\n    for (i = o = ref = k - 1; o >= 0; i = o += -1) {\n      p1 = stack[a + i];\n      bake_poly_term(i);\n    }\n    n = tos - h;\n    if (n > 1) {\n      list(n);\n      push(symbol(ADD));\n      swap();\n      cons();\n    }\n    p1 = pop();\n    moveTos(tos - k);\n    return push(p1);\n  };\n\n  // p1 points to coefficient of p2 ^ k\n\n  // k is an int\n  bake_poly_term = function(k) {\n    var h, n;\n    h = 0;\n    n = 0;\n    if (isZeroAtomOrTensor(p1)) {\n      return;\n    }\n    // constant term?\n    if (k === 0) {\n      if (car(p1) === symbol(ADD)) {\n        p1 = cdr(p1);\n        while (iscons(p1)) {\n          push(car(p1));\n          p1 = cdr(p1);\n        }\n      } else {\n        push(p1);\n      }\n      return;\n    }\n    h = tos;\n    // coefficient\n    if (car(p1) === symbol(MULTIPLY)) {\n      p1 = cdr(p1);\n      while (iscons(p1)) {\n        push(car(p1));\n        p1 = cdr(p1);\n      }\n    } else if (!equaln(p1, 1)) {\n      push(p1);\n    }\n    // x ^ k\n    if (k === 1) {\n      push(p2);\n    } else {\n      push(symbol(POWER));\n      push(p2);\n      push_integer(k);\n      list(3);\n    }\n    n = tos - h;\n    if (n > 1) {\n      list(n);\n      push(symbol(MULTIPLY));\n      swap();\n      return cons();\n    }\n  };\n\n  Eval_besselj = function() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    return besselj();\n  };\n\n  besselj = function() {\n    save();\n    yybesselj();\n    return restore();\n  };\n\n  //define X p1\n  //define N p2\n  //define SGN p3\n  yybesselj = function() {\n    var d, n;\n    d = 0.0;\n    n = 0;\n    p2 = pop();\n    p1 = pop();\n    push(p2);\n    n = pop_integer();\n    // numerical result\n    if (isdouble(p1) && !isNaN(n)) {\n      d = jn(n, p1.d);\n      push_double(d);\n      return;\n    }\n    // bessej(0,0) = 1\n    if (isZeroAtomOrTensor(p1) && isZeroAtomOrTensor(p2)) {\n      push_integer(1);\n      return;\n    }\n    // besselj(0,n) = 0\n    if (isZeroAtomOrTensor(p1) && !isNaN(n)) {\n      push_integer(0);\n      return;\n    }\n    // half arguments\n    if (p2.k === NUM && MEQUAL(p2.q.b, 2)) {\n      // n = 1/2\n      if (MEQUAL(p2.q.a, 1)) {\n        if (evaluatingAsFloats) {\n          push_double(2.0 / Math.PI);\n        } else {\n          push_integer(2);\n          push_symbol(PI);\n          divide();\n        }\n        push(p1);\n        divide();\n        push_rational(1, 2);\n        power();\n        push(p1);\n        sine();\n        multiply();\n        return;\n      }\n      // n = -1/2\n      if (MEQUAL(p2.q.a, -1)) {\n        if (evaluatingAsFloats) {\n          push_double(2.0 / Math.PI);\n        } else {\n          push_integer(2);\n          push_symbol(PI);\n          divide();\n        }\n        push(p1);\n        divide();\n        push_rational(1, 2);\n        power();\n        push(p1);\n        cosine();\n        multiply();\n        return;\n      }\n      // besselj(x,n) = (2/x) (n-sgn(n)) besselj(x,n-sgn(n)) - besselj(x,n-2*sgn(n))\n      push_integer(MSIGN(p2.q.a));\n      p3 = pop();\n      push_integer(2);\n      push(p1);\n      divide();\n      push(p2);\n      push(p3);\n      subtract();\n      multiply();\n      push(p1);\n      push(p2);\n      push(p3);\n      subtract();\n      besselj();\n      multiply();\n      push(p1);\n      push(p2);\n      push_integer(2);\n      push(p3);\n      multiply();\n      subtract();\n      besselj();\n      subtract();\n      return;\n    }\n    //if 0 # test cases needed\n    if (isnegativeterm(p1)) {\n      push(p1);\n      negate();\n      push(p2);\n      power();\n      push(p1);\n      push(p2);\n      negate();\n      power();\n      multiply();\n      push_symbol(BESSELJ);\n      push(p1);\n      negate();\n      push(p2);\n      list(3);\n      multiply();\n      return;\n    }\n    if (isnegativeterm(p2)) {\n      push_integer(-1);\n      push(p2);\n      power();\n      push_symbol(BESSELJ);\n      push(p1);\n      push(p2);\n      negate();\n      list(3);\n      multiply();\n      return;\n    }\n    //endif\n    push(symbol(BESSELJ));\n    push(p1);\n    push(p2);\n    return list(3);\n  };\n\n  Eval_bessely = function() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    return bessely();\n  };\n\n  bessely = function() {\n    save();\n    yybessely();\n    return restore();\n  };\n\n  //define X p1\n  //define N p2\n  yybessely = function() {\n    var d, n;\n    d = 0.0;\n    n = 0;\n    p2 = pop();\n    p1 = pop();\n    push(p2);\n    n = pop_integer();\n    if (isdouble(p1) && !isNaN(n)) {\n      d = yn(n, p1.d);\n      push_double(d);\n      return;\n    }\n    if (isnegativeterm(p2)) {\n      push_integer(-1);\n      push(p2);\n      power();\n      push_symbol(BESSELY);\n      push(p1);\n      push(p2);\n      negate();\n      list(3);\n      multiply();\n      return;\n    }\n    push_symbol(BESSELY);\n    push(p1);\n    push(p2);\n    list(3);\n  };\n\n  //double convert_rational_to_double(U *)\n  //double convert_bignum_to_double(unsigned int *)\n  //int ge(unsigned int *, unsigned int *, int)\n  mint = function(a) {\n    return bigInt(a);\n  };\n\n  isSmall = function(a) {\n    return a.geq(Number.MIN_SAFE_INTEGER) && a.leq(Number.MAX_SAFE_INTEGER);\n  };\n\n  // b is +1 or -1, a is a bigint\n  setSignTo = function(a, b) {\n    if (a.isPositive()) {\n      if (b < 0) {\n        return a.multiply(bigInt(-1));\n      }\n    } else {\n      // a is negative\n      if (b > 0) {\n        return a.multiply(bigInt(-1));\n      }\n    }\n    return a;\n  };\n\n  makeSignSameAs = function(a, b) {\n    if (a.isPositive()) {\n      if (b.isNegative()) {\n        return a.multiply(bigInt(-1));\n      }\n    } else {\n      // a is negative\n      if (b.isPositive()) {\n        return a.multiply(bigInt(-1));\n      }\n    }\n    return a;\n  };\n\n  makePositive = function(a) {\n    if (a.isNegative()) {\n      return a.multiply(bigInt(-1));\n    }\n    return a;\n  };\n\n  // n is an int\n  /*\n  mtotal = 0\n  MP_MIN_SIZE = 2\n  MP_MAX_FREE  = 1000\n\n  mnew = (n) ->\n    if (n < MP_MIN_SIZE)\n      n = MP_MIN_SIZE\n    if (n == MP_MIN_SIZE && mfreecount)\n      p = free_stack[--mfreecount]\n    else\n      p = [] #(unsigned int *) malloc((n + 3) * sizeof (int))\n      #if (p == 0)\n   *  stop(\"malloc failure\")\n    p[0] = n\n    mtotal += n\n    return p[3]\n   */\n  // p is the index of array of ints\n  // !!! array wasn't passed here\n  /*\n  free_stack = []\n\n  mfree = (array, p) ->\n    p -= 3\n    mtotal -= array[p]\n    if (array[p] == MP_MIN_SIZE && mfreecount < MP_MAX_FREE)\n      free_stack[mfreecount++] = p\n    else\n      free(p)\n  */\n  // convert int to bignum\n\n  // n is an int\n  /*\n  mint = (n) ->\n    p = mnew(1)\n    if (n < 0)\n   * !!! this is FU\n   * MSIGN(p) = -1\n      fu = true\n    else\n   * !!! this is FU\n      #MSIGN(p) = 1\n      fu = true\n   * !!! this is FU\n    #MLENGTH(p) = 1\n    p[0] = Math.abs(n)\n    return p\n   */\n  // copy bignum\n\n  // a is an array of ints\n  /*\n  mcopy = (a) ->\n    #unsigned int *b\n\n    b = mnew(MLENGTH(a))\n\n   * !!! fu\n    #MSIGN(b) = MSIGN(a)\n    #MLENGTH(b) = MLENGTH(a)\n\n    for i in [0...MLENGTH(a)]\n      b[i] = a[i]\n\n    return b\n   */\n  /*\n   * \n   * ge not invoked from anywhere - is you need ge\n   * just use the bigNum's ge implementation\n   * leaving it here just in case I decide to backport to C\n   *\n   * a >= b ?\n   * and and b arrays of ints, len is an int\n  ge = (a, b, len) ->\n    i = 0\n    for i in [0...len]\n      if (a[i] == b[i])\n        continue\n      else\n        break\n    if (a[i] >= b[i])\n      return 1\n    else\n      return 0\n   */\n  add_numbers = function() {\n    var a, b, theResult;\n    a = 1.0;\n    b = 1.0;\n    //if DEBUG then console.log(\"add_numbers adding numbers: \" + print_list(stack[tos - 1]) + \" and \" + print_list(stack[tos - 2]))\n    if (isrational(stack[tos - 1]) && isrational(stack[tos - 2])) {\n      qadd();\n      return;\n    }\n    save();\n    p2 = pop();\n    p1 = pop();\n    if (isdouble(p1)) {\n      a = p1.d;\n    } else {\n      a = convert_rational_to_double(p1);\n    }\n    if (isdouble(p2)) {\n      b = p2.d;\n    } else {\n      b = convert_rational_to_double(p2);\n    }\n    theResult = a + b;\n    push_double(theResult);\n    return restore();\n  };\n\n  subtract_numbers = function() {\n    var a, b;\n    a = 0.0;\n    b = 0.0;\n    if (isrational(stack[tos - 1]) && isrational(stack[tos - 2])) {\n      qsub();\n      return;\n    }\n    save();\n    p2 = pop();\n    p1 = pop();\n    if (isdouble(p1)) {\n      a = p1.d;\n    } else {\n      a = convert_rational_to_double(p1);\n    }\n    if (isdouble(p2)) {\n      b = p2.d;\n    } else {\n      b = convert_rational_to_double(p2);\n    }\n    push_double(a - b);\n    return restore();\n  };\n\n  multiply_numbers = function() {\n    var a, b;\n    a = 0.0;\n    b = 0.0;\n    if (isrational(stack[tos - 1]) && isrational(stack[tos - 2])) {\n      qmul();\n      return;\n    }\n    save();\n    p2 = pop();\n    p1 = pop();\n    if (isdouble(p1)) {\n      a = p1.d;\n    } else {\n      a = convert_rational_to_double(p1);\n    }\n    if (isdouble(p2)) {\n      b = p2.d;\n    } else {\n      b = convert_rational_to_double(p2);\n    }\n    push_double(a * b);\n    return restore();\n  };\n\n  divide_numbers = function() {\n    var a, b;\n    a = 0.0;\n    b = 0.0;\n    if (isrational(stack[tos - 1]) && isrational(stack[tos - 2])) {\n      qdiv();\n      return;\n    }\n    save();\n    p2 = pop();\n    p1 = pop();\n    if (isZeroAtomOrTensor(p2)) {\n      stop(\"divide by zero\");\n    }\n    if (isdouble(p1)) {\n      a = p1.d;\n    } else {\n      a = convert_rational_to_double(p1);\n    }\n    if (isdouble(p2)) {\n      b = p2.d;\n    } else {\n      b = convert_rational_to_double(p2);\n    }\n    push_double(a / b);\n    return restore();\n  };\n\n  invert_number = function() {\n    var a, b;\n    //unsigned int *a, *b\n    save();\n    p1 = pop();\n    if (isZeroAtomOrTensor(p1)) {\n      stop(\"divide by zero\");\n    }\n    if (isdouble(p1)) {\n      push_double(1 / p1.d);\n      restore();\n      return;\n    }\n    a = bigInt(p1.q.a);\n    b = bigInt(p1.q.b);\n    b = makeSignSameAs(b, a);\n    a = setSignTo(a, 1);\n    p1 = new U();\n    p1.k = NUM;\n    p1.q.a = b;\n    p1.q.b = a;\n    push(p1);\n    return restore();\n  };\n\n  // a and b are Us\n  compare_rationals = function(a, b) {\n    var ab, ba, t;\n    t = 0;\n    //unsigned int *ab, *ba\n    ab = mmul(a.q.a, b.q.b);\n    ba = mmul(a.q.b, b.q.a);\n    t = mcmp(ab, ba);\n    return t;\n  };\n\n  // a and b are Us\n  compare_numbers = function(a, b) {\n    var x, y;\n    x = 0.0;\n    y = 0.0;\n    if (isrational(a) && isrational(b)) {\n      return compare_rationals(a, b);\n    }\n    if (isdouble(a)) {\n      x = a.d;\n    } else {\n      x = convert_rational_to_double(a);\n    }\n    if (isdouble(b)) {\n      y = b.d;\n    } else {\n      y = convert_rational_to_double(b);\n    }\n    if (x < y) {\n      return -1;\n    }\n    if (x > y) {\n      return 1;\n    }\n    return 0;\n  };\n\n  negate_number = function() {\n    save();\n    p1 = pop();\n    if (isZeroAtomOrTensor(p1)) {\n      push(p1);\n      restore();\n      return;\n    }\n    switch (p1.k) {\n      case NUM:\n        p2 = new U();\n        p2.k = NUM;\n        p2.q.a = bigInt(p1.q.a.multiply(bigInt.minusOne));\n        p2.q.b = bigInt(p1.q.b);\n        push(p2);\n        break;\n      case DOUBLE:\n        push_double(-p1.d);\n        break;\n      default:\n        stop(\"bug caught in mp_negate_number\");\n    }\n    return restore();\n  };\n\n  bignum_truncate = function() {\n    var a;\n    //unsigned int *a\n    save();\n    p1 = pop();\n    a = mdiv(p1.q.a, p1.q.b);\n    p1 = new U();\n    p1.k = NUM;\n    p1.q.a = a;\n    p1.q.b = bigInt(1);\n    push(p1);\n    return restore();\n  };\n\n  mp_numerator = function() {\n    save();\n    p1 = pop();\n    if (p1.k !== NUM) {\n      push(one);\n      restore();\n      return;\n    }\n    p2 = new U();\n    p2.k = NUM;\n    p2.q.a = bigInt(p1.q.a);\n    p2.q.b = bigInt(1);\n    push(p2);\n    return restore();\n  };\n\n  mp_denominator = function() {\n    save();\n    p1 = pop();\n    if (p1.k !== NUM) {\n      push(one);\n      restore();\n      return;\n    }\n    p2 = new U();\n    p2.k = NUM;\n    p2.q.a = bigInt(p1.q.b);\n    p2.q.b = bigInt(1);\n    push(p2);\n    return restore();\n  };\n\n  // expo is an integer\n  bignum_power_number = function(expo) {\n    var a, b, t;\n    //unsigned int *a, *b, *t\n    save();\n    p1 = pop();\n    a = mpow(p1.q.a, Math.abs(expo));\n    b = mpow(p1.q.b, Math.abs(expo));\n    if (expo < 0) {\n      // swap a and b\n      t = a;\n      a = b;\n      b = t;\n      a = makeSignSameAs(a, b);\n      b = setSignTo(b, 1);\n    }\n    p1 = new U();\n    p1.k = NUM;\n    p1.q.a = a;\n    p1.q.b = b;\n    push(p1);\n    return restore();\n  };\n\n  // p an array of ints\n  convert_bignum_to_double = function(p) {\n    return p.toJSNumber();\n  };\n\n  // p is a U\n  convert_rational_to_double = function(p) {\n    var quotientAndRemainder, result;\n    if (p.q == null) {\n      debugger;\n    }\n    quotientAndRemainder = p.q.a.divmod(p.q.b);\n    result = quotientAndRemainder.quotient + quotientAndRemainder.remainder / p.q.b.toJSNumber();\n    return result;\n  };\n\n  // n an integer\n  new_integer = function(n) {\n    var theNewInteger;\n    theNewInteger = new U();\n    theNewInteger.k = NUM;\n    theNewInteger.q.a = bigInt(n);\n    theNewInteger.q.b = bigInt(1);\n    return theNewInteger;\n  };\n\n  // n an integer\n  push_integer = function(n) {\n    if (DEBUG) {\n      console.log(\"pushing integer \" + n);\n    }\n    return push(new_integer(n));\n  };\n\n  // d a double\n  push_double = function(d) {\n    save();\n    p1 = new U();\n    p1.k = DOUBLE;\n    p1.d = d;\n    push(p1);\n    return restore();\n  };\n\n  // a,b parts of a rational\n  push_rational = function(a, b) {\n    /*\n    save()\n    p1 = new U()\n    p1.k = NUM\n    p1.q.a = bigInt(a)\n    p1.q.b = bigInt(b)\n    ## FIXME -- normalize ##\n    push(p1)\n    restore()\n     */\n    var p;\n    p = new U();\n    p.k = NUM;\n    p.q.a = bigInt(a);\n    p.q.b = bigInt(b);\n    return push(p);\n  };\n\n  pop_integer = function() {\n    var n;\n    n = 0/0;\n    save();\n    p1 = pop();\n    switch (p1.k) {\n      case NUM:\n        if (isinteger(p1) && isSmall(p1.q.a)) {\n          n = p1.q.a.toJSNumber();\n        }\n        break;\n      case DOUBLE:\n        if (DEBUG) {\n          console.log(\"popping integer but double is found\");\n        }\n        if (Math.floor(p1.d) === p1.d) {\n          if (DEBUG) {\n            console.log(\"...altough it's an integer\");\n          }\n          n = p1.d;\n        }\n    }\n    restore();\n    return n;\n  };\n\n  // p is a U, flag is an int\n  print_double = function(p, flag) {\n    var accumulator, buf;\n    accumulator = \"\";\n    buf = doubleToReasonableString(p.d);\n    if (flag === 1 && buf === '-') {\n      accumulator += print_str(buf + 1);\n    } else {\n      accumulator += print_str(buf);\n    }\n    return accumulator;\n  };\n\n  // s is a string\n  bignum_scan_integer = function(s) {\n    var a, scounter, sign_;\n    //unsigned int *a\n    //char sign\n    save();\n    scounter = 0;\n    sign_ = s[scounter];\n    if (sign_ === '+' || sign_ === '-') {\n      scounter++;\n    }\n    // !!!! some mess in here, added an argument\n    a = bigInt(s.substring(scounter));\n    p1 = new U();\n    p1.k = NUM;\n    p1.q.a = a;\n    p1.q.b = bigInt(1);\n    push(p1);\n    if (sign_ === '-') {\n      negate();\n    }\n    return restore();\n  };\n\n  // s a string\n  bignum_scan_float = function(s) {\n    return push_double(parseFloat(s));\n  };\n\n  // gives the capability of printing the unsigned\n  // value. This is handy because printing of the sign\n  // might be taken care of \"upstream\"\n  // e.g. when printing a base elevated to a negative exponent\n  // prints the inverse of the base powered to the unsigned\n  // exponent.\n  // p is a U\n  print_number = function(p, signed) {\n    var aAsString, accumulator, buf, denominatorString;\n    accumulator = \"\";\n    denominatorString = \"\";\n    buf = \"\";\n    switch (p.k) {\n      case NUM:\n        aAsString = p.q.a.toString();\n        if (!signed) {\n          if (aAsString[0] === \"-\") {\n            aAsString = aAsString.substring(1);\n          }\n        }\n        if (printMode === PRINTMODE_LATEX && isfraction(p)) {\n          aAsString = \"\\\\frac{\" + aAsString + \"}{\";\n        }\n        accumulator += aAsString;\n        if (isfraction(p)) {\n          if (printMode !== PRINTMODE_LATEX) {\n            accumulator += \"/\";\n          }\n          denominatorString = p.q.b.toString();\n          if (printMode === PRINTMODE_LATEX) {\n            denominatorString += \"}\";\n          }\n          accumulator += denominatorString;\n        }\n        break;\n      case DOUBLE:\n        aAsString = doubleToReasonableString(p.d);\n        if (!signed) {\n          if (aAsString[0] === \"-\") {\n            aAsString = aAsString.substring(1);\n          }\n        }\n        accumulator += aAsString;\n    }\n    return accumulator;\n  };\n\n  gcd_numbers = function() {\n    save();\n    p2 = pop();\n    p1 = pop();\n    //  if (!isinteger(p1) || !isinteger(p2))\n    //    stop(\"integer args expected for gcd\")\n    p3 = new U();\n    p3.k = NUM;\n    p3.q.a = mgcd(p1.q.a, p2.q.a);\n    p3.q.b = mgcd(p1.q.b, p2.q.b);\n    p3.q.a = setSignTo(p3.q.a, 1);\n    push(p3);\n    return restore();\n  };\n\n  pop_double = function() {\n    var d;\n    d = 0.0;\n    save();\n    p1 = pop();\n    switch (p1.k) {\n      case NUM:\n        d = convert_rational_to_double(p1);\n        break;\n      case DOUBLE:\n        d = p1.d;\n        break;\n      default:\n        d = 0.0;\n    }\n    restore();\n    return d;\n  };\n\n  bignum_float = function() {\n    var d;\n    d = 0.0;\n    d = convert_rational_to_double(pop());\n    return push_double(d);\n  };\n\n  //static unsigned int *__factorial(int)\n\n  // n is an int\n  bignum_factorial = function(n) {\n    save();\n    p1 = new U();\n    p1.k = NUM;\n    p1.q.a = __factorial(n);\n    p1.q.b = bigInt(1);\n    push(p1);\n    return restore();\n  };\n\n  // n is an int\n  __factorial = function(n) {\n    var a, b, i, o, ref, t;\n    i = 0;\n    //unsigned int *a, *b, *t\n    if (n === 0 || n === 1) {\n      a = bigInt(1);\n      return a;\n    }\n    a = bigInt(2);\n    b = bigInt(0);\n    if (3 <= n) {\n      for (i = o = 3, ref = n; (3 <= ref ? o <= ref : o >= ref); i = 3 <= ref ? ++o : --o) {\n        b = bigInt(i);\n        t = mmul(a, b);\n        a = t;\n      }\n    }\n    return a;\n  };\n\n  mask = [0x00000001, 0x00000002, 0x00000004, 0x00000008, 0x00000010, 0x00000020, 0x00000040, 0x00000080, 0x00000100, 0x00000200, 0x00000400, 0x00000800, 0x00001000, 0x00002000, 0x00004000, 0x00008000, 0x00010000, 0x00020000, 0x00040000, 0x00080000, 0x00100000, 0x00200000, 0x00400000, 0x00800000, 0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000, 0x20000000, 0x40000000, 0x80000000];\n\n  // unsigned int *x, unsigned int k\n  mp_set_bit = function(x, k) {\n    console.log(\"not implemented yet\");\n    debugger;\n    return x[k / 32] |= mask[k % 32];\n  };\n\n  // unsigned int *x, unsigned int k\n  mp_clr_bit = function(x, k) {\n    console.log(\"not implemented yet\");\n    debugger;\n    return x[k / 32] &= ~mask[k % 32];\n  };\n\n  // unsigned int *a\n  mshiftright = function(a) {\n    return a = a.shiftRight();\n  };\n\n  //  Binomial coefficient\n\n  //  Input:    tos-2    n\n\n  //      tos-1    k\n\n  //  Output:    Binomial coefficient on stack\n\n  //  binomial(n, k) = n! / k! / (n - k)!\n\n  //  The binomial coefficient vanishes for k < 0 or k > n. (A=B, p. 19)\n  Eval_binomial = function() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    return binomial();\n  };\n\n  binomial = function() {\n    save();\n    ybinomial();\n    return restore();\n  };\n\n  //define N p1\n  //define K p2\n  ybinomial = function() {\n    p2 = pop();\n    p1 = pop();\n    if (BINOM_check_args() === 0) {\n      push(zero);\n      return;\n    }\n    push(p1);\n    factorial();\n    push(p2);\n    factorial();\n    divide();\n    push(p1);\n    push(p2);\n    subtract();\n    factorial();\n    return divide();\n  };\n\n  BINOM_check_args = function() {\n    if (isNumericAtom(p1) && lessp(p1, zero)) {\n      return 0;\n    } else if (isNumericAtom(p2) && lessp(p2, zero)) {\n      return 0;\n    } else if (isNumericAtom(p1) && isNumericAtom(p2) && lessp(p1, p2)) {\n      return 0;\n    } else {\n      return 1;\n    }\n  };\n\n  Eval_ceiling = function() {\n    push(cadr(p1));\n    Eval();\n    return ceiling();\n  };\n\n  ceiling = function() {\n    save();\n    yyceiling();\n    return restore();\n  };\n\n  yyceiling = function() {\n    var d, doNothing;\n    d = 0.0;\n    p1 = pop();\n    if (!isNumericAtom(p1)) {\n      push_symbol(CEILING);\n      push(p1);\n      list(2);\n      return;\n    }\n    if (isdouble(p1)) {\n      d = Math.ceil(p1.d);\n      push_double(d);\n      return;\n    }\n    if (isinteger(p1)) {\n      push(p1);\n      return;\n    }\n    p3 = new U();\n    p3.k = NUM;\n    p3.q.a = mdiv(p1.q.a, p1.q.b);\n    p3.q.b = mint(1);\n    push(p3);\n    if (isnegativenumber(p1)) {\n      return doNothing = 1;\n    } else {\n      push_integer(1);\n      return add();\n    }\n  };\n\n  Eval_choose = function() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    return choose();\n  };\n\n  // Result vanishes for k < 0 or k > n. (A=B, p. 19)\n\n  //define N p1\n  //define K p2\n  choose = function() {\n    save();\n    p2 = pop();\n    p1 = pop();\n    if (choose_check_args() === 0) {\n      push_integer(0);\n      restore();\n      return;\n    }\n    push(p1);\n    factorial();\n    push(p2);\n    factorial();\n    divide();\n    push(p1);\n    push(p2);\n    subtract();\n    factorial();\n    divide();\n    return restore();\n  };\n\n  choose_check_args = function() {\n    if (isNumericAtom(p1) && lessp(p1, zero)) {\n      return 0;\n    } else if (isNumericAtom(p2) && lessp(p2, zero)) {\n      return 0;\n    } else if (isNumericAtom(p1) && isNumericAtom(p2) && lessp(p1, p2)) {\n      return 0;\n    } else {\n      return 1;\n    }\n  };\n\n  Eval_circexp = function() {\n    push(cadr(p1));\n    Eval();\n    circexp();\n    // normalize\n    return Eval();\n  };\n\n  circexp = function() {\n    var h, i, o, ref;\n    i = 0;\n    h = 0;\n    save();\n    p1 = pop();\n    if (car(p1) === symbol(COS)) {\n      push(cadr(p1));\n      expcos();\n      restore();\n      return;\n    }\n    if (car(p1) === symbol(SIN)) {\n      push(cadr(p1));\n      expsin();\n      restore();\n      return;\n    }\n    if (car(p1) === symbol(TAN)) {\n      p1 = cadr(p1);\n      push(imaginaryunit);\n      push(p1);\n      multiply();\n      exponential();\n      p2 = pop();\n      push(imaginaryunit);\n      push(p1);\n      multiply();\n      negate();\n      exponential();\n      p3 = pop();\n      push(p3);\n      push(p2);\n      subtract();\n      push(imaginaryunit);\n      multiply();\n      push(p2);\n      push(p3);\n      add();\n      divide();\n      restore();\n      return;\n    }\n    if (car(p1) === symbol(COSH)) {\n      p1 = cadr(p1);\n      push(p1);\n      exponential();\n      push(p1);\n      negate();\n      exponential();\n      add();\n      push_rational(1, 2);\n      multiply();\n      restore();\n      return;\n    }\n    if (car(p1) === symbol(SINH)) {\n      p1 = cadr(p1);\n      push(p1);\n      exponential();\n      push(p1);\n      negate();\n      exponential();\n      subtract();\n      push_rational(1, 2);\n      multiply();\n      restore();\n      return;\n    }\n    if (car(p1) === symbol(TANH)) {\n      p1 = cadr(p1);\n      push(p1);\n      push_integer(2);\n      multiply();\n      exponential();\n      p1 = pop();\n      push(p1);\n      push_integer(1);\n      subtract();\n      push(p1);\n      push_integer(1);\n      add();\n      divide();\n      restore();\n      return;\n    }\n    if (iscons(p1)) {\n      h = tos;\n      while (iscons(p1)) {\n        push(car(p1));\n        circexp();\n        p1 = cdr(p1);\n      }\n      list(tos - h);\n      restore();\n      return;\n    }\n    if (p1.k === TENSOR) {\n      push(p1);\n      copy_tensor();\n      p1 = pop();\n      for (i = o = 0, ref = p1.tensor.nelem; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n        push(p1.tensor.elem[i]);\n        circexp();\n        p1.tensor.elem[i] = pop();\n      }\n      push(p1);\n      restore();\n      return;\n    }\n    push(p1);\n    return restore();\n  };\n\n  Eval_clearall = function() {\n    do_clearall();\n    return push(symbol(NIL));\n  };\n\n  do_clearall = function() {\n    if (test_flag === 0) {\n      clear_term();\n    }\n    do_clearPatterns();\n    clear_symbols();\n    defn();\n    return codeGen = false;\n  };\n\n  // clearall from application GUI code\n  clearall = function() {\n    return run(\"clearall\");\n  };\n\n  // this transformation is done in run.coffee, see there\n  // for more info.\n  clearRenamedVariablesToAvoidBindingToExternalScope = function() {\n    var i, o, ref, results;\n    results = [];\n    for (i = o = 0, ref = symtab.length; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      if (symtab[i].printname.indexOf(\"AVOID_BINDING_TO_EXTERNAL_SCOPE_VALUE\") !== -1) {\n        // just clear it\n        symtab[i].k = SYM;\n        symtab[i].printname = \"\";\n        binding[i] = symtab[i];\n        results.push(isSymbolReclaimable[i] = true);\n      } else {\n        results.push(void 0);\n      }\n    }\n    return results;\n  };\n\n  Eval_clear = function() {\n    var indexFound, variableToBeCleared;\n    p2 = cdr(p1);\n    while (iscons(p2)) {\n      variableToBeCleared = car(p2);\n      //console.log variableToBeCleared + \"\"\n      if (variableToBeCleared.k !== SYM) {\n        stop(\"symbol error\");\n      }\n      //console.log \"getting binding of \" + p.toString()\n      //if p.toString() == \"aaa\"\n      //  debugger\n      indexFound = symtab.indexOf(variableToBeCleared);\n      symtab[indexFound].k = SYM;\n      symtab[indexFound].printname = \"\";\n      binding[indexFound] = symtab[indexFound];\n      isSymbolReclaimable[indexFound] = true;\n      p2 = cdr(p2);\n    }\n    return push(symbol(NIL));\n  };\n\n  /*\n   Convert complex z to clock form\n\n    Input:    push  z\n\n    Output:    Result on stack\n\n    clock(z) = abs(z) * (-1) ^ (arg(z) / pi)\n\n    For example, clock(exp(i pi/3)) gives the result (-1)^(1/3)\n  */\n  // P.S. I couldn't find independent definition/aknowledgment\n  // of the naming \"clock form\" anywhere on the web, seems like a\n  // naming specific to eigenmath.\n  // Clock form is another way to express a complex number, and\n  // it has three advantages\n  //   1) it's uniform with how for example\n  //      i is expressed i.e. (-1)^(1/2)\n  //   2) it's very compact\n  //   3) it's a straighforward notation for roots of 1 and -1\n  DEBUG_CLOCKFORM = false;\n\n  Eval_clock = function() {\n    push(cadr(p1));\n    Eval();\n    return clockform();\n  };\n\n  clockform = function() {\n    save();\n    //if 1\n    p1 = pop();\n    push(p1);\n    abs();\n    if (DEBUG_CLOCKFORM) {\n      console.log(\"clockform: abs of \" + p1 + \" : \" + stack[tos - 1]);\n    }\n    // pushing the expression (-1)^... but note\n    // that we can't use \"power\", as \"power\" evaluates\n    // clock forms into rectangular form (see \"-1 ^ rational\"\n    // section in power)\n    push_symbol(POWER);\n    push_integer(-1);\n    push(p1);\n    arg();\n    if (DEBUG_CLOCKFORM) {\n      console.log(\"clockform: arg of \" + p1 + \" : \" + stack[tos - 1]);\n    }\n    if (evaluatingAsFloats) {\n      push_double(Math.PI);\n    } else {\n      push(symbol(PI));\n    }\n    divide();\n    if (DEBUG_CLOCKFORM) {\n      console.log(\"clockform: divide : \" + stack[tos - 1]);\n    }\n    list(3);\n    if (DEBUG_CLOCKFORM) {\n      console.log(\"clockform: power : \" + stack[tos - 1]);\n    }\n    multiply();\n    if (DEBUG_CLOCKFORM) {\n      console.log(\"clockform: multiply : \" + stack[tos - 1]);\n    }\n    //else\n    /*\n    p1 = pop()\n    push(p1)\n    abs()\n    push(symbol(E))\n    push(p1)\n    arg()\n    push(imaginaryunit)\n    multiply()\n    power()\n    multiply()\n    */\n    //endif\n    return restore();\n  };\n\n  /* coeff =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  p,x,n\n\n  General description\n  -------------------\n  Returns the coefficient of x^n in polynomial p. The x argument can be omitted for polynomials in x.\n\n  */\n  //define P p1\n  //define X p2\n  //define N p3\n  Eval_coeff = function() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    push(cadddr(p1));\n    Eval();\n    p3 = pop();\n    p2 = pop();\n    p1 = pop();\n    if (p3 === symbol(NIL)) { // p3 is N  # only 2 args?\n      p3 = p2;\n      p2 = symbol(SYMBOL_X); // p2 is X\n    }\n    push(p1);\n    push(p2);\n    push(p3);\n    power();\n    divide();\n    push(p2);\n    return filter();\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Put polynomial coefficients on the stack\n\n  //  Input:  as per params\n\n  //  Output:    Returns number of coefficients on stack\n\n  //      tos-n    Coefficient of x^0\n\n  //      tos-1    Coefficient of x^(n-1)\n\n  //-----------------------------------------------------------------------------\n  coeff = function(variable, polynomial) {\n    var coeffsCount, constant, polynomialWithoutConstant, prev_expanding;\n    if (DEBUG) {\n      console.log(\"coeff: \" + variable + \" \" + polynomial);\n    }\n    // works like this:\n    //   1) find the constant (by just evaluating the pol setting the variable to zero)\n    //   2) set aside the found constant: it's one of the coefficients to return\n    //   3) take the polynomial and remove the constant\n    //   4) divide that by variable, lowering the degree by one\n    //   5) go back to 1) until degree is zero\n    coeffsCount = 0;\n    while (true) {\n      push(polynomial);\n      push(variable);\n      push(zero);\n      subst();\n      Eval();\n      constant = pop();\n      \n      // this will be a coefficient that will be returned\n      push(constant);\n      coeffsCount++;\n      push(polynomial);\n      push(constant);\n      subtract();\n      polynomialWithoutConstant = pop();\n      if (equal(polynomialWithoutConstant, zero)) {\n        if (DEBUG) {\n          console.log(\"coeff: result: \" + coeffsCount);\n        }\n        return coeffsCount;\n      }\n      push(polynomialWithoutConstant);\n      push(variable);\n      prev_expanding = expanding;\n      expanding = 1;\n      divide();\n      expanding = prev_expanding;\n      //console.log(\"just divided: \" + stack[tos-1].toString())\n      // this is now the new polynomial with degree decreased by 1\n      polynomial = pop();\n    }\n  };\n\n  Eval_cofactor = function() {\n    var doNothing, i, j, n;\n    i = 0;\n    j = 0;\n    n = 0;\n    push(cadr(p1));\n    Eval();\n    p2 = pop();\n    if (istensor(p2) && p2.tensor.ndim === 2 && p2.tensor.dim[0] === p2.tensor.dim[1]) {\n      doNothing = 1;\n    } else {\n      stop(\"cofactor: 1st arg: square matrix expected\");\n    }\n    n = p2.tensor.dim[0];\n    push(caddr(p1));\n    Eval();\n    i = pop_integer();\n    if (i < 1 || i > n) {\n      stop(\"cofactor: 2nd arg: row index expected\");\n    }\n    push(cadddr(p1));\n    Eval();\n    j = pop_integer();\n    if (j < 1 || j > n) {\n      stop(\"cofactor: 3rd arg: column index expected\");\n    }\n    return cofactor(p2, n, i - 1, j - 1);\n  };\n\n  cofactor = function(p, n, row, col) {\n    var i, i1, j, o, ref, ref1;\n    i = 0;\n    j = 0;\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      for (j = i1 = 0, ref1 = n; (0 <= ref1 ? i1 < ref1 : i1 > ref1); j = 0 <= ref1 ? ++i1 : --i1) {\n        if (i !== row && j !== col) {\n          push(p.tensor.elem[n * i + j]);\n        }\n      }\n    }\n    determinant(n - 1);\n    if ((row + col) % 2) {\n      return negate();\n    }\n  };\n\n  // Condense an expression by factoring common terms.\n  Eval_condense = function() {\n    push(cadr(p1));\n    Eval();\n    return Condense();\n  };\n\n  Condense = function() {\n    var prev_expanding;\n    prev_expanding = expanding;\n    expanding = 0;\n    save();\n    yycondense();\n    restore();\n    return expanding = prev_expanding;\n  };\n\n  yycondense = function() {\n    //expanding = 0\n    p1 = pop();\n    if (car(p1) !== symbol(ADD)) {\n      push(p1);\n      return;\n    }\n    // get gcd of all terms\n    p3 = cdr(p1);\n    push(car(p3));\n    p3 = cdr(p3);\n    while (iscons(p3)) {\n      push(car(p3));\n      if (DEBUG) {\n        console.log(\"calculating gcd between: \" + stack[tos - 1] + \" and \" + stack[tos - 2]);\n      }\n      gcd();\n      if (DEBUG) {\n        console.log(\"partial gcd: \" + stack[tos - 1]);\n      }\n      p3 = cdr(p3);\n    }\n    if (DEBUG) {\n      console.log(\"condense: this is the gcd of all the terms: \" + stack[tos - 1]);\n    }\n    // divide each term by gcd\n    inverse();\n    p2 = pop();\n    push(zero);\n    p3 = cdr(p1);\n    while (iscons(p3)) {\n      push(p2);\n      push(car(p3));\n      //multiply()\n      multiply_noexpand();\n      add();\n      p3 = cdr(p3);\n    }\n    // We multiplied above w/o expanding so some factors cancelled.\n\n    // Now we expand which normalizes the result and, in some cases,\n    // simplifies it too (see test case H).\n    yyexpand();\n    // multiply result by gcd\n    push(p2);\n    return divide();\n  };\n\n  Eval_conj = function() {\n    push(cadr(p1));\n    Eval();\n    p1 = pop();\n    push(p1);\n    if (!Find(p1, imaginaryunit)) { // example: (-1)^(1/3)\n      polar();\n      conjugate();\n      return clockform();\n    } else {\n      return conjugate();\n    }\n  };\n\n  // careful is you pass this one an expression with\n  // i (instead of (-1)^(1/2)) then this doesn't work!\n  conjugate = function() {\n    push(imaginaryunit);\n    push(imaginaryunit);\n    negate();\n    subst();\n    return Eval();\n  };\n\n  // Cons two things on the stack.\n  consCount = 0;\n\n  cons = function() {\n    var p;\n    consCount++;\n    if (DEBUG) {\n      console.log(\"cons tos: \" + tos + \" # \" + consCount);\n    }\n    //if consCount == 444\n    //  debugger\n    // auto var ok, no opportunity for garbage collection after p = alloc()\n    p = new U();\n    p.k = CONS;\n    p.cons.cdr = pop();\n    if (p === p.cons.cdr) {\n      debugger;\n      console.log(\"something wrong p == its cdr\");\n    }\n    p.cons.car = pop();\n    /*\n    console.log \"cons new cdr.k = \" + p.cons.cdr.k + \"\\nor more in detail:\"\n    console.log print_list p.cons.cdr\n    console.log \"cons new car.k = \" + p.cons.car.k + \"\\nor more in detail:\"\n    console.log print_list p.cons.car\n    */\n    return push(p);\n  };\n\n  Eval_contract = function() {\n    push(cadr(p1));\n    Eval();\n    if (cddr(p1) === symbol(NIL)) {\n      push_integer(1);\n      push_integer(2);\n    } else {\n      push(caddr(p1));\n      Eval();\n      push(cadddr(p1));\n      Eval();\n    }\n    return contract();\n  };\n\n  contract = function() {\n    save();\n    yycontract();\n    return restore();\n  };\n\n  yycontract = function() {\n    var a, ai, an, b, h, i, i1, j, j1, k, l, l1, m, m1, n, n1, ndim, nelem, o, o1, ref, ref1, ref2, ref3, ref4, ref5, ref6;\n    h = 0;\n    i = 0;\n    j = 0;\n    k = 0;\n    l = 0;\n    m = 0;\n    n = 0;\n    ndim = 0;\n    nelem = 0;\n    ai = [];\n    an = [];\n    p3 = pop();\n    p2 = pop();\n    p1 = pop();\n    if (!istensor(p1)) {\n      if (!isZeroAtomOrTensor(p1)) {\n        stop(\"contract: tensor expected, 1st arg is not a tensor\");\n      }\n      push(zero);\n      return;\n    }\n    push(p2);\n    l = pop_integer();\n    push(p3);\n    m = pop_integer();\n    ndim = p1.tensor.ndim;\n    if (l < 1 || l > ndim || m < 1 || m > ndim || l === m || p1.tensor.dim[l - 1] !== p1.tensor.dim[m - 1]) {\n      stop(\"contract: index out of range\");\n    }\n    l--;\n    m--;\n    n = p1.tensor.dim[l];\n    // nelem is the number of elements in \"b\"\n    nelem = 1;\n    for (i = o = 0, ref = ndim; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      if (i !== l && i !== m) {\n        nelem *= p1.tensor.dim[i];\n      }\n    }\n    //console.log \"nelem:\" + nelem\n    p2 = alloc_tensor(nelem);\n    //console.log \"p2:\" + p2\n    p2.tensor.ndim = ndim - 2;\n    j = 0;\n    for (i = i1 = 0, ref1 = ndim; (0 <= ref1 ? i1 < ref1 : i1 > ref1); i = 0 <= ref1 ? ++i1 : --i1) {\n      if (i !== l && i !== m) {\n        p2.tensor.dim[j++] = p1.tensor.dim[i];\n      }\n    }\n    a = p1.tensor.elem;\n    b = p2.tensor.elem;\n//console.log \"a: \" + a\n//console.log \"b: \" + b\n    for (i = j1 = 0, ref2 = ndim; (0 <= ref2 ? j1 < ref2 : j1 > ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n      ai[i] = 0;\n      an[i] = p1.tensor.dim[i];\n    }\n    for (i = l1 = 0, ref3 = nelem; (0 <= ref3 ? l1 < ref3 : l1 > ref3); i = 0 <= ref3 ? ++l1 : --l1) {\n      push(zero);\n      for (j = m1 = 0, ref4 = n; (0 <= ref4 ? m1 < ref4 : m1 > ref4); j = 0 <= ref4 ? ++m1 : --m1) {\n        ai[l] = j;\n        ai[m] = j;\n        h = 0;\n        for (k = n1 = 0, ref5 = ndim; (0 <= ref5 ? n1 < ref5 : n1 > ref5); k = 0 <= ref5 ? ++n1 : --n1) {\n          h = (h * an[k]) + ai[k];\n        }\n        push(a[h]);\n        //console.log \"a[h]: \" + a[h]\n        add();\n      }\n      //console.log \"tos: \" + stack[tos-1]\n      b[i] = pop();\n//console.log \"b[i]: \" + b[i]\n      for (j = o1 = ref6 = ndim - 1; (ref6 <= 0 ? o1 <= 0 : o1 >= 0); j = ref6 <= 0 ? ++o1 : --o1) {\n        if (j === l || j === m) {\n          continue;\n        }\n        if (++ai[j] < an[j]) {\n          break;\n        }\n        ai[j] = 0;\n      }\n    }\n    if (nelem === 1) {\n      return push(b[0]);\n    } else {\n      return push(p2);\n    }\n  };\n\n  //console.log \"returning: \" + stack[tos-1]\n  /* cos =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  x\n\n  General description\n  -------------------\n  Returns the cosine of x.\n\n  */\n  Eval_cos = function() {\n    push(cadr(p1));\n    Eval();\n    return cosine();\n  };\n\n  cosine = function() {\n    save();\n    p1 = pop();\n    if (car(p1) === symbol(ADD)) {\n      cosine_of_angle_sum();\n    } else {\n      cosine_of_angle();\n    }\n    return restore();\n  };\n\n  // Use angle sum formula for special angles.\n\n  //define A p3\n  //define B p4\n  cosine_of_angle_sum = function() {\n    p2 = cdr(p1);\n    while (iscons(p2)) {\n      p4 = car(p2);\n      if (isnpi(p4)) { // p4 is B\n        push(p1);\n        push(p4);\n        subtract();\n        p3 = pop();\n        push(p3);\n        cosine();\n        push(p4);\n        cosine();\n        multiply();\n        push(p3);\n        sine();\n        push(p4);\n        sine();\n        multiply();\n        subtract();\n        return;\n      }\n      p2 = cdr(p2);\n    }\n    return cosine_of_angle();\n  };\n\n  cosine_of_angle = function() {\n    var d, n;\n    if (car(p1) === symbol(ARCCOS)) {\n      push(cadr(p1));\n      return;\n    }\n    if (isdouble(p1)) {\n      d = Math.cos(p1.d);\n      if (Math.abs(d) < 1e-10) {\n        d = 0.0;\n      }\n      push_double(d);\n      return;\n    }\n    // cosine function is symmetric, cos(-x) = cos(x)\n    if (isnegative(p1)) {\n      push(p1);\n      negate();\n      p1 = pop();\n    }\n    // cos(arctan(x)) = 1 / sqrt(1 + x^2)\n\n    // see p. 173 of the CRC Handbook of Mathematical Sciences\n    if (car(p1) === symbol(ARCTAN)) {\n      push_integer(1);\n      push(cadr(p1));\n      push_integer(2);\n      power();\n      add();\n      push_rational(-1, 2);\n      power();\n      return;\n    }\n    // multiply by 180/pi to go from radians to degrees.\n    // we go from radians to degrees because it's much\n    // easier to calculate symbolic results of most (not all) \"classic\"\n    // angles (e.g. 30,45,60...) if we calculate the degrees\n    // and the we do a switch on that.\n    // Alternatively, we could look at the fraction of pi\n    // (e.g. 60 degrees is 1/3 pi) but that's more\n    // convoluted as we'd need to look at both numerator and\n    // denominator.\n    push(p1);\n    push_integer(180);\n    multiply();\n    if (evaluatingAsFloats) {\n      push_double(Math.PI);\n    } else {\n      push_symbol(PI);\n    }\n    divide();\n    n = pop_integer();\n    // most \"good\" (i.e. compact) trigonometric results\n    // happen for a round number of degrees. There are some exceptions\n    // though, e.g. 22.5 degrees, which we don't capture here.\n    if (n < 0 || isNaN(n)) {\n      push(symbol(COS));\n      push(p1);\n      list(2);\n      return;\n    }\n    switch (n % 360) {\n      case 90:\n      case 270:\n        return push_integer(0);\n      case 60:\n      case 300:\n        return push_rational(1, 2);\n      case 120:\n      case 240:\n        return push_rational(-1, 2);\n      case 45:\n      case 315:\n        push_rational(1, 2);\n        push_integer(2);\n        push_rational(1, 2);\n        power();\n        return multiply();\n      case 135:\n      case 225:\n        push_rational(-1, 2);\n        push_integer(2);\n        push_rational(1, 2);\n        power();\n        return multiply();\n      case 30:\n      case 330:\n        push_rational(1, 2);\n        push_integer(3);\n        push_rational(1, 2);\n        power();\n        return multiply();\n      case 150:\n      case 210:\n        push_rational(-1, 2);\n        push_integer(3);\n        push_rational(1, 2);\n        power();\n        return multiply();\n      case 0:\n        return push_integer(1);\n      case 180:\n        return push_integer(-1);\n      default:\n        push(symbol(COS));\n        push(p1);\n        return list(2);\n    }\n  };\n\n  Eval_cosh = function() {\n    push(cadr(p1));\n    Eval();\n    return ycosh();\n  };\n\n  ycosh = function() {\n    save();\n    yycosh();\n    return restore();\n  };\n\n  yycosh = function() {\n    var d;\n    d = 0.0;\n    p1 = pop();\n    if (car(p1) === symbol(ARCCOSH)) {\n      push(cadr(p1));\n      return;\n    }\n    if (isdouble(p1)) {\n      d = Math.cosh(p1.d);\n      if (Math.abs(d) < 1e-10) {\n        d = 0.0;\n      }\n      push_double(d);\n      return;\n    }\n    if (isZeroAtomOrTensor(p1)) {\n      push(one);\n      return;\n    }\n    push_symbol(COSH);\n    push(p1);\n    return list(2);\n  };\n\n  // this function extract parts subtrees from a tree.\n  // It is used in two\n  // places that have to do with pattern matching.\n  // One is for integrals, where an expression or its\n  // subparts are matched against cases in an\n  // integrals table.\n  // Another one is for applyging tranformation patterns\n  // defined via PATTERN, again patterns are applied to\n  // either the whole expression or any of its parts.\n\n  // unclear to me at the moment\n  // why this is exposed as something that can\n  // be evalled. Never called.\n  Eval_decomp = function() {\n    var h;\n    save();\n    console.log(\"Eval_decomp is being called!!!!!!!!!!!!!!!!!!!!\");\n    h = tos;\n    push(symbol(NIL));\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    p1 = pop();\n    if (p1 === symbol(NIL)) {\n      guess();\n    } else {\n      push(p1);\n    }\n    decomp(false);\n    list(tos - h);\n    return restore();\n  };\n\n  pushTryNotToDuplicate = function(toBePushed) {\n    if (tos > 0) {\n      if (DEBUG) {\n        console.log(\"comparing \" + toBePushed + \" to: \" + stack[tos - 1]);\n      }\n      if (equal(toBePushed, stack[tos - 1])) {\n        if (DEBUG) {\n          console.log(\"skipping \" + toBePushed + \" because it's already on stack \");\n        }\n        return;\n      }\n    }\n    return push(toBePushed);\n  };\n\n  // returns constant expressions on the stack\n  decomp = function(generalTransform) {\n    save();\n    p2 = pop();\n    p1 = pop();\n    if (DEBUG) {\n      console.log(\"DECOMPOSING \" + p1);\n    }\n    // is the entire expression constant?\n    if (generalTransform) {\n      if (!iscons(p1)) {\n        if (DEBUG) {\n          console.log(\" ground thing: \" + p1);\n        }\n        pushTryNotToDuplicate(p1);\n        restore();\n        return;\n      }\n    } else {\n      if (Find(p1, p2) === 0) {\n        if (DEBUG) {\n          console.log(\" entire expression is constant\");\n        }\n        pushTryNotToDuplicate(p1);\n        //push(p1);  # may need later for pushing both +a, -a\n        //negate()\n        restore();\n        return;\n      }\n    }\n    // sum?\n    if (isadd(p1)) {\n      decomp_sum(generalTransform);\n      restore();\n      return;\n    }\n    // product?\n    if (ismultiply(p1)) {\n      decomp_product(generalTransform);\n      restore();\n      return;\n    }\n    // naive decomp if not sum or product\n    if (DEBUG) {\n      console.log(\" naive decomp\");\n    }\n    p3 = cdr(p1);\n    if (DEBUG) {\n      console.log(\"startig p3: \" + p3);\n    }\n    while (iscons(p3)) {\n      // for a general transformations,\n      // we want to match any part of the tree so\n      // we need to push the subtree as well\n      // as recurse to its parts\n      if (generalTransform) {\n        push(car(p3));\n      }\n      if (DEBUG) {\n        console.log(\"recursive decomposition\");\n      }\n      push(car(p3));\n      if (DEBUG) {\n        console.log(\"car(p3): \" + car(p3));\n      }\n      push(p2);\n      if (DEBUG) {\n        console.log(\"p2: \" + p2);\n      }\n      decomp(generalTransform);\n      p3 = cdr(p3);\n    }\n    return restore();\n  };\n\n  decomp_sum = function(generalTransform) {\n    var h;\n    if (DEBUG) {\n      console.log(\" decomposing the sum \");\n    }\n    h = 0;\n    // decomp terms involving x\n    p3 = cdr(p1);\n    while (iscons(p3)) {\n      if (Find(car(p3), p2) || generalTransform) {\n        push(car(p3));\n        push(p2);\n        decomp(generalTransform);\n      }\n      p3 = cdr(p3);\n    }\n    // add together all constant terms\n    h = tos;\n    p3 = cdr(p1);\n    while (iscons(p3)) {\n      if (Find(car(p3), p2) === 0) {\n        pushTryNotToDuplicate(car(p3));\n      }\n      p3 = cdr(p3);\n    }\n    if (tos - h) {\n      add_all(tos - h);\n      p3 = pop();\n      pushTryNotToDuplicate(p3);\n      push(p3);\n      return negate(); // need both +a, -a for some integrals\n    }\n  };\n\n  decomp_product = function(generalTransform) {\n    var h;\n    if (DEBUG) {\n      console.log(\" decomposing the product \");\n    }\n    h = 0;\n    // decomp factors involving x\n    p3 = cdr(p1);\n    while (iscons(p3)) {\n      if (Find(car(p3), p2) || generalTransform) {\n        push(car(p3));\n        push(p2);\n        decomp(generalTransform);\n      }\n      p3 = cdr(p3);\n    }\n    // multiply together all constant factors\n    h = tos;\n    p3 = cdr(p1);\n    while (iscons(p3)) {\n      if (Find(car(p3), p2) === 0) {\n        pushTryNotToDuplicate(car(p3));\n      }\n      p3 = cdr(p3);\n    }\n    if (tos - h) {\n      return multiply_all(tos - h);\n    }\n  };\n\n  //p3 = pop();  # may need later for pushing both +a, -a\n  //push(p3)\n  //push(p3)\n  //negate()\n  // Store a function definition\n\n  // Example:\n\n  //      f(x,y)=x^y\n\n  // For this definition, p1 points to the following structure.\n\n  //     p1\n  //      |\n  //   ___v__    ______                        ______ \n  //  |CONS  |->|CONS  |--------------------->|CONS  |\n  //  |______|  |______|                      |______|\n  //      |         |                             |\n  //   ___v__    ___v__    ______    ______    ___v__    ______    ______\n  //  |SETQ  |  |CONS  |->|CONS  |->|CONS  |  |CONS  |->|CONS  |->|CONS  |\n  //  |______|  |______|  |______|  |______|  |______|  |______|  |______|\n  //                |         |         |         |         |         |\n  //             ___v__    ___v__    ___v__    ___v__    ___v__    ___v__\n  //            |SYM f |  |SYM x |  |SYM y |  |POWER |  |SYM x |  |SYM y |\n  //            |______|  |______|  |______|  |______|  |______|  |______|\n\n  // the result (in f) is a FUNCTION node\n  // that contains both the body and the argument list.\n\n  // We have\n\n  //  caadr(p1) points to the function name i.e. f\n  //  cdadr(p1) points to the arguments i.e. the list (x y)\n  //  caddr(p1) points to the function body i.e. (power x y)\n\n  //define F p3 # F points to the function name\n  //define A p4 # A points to the argument list\n  //define B p5 # B points to the function body\n  define_user_function = function() {\n    p3 = caadr(p1);\n    p4 = cdadr(p1);\n    p5 = caddr(p1);\n    if (!issymbol(p3)) { // p3 is F\n      stop(\"function name?\");\n    }\n    // evaluate function body (maybe)\n    if (car(p5) === symbol(EVAL)) { // p5 is B\n      push(cadr(p5));\n      Eval();\n      p5 = pop(); // p5 is B\n    }\n    \n    // note how, unless explicitly forced by an eval,\n    // (handled by the if just above)\n    // we don't eval/simplify\n    // the body.\n    // Why? because it's the easiest way\n    // to solve scope problems i.e.\n    //   x = 0\n    //   f(x) = x + 1\n    //   f(4) # would reply 1\n    // which would need to otherwise\n    // be solved by some scope device\n    // somehow\n    push_symbol(FUNCTION);\n    push(p5);\n    push(p4);\n    list(3);\n    p5 = pop();\n    set_binding(p3, p5);\n    return push_symbol(NIL);\n  };\n\n  Eval_function_reference = function() {\n    return push(p1);\n  };\n\n  /* defint =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  f,x,a,b[,y,c,d...]\n\n  General description\n  -------------------\n  Returns the definite integral of f with respect to x evaluated from \"a\" to b.\n  The argument list can be extended for multiple integrals (or \"iterated\n  integrals\"), for example a double integral (which can represent for\n  example a volume under a surface), or a triple integral, etc. For\n  example, defint(f,x,a,b,y,c,d).\n\n  */\n  //define F p2\n  //define X p3\n  //define A p4\n  //define B p5\n  Eval_defint = function() {\n    push(cadr(p1));\n    Eval();\n    p2 = pop(); // p2 is F\n    p1 = cddr(p1);\n    // defint can handle multiple\n    // integrals, so we loop over the\n    // multiple integrals here\n    while (iscons(p1)) {\n      push(car(p1));\n      p1 = cdr(p1);\n      Eval();\n      p3 = pop(); // p3 is X\n      push(car(p1));\n      p1 = cdr(p1);\n      Eval();\n      p4 = pop(); // p4 is A\n      push(car(p1));\n      p1 = cdr(p1);\n      Eval();\n      p5 = pop(); // p5 is B\n      \n      // obtain the primitive of F against the\n      // specified variable X\n      // note that the primitive changes over\n      // the calculation of the multiple\n      // integrals.\n      push(p2);\n      push(p3);\n      integral();\n      p2 = pop(); // contains the antiderivative of F\n      \n      // evaluate the integral in A\n      push(p2);\n      push(p3);\n      push(p5);\n      subst();\n      Eval();\n      // evaluate the integral in B\n      push(p2);\n      push(p3);\n      push(p4);\n      subst();\n      Eval();\n      // integral between B and A is the\n      // subtraction. Note that this could\n      // be a number but also a function.\n      // and we might have to integrate this\n      // number/function again doing the while\n      // loop again if this is a multiple\n      // integral.\n      subtract();\n      p2 = pop();\n    }\n    return push(p2);\n  };\n\n  Eval_degree = function() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    p1 = pop();\n    if (p1 === symbol(NIL)) {\n      guess();\n    } else {\n      push(p1);\n    }\n    return degree();\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Find the degree of a polynomial\n\n  //  Input:    tos-2    p(x)\n\n  //      tos-1    x\n\n  //  Output:    Result on stack\n\n  //  Note: Finds the largest numerical power of x. Does not check for\n  //  weirdness in p(x).\n\n  //-----------------------------------------------------------------------------\n\n  //define POLY p1\n  //define X p2\n  //define DEGREE p3\n  degree = function() {\n    save();\n    p2 = pop();\n    p1 = pop();\n    p3 = zero;\n    yydegree(p1);\n    push(p3);\n    return restore();\n  };\n\n  yydegree = function(p) {\n    var results;\n    if (equal(p, p2)) {\n      if (isZeroAtomOrTensor(p3)) {\n        return p3 = one;\n      }\n    } else if (car(p) === symbol(POWER)) {\n      if (equal(cadr(p), p2) && isNumericAtom(caddr(p)) && lessp(p3, caddr(p))) {\n        return p3 = caddr(p);\n      }\n    } else if (iscons(p)) {\n      p = cdr(p);\n      results = [];\n      while (iscons(p)) {\n        yydegree(car(p));\n        results.push(p = cdr(p));\n      }\n      return results;\n    }\n  };\n\n  Eval_denominator = function() {\n    push(cadr(p1));\n    Eval();\n    return denominator();\n  };\n\n  denominator = function() {\n    var h, theArgument;\n    h = 0;\n    theArgument = pop();\n    //console.trace \"denominator of: \" + theArgument\n    if (car(theArgument) === symbol(ADD)) {\n      push(theArgument);\n      rationalize();\n      theArgument = pop();\n    }\n    if (car(theArgument) === symbol(MULTIPLY) && !isplusone(car(cdr(theArgument)))) {\n      h = tos;\n      theArgument = cdr(theArgument);\n      while (iscons(theArgument)) {\n        push(car(theArgument));\n        denominator();\n        theArgument = cdr(theArgument);\n      }\n      return multiply_all(tos - h);\n    } else if (isrational(theArgument)) {\n      push(theArgument);\n      return mp_denominator();\n    } else if (car(theArgument) === symbol(POWER) && isnegativeterm(caddr(theArgument))) {\n      push(theArgument);\n      return reciprocate();\n    } else {\n      return push(one);\n    }\n  };\n\n  // derivative\n\n  //define F p3\n  //define X p4\n  //define N p5\n  Eval_derivative = function() {\n    var doNothing, i, i1, n, o, ref, ref1;\n    // evaluate 1st arg to get function F\n    i = 0;\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    // evaluate 2nd arg and then...\n\n    // example  result of 2nd arg  what to do\n\n    // d(f)    nil      guess X, N = nil\n    // d(f,2)  2      guess X, N = 2\n    // d(f,x)  x      X = x, N = nil\n    // d(f,x,2)  x      X = x, N = 2\n    // d(f,x,y)  x      X = x, N = y\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p2 = pop();\n    if (p2 === symbol(NIL)) {\n      guess();\n      push(symbol(NIL));\n    } else if (isNumericAtom(p2)) {\n      guess();\n      push(p2);\n    } else {\n      push(p2);\n      p1 = cdr(p1);\n      push(car(p1));\n      Eval();\n    }\n    p5 = pop();\n    p4 = pop();\n    p3 = pop();\n    while (1) {\n      // p5 (N) might be a symbol instead of a number\n      if (isNumericAtom(p5)) { // p5 is N\n        push(p5);\n        n = pop_integer();\n        if (isNaN(n)) {\n          stop(\"nth derivative: check n\");\n        }\n      } else {\n        n = 1;\n      }\n      push(p3);\n      if (n >= 0) {\n        for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n          push(p4);\n          derivative();\n        }\n      } else {\n        n = -n;\n        for (i = i1 = 0, ref1 = n; (0 <= ref1 ? i1 < ref1 : i1 > ref1); i = 0 <= ref1 ? ++i1 : --i1) {\n          push(p4);\n          integral();\n        }\n      }\n      p3 = pop();\n      if (p5 === symbol(NIL)) { // p5 is N\n        break;\n      }\n      // otherwise...\n\n      // N    arg1    what to do\n\n      // number  nil    break\n      // number  number    N = arg1, continue\n      // number  symbol    X = arg1, N = arg2, continue\n\n      // symbol  nil    X = N, N = nil, continue\n      // symbol  number    X = N, N = arg1, continue\n      // symbol  symbol    X = N, N = arg1, continue\n      if (isNumericAtom(p5)) { // p5 is N\n        p1 = cdr(p1);\n        push(car(p1));\n        Eval();\n        p5 = pop();\n        if (p5 === symbol(NIL)) { // p5 is N\n          break; // arglist exhausted\n        }\n        if (isNumericAtom(p5)) { // p5 is N\n          doNothing = 1; // N = arg1\n        } else {\n          p4 = p5;\n          p1 = cdr(p1);\n          push(car(p1));\n          Eval();\n          p5 = pop(); // p5 is N  # N = arg2\n        }\n      } else {\n        p4 = p5;\n        p1 = cdr(p1);\n        push(car(p1));\n        Eval();\n        p5 = pop(); // p5 is N  # N = arg1\n      }\n    }\n    return push(p3); // p3 is F # final result\n  };\n\n  derivative = function() {\n    save();\n    p2 = pop();\n    p1 = pop();\n    if (isNumericAtom(p2)) {\n      stop(\"undefined function\");\n    }\n    if (istensor(p1)) {\n      if (istensor(p2)) {\n        d_tensor_tensor();\n      } else {\n        d_tensor_scalar();\n      }\n    } else {\n      if (istensor(p2)) {\n        d_scalar_tensor();\n      } else {\n        d_scalar_scalar();\n      }\n    }\n    return restore();\n  };\n\n  d_scalar_scalar = function() {\n    if (issymbol(p2)) {\n      return d_scalar_scalar_1();\n    } else {\n      // Example: d(sin(cos(x)),cos(x))\n      // Replace cos(x) <- X, find derivative, then do X <- cos(x)\n      push(p1);\n      push(p2);\n      push(symbol(SECRETX));\n      subst();\n      push(symbol(SECRETX));\n      derivative();\n      push(symbol(SECRETX));\n      push(p2);\n      return subst(); // cos(X) -> cos(cos(x))\n    }\n  };\n\n  d_scalar_scalar_1 = function() {\n    // d(x,x)?\n    if (equal(p1, p2)) {\n      push(one);\n      return;\n    }\n    if (!iscons(p1)) {\n      push(zero);\n      return;\n    }\n    if (isadd(p1)) {\n      dsum();\n      return;\n    }\n    if (car(p1) === symbol(MULTIPLY)) {\n      dproduct();\n      return;\n    }\n    if (car(p1) === symbol(POWER)) {\n      dpower();\n      return;\n    }\n    if (car(p1) === symbol(DERIVATIVE)) {\n      dd();\n      return;\n    }\n    if (car(p1) === symbol(LOG)) {\n      dlog();\n      return;\n    }\n    if (car(p1) === symbol(SIN)) {\n      dsin();\n      return;\n    }\n    if (car(p1) === symbol(COS)) {\n      dcos();\n      return;\n    }\n    if (car(p1) === symbol(TAN)) {\n      dtan();\n      return;\n    }\n    if (car(p1) === symbol(ARCSIN)) {\n      darcsin();\n      return;\n    }\n    if (car(p1) === symbol(ARCCOS)) {\n      darccos();\n      return;\n    }\n    if (car(p1) === symbol(ARCTAN)) {\n      darctan();\n      return;\n    }\n    if (car(p1) === symbol(SINH)) {\n      dsinh();\n      return;\n    }\n    if (car(p1) === symbol(COSH)) {\n      dcosh();\n      return;\n    }\n    if (car(p1) === symbol(TANH)) {\n      dtanh();\n      return;\n    }\n    if (car(p1) === symbol(ARCSINH)) {\n      darcsinh();\n      return;\n    }\n    if (car(p1) === symbol(ARCCOSH)) {\n      darccosh();\n      return;\n    }\n    if (car(p1) === symbol(ARCTANH)) {\n      darctanh();\n      return;\n    }\n    if (car(p1) === symbol(ABS)) {\n      dabs();\n      return;\n    }\n    if (car(p1) === symbol(SGN)) {\n      dsgn();\n      return;\n    }\n    if (car(p1) === symbol(HERMITE)) {\n      dhermite();\n      return;\n    }\n    if (car(p1) === symbol(ERF)) {\n      derf();\n      return;\n    }\n    if (car(p1) === symbol(ERFC)) {\n      derfc();\n      return;\n    }\n    if (car(p1) === symbol(BESSELJ)) {\n      if (isZeroAtomOrTensor(caddr(p1))) {\n        dbesselj0();\n      } else {\n        dbesseljn();\n      }\n      return;\n    }\n    if (car(p1) === symbol(BESSELY)) {\n      if (isZeroAtomOrTensor(caddr(p1))) {\n        dbessely0();\n      } else {\n        dbesselyn();\n      }\n      return;\n    }\n    if (car(p1) === symbol(INTEGRAL) && caddr(p1) === p2) {\n      derivative_of_integral();\n      return;\n    }\n    return dfunction();\n  };\n\n  dsum = function() {\n    var h;\n    h = tos;\n    p1 = cdr(p1);\n    while (iscons(p1)) {\n      push(car(p1));\n      push(p2);\n      derivative();\n      p1 = cdr(p1);\n    }\n    return add_all(tos - h);\n  };\n\n  dproduct = function() {\n    var i, i1, j, n, o, ref, ref1;\n    i = 0;\n    j = 0;\n    n = 0;\n    n = length(p1) - 1;\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      p3 = cdr(p1);\n      for (j = i1 = 0, ref1 = n; (0 <= ref1 ? i1 < ref1 : i1 > ref1); j = 0 <= ref1 ? ++i1 : --i1) {\n        push(car(p3));\n        if (i === j) {\n          push(p2);\n          derivative();\n        }\n        p3 = cdr(p3);\n      }\n      multiply_all(n);\n    }\n    return add_all(n);\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //       v\n  //  y = u\n\n  //  log y = v log u\n\n  //  1 dy   v du           dv\n  //  - -- = - -- + (log u) --\n  //  y dx   u dx           dx\n\n  //  dy    v  v du           dv\n  //  -- = u  (- -- + (log u) --)\n  //  dx       u dx           dx\n\n  //-----------------------------------------------------------------------------\n  dpower = function() {\n    push(caddr(p1));\n    push(cadr(p1));\n    divide();\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    multiply();\n    push(cadr(p1));\n    logarithm();\n    push(caddr(p1));\n    push(p2);\n    derivative();\n    multiply();\n    add();\n    push(p1);\n    return multiply();\n  };\n\n  dlog = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    return divide();\n  };\n\n  //  derivative of derivative\n\n  //  example: d(d(f(x,y),y),x)\n\n  //  p1 = d(f(x,y),y)\n\n  //  p2 = x\n\n  //  cadr(p1) = f(x,y)\n\n  //  caddr(p1) = y\n  dd = function() {\n    // d(f(x,y),x)\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    p3 = pop();\n    if (car(p3) === symbol(DERIVATIVE)) {\n      // sort dx terms\n      push_symbol(DERIVATIVE);\n      push_symbol(DERIVATIVE);\n      push(cadr(p3));\n      if (lessp(caddr(p3), caddr(p1))) {\n        push(caddr(p3));\n        list(3);\n        push(caddr(p1));\n      } else {\n        push(caddr(p1));\n        list(3);\n        push(caddr(p3));\n      }\n      return list(3);\n    } else {\n      push(p3);\n      push(caddr(p1));\n      return derivative();\n    }\n  };\n\n  // derivative of a generic function\n  dfunction = function() {\n    p3 = cdr(p1);\n    if (p3 === symbol(NIL) || Find(p3, p2)) {\n      push_symbol(DERIVATIVE);\n      push(p1);\n      push(p2);\n      return list(3);\n    } else {\n      return push(zero);\n    }\n  };\n\n  dsin = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    cosine();\n    return multiply();\n  };\n\n  dcos = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    sine();\n    multiply();\n    return negate();\n  };\n\n  dtan = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    cosine();\n    push_integer(-2);\n    power();\n    return multiply();\n  };\n\n  darcsin = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push_integer(1);\n    push(cadr(p1));\n    push_integer(2);\n    power();\n    subtract();\n    push_rational(-1, 2);\n    power();\n    return multiply();\n  };\n\n  darccos = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push_integer(1);\n    push(cadr(p1));\n    push_integer(2);\n    power();\n    subtract();\n    push_rational(-1, 2);\n    power();\n    multiply();\n    return negate();\n  };\n\n  //        Without simplify  With simplify\n\n  //  d(arctan(y/x),x)  -y/(x^2*(y^2/x^2+1))  -y/(x^2+y^2)\n\n  //  d(arctan(y/x),y)  1/(x*(y^2/x^2+1))  x/(x^2+y^2)\n  darctan = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push_integer(1);\n    push(cadr(p1));\n    push_integer(2);\n    power();\n    add();\n    inverse();\n    multiply();\n    return simplify();\n  };\n\n  dsinh = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    ycosh();\n    return multiply();\n  };\n\n  dcosh = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    ysinh();\n    return multiply();\n  };\n\n  dtanh = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    ycosh();\n    push_integer(-2);\n    power();\n    return multiply();\n  };\n\n  darcsinh = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    push_integer(2);\n    power();\n    push_integer(1);\n    add();\n    push_rational(-1, 2);\n    power();\n    return multiply();\n  };\n\n  darccosh = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    push_integer(2);\n    power();\n    push_integer(-1);\n    add();\n    push_rational(-1, 2);\n    power();\n    return multiply();\n  };\n\n  darctanh = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push_integer(1);\n    push(cadr(p1));\n    push_integer(2);\n    power();\n    subtract();\n    inverse();\n    return multiply();\n  };\n\n  dabs = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    sgn();\n    return multiply();\n  };\n\n  dsgn = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    dirac();\n    multiply();\n    push_integer(2);\n    return multiply();\n  };\n\n  dhermite = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push_integer(2);\n    push(caddr(p1));\n    multiply();\n    multiply();\n    push(cadr(p1));\n    push(caddr(p1));\n    push_integer(-1);\n    add();\n    hermite();\n    return multiply();\n  };\n\n  derf = function() {\n    push(cadr(p1));\n    push_integer(2);\n    power();\n    push_integer(-1);\n    multiply();\n    exponential();\n    if (evaluatingAsFloats) {\n      push_double(Math.PI);\n    } else {\n      push_symbol(PI);\n    }\n    push_rational(-1, 2);\n    power();\n    multiply();\n    push_integer(2);\n    multiply();\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    return multiply();\n  };\n\n  derfc = function() {\n    push(cadr(p1));\n    push_integer(2);\n    power();\n    push_integer(-1);\n    multiply();\n    exponential();\n    if (evaluatingAsFloats) {\n      push_double(Math.PI);\n    } else {\n      push_symbol(PI);\n    }\n    push_rational(-1, 2);\n    power();\n    multiply();\n    push_integer(-2);\n    multiply();\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    return multiply();\n  };\n\n  dbesselj0 = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    push_integer(1);\n    besselj();\n    multiply();\n    push_integer(-1);\n    return multiply();\n  };\n\n  dbesseljn = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    push(caddr(p1));\n    push_integer(-1);\n    add();\n    besselj();\n    push(caddr(p1));\n    push_integer(-1);\n    multiply();\n    push(cadr(p1));\n    divide();\n    push(cadr(p1));\n    push(caddr(p1));\n    besselj();\n    multiply();\n    add();\n    return multiply();\n  };\n\n  dbessely0 = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    push_integer(1);\n    besselj();\n    multiply();\n    push_integer(-1);\n    return multiply();\n  };\n\n  dbesselyn = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    push(caddr(p1));\n    push_integer(-1);\n    add();\n    bessely();\n    push(caddr(p1));\n    push_integer(-1);\n    multiply();\n    push(cadr(p1));\n    divide();\n    push(cadr(p1));\n    push(caddr(p1));\n    bessely();\n    multiply();\n    add();\n    return multiply();\n  };\n\n  derivative_of_integral = function() {\n    return push(cadr(p1));\n  };\n\n  DET_check_arg = function() {\n    if (!istensor(p1)) {\n      return 0;\n    } else if (p1.tensor.ndim !== 2) {\n      return 0;\n    } else if (p1.tensor.dim[0] !== p1.tensor.dim[1]) {\n      return 0;\n    } else {\n      return 1;\n    }\n  };\n\n  det = function() {\n    var a, i, i1, n, o, ref, ref1;\n    i = 0;\n    n = 0;\n    //U **a\n    save();\n    p1 = pop();\n    if (DET_check_arg() === 0) {\n      push_symbol(DET);\n      push(p1);\n      list(2);\n      restore();\n      return;\n    }\n    n = p1.tensor.nelem;\n    a = p1.tensor.elem;\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      if (!isNumericAtom(a[i])) {\n        break;\n      }\n    }\n    if (i === n) {\n      yydetg();\n    } else {\n      for (i = i1 = 0, ref1 = p1.tensor.nelem; (0 <= ref1 ? i1 < ref1 : i1 > ref1); i = 0 <= ref1 ? ++i1 : --i1) {\n        push(p1.tensor.elem[i]);\n      }\n      determinant(p1.tensor.dim[0]);\n    }\n    return restore();\n  };\n\n  // determinant of n * n matrix elements on the stack\n  determinant = function(n) {\n    var a, breakFromOutherWhile, h, i, i1, j, k, o, q, ref, ref1, s, sign_, t;\n    h = 0;\n    i = 0;\n    j = 0;\n    k = 0;\n    q = 0;\n    s = 0;\n    sign_ = 0;\n    t = 0;\n    a = [];\n    //int *a, *c, *d\n    h = tos - n * n;\n//a = (int *) malloc(3 * n * sizeof (int))\n\n    //if (a == NULL)\n//  out_of_memory()\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      a[i] = i;\n      a[i + n] = 0;\n      a[i + n + n] = 1;\n    }\n    sign_ = 1;\n    push(zero);\n    while (1) {\n      if (sign_ === 1) {\n        push_integer(1);\n      } else {\n        push_integer(-1);\n      }\n      for (i = i1 = 0, ref1 = n; (0 <= ref1 ? i1 < ref1 : i1 > ref1); i = 0 <= ref1 ? ++i1 : --i1) {\n        k = n * a[i] + i;\n        push(stack[h + k]);\n        multiply(); // FIXME -- problem here\n      }\n      add();\n      // next permutation (Knuth's algorithm P)\n      j = n - 1;\n      s = 0;\n      breakFromOutherWhile = false;\n      while (1) {\n        q = a[n + j] + a[n + n + j];\n        if (q < 0) {\n          a[n + n + j] = -a[n + n + j];\n          j--;\n          continue;\n        }\n        if (q === j + 1) {\n          if (j === 0) {\n            breakFromOutherWhile = true;\n            break;\n          }\n          s++;\n          a[n + n + j] = -a[n + n + j];\n          j--;\n          continue;\n        }\n        break;\n      }\n      if (breakFromOutherWhile) {\n        break;\n      }\n      t = a[j - a[n + j] + s];\n      a[j - a[n + j] + s] = a[j - q + s];\n      a[j - q + s] = t;\n      a[n + j] = q;\n      sign_ = -sign_;\n    }\n    stack[h] = stack[tos - 1];\n    return moveTos(h + 1);\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Input:    Matrix on stack\n\n  //  Output:    Determinant on stack\n\n  //  Note:\n\n  //  Uses Gaussian elimination which is faster for numerical matrices.\n\n  //  Gaussian Elimination works by walking down the diagonal and clearing\n  //  out the columns below it.\n\n  //-----------------------------------------------------------------------------\n  detg = function() {\n    save();\n    p1 = pop();\n    if (DET_check_arg() === 0) {\n      push_symbol(DET);\n      push(p1);\n      list(2);\n      restore();\n      return;\n    }\n    yydetg();\n    return restore();\n  };\n\n  yydetg = function() {\n    var i, n, o, ref;\n    i = 0;\n    n = 0;\n    n = p1.tensor.dim[0];\n    for (i = o = 0, ref = n * n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      push(p1.tensor.elem[i]);\n    }\n    lu_decomp(n);\n    moveTos(tos - n * n);\n    return push(p1);\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Input:    n * n matrix elements on stack\n\n  //  Output:    p1  determinant\n\n  //      p2  mangled\n\n  //      upper diagonal matrix on stack\n\n  //-----------------------------------------------------------------------------\n  M = function(h, n, i, j) {\n    return stack[h + n * i + j];\n  };\n\n  setM = function(h, n, i, j, value) {\n    return stack[h + n * i + j] = value;\n  };\n\n  lu_decomp = function(n) {\n    var d, h, i, i1, j, j1, l1, m1, o, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8;\n    d = 0;\n    h = 0;\n    i = 0;\n    j = 0;\n    h = tos - n * n;\n    p1 = one;\n    for (d = o = 0, ref = n - 1; (0 <= ref ? o < ref : o > ref); d = 0 <= ref ? ++o : --o) {\n      // diagonal element zero?\n      if (equal(M(h, n, d, d), zero)) {\n// find a new row\n        for (i = i1 = ref1 = d + 1, ref2 = n; (ref1 <= ref2 ? i1 < ref2 : i1 > ref2); i = ref1 <= ref2 ? ++i1 : --i1) {\n          if (!equal(M(h, n, i, d), zero)) {\n            break;\n          }\n        }\n        if (i === n) {\n          p1 = zero;\n          break;\n        }\n// exchange rows\n        for (j = j1 = ref3 = d, ref4 = n; (ref3 <= ref4 ? j1 < ref4 : j1 > ref4); j = ref3 <= ref4 ? ++j1 : --j1) {\n          p2 = M(h, n, d, j);\n          setM(h, n, d, j, M(h, n, i, j));\n          setM(h, n, i, j, p2);\n        }\n        // negate det\n        push(p1);\n        negate();\n        p1 = pop();\n      }\n      // update det\n      push(p1);\n      push(M(h, n, d, d));\n      multiply();\n      p1 = pop();\n// update lower diagonal matrix\n      for (i = l1 = ref5 = d + 1, ref6 = n; (ref5 <= ref6 ? l1 < ref6 : l1 > ref6); i = ref5 <= ref6 ? ++l1 : --l1) {\n        // multiplier\n        push(M(h, n, i, d));\n        push(M(h, n, d, d));\n        divide();\n        negate();\n        p2 = pop();\n        // update one row\n        setM(h, n, i, d, zero);\n        for (j = m1 = ref7 = d + 1, ref8 = n; (ref7 <= ref8 ? m1 < ref8 : m1 > ref8); j = ref7 <= ref8 ? ++m1 : --m1) {\n          push(M(h, n, d, j));\n          push(p2);\n          multiply();\n          push(M(h, n, i, j));\n          add();\n          setM(h, n, i, j, pop());\n        }\n      }\n    }\n    // last diagonal element\n    push(p1);\n    push(M(h, n, n - 1, n - 1));\n    multiply();\n    return p1 = pop();\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Author : philippe.billet@noos.fr\n\n  //  Dirac function dirac(x)\n  //  dirac(-x)=dirac(x)\n  //  dirac(b-a)=dirac(a-b)\n  //-----------------------------------------------------------------------------\n  Eval_dirac = function() {\n    push(cadr(p1));\n    Eval();\n    return dirac();\n  };\n\n  dirac = function() {\n    save();\n    ydirac();\n    return restore();\n  };\n\n  //define p1 p1\n  ydirac = function() {\n    p1 = pop();\n    if (isdouble(p1)) {\n      if (p1.d === 0) {\n        push_integer(1);\n        return;\n      } else {\n        push_integer(0);\n        return;\n      }\n    }\n    if (isrational(p1)) {\n      if (MZERO(mmul(p1.q.a, p1.q.b))) {\n        push_integer(1);\n        return;\n      } else {\n        push_integer(0);\n        return;\n      }\n    }\n    if (car(p1) === symbol(POWER)) {\n      push_symbol(DIRAC);\n      push(cadr(p1));\n      list(2);\n      return;\n    }\n    if (isnegativeterm(p1)) {\n      push_symbol(DIRAC);\n      push(p1);\n      negate();\n      list(2);\n      return;\n    }\n    if (isnegativeterm(p1) || (car(p1) === symbol(ADD) && isnegativeterm(cadr(p1)))) {\n      push(p1);\n      negate();\n      p1 = pop();\n    }\n    push_symbol(DIRAC);\n    push(p1);\n    return list(2);\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Generate all divisors of a term\n\n  //  Input:    Term on stack (factor * factor * ...)\n\n  //  Output:    Divisors on stack\n\n  //-----------------------------------------------------------------------------\n  divisors = function() {\n    var h, i, n, o, ref, subsetOfStack;\n    i = 0;\n    h = 0;\n    n = 0;\n    save();\n    h = tos - 1;\n    divisors_onstack();\n    n = tos - h;\n    //qsort(stack + h, n, sizeof (U *), __cmp)\n    subsetOfStack = stack.slice(h, h + n);\n    subsetOfStack.sort(cmp_expr);\n    stack = stack.slice(0, h).concat(subsetOfStack).concat(stack.slice(h + n));\n    p1 = alloc_tensor(n);\n    p1.tensor.ndim = 1;\n    p1.tensor.dim[0] = n;\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      p1.tensor.elem[i] = stack[h + i];\n    }\n    moveTos(h);\n    push(p1);\n    return restore();\n  };\n\n  divisors_onstack = function() {\n    var h, i, k, n, o, ref;\n    h = 0;\n    i = 0;\n    k = 0;\n    n = 0;\n    save();\n    p1 = pop();\n    h = tos;\n    // push all of the term's factors\n    if (isNumericAtom(p1)) {\n      push(p1);\n      factor_small_number();\n    } else if (car(p1) === symbol(ADD)) {\n      push(p1);\n      __factor_add();\n    //printf(\">>>\\n\")\n    //for (i = h; i < tos; i++)\n    //print(stdout, stack[i])\n    //printf(\"<<<\\n\")\n    } else if (car(p1) === symbol(MULTIPLY)) {\n      p1 = cdr(p1);\n      if (isNumericAtom(car(p1))) {\n        push(car(p1));\n        factor_small_number();\n        p1 = cdr(p1);\n      }\n      while (iscons(p1)) {\n        p2 = car(p1);\n        if (car(p2) === symbol(POWER)) {\n          push(cadr(p2));\n          push(caddr(p2));\n        } else {\n          push(p2);\n          push(one);\n        }\n        p1 = cdr(p1);\n      }\n    } else if (car(p1) === symbol(POWER)) {\n      push(cadr(p1));\n      push(caddr(p1));\n    } else {\n      push(p1);\n      push(one);\n    }\n    k = tos;\n    // contruct divisors by recursive descent\n    push(one);\n    gen(h, k);\n    // move\n    n = tos - k;\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      stack[h + i] = stack[k + i];\n    }\n    moveTos(h + n);\n    return restore();\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Generate divisors\n\n  //  Input:    Base-exponent pairs on stack\n\n  //      h  first pair\n\n  //      k  just past last pair\n\n  //  Output:    Divisors on stack\n\n  //  For example, factor list 2 2 3 1 results in 6 divisors,\n\n  //    1\n  //    3\n  //    2\n  //    6\n  //    4\n  //    12\n\n  //-----------------------------------------------------------------------------\n\n  //define ACCUM p1\n  //define BASE p2\n  //define EXPO p3\n  gen = function(h, k) {\n    var expo, i, o, ref;\n    expo = 0;\n    i = 0;\n    save();\n    p1 = pop();\n    if (h === k) {\n      push(p1);\n      restore();\n      return;\n    }\n    p2 = stack[h + 0];\n    p3 = stack[h + 1];\n    push(p3);\n    expo = pop_integer();\n    if (!isNaN(expo)) {\n      for (i = o = 0, ref = Math.abs(expo); (0 <= ref ? o <= ref : o >= ref); i = 0 <= ref ? ++o : --o) {\n        push(p1);\n        push(p2);\n        push_integer(sign(expo) * i);\n        power();\n        multiply();\n        gen(h + 2, k);\n      }\n    }\n    return restore();\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Factor ADD expression\n\n  //  Input:    Expression on stack\n\n  //  Output:    Factors on stack\n\n  //  Each factor consists of two expressions, the factor itself followed\n  //  by the exponent.\n\n  //-----------------------------------------------------------------------------\n  __factor_add = function() {\n    save();\n    p1 = pop();\n    // get gcd of all terms\n    p3 = cdr(p1);\n    push(car(p3));\n    p3 = cdr(p3);\n    while (iscons(p3)) {\n      push(car(p3));\n      gcd();\n      p3 = cdr(p3);\n    }\n    // check gcd\n    p2 = pop();\n    if (isplusone(p2)) {\n      push(p1);\n      push(one);\n      restore();\n      return;\n    }\n    // push factored gcd\n    if (isNumericAtom(p2)) {\n      push(p2);\n      factor_small_number();\n    } else if (car(p2) === symbol(MULTIPLY)) {\n      p3 = cdr(p2);\n      if (isNumericAtom(car(p3))) {\n        push(car(p3));\n        factor_small_number();\n      } else {\n        push(car(p3));\n        push(one);\n      }\n      p3 = cdr(p3);\n      while (iscons(p3)) {\n        push(car(p3));\n        push(one);\n        p3 = cdr(p3);\n      }\n    } else {\n      push(p2);\n      push(one);\n    }\n    // divide each term by gcd\n    push(p2);\n    inverse();\n    p2 = pop();\n    push(zero);\n    p3 = cdr(p1);\n    while (iscons(p3)) {\n      push(p2);\n      push(car(p3));\n      multiply();\n      add();\n      p3 = cdr(p3);\n    }\n    push(one);\n    return restore();\n  };\n\n  // power function for double precision floating point\n  dpow = function() {\n    var a, b, base, expo, result, theta;\n    a = 0.0;\n    b = 0.0;\n    base = 0.0;\n    expo = 0.0;\n    result = 0.0;\n    theta = 0.0;\n    expo = pop_double();\n    base = pop_double();\n    // divide by zero?\n    if (base === 0.0 && expo < 0.0) {\n      stop(\"divide by zero\");\n    }\n    // nonnegative base or integer power?\n    if (base >= 0.0 || (expo % 1.0) === 0.0) {\n      result = Math.pow(base, expo);\n      push_double(result);\n      return;\n    }\n    result = Math.pow(Math.abs(base), expo);\n    theta = Math.PI * expo;\n    // this ensures the real part is 0.0 instead of a tiny fraction\n    if ((expo % 0.5) === 0.0) {\n      a = 0.0;\n      b = Math.sin(theta);\n    } else {\n      a = Math.cos(theta);\n      b = Math.sin(theta);\n    }\n    push_double(a * result);\n    push_double(b * result);\n    push(imaginaryunit);\n    multiply();\n    return add();\n  };\n\n  /* eigen =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  m\n\n  General description\n  -------------------\n  Compute eigenvalues and eigenvectors. Matrix m must be both numerical and symmetric.\n  The eigenval function returns a matrix with the eigenvalues along the diagonal.\n  The eigenvec function returns a matrix with the eigenvectors arranged as row vectors.\n  The eigen function does not return anything but stores the eigenvalue matrix in D\n  and the eigenvector matrix in Q.\n\n  Input:    stack[tos - 1]    symmetric matrix\n\n  Output:    D      diagnonal matrix\n        Q      eigenvector matrix\n\n  D and Q have the property that\n\n    A == dot(transpose(Q),D,Q)\n\n  where A is the original matrix.\n\n  The eigenvalues are on the diagonal of D.\n  The eigenvectors are row vectors in Q.\n\n  The eigenvalue relation:\n\n    A X = lambda X\n\n  can be checked as follows:\n\n    lambda = D[1,1]\n    X = Q[1]\n    dot(A,X) - lambda X\n\n  Example 1. Check the relation AX = lambda X where lambda is an eigenvalue and X is the associated eigenvector.\n\n  Enter:\n\n       A = hilbert(3)\n\n       eigen(A)\n\n       lambda = D[1,1]\n\n       X = Q[1]\n\n       dot(A,X) - lambda X\n\n  Result:\n\n       -1.16435e-14\n\n       -6.46705e-15\n\n       -4.55191e-15\n\n  Example 2: Check the relation A = QTDQ.\n\n  Enter:\n\n    A - dot(transpose(Q),D,Q)\n\n  Result: \n\n    6.27365e-12    -1.58236e-11   1.81902e-11\n\n    -1.58236e-11   -1.95365e-11   2.56514e-12\n\n    1.81902e-11    2.56514e-12    1.32627e-11\n\n  */\n  //define D(i, j) yydd[EIG_N * (i) + (j)]\n  //define Q(i, j) yyqq[EIG_N * (i) + (j)]\n  EIG_N = 0;\n\n  EIG_yydd = [];\n\n  EIG_yyqq = [];\n\n  Eval_eigen = function() {\n    if (EIG_check_arg() === 0) {\n      stop(\"eigen: argument is not a square matrix\");\n    }\n    eigen(EIGEN);\n    p1 = usr_symbol(\"D\");\n    set_binding(p1, p2);\n    p1 = usr_symbol(\"Q\");\n    set_binding(p1, p3);\n    return push(symbol(NIL));\n  };\n\n  Eval_eigenval = function() {\n    if (EIG_check_arg() === 0) {\n      push_symbol(EIGENVAL);\n      push(p1);\n      list(2);\n      return;\n    }\n    eigen(EIGENVAL);\n    return push(p2);\n  };\n\n  Eval_eigenvec = function() {\n    if (EIG_check_arg() === 0) {\n      push_symbol(EIGENVEC);\n      push(p1);\n      list(2);\n      return;\n    }\n    eigen(EIGENVEC);\n    return push(p3);\n  };\n\n  EIG_check_arg = function() {\n    var i, i1, j, j1, l1, o, ref, ref1, ref2, ref3, ref4;\n    i = 0;\n    j = 0;\n    push(cadr(p1));\n    Eval();\n    yyfloat();\n    Eval();\n    p1 = pop();\n    if (!istensor(p1)) {\n      return 0;\n    }\n    if (p1.tensor.ndim !== 2 || p1.tensor.dim[0] !== p1.tensor.dim[1]) {\n      stop(\"eigen: argument is not a square matrix\");\n    }\n    EIG_N = p1.tensor.dim[0];\n    for (i = o = 0, ref = EIG_N; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      for (j = i1 = 0, ref1 = EIG_N; (0 <= ref1 ? i1 < ref1 : i1 > ref1); j = 0 <= ref1 ? ++i1 : --i1) {\n        if (!isdouble(p1.tensor.elem[EIG_N * i + j])) {\n          stop(\"eigen: matrix is not numerical\");\n        }\n      }\n    }\n    for (i = j1 = 0, ref2 = EIG_N - 1; (0 <= ref2 ? j1 < ref2 : j1 > ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n      for (j = l1 = ref3 = i + 1, ref4 = EIG_N; (ref3 <= ref4 ? l1 < ref4 : l1 > ref4); j = ref3 <= ref4 ? ++l1 : --l1) {\n        if (Math.abs(p1.tensor.elem[EIG_N * i + j].d - p1.tensor.elem[EIG_N * j + i].d) > 1e-10) {\n          stop(\"eigen: matrix is not symmetrical\");\n        }\n      }\n    }\n    return 1;\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Input:    p1    matrix\n\n  //  Output:    p2    eigenvalues\n\n  //      p3    eigenvectors\n\n  //-----------------------------------------------------------------------------\n  eigen = function(op) {\n    var i, i1, j, j1, l1, m1, n1, o, o1, q1, r1, ref, ref1, ref10, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, results, s1;\n    i = 0;\n    j = 0;\n// malloc working vars\n\n    //EIG_yydd = (double *) malloc(n * n * sizeof (double))\n    for (i = o = 0, ref = EIG_N * EIG_N; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      EIG_yydd[i] = 0.0;\n    }\n//if (EIG_yydd == NULL)\n//  stop(\"malloc failure\")\n\n    //EIG_yyqq = (double *) malloc(n * n * sizeof (double))\n    for (i = i1 = 0, ref1 = EIG_N * EIG_N; (0 <= ref1 ? i1 < ref1 : i1 > ref1); i = 0 <= ref1 ? ++i1 : --i1) {\n      EIG_yyqq[i] = 0.0;\n    }\n//if (EIG_yyqq == NULL)\n//  stop(\"malloc failure\")\n\n    // initialize D\n    for (i = j1 = 0, ref2 = EIG_N; (0 <= ref2 ? j1 < ref2 : j1 > ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n      EIG_yydd[EIG_N * i + i] = p1.tensor.elem[EIG_N * i + i].d;\n      for (j = l1 = ref3 = i + 1, ref4 = EIG_N; (ref3 <= ref4 ? l1 < ref4 : l1 > ref4); j = ref3 <= ref4 ? ++l1 : --l1) {\n        EIG_yydd[EIG_N * i + j] = p1.tensor.elem[EIG_N * i + j].d;\n        EIG_yydd[EIG_N * j + i] = p1.tensor.elem[EIG_N * i + j].d;\n      }\n    }\n// initialize Q\n    for (i = m1 = 0, ref5 = EIG_N; (0 <= ref5 ? m1 < ref5 : m1 > ref5); i = 0 <= ref5 ? ++m1 : --m1) {\n      EIG_yyqq[EIG_N * i + i] = 1.0;\n      for (j = n1 = ref6 = i + 1, ref7 = EIG_N; (ref6 <= ref7 ? n1 < ref7 : n1 > ref7); j = ref6 <= ref7 ? ++n1 : --n1) {\n        EIG_yyqq[EIG_N * i + j] = 0.0;\n        EIG_yyqq[EIG_N * j + i] = 0.0;\n      }\n    }\n// step up to 100 times\n    for (i = o1 = 0; o1 < 100; i = ++o1) {\n      if (step() === 0) {\n        break;\n      }\n    }\n    if (i === 100) {\n      printstr(\"\\nnote: eigen did not converge\\n\");\n    }\n    // p2 = D\n    if (op === EIGEN || op === EIGENVAL) {\n      push(p1);\n      copy_tensor();\n      p2 = pop();\n      for (i = q1 = 0, ref8 = EIG_N; (0 <= ref8 ? q1 < ref8 : q1 > ref8); i = 0 <= ref8 ? ++q1 : --q1) {\n        for (j = r1 = 0, ref9 = EIG_N; (0 <= ref9 ? r1 < ref9 : r1 > ref9); j = 0 <= ref9 ? ++r1 : --r1) {\n          push_double(EIG_yydd[EIG_N * i + j]);\n          p2.tensor.elem[EIG_N * i + j] = pop();\n        }\n      }\n    }\n    // p3 = Q\n    if (op === EIGEN || op === EIGENVEC) {\n      push(p1);\n      copy_tensor();\n      p3 = pop();\n      results = [];\n      for (i = s1 = 0, ref10 = EIG_N; (0 <= ref10 ? s1 < ref10 : s1 > ref10); i = 0 <= ref10 ? ++s1 : --s1) {\n        results.push((function() {\n          var ref11, results1, t1;\n          results1 = [];\n          for (j = t1 = 0, ref11 = EIG_N; (0 <= ref11 ? t1 < ref11 : t1 > ref11); j = 0 <= ref11 ? ++t1 : --t1) {\n            push_double(EIG_yyqq[EIG_N * i + j]);\n            results1.push(p3.tensor.elem[EIG_N * i + j] = pop());\n          }\n          return results1;\n        })());\n      }\n      return results;\n    }\n  };\n\n  // free working vars\n\n  //-----------------------------------------------------------------------------\n\n  //  Example: p = 1, q = 3\n\n  //    c  0  s  0\n\n  //    0  1  0  0\n  //  G =\n  //    -s  0  c  0\n\n  //    0  0  0  1\n\n  //  The effect of multiplying G times A is...\n\n  //  row 1 of A    = c (row 1 of A ) + s (row 3 of A )\n  //            n+1                n                 n\n\n  //  row 3 of A    = c (row 3 of A ) - s (row 1 of A )\n  //            n+1                n                 n\n\n  //  In terms of components the overall effect is...\n\n  //  row 1 = c row 1 + s row 3\n\n  //    A[1,1] = c A[1,1] + s A[3,1]\n\n  //    A[1,2] = c A[1,2] + s A[3,2]\n\n  //    A[1,3] = c A[1,3] + s A[3,3]\n\n  //    A[1,4] = c A[1,4] + s A[3,4]\n\n  //  row 3 = c row 3 - s row 1\n\n  //    A[3,1] = c A[3,1] - s A[1,1]\n\n  //    A[3,2] = c A[3,2] - s A[1,2]\n\n  //    A[3,3] = c A[3,3] - s A[1,3]\n\n  //    A[3,4] = c A[3,4] - s A[1,4]\n\n  //                                     T\n  //  The effect of multiplying A times G  is...\n\n  //  col 1 of A    = c (col 1 of A ) + s (col 3 of A )\n  //            n+1                n                 n\n\n  //  col 3 of A    = c (col 3 of A ) - s (col 1 of A )\n  //            n+1                n                 n\n\n  //  In terms of components the overall effect is...\n\n  //  col 1 = c col 1 + s col 3\n\n  //    A[1,1] = c A[1,1] + s A[1,3]\n\n  //    A[2,1] = c A[2,1] + s A[2,3]\n\n  //    A[3,1] = c A[3,1] + s A[3,3]\n\n  //    A[4,1] = c A[4,1] + s A[4,3]\n\n  //  col 3 = c col 3 - s col 1\n\n  //    A[1,3] = c A[1,3] - s A[1,1]\n\n  //    A[2,3] = c A[2,3] - s A[2,1]\n\n  //    A[3,3] = c A[3,3] - s A[3,1]\n\n  //    A[4,3] = c A[4,3] - s A[4,1]\n\n  //  What we want to do is just compute the upper triangle of A since we\n  //  know the lower triangle is identical.\n\n  //  In other words, we just want to update components A[i,j] where i < j.\n\n  //-----------------------------------------------------------------------------\n\n  //  Example: p = 2, q = 5\n\n  //        p      q\n\n  //      j=1  j=2  j=3  j=4  j=5  j=6\n\n  //    i=1  .  A[1,2]  .  .  A[1,5]  .\n\n  //  p  i=2  A[2,1]  A[2,2]  A[2,3]  A[2,4]  A[2,5]  A[2,6]\n\n  //    i=3  .  A[3,2]  .  .  A[3,5]  .\n\n  //    i=4  .  A[4,2]  .  .  A[4,5]  .\n\n  //  q  i=5  A[5,1]  A[5,2]  A[5,3]  A[5,4]  A[5,5]  A[5,6]\n\n  //    i=6  .  A[6,2]  .  .  A[6,5]  .\n\n  //-----------------------------------------------------------------------------\n\n  //  This is what B = GA does:\n\n  //  row 2 = c row 2 + s row 5\n\n  //    B[2,1] = c * A[2,1] + s * A[5,1]\n  //    B[2,2] = c * A[2,2] + s * A[5,2]\n  //    B[2,3] = c * A[2,3] + s * A[5,3]\n  //    B[2,4] = c * A[2,4] + s * A[5,4]\n  //    B[2,5] = c * A[2,5] + s * A[5,5]\n  //    B[2,6] = c * A[2,6] + s * A[5,6]\n\n  //  row 5 = c row 5 - s row 2\n\n  //    B[5,1] = c * A[5,1] + s * A[2,1]\n  //    B[5,2] = c * A[5,2] + s * A[2,2]\n  //    B[5,3] = c * A[5,3] + s * A[2,3]\n  //    B[5,4] = c * A[5,4] + s * A[2,4]\n  //    B[5,5] = c * A[5,5] + s * A[2,5]\n  //    B[5,6] = c * A[5,6] + s * A[2,6]\n\n  //                 T\n  //  This is what BG  does:\n\n  //  col 2 = c col 2 + s col 5\n\n  //    B[1,2] = c * A[1,2] + s * A[1,5]\n  //    B[2,2] = c * A[2,2] + s * A[2,5]\n  //    B[3,2] = c * A[3,2] + s * A[3,5]\n  //    B[4,2] = c * A[4,2] + s * A[4,5]\n  //    B[5,2] = c * A[5,2] + s * A[5,5]\n  //    B[6,2] = c * A[6,2] + s * A[6,5]\n\n  //  col 5 = c col 5 - s col 2\n\n  //    B[1,5] = c * A[1,5] - s * A[1,2]\n  //    B[2,5] = c * A[2,5] - s * A[2,2]\n  //    B[3,5] = c * A[3,5] - s * A[3,2]\n  //    B[4,5] = c * A[4,5] - s * A[4,2]\n  //    B[5,5] = c * A[5,5] - s * A[5,2]\n  //    B[6,5] = c * A[6,5] - s * A[6,2]\n\n  //-----------------------------------------------------------------------------\n\n  //  Step 1: Just do upper triangle (i < j), B[2,5] = 0\n\n  //    B[1,2] = c * A[1,2] + s * A[1,5]\n\n  //    B[2,3] = c * A[2,3] + s * A[5,3]\n  //    B[2,4] = c * A[2,4] + s * A[5,4]\n  //    B[2,6] = c * A[2,6] + s * A[5,6]\n\n  //    B[1,5] = c * A[1,5] - s * A[1,2]\n  //    B[3,5] = c * A[3,5] - s * A[3,2]\n  //    B[4,5] = c * A[4,5] - s * A[4,2]\n\n  //    B[5,6] = c * A[5,6] + s * A[2,6]\n\n  //-----------------------------------------------------------------------------\n\n  //  Step 2: Transpose where i > j since A[i,j] == A[j,i]\n\n  //    B[1,2] = c * A[1,2] + s * A[1,5]\n\n  //    B[2,3] = c * A[2,3] + s * A[3,5]\n  //    B[2,4] = c * A[2,4] + s * A[4,5]\n  //    B[2,6] = c * A[2,6] + s * A[5,6]\n\n  //    B[1,5] = c * A[1,5] - s * A[1,2]\n  //    B[3,5] = c * A[3,5] - s * A[2,3]\n  //    B[4,5] = c * A[4,5] - s * A[2,4]\n\n  //    B[5,6] = c * A[5,6] + s * A[2,6]\n\n  //-----------------------------------------------------------------------------\n\n  //  Step 3: Same as above except reorder\n\n  //  k < p    (k = 1)\n\n  //    A[1,2] = c * A[1,2] + s * A[1,5]\n  //    A[1,5] = c * A[1,5] - s * A[1,2]\n\n  //  p < k < q  (k = 3..4)\n\n  //    A[2,3] = c * A[2,3] + s * A[3,5]\n  //    A[3,5] = c * A[3,5] - s * A[2,3]\n\n  //    A[2,4] = c * A[2,4] + s * A[4,5]\n  //    A[4,5] = c * A[4,5] - s * A[2,4]\n\n  //  q < k    (k = 6)\n\n  //    A[2,6] = c * A[2,6] + s * A[5,6]\n  //    A[5,6] = c * A[5,6] - s * A[2,6]\n\n  //-----------------------------------------------------------------------------\n  step = function() {\n    var count, i, i1, j, o, ref, ref1, ref2;\n    i = 0;\n    j = 0;\n    count = 0;\n// for each upper triangle \"off-diagonal\" component do step2\n    for (i = o = 0, ref = EIG_N - 1; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      for (j = i1 = ref1 = i + 1, ref2 = EIG_N; (ref1 <= ref2 ? i1 < ref2 : i1 > ref2); j = ref1 <= ref2 ? ++i1 : --i1) {\n        if (EIG_yydd[EIG_N * i + j] !== 0.0) {\n          step2(i, j);\n          count++;\n        }\n      }\n    }\n    return count;\n  };\n\n  step2 = function(p, q) {\n    var c, cc, i1, j1, k, o, ref, ref1, ref2, s, ss, t, theta;\n    k = 0;\n    t = 0.0;\n    theta = 0.0;\n    c = 0.0;\n    cc = 0.0;\n    s = 0.0;\n    ss = 0.0;\n    // compute c and s\n\n    // from Numerical Recipes (except they have a_qq - a_pp)\n    theta = 0.5 * (EIG_yydd[EIG_N * p + p] - EIG_yydd[EIG_N * q + q]) / EIG_yydd[EIG_N * p + q];\n    t = 1.0 / (Math.abs(theta) + Math.sqrt(theta * theta + 1.0));\n    if (theta < 0.0) {\n      t = -t;\n    }\n    c = 1.0 / Math.sqrt(t * t + 1.0);\n    s = t * c;\n// D = GD\n\n    // which means \"add rows\"\n    for (k = o = 0, ref = EIG_N; (0 <= ref ? o < ref : o > ref); k = 0 <= ref ? ++o : --o) {\n      cc = EIG_yydd[EIG_N * p + k];\n      ss = EIG_yydd[EIG_N * q + k];\n      EIG_yydd[EIG_N * p + k] = c * cc + s * ss;\n      EIG_yydd[EIG_N * q + k] = c * ss - s * cc;\n    }\n// D = D transpose(G)\n\n    // which means \"add columns\"\n    for (k = i1 = 0, ref1 = EIG_N; (0 <= ref1 ? i1 < ref1 : i1 > ref1); k = 0 <= ref1 ? ++i1 : --i1) {\n      cc = EIG_yydd[EIG_N * k + p];\n      ss = EIG_yydd[EIG_N * k + q];\n      EIG_yydd[EIG_N * k + p] = c * cc + s * ss;\n      EIG_yydd[EIG_N * k + q] = c * ss - s * cc;\n    }\n// Q = GQ\n\n    // which means \"add rows\"\n    for (k = j1 = 0, ref2 = EIG_N; (0 <= ref2 ? j1 < ref2 : j1 > ref2); k = 0 <= ref2 ? ++j1 : --j1) {\n      cc = EIG_yyqq[EIG_N * p + k];\n      ss = EIG_yyqq[EIG_N * q + k];\n      EIG_yyqq[EIG_N * p + k] = c * cc + s * ss;\n      EIG_yyqq[EIG_N * q + k] = c * ss - s * cc;\n    }\n    EIG_yydd[EIG_N * p + q] = 0.0;\n    return EIG_yydd[EIG_N * q + p] = 0.0;\n  };\n\n  Eval_erf = function() {\n    push(cadr(p1));\n    Eval();\n    return yerf();\n  };\n\n  yerf = function() {\n    save();\n    yyerf();\n    return restore();\n  };\n\n  yyerf = function() {\n    var d;\n    d = 0.0;\n    p1 = pop();\n    if (isdouble(p1)) {\n      d = 1.0 - erfc(p1.d);\n      push_double(d);\n      return;\n    }\n    if (isZeroAtomOrTensor(p1)) {\n      push(zero);\n      return;\n    }\n    if (isnegativeterm(p1)) {\n      push_symbol(ERF);\n      push(p1);\n      negate();\n      list(2);\n      negate();\n      return;\n    }\n    push_symbol(ERF);\n    push(p1);\n    list(2);\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Author : philippe.billet@noos.fr\n\n  //  erfc(x)\n\n  //  GW  Added erfc() from Numerical Recipes in C\n\n  //-----------------------------------------------------------------------------\n  Eval_erfc = function() {\n    push(cadr(p1));\n    Eval();\n    return yerfc();\n  };\n\n  yerfc = function() {\n    save();\n    yyerfc();\n    return restore();\n  };\n\n  yyerfc = function() {\n    var d;\n    d = 0.0;\n    p1 = pop();\n    if (isdouble(p1)) {\n      d = erfc(p1.d);\n      push_double(d);\n      return;\n    }\n    if (isZeroAtomOrTensor(p1)) {\n      push(one);\n      return;\n    }\n    push_symbol(ERFC);\n    push(p1);\n    list(2);\n  };\n\n  // from Numerical Recipes in C\n  erfc = function(x) {\n    var ans, t, z;\n    if (x === 0) {\n      return 1.0;\n    }\n    t = 0.0;\n    z = 0.0;\n    ans = 0.0;\n    z = Math.abs(x);\n    t = 1.0 / (1.0 + 0.5 * z);\n    ans = t * Math.exp(-z * z - 1.26551223 + t * (1.00002368 + t * (0.37409196 + t * (0.09678418 + t * (-0.18628806 + t * (0.27886807 + t * (-1.13520398 + t * (1.48851587 + t * (-0.82215223 + t * 0.17087277)))))))));\n    if (x >= 0.0) {\n      return ans;\n    } else {\n      return 2.0 - ans;\n    }\n  };\n\n  // Evaluate an expression, for example...\n\n  //  push(p1)\n  //  Eval()\n  //  p2 = pop()\n  Eval = function() {\n    var willEvaluateAsFloats;\n    check_esc_flag();\n    save();\n    p1 = pop();\n    if (p1 == null) {\n      debugger;\n    }\n    if (!evaluatingAsFloats && isfloating(p1)) {\n      willEvaluateAsFloats = true;\n      evaluatingAsFloats++;\n    }\n    switch (p1.k) {\n      case CONS:\n        Eval_cons();\n        break;\n      case NUM:\n        if (evaluatingAsFloats) {\n          push_double(convert_rational_to_double(p1));\n        } else {\n          push(p1);\n        }\n        break;\n      case DOUBLE:\n      case STR:\n        push(p1);\n        break;\n      case TENSOR:\n        Eval_tensor();\n        break;\n      case SYM:\n        Eval_sym();\n        break;\n      default:\n        stop(\"atom?\");\n    }\n    if (willEvaluateAsFloats) {\n      evaluatingAsFloats--;\n    }\n    return restore();\n  };\n\n  Eval_sym = function() {\n    var cycleString, i, o, positionIfSymbolAlreadyBeingEvaluated, ref, ref1;\n    // note that function calls are not processed here\n    // because, since they have an argument (at least an empty one)\n    // they are actually CONs, which is a branch of the\n    // switch before the one that calls this function\n\n    // bare keyword?\n    // If it's a keyword, then we don't look\n    // at the binding array, because keywords\n    // are not redefinable. \n    if (iskeyword(p1)) {\n      push(p1);\n      push(symbol(LAST));\n      list(2);\n      Eval();\n      return;\n    } else if (p1 === symbol(PI) && evaluatingAsFloats) {\n      push_double(Math.PI);\n      return;\n    }\n    // Evaluate symbol's binding\n    p2 = get_binding(p1);\n    if (DEBUG) {\n      console.log(\"looked up: \" + p1 + \" which contains: \" + p2);\n    }\n    push(p2);\n    // differently from standard Lisp,\n    // here the evaluation is not\n    // one-step only, rather it keeps evaluating\n    // \"all the way\" until a symbol is\n    // defined as itself.\n    // Uncomment these two lines to get Lisp\n    // behaviour (and break most tests)\n    if (p1 !== p2) {\n      // detect recursive lookup of symbols, which would otherwise\n      // cause a stack overflow.\n      // Note that recursive functions will still work because\n      // as mentioned at the top, this method doesn't look\n      // up and evaluate function calls.\n      positionIfSymbolAlreadyBeingEvaluated = chainOfUserSymbolsNotFunctionsBeingEvaluated.indexOf(p1);\n      if (positionIfSymbolAlreadyBeingEvaluated !== -1) {\n        cycleString = \"\";\n        for (i = o = ref = positionIfSymbolAlreadyBeingEvaluated, ref1 = chainOfUserSymbolsNotFunctionsBeingEvaluated.length; (ref <= ref1 ? o < ref1 : o > ref1); i = ref <= ref1 ? ++o : --o) {\n          cycleString += chainOfUserSymbolsNotFunctionsBeingEvaluated[i].printname + \" -> \";\n        }\n        cycleString += p1.printname;\n        stop(\"recursive evaluation of symbols: \" + cycleString);\n        return;\n      }\n      chainOfUserSymbolsNotFunctionsBeingEvaluated.push(p1);\n      Eval();\n      return chainOfUserSymbolsNotFunctionsBeingEvaluated.pop();\n    }\n  };\n\n  Eval_cons = function() {\n    var cons_head;\n    cons_head = car(p1);\n    // normally the cons_head is a symbol,\n    // but sometimes in the case of\n    // functions we don't have a symbol,\n    // we have to evaluate something to get to the\n    // symbol. For example if a function is inside\n    // a tensor, then we need to evaluate an index\n    // access first to get to the function.\n    // In those cases, we find an EVAL here,\n    // so we proceed to EVAL\n    if (car(cons_head) === symbol(EVAL)) {\n      Eval_user_function();\n      return;\n    }\n    if (!issymbol(cons_head)) {\n      stop(\"cons?\");\n    }\n    switch (symnum(cons_head)) {\n      case ABS:\n        return Eval_abs();\n      case ADD:\n        return Eval_add();\n      case ADJ:\n        return Eval_adj();\n      case AND:\n        return Eval_and();\n      case ARCCOS:\n        return Eval_arccos();\n      case ARCCOSH:\n        return Eval_arccosh();\n      case ARCSIN:\n        return Eval_arcsin();\n      case ARCSINH:\n        return Eval_arcsinh();\n      case ARCTAN:\n        return Eval_arctan();\n      case ARCTANH:\n        return Eval_arctanh();\n      case ARG:\n        return Eval_arg();\n      case ATOMIZE:\n        return Eval_atomize();\n      case BESSELJ:\n        return Eval_besselj();\n      case BESSELY:\n        return Eval_bessely();\n      case BINDING:\n        return Eval_binding();\n      case BINOMIAL:\n        return Eval_binomial();\n      case CEILING:\n        return Eval_ceiling();\n      case CHECK:\n        return Eval_check();\n      case CHOOSE:\n        return Eval_choose();\n      case CIRCEXP:\n        return Eval_circexp();\n      case CLEAR:\n        return Eval_clear();\n      case CLEARALL:\n        return Eval_clearall();\n      case CLEARPATTERNS:\n        return Eval_clearpatterns();\n      case CLOCK:\n        return Eval_clock();\n      case COEFF:\n        return Eval_coeff();\n      case COFACTOR:\n        return Eval_cofactor();\n      case CONDENSE:\n        return Eval_condense();\n      case CONJ:\n        return Eval_conj();\n      case CONTRACT:\n        return Eval_contract();\n      case COS:\n        return Eval_cos();\n      case COSH:\n        return Eval_cosh();\n      case DECOMP:\n        return Eval_decomp();\n      case DEGREE:\n        return Eval_degree();\n      case DEFINT:\n        return Eval_defint();\n      case DENOMINATOR:\n        return Eval_denominator();\n      case DERIVATIVE:\n        return Eval_derivative();\n      case DET:\n        return Eval_det();\n      case DIM:\n        return Eval_dim();\n      case DIRAC:\n        return Eval_dirac();\n      case DIVISORS:\n        return Eval_divisors();\n      case DO:\n        return Eval_do();\n      case DOT:\n        return Eval_inner();\n      case DRAW:\n        return Eval_draw();\n      case DSOLVE:\n        return Eval_dsolve();\n      case EIGEN:\n        return Eval_eigen();\n      case EIGENVAL:\n        return Eval_eigenval();\n      case EIGENVEC:\n        return Eval_eigenvec();\n      case ERF:\n        return Eval_erf();\n      case ERFC:\n        return Eval_erfc();\n      case EVAL:\n        return Eval_Eval();\n      case EXP:\n        return Eval_exp();\n      case EXPAND:\n        return Eval_expand();\n      case EXPCOS:\n        return Eval_expcos();\n      case EXPSIN:\n        return Eval_expsin();\n      case FACTOR:\n        return Eval_factor();\n      case FACTORIAL:\n        return Eval_factorial();\n      case FACTORPOLY:\n        return Eval_factorpoly();\n      case FILTER:\n        return Eval_filter();\n      case FLOATF:\n        return Eval_float();\n      case APPROXRATIO:\n        return Eval_approxratio();\n      case FLOOR:\n        return Eval_floor();\n      case FOR:\n        return Eval_for();\n      // this is invoked only when we\n      // evaluate a function that is NOT being called\n      // e.g. when f is a function as we do\n      //  g = f\n      case FUNCTION:\n        return Eval_function_reference();\n      case GAMMA:\n        return Eval_gamma();\n      case GCD:\n        return Eval_gcd();\n      case HERMITE:\n        return Eval_hermite();\n      case HILBERT:\n        return Eval_hilbert();\n      case IMAG:\n        return Eval_imag();\n      case INDEX:\n        return Eval_index();\n      case INNER:\n        return Eval_inner();\n      case INTEGRAL:\n        return Eval_integral();\n      case INV:\n        return Eval_inv();\n      case INVG:\n        return Eval_invg();\n      case ISINTEGER:\n        return Eval_isinteger();\n      case ISPRIME:\n        return Eval_isprime();\n      case LAGUERRE:\n        return Eval_laguerre();\n      //  when LAPLACE then Eval_laplace()\n      case LCM:\n        return Eval_lcm();\n      case LEADING:\n        return Eval_leading();\n      case LEGENDRE:\n        return Eval_legendre();\n      case LOG:\n        return Eval_log();\n      case LOOKUP:\n        return Eval_lookup();\n      case MOD:\n        return Eval_mod();\n      case MULTIPLY:\n        return Eval_multiply();\n      case NOT:\n        return Eval_not();\n      case NROOTS:\n        return Eval_nroots();\n      case NUMBER:\n        return Eval_number();\n      case NUMERATOR:\n        return Eval_numerator();\n      case OPERATOR:\n        return Eval_operator();\n      case OR:\n        return Eval_or();\n      case OUTER:\n        return Eval_outer();\n      case PATTERN:\n        return Eval_pattern();\n      case PATTERNSINFO:\n        return Eval_patternsinfo();\n      case POLAR:\n        return Eval_polar();\n      case POWER:\n        return Eval_power();\n      case PRIME:\n        return Eval_prime();\n      case PRINT:\n        return Eval_print();\n      case PRINT2DASCII:\n        return Eval_print2dascii();\n      case PRINTFULL:\n        return Eval_printcomputer();\n      case PRINTLATEX:\n        return Eval_printlatex();\n      case PRINTLIST:\n        return Eval_printlist();\n      case PRINTPLAIN:\n        return Eval_printhuman();\n      case PRODUCT:\n        return Eval_product();\n      case QUOTE:\n        return Eval_quote();\n      case QUOTIENT:\n        return Eval_quotient();\n      case RANK:\n        return Eval_rank();\n      case RATIONALIZE:\n        return Eval_rationalize();\n      case REAL:\n        return Eval_real();\n      case ROUND:\n        return Eval_round();\n      case YYRECT:\n        return Eval_rect();\n      case ROOTS:\n        return Eval_roots();\n      case SETQ:\n        return Eval_setq();\n      case SGN:\n        return Eval_sgn();\n      case SILENTPATTERN:\n        return Eval_silentpattern();\n      case SIMPLIFY:\n        return Eval_simplify();\n      case SIN:\n        return Eval_sin();\n      case SINH:\n        return Eval_sinh();\n      case SHAPE:\n        return Eval_shape();\n      case SQRT:\n        return Eval_sqrt();\n      case STOP:\n        return Eval_stop();\n      case SUBST:\n        return Eval_subst();\n      case SUM:\n        return Eval_sum();\n      case SYMBOLSINFO:\n        return Eval_symbolsinfo();\n      case TAN:\n        return Eval_tan();\n      case TANH:\n        return Eval_tanh();\n      case TAYLOR:\n        return Eval_taylor();\n      case TEST:\n        return Eval_test();\n      case TESTEQ:\n        return Eval_testeq();\n      case TESTGE:\n        return Eval_testge();\n      case TESTGT:\n        return Eval_testgt();\n      case TESTLE:\n        return Eval_testle();\n      case TESTLT:\n        return Eval_testlt();\n      case TRANSPOSE:\n        return Eval_transpose();\n      case UNIT:\n        return Eval_unit();\n      case ZERO:\n        return Eval_zero();\n      default:\n        return Eval_user_function();\n    }\n  };\n\n  Eval_binding = function() {\n    return push(get_binding(cadr(p1)));\n  };\n\n  Eval_check = function() {\n    var checkResult;\n    // check the argument\n    checkResult = isZeroLikeOrNonZeroLikeOrUndetermined(cadr(p1));\n    if (checkResult == null) {\n      // returned null: unknown result\n      // leave the whole check unevalled\n      return push(p1);\n    } else {\n      // returned 1 or 0\n      return push_integer(checkResult);\n    }\n  };\n\n  Eval_det = function() {\n    push(cadr(p1));\n    Eval();\n    return det();\n  };\n\n  Eval_dim = function() {\n    var n;\n    //int n\n    push(cadr(p1));\n    Eval();\n    p2 = pop();\n    if (iscons(cddr(p1))) {\n      push(caddr(p1));\n      Eval();\n      n = pop_integer();\n    } else {\n      n = 1;\n    }\n    if (!istensor(p2)) {\n      return push_integer(1); // dim of scalar is 1\n    } else if (n < 1 || n > p2.tensor.ndim) {\n      return push(p1);\n    } else {\n      return push_integer(p2.tensor.dim[n - 1]);\n    }\n  };\n\n  Eval_divisors = function() {\n    push(cadr(p1));\n    Eval();\n    return divisors();\n  };\n\n  Eval_do = function() {\n    var results;\n    push(car(p1));\n    p1 = cdr(p1);\n    results = [];\n    while (iscons(p1)) {\n      pop();\n      push(car(p1));\n      Eval();\n      results.push(p1 = cdr(p1));\n    }\n    return results;\n  };\n\n  Eval_dsolve = function() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    push(cadddr(p1));\n    Eval();\n    return dsolve();\n  };\n\n  // for example, Eval(f,x,2)\n  Eval_Eval = function() {\n    push(cadr(p1));\n    Eval();\n    p1 = cddr(p1);\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n      push(cadr(p1));\n      Eval();\n      subst();\n      p1 = cddr(p1);\n    }\n    return Eval();\n  };\n\n  // exp evaluation: it replaces itself with\n  // a POWER(E,something) node and evals that one\n  Eval_exp = function() {\n    push(cadr(p1));\n    Eval();\n    return exponential();\n  };\n\n  Eval_factorial = function() {\n    push(cadr(p1));\n    Eval();\n    return factorial();\n  };\n\n  Eval_factorpoly = function() {\n    var results;\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    factorpoly();\n    p1 = cdr(p1);\n    results = [];\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n      factorpoly();\n      results.push(p1 = cdr(p1));\n    }\n    return results;\n  };\n\n  Eval_hermite = function() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    return hermite();\n  };\n\n  Eval_hilbert = function() {\n    push(cadr(p1));\n    Eval();\n    return hilbert();\n  };\n\n  Eval_index = function() {\n    var h, orig, theTensor;\n    h = tos;\n    orig = p1;\n    \n    // look into the head of the list,\n    // when evaluated it should be a tensor\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    theTensor = stack[tos - 1];\n    if (isNumericAtom(theTensor)) {\n      stop(\"trying to access a scalar as a tensor\");\n    }\n    if (!istensor(theTensor)) {\n      // the tensor is not allocated yet, so\n      // leaving the expression unevalled\n      moveTos(h);\n      push(orig);\n      return;\n    }\n    // we examined the head of the list which\n    // was the tensor, now look into\n    // the indexes\n    p1 = cdr(p1);\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n      if (!isintegerorintegerfloat(stack[tos - 1])) {\n        // index with something other than\n        // an integer\n        moveTos(h);\n        push(orig);\n        return;\n      }\n      p1 = cdr(p1);\n    }\n    return index_function(tos - h);\n  };\n\n  Eval_inv = function() {\n    push(cadr(p1));\n    Eval();\n    return inv();\n  };\n\n  Eval_invg = function() {\n    push(cadr(p1));\n    Eval();\n    return invg();\n  };\n\n  Eval_isinteger = function() {\n    var n;\n    push(cadr(p1));\n    Eval();\n    p1 = pop();\n    if (isrational(p1)) {\n      if (isinteger(p1)) {\n        push(one);\n      } else {\n        push(zero);\n      }\n      return;\n    }\n    if (isdouble(p1)) {\n      n = Math.floor(p1.d);\n      if (n === p1.d) {\n        push(one);\n      } else {\n        push(zero);\n      }\n      return;\n    }\n    push_symbol(ISINTEGER);\n    push(p1);\n    return list(2);\n  };\n\n  Eval_number = function() {\n    push(cadr(p1));\n    Eval();\n    p1 = pop();\n    if (p1.k === NUM || p1.k === DOUBLE) {\n      return push_integer(1);\n    } else {\n      return push_integer(0);\n    }\n  };\n\n  Eval_operator = function() {\n    var h;\n    h = tos;\n    push_symbol(OPERATOR);\n    p1 = cdr(p1);\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n      p1 = cdr(p1);\n    }\n    return list(tos - h);\n  };\n\n  // quote definition\n  Eval_quote = function() {\n    return push(cadr(p1));\n  };\n\n  // rank definition\n  Eval_rank = function() {\n    push(cadr(p1));\n    Eval();\n    p1 = pop();\n    if (istensor(p1)) {\n      return push_integer(p1.tensor.ndim);\n    } else {\n      return push(zero);\n    }\n  };\n\n  // Evaluates the right side and assigns the\n  // result of the evaluation to the left side.\n  // It's called setq because it stands for \"set quoted\" from Lisp,\n  // see:\n  //   http://stackoverflow.com/questions/869529/difference-between-set-setq-and-setf-in-common-lisp\n  // Note that this also takes case of assigning to a tensor\n  // element, which is something that setq wouldn't do\n  // in list, see comments further down below.\n\n  // Example:\n  //   f = x\n  //   // f evaluates to x, so x is assigned to g really\n  //   // rather than actually f being assigned to g\n  //   g = f\n  //   f = y\n  //   g\n  //   > x\n  Eval_setq = function() {\n    // case of tensor\n    if (caadr(p1) === symbol(INDEX)) {\n      setq_indexed();\n      return;\n    }\n    // case of function definition\n    if (iscons(cadr(p1))) {\n      define_user_function();\n      return;\n    }\n    if (!issymbol(cadr(p1))) {\n      stop(\"symbol assignment: error in symbol\");\n    }\n    push(caddr(p1));\n    Eval();\n    p2 = pop();\n    set_binding(cadr(p1), p2);\n    // An assignment returns nothing.\n    // This is unlike most programming languages\n    // where an assignment does return the\n    // assigned value.\n    // TODO Could be changed.\n    return push(symbol(NIL));\n  };\n\n  // Here \"setq\" is a misnomer because\n  // setq wouldn't work in Lisp to set array elements\n  // since setq stands for \"set quoted\" and you wouldn't\n  // quote an array element access.\n  // You'd rather use setf, which is a macro that can\n  // assign a value to anything.\n  //   (setf (aref YourArray 2) \"blue\")\n  // see\n  //   http://stackoverflow.com/questions/18062016/common-lisp-how-to-set-an-element-in-a-2d-array\n  //-----------------------------------------------------------------------------\n\n  //  Example: a[1] = b\n\n  //  p1  *-------*-----------------------*\n  //    |  |      |\n  //    setq  *-------*-------*  b\n  //      |  |  |\n  //      index  a  1\n\n  //  cadadr(p1) -> a\n\n  //-----------------------------------------------------------------------------\n  setq_indexed = function() {\n    var h;\n    p4 = cadadr(p1);\n    if (!issymbol(p4)) {\n      // this is likely to happen when one tries to\n      // do assignments like these\n      //   1[2] = 3\n      // or\n      //   f(x)[1] = 2\n      // or\n      //   [[1,2],[3,4]][5] = 6\n\n      // In other words, one can only do\n      // a straight assignment like\n      //   existingMatrix[index] = something\n      stop(\"indexed assignment: expected a symbol name\");\n    }\n    h = tos;\n    push(caddr(p1));\n    Eval();\n    p2 = cdadr(p1);\n    while (iscons(p2)) {\n      push(car(p2));\n      Eval();\n      p2 = cdr(p2);\n    }\n    set_component(tos - h);\n    p3 = pop();\n    set_binding(p4, p3);\n    return push(symbol(NIL));\n  };\n\n  Eval_sqrt = function() {\n    push(cadr(p1));\n    Eval();\n    push_rational(1, 2);\n    return power();\n  };\n\n  Eval_stop = function() {\n    return stop(\"user stop\");\n  };\n\n  Eval_subst = function() {\n    push(cadddr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    push(cadr(p1));\n    Eval();\n    subst();\n    return Eval(); // normalize\n  };\n\n  \n  // always returns a matrix with rank 2\n  // i.e. two dimensions,\n  // the passed parameter is the size\n  Eval_unit = function() {\n    var i, n, o, ref;\n    i = 0;\n    n = 0;\n    push(cadr(p1));\n    Eval();\n    n = pop_integer();\n    if (isNaN(n)) {\n      push(p1);\n      return;\n    }\n    if (n < 1) {\n      push(p1);\n      return;\n    }\n    p1 = alloc_tensor(n * n);\n    p1.tensor.ndim = 2;\n    p1.tensor.dim[0] = n;\n    p1.tensor.dim[1] = n;\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      p1.tensor.elem[n * i + i] = one;\n    }\n    check_tensor_dimensions(p1);\n    return push(p1);\n  };\n\n  Eval_noexpand = function() {\n    var prev_expanding;\n    prev_expanding = expanding;\n    expanding = 0;\n    Eval();\n    return expanding = prev_expanding;\n  };\n\n  // like Eval() except \"=\" (assignment) is treated\n  // as \"==\" (equality test)\n  // This is because\n  //  * this allows users to be lazy and just\n  //    use \"=\" instead of \"==\" as per more common\n  //    mathematical notation\n  //  * in many places we don't expect an assignment\n  //    e.g. we don't expect to test the zero-ness\n  //    of an assignment or the truth value of\n  //    an assignment\n  // Note that these are questionable assumptions\n  // as for example in most programming languages one\n  // can indeed test the value of an assignment (the\n  // value is just the evaluation of the right side)\n  Eval_predicate = function() {\n    save();\n    p1 = top();\n    if (car(p1) === symbol(SETQ)) {\n      // replace the assignment in the\n      // head with an equality test\n      pop();\n      push_symbol(TESTEQ);\n      push(cadr(p1));\n      push(caddr(p1));\n      list(3);\n    }\n    Eval();\n    return restore();\n  };\n\n  // Partial fraction expansion\n\n  // Example\n\n  //      expand(1/(x^3+x^2),x)\n\n  //        1      1       1\n  //      ---- - --- + -------\n  //        2     x     x + 1\n  //       x\n  Eval_expand = function() {\n    // 1st arg\n    push(cadr(p1));\n    Eval();\n    // 2nd arg\n    push(caddr(p1));\n    Eval();\n    p2 = pop();\n    if (p2 === symbol(NIL)) {\n      guess();\n    } else {\n      push(p2);\n    }\n    return expand();\n  };\n\n  //define A p2\n  //define B p3\n  //define C p4\n  //define F p5\n  //define P p6\n  //define Q p7\n  //define T p8\n  //define X p9\n  expand = function() {\n    var prev_expanding;\n    save();\n    p9 = pop();\n    p5 = pop();\n    if (istensor(p5)) {\n      expand_tensor();\n      restore();\n      return;\n    }\n    // if sum of terms then sum over the expansion of each term\n    if (car(p5) === symbol(ADD)) {\n      push_integer(0);\n      p1 = cdr(p5);\n      while (iscons(p1)) {\n        push(car(p1));\n        push(p9);\n        expand();\n        add();\n        p1 = cdr(p1);\n      }\n      restore();\n      return;\n    }\n    // B = numerator\n    push(p5);\n    numerator();\n    p3 = pop();\n    // A = denominator\n    push(p5);\n    denominator();\n    p2 = pop();\n    remove_negative_exponents();\n    // Q = quotient\n    push(p3);\n    push(p2);\n    push(p9);\n    // if the denominator is one then always bail out\n    // also bail out if the denominator is not one but\n    // it's not anything recognizable as a polynomial.\n    if (isone(p3) || isone(p2)) {\n      if (!ispolyexpandedform(p2, p9) || isone(p2)) {\n        pop();\n        pop();\n        pop();\n        push(p5);\n        // p5 is the original input, leave unchanged\n        restore();\n        return;\n      }\n    }\n    divpoly();\n    p7 = pop();\n    // remainder B = B - A * Q\n    push(p3);\n    push(p2);\n    push(p7);\n    multiply();\n    subtract();\n    p3 = pop();\n    // if the remainder is zero then we're done\n    if (isZeroAtomOrTensor(p3)) {\n      push(p7);\n      restore();\n      return;\n    }\n    // A = factor(A)\n\n    //console.log(\"expand - to be factored: \" + p2)\n    push(p2);\n    push(p9);\n    factorpoly();\n    p2 = pop();\n    //console.log(\"expand - factored to: \" + p2)\n    expand_get_C();\n    expand_get_B();\n    expand_get_A();\n    if (istensor(p4)) {\n      push(p4);\n      prev_expanding = expanding;\n      expanding = 1;\n      inv();\n      expanding = prev_expanding;\n      push(p3);\n      inner();\n      push(p2);\n      inner();\n    } else {\n      push(p3);\n      push(p4);\n      prev_expanding = expanding;\n      expanding = 1;\n      divide();\n      expanding = prev_expanding;\n      push(p2);\n      multiply();\n    }\n    push(p7);\n    add();\n    return restore();\n  };\n\n  expand_tensor = function() {\n    var i, o, ref;\n    i = 0;\n    push(p5);\n    copy_tensor();\n    p5 = pop();\n    for (i = o = 0, ref = p5.tensor.nelem; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      push(p5.tensor.elem[i]);\n      push(p9);\n      expand();\n      p5.tensor.elem[i] = pop();\n    }\n    return push(p5);\n  };\n\n  remove_negative_exponents = function() {\n    var h, i, j, k, n, o, ref;\n    h = 0;\n    i = 0;\n    j = 0;\n    k = 0;\n    n = 0;\n    h = tos;\n    factors(p2);\n    factors(p3);\n    n = tos - h;\n    // find the smallest exponent\n    j = 0;\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      p1 = stack[h + i];\n      if (car(p1) !== symbol(POWER)) {\n        continue;\n      }\n      if (cadr(p1) !== p9) {\n        continue;\n      }\n      push(caddr(p1));\n      k = pop_integer();\n      if (isNaN(k)) {\n        continue;\n      }\n      if (k < j) {\n        j = k;\n      }\n    }\n    moveTos(h);\n    if (j === 0) {\n      return;\n    }\n    // A = A / X^j\n    push(p2);\n    push(p9);\n    push_integer(-j);\n    power();\n    multiply();\n    p2 = pop();\n    // B = B / X^j\n    push(p3);\n    push(p9);\n    push_integer(-j);\n    power();\n    multiply();\n    return p3 = pop();\n  };\n\n  // Returns the expansion coefficient matrix C.\n\n  // Example:\n\n  //       B         1\n  //      --- = -----------\n  //       A      2 \n  //             x (x + 1)\n\n  // We have\n\n  //       B     Y1     Y2      Y3\n  //      --- = ---- + ---- + -------\n  //       A      2     x      x + 1\n  //             x\n\n  // Our task is to solve for the unknowns Y1, Y2, and Y3.\n\n  // Multiplying both sides by A yields\n\n  //           AY1     AY2      AY3\n  //      B = ----- + ----- + -------\n  //            2      x       x + 1\n  //           x\n\n  // Let\n\n  //            A               A                 A\n  //      W1 = ----       W2 = ---        W3 = -------\n  //             2              x               x + 1\n  //            x\n\n  // Then the coefficient matrix C is\n\n  //              coeff(W1,x,0)   coeff(W2,x,0)   coeff(W3,x,0)\n\n  //       C =    coeff(W1,x,1)   coeff(W2,x,1)   coeff(W3,x,1)\n\n  //              coeff(W1,x,2)   coeff(W2,x,2)   coeff(W3,x,2)\n\n  // It follows that\n\n  //       coeff(B,x,0)     Y1\n\n  //       coeff(B,x,1) = C Y2\n\n  //       coeff(B,x,2) =   Y3\n\n  // Hence\n\n  //       Y1       coeff(B,x,0)\n  //             -1\n  //       Y2 = C   coeff(B,x,1)\n\n  //       Y3       coeff(B,x,2)\n  expand_get_C = function() {\n    var a, h, i, i1, j, n, o, prev_expanding, ref, ref1;\n    h = 0;\n    i = 0;\n    j = 0;\n    n = 0;\n    //U **a\n    h = tos;\n    if (car(p2) === symbol(MULTIPLY)) {\n      p1 = cdr(p2);\n      while (iscons(p1)) {\n        p5 = car(p1);\n        expand_get_CF();\n        p1 = cdr(p1);\n      }\n    } else {\n      p5 = p2;\n      expand_get_CF();\n    }\n    n = tos - h;\n    if (n === 1) {\n      p4 = pop();\n      return;\n    }\n    p4 = alloc_tensor(n * n);\n    p4.tensor.ndim = 2;\n    p4.tensor.dim[0] = n;\n    p4.tensor.dim[1] = n;\n    a = h;\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      for (j = i1 = 0, ref1 = n; (0 <= ref1 ? i1 < ref1 : i1 > ref1); j = 0 <= ref1 ? ++i1 : --i1) {\n        push(stack[a + j]);\n        push(p9);\n        push_integer(i);\n        power();\n        prev_expanding = expanding;\n        expanding = 1;\n        divide();\n        expanding = prev_expanding;\n        push(p9);\n        filter();\n        p4.tensor.elem[n * i + j] = pop();\n      }\n    }\n    return moveTos(tos - n);\n  };\n\n  // The following table shows the push order for simple roots, repeated roots,\n  // and inrreducible factors.\n\n  //  Factor F        Push 1st        Push 2nd         Push 3rd      Push 4th\n\n  //                   A\n  //  x               ---\n  //                   x\n\n  //   2               A               A\n  //  x               ----            ---\n  //                    2              x\n  //                   x\n\n  //                     A\n  //  x + 1           -------\n  //                   x + 1\n\n  //         2            A              A\n  //  (x + 1)         ----------      -------\n  //                          2        x + 1\n  //                   (x + 1)\n\n  //   2                   A               Ax\n  //  x  + x + 1      ------------    ------------\n  //                    2               2\n  //                   x  + x + 1      x  + x + 1\n\n  //    2         2          A              Ax              A             Ax\n  //  (x  + x + 1)    --------------- ---------------  ------------  ------------\n  //                     2         2     2         2     2             2\n  //                   (x  + x + 1)    (x  + x + 1)     x  + x + 1    x  + x + 1\n\n  // For T = A/F and F = P^N we have\n\n  //      Factor F          Push 1st    Push 2nd    Push 3rd    Push 4th\n\n  //      x                 T\n\n  //       2\n  //      x                 T           TP\n\n  //      x + 1             T\n\n  //             2\n  //      (x + 1)           T           TP\n\n  //       2\n  //      x  + x + 1        T           TX\n\n  //        2         2\n  //      (x  + x + 1)      T           TX          TP          TPX\n\n  // Hence we want to push in the order\n\n  //      T * (P ^ i) * (X ^ j)\n\n  // for all i, j such that\n\n  //      i = 0, 1, ..., N - 1\n\n  //      j = 0, 1, ..., deg(P) - 1\n\n  // where index j runs first.\n  expand_get_CF = function() {\n    var d, i, j, n, o, prev_expanding, ref, results;\n    d = 0;\n    i = 0;\n    j = 0;\n    n = 0;\n    if (!Find(p5, p9)) {\n      return;\n    }\n    prev_expanding = expanding;\n    expanding = 1;\n    trivial_divide();\n    expanding = prev_expanding;\n    if (car(p5) === symbol(POWER)) {\n      push(caddr(p5));\n      n = pop_integer();\n      p6 = cadr(p5);\n    } else {\n      n = 1;\n      p6 = p5;\n    }\n    push(p6);\n    push(p9);\n    degree();\n    d = pop_integer();\n    results = [];\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      results.push((function() {\n        var i1, ref1, results1;\n        results1 = [];\n        for (j = i1 = 0, ref1 = d; (0 <= ref1 ? i1 < ref1 : i1 > ref1); j = 0 <= ref1 ? ++i1 : --i1) {\n          push(p8);\n          push(p6);\n          push_integer(i);\n          power();\n          prev_expanding = expanding;\n          expanding = 1;\n          multiply();\n          expanding = prev_expanding;\n          push(p9);\n          push_integer(j);\n          power();\n          prev_expanding = expanding;\n          expanding = 1;\n          multiply();\n          results1.push(expanding = prev_expanding);\n        }\n        return results1;\n      })());\n    }\n    return results;\n  };\n\n  // Returns T = A/F where F is a factor of A.\n  trivial_divide = function() {\n    var h;\n    h = 0;\n    if (car(p2) === symbol(MULTIPLY)) {\n      h = tos;\n      p0 = cdr(p2);\n      while (iscons(p0)) {\n        if (!equal(car(p0), p5)) {\n          push(car(p0));\n          Eval(); // force expansion of (x+1)^2, f.e.\n        }\n        p0 = cdr(p0);\n      }\n      multiply_all(tos - h);\n    } else {\n      push_integer(1);\n    }\n    return p8 = pop();\n  };\n\n  // Returns the expansion coefficient vector B.\n  expand_get_B = function() {\n    var i, n, o, prev_expanding, ref;\n    i = 0;\n    n = 0;\n    if (!istensor(p4)) {\n      return;\n    }\n    n = p4.tensor.dim[0];\n    p8 = alloc_tensor(n);\n    p8.tensor.ndim = 1;\n    p8.tensor.dim[0] = n;\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      push(p3);\n      push(p9);\n      push_integer(i);\n      power();\n      prev_expanding = expanding;\n      expanding = 1;\n      divide();\n      expanding = prev_expanding;\n      push(p9);\n      filter();\n      p8.tensor.elem[i] = pop();\n    }\n    return p3 = p8;\n  };\n\n  // Returns the expansion fractions in A.\n  expand_get_A = function() {\n    var h, i, n, o, ref;\n    h = 0;\n    i = 0;\n    n = 0;\n    if (!istensor(p4)) {\n      push(p2);\n      reciprocate();\n      p2 = pop();\n      return;\n    }\n    h = tos;\n    if (car(p2) === symbol(MULTIPLY)) {\n      p8 = cdr(p2);\n      while (iscons(p8)) {\n        p5 = car(p8);\n        expand_get_AF();\n        p8 = cdr(p8);\n      }\n    } else {\n      p5 = p2;\n      expand_get_AF();\n    }\n    n = tos - h;\n    p8 = alloc_tensor(n);\n    p8.tensor.ndim = 1;\n    p8.tensor.dim[0] = n;\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      p8.tensor.elem[i] = stack[h + i];\n    }\n    moveTos(h);\n    return p2 = p8;\n  };\n\n  expand_get_AF = function() {\n    var d, i, j, n, o, ref, results;\n    d = 0;\n    i = 0;\n    j = 0;\n    n = 1;\n    if (!Find(p5, p9)) {\n      return;\n    }\n    if (car(p5) === symbol(POWER)) {\n      push(caddr(p5));\n      n = pop_integer();\n      p5 = cadr(p5);\n    }\n    push(p5);\n    push(p9);\n    degree();\n    d = pop_integer();\n    results = [];\n    for (i = o = ref = n; (ref <= 0 ? o < 0 : o > 0); i = ref <= 0 ? ++o : --o) {\n      results.push((function() {\n        var i1, ref1, results1;\n        results1 = [];\n        for (j = i1 = 0, ref1 = d; (0 <= ref1 ? i1 < ref1 : i1 > ref1); j = 0 <= ref1 ? ++i1 : --i1) {\n          push(p5);\n          push_integer(i);\n          power();\n          reciprocate();\n          push(p9);\n          push_integer(j);\n          power();\n          results1.push(multiply());\n        }\n        return results1;\n      })());\n    }\n    return results;\n  };\n\n  // Do the exponential cosine function.\n  Eval_expcos = function() {\n    push(cadr(p1));\n    Eval();\n    return expcos();\n  };\n\n  expcos = function() {\n    save();\n    p1 = pop();\n    push(imaginaryunit);\n    push(p1);\n    multiply();\n    exponential();\n    push_rational(1, 2);\n    multiply();\n    push(imaginaryunit);\n    negate();\n    push(p1);\n    multiply();\n    exponential();\n    push_rational(1, 2);\n    multiply();\n    add();\n    return restore();\n  };\n\n  // Do the exponential sine function.\n  Eval_expsin = function() {\n    push(cadr(p1));\n    Eval();\n    return expsin();\n  };\n\n  expsin = function() {\n    save();\n    p1 = pop();\n    push(imaginaryunit);\n    push(p1);\n    multiply();\n    exponential();\n    push(imaginaryunit);\n    divide();\n    push_rational(1, 2);\n    multiply();\n    push(imaginaryunit);\n    negate();\n    push(p1);\n    multiply();\n    exponential();\n    push(imaginaryunit);\n    divide();\n    push_rational(1, 2);\n    multiply();\n    subtract();\n    return restore();\n  };\n\n  // factor a polynomial or integer\n  Eval_factor = function() {\n    var results;\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    p2 = pop();\n    if (p2 === symbol(NIL)) {\n      guess();\n    } else {\n      push(p2);\n    }\n    factor();\n    // more factoring?\n    p1 = cdddr(p1);\n    results = [];\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n      factor_again();\n      results.push(p1 = cdr(p1));\n    }\n    return results;\n  };\n\n  factor_again = function() {\n    var h, n;\n    save();\n    p2 = pop();\n    p1 = pop();\n    h = tos;\n    if (car(p1) === symbol(MULTIPLY)) {\n      p1 = cdr(p1);\n      while (iscons(p1)) {\n        push(car(p1));\n        push(p2);\n        factor_term();\n        p1 = cdr(p1);\n      }\n    } else {\n      push(p1);\n      push(p2);\n      factor_term();\n    }\n    n = tos - h;\n    if (n > 1) {\n      multiply_all_noexpand(n);\n    }\n    return restore();\n  };\n\n  factor_term = function() {\n    save();\n    factorpoly();\n    p1 = pop();\n    if (car(p1) === symbol(MULTIPLY)) {\n      p1 = cdr(p1);\n      while (iscons(p1)) {\n        push(car(p1));\n        p1 = cdr(p1);\n      }\n    } else {\n      push(p1);\n    }\n    return restore();\n  };\n\n  factor = function() {\n    save();\n    p2 = pop();\n    p1 = pop();\n    if (isinteger(p1)) {\n      push(p1);\n      factor_number(); // see pollard.cpp\n    } else {\n      push(p1);\n      push(p2);\n      factorpoly();\n    }\n    return restore();\n  };\n\n  // for factoring small integers (2^32 or less)\n  factor_small_number = function() {\n    var d, expo, i, n, o, ref;\n    i = 0;\n    save();\n    n = pop_integer();\n    if (isNaN(n)) {\n      stop(\"number too big to factor\");\n    }\n    if (n < 0) {\n      n = -n;\n    }\n    for (i = o = 0, ref = MAXPRIMETAB; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      d = primetab[i];\n      if (d > n / d) {\n        break;\n      }\n      expo = 0;\n      while (n % d === 0) {\n        n /= d;\n        expo++;\n      }\n      if (expo) {\n        push_integer(d);\n        push_integer(expo);\n      }\n    }\n    if (n > 1) {\n      push_integer(n);\n      push_integer(1);\n    }\n    return restore();\n  };\n\n  factorial = function() {\n    var n;\n    n = 0;\n    save();\n    p1 = pop();\n    push(p1);\n    n = pop_integer();\n    if (n < 0 || isNaN(n)) {\n      push_symbol(FACTORIAL);\n      push(p1);\n      list(2);\n      restore();\n      return;\n    }\n    bignum_factorial(n);\n    return restore();\n  };\n\n  // simplification rules for factorials (m < n)\n\n  //  (e + 1) * factorial(e)  ->  factorial(e + 1)\n\n  //  factorial(e) / e  ->  factorial(e - 1)\n\n  //  e / factorial(e)  ->  1 / factorial(e - 1)\n\n  //  factorial(e + n)\n  //  ----------------  ->  (e + m + 1)(e + m + 2)...(e + n)\n  //  factorial(e + m)\n\n  //  factorial(e + m)                               1\n  //  ----------------  ->  --------------------------------\n  //  factorial(e + n)    (e + m + 1)(e + m + 2)...(e + n)\n\n  // this function is not actually used, but\n  // all these simplifications\n  // do happen automatically via simplify\n  simplifyfactorials = function() {\n    var x;\n    x = 0;\n    save();\n    x = expanding;\n    expanding = 0;\n    p1 = pop();\n    if (car(p1) === symbol(ADD)) {\n      push(zero);\n      p1 = cdr(p1);\n      while (iscons(p1)) {\n        push(car(p1));\n        simplifyfactorials();\n        add();\n        p1 = cdr(p1);\n      }\n      expanding = x;\n      restore();\n      return;\n    }\n    if (car(p1) === symbol(MULTIPLY)) {\n      sfac_product();\n      expanding = x;\n      restore();\n      return;\n    }\n    push(p1);\n    expanding = x;\n    return restore();\n  };\n\n  sfac_product = function() {\n    var i, i1, j, j1, n, o, ref, ref1, ref2, ref3, s;\n    i = 0;\n    j = 0;\n    n = 0;\n    s = tos;\n    p1 = cdr(p1);\n    n = 0;\n    while (iscons(p1)) {\n      push(car(p1));\n      p1 = cdr(p1);\n      n++;\n    }\n    for (i = o = 0, ref = n - 1; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      if (stack[s + i] === symbol(NIL)) {\n        continue;\n      }\n      for (j = i1 = ref1 = i + 1, ref2 = n; (ref1 <= ref2 ? i1 < ref2 : i1 > ref2); j = ref1 <= ref2 ? ++i1 : --i1) {\n        if (stack[s + j] === symbol(NIL)) {\n          continue;\n        }\n        sfac_product_f(s, i, j);\n      }\n    }\n    push(one);\n    for (i = j1 = 0, ref3 = n; (0 <= ref3 ? j1 < ref3 : j1 > ref3); i = 0 <= ref3 ? ++j1 : --j1) {\n      if (stack[s + i] === symbol(NIL)) {\n        continue;\n      }\n      push(stack[s + i]);\n      multiply();\n    }\n    p1 = pop();\n    moveTos(tos - n);\n    return push(p1);\n  };\n\n  sfac_product_f = function(s, a, b) {\n    var i, n, o, ref;\n    i = 0;\n    n = 0;\n    p1 = stack[s + a];\n    p2 = stack[s + b];\n    if (ispower(p1)) {\n      p3 = caddr(p1);\n      p1 = cadr(p1);\n    } else {\n      p3 = one;\n    }\n    if (ispower(p2)) {\n      p4 = caddr(p2);\n      p2 = cadr(p2);\n    } else {\n      p4 = one;\n    }\n    if (isfactorial(p1) && isfactorial(p2)) {\n      // Determine if the powers cancel.\n      push(p3);\n      push(p4);\n      add();\n      yyexpand();\n      n = pop_integer();\n      if (n !== 0) {\n        return;\n      }\n      // Find the difference between the two factorial args.\n\n      // For example, the difference between (a + 2)! and a! is 2.\n      push(cadr(p1));\n      push(cadr(p2));\n      subtract();\n      yyexpand();\n      n = pop_integer();\n      if (n === 0 || isNaN(n)) {\n        return;\n      }\n      if (n < 0) {\n        n = -n;\n        p5 = p1;\n        p1 = p2;\n        p2 = p5;\n        p5 = p3;\n        p3 = p4;\n        p4 = p5;\n      }\n      push(one);\n      for (i = o = 1, ref = n; (1 <= ref ? o <= ref : o >= ref); i = 1 <= ref ? ++o : --o) {\n        push(cadr(p2));\n        push_integer(i);\n        add();\n        push(p3);\n        power();\n        multiply();\n      }\n      stack[s + a] = pop();\n      return stack[s + b] = symbol(NIL);\n    }\n  };\n\n  // Factor a polynomial\n  factorpoly = function() {\n    var polynomial, variable;\n    if (DEBUG) {\n      console.log(\"factorpoly: \" + stack[tos - 1].toString() + \" \" + stack[tos - 2].toString());\n    }\n    save();\n    variable = pop();\n    polynomial = pop();\n    if (!Find(polynomial, variable) || !ispolyexpandedform(polynomial, variable) || !issymbol(variable)) {\n      push(polynomial);\n    } else {\n      yyfactorpoly(variable, polynomial);\n    }\n    return restore();\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Input:    tos-2    true polynomial\n\n  //      tos-1    free variable\n\n  //  Output:    factored polynomial on stack\n\n  //-----------------------------------------------------------------------------\n  yyfactorpoly = function(variable, polynomial) {\n    var A, AxPlusB, B, checkingTheDivision, dividend, factpoly_expo, firstParam, foundComplexRoot, foundRealRoot, h, i, i1, j1, l1, o, partOfPolynomialFactoredSoFar, polycoeff, prev_expanding, previousFactorisation, ref, ref1, ref2, ref3, remainingPoly, secondDegreePloly, secondParam, whichRootsAreWeFinding;\n    if (DEBUG) {\n      firstParam = variable;\n      secondParam = polynomial;\n      console.log(\"yyfactorpoly: \" + firstParam + \" \" + secondParam);\n    }\n    save();\n    h = tos;\n    if (isfloating(polynomial)) {\n      stop(\"floating point numbers in polynomial\");\n    }\n    polycoeff = tos;\n    factpoly_expo = coeff(variable, polynomial) - 1;\n    if (DEBUG) {\n      console.log(\"yyfactorpoly: \" + firstParam + \" \" + secondParam + \" factpoly_expo before rationalize_coefficients: \" + factpoly_expo);\n    }\n    partOfPolynomialFactoredSoFar = rationalize_coefficients(h);\n    if (DEBUG) {\n      console.log(\"yyfactorpoly: \" + firstParam + \" \" + secondParam + \" factpoly_expo  after rationalize_coefficients: \" + factpoly_expo);\n    }\n    // for univariate polynomials we could do factpoly_expo > 1\n    whichRootsAreWeFinding = \"real\";\n    remainingPoly = null;\n    while (factpoly_expo > 0) {\n      if (DEBUG) {\n        console.log(\"yyfactorpoly: \" + firstParam + \" \" + secondParam + \" factpoly_expo inside while loop: \" + factpoly_expo);\n      }\n      if (isZeroAtomOrTensor(stack[polycoeff + 0])) {\n        if (DEBUG) {\n          console.log(\"yyfactorpoly: \" + firstParam + \" \" + secondParam + \" isZeroAtomOrTensor\");\n        }\n        A = one;\n        B = zero;\n      } else {\n        //console.log(\"trying to find a \" + whichRootsAreWeFinding + \" root\")\n        if (whichRootsAreWeFinding === \"real\") {\n          [foundRealRoot, A, B] = get_factor_from_real_root(variable, factpoly_expo, polycoeff);\n        } else if (whichRootsAreWeFinding === \"complex\") {\n          [foundComplexRoot, A] = get_factor_from_complex_root(remainingPoly, factpoly_expo, polycoeff);\n        }\n      }\n      if (whichRootsAreWeFinding === \"real\") {\n        if (foundRealRoot === 0) {\n          whichRootsAreWeFinding = \"complex\";\n          continue;\n        } else {\n          // build the 1-degree polynomial out of the\n          // real solution that was just found.\n          push(A); // A\n          push(variable); // x\n          multiply();\n          push(B); // B\n          add();\n          AxPlusB = pop();\n          if (DEBUG) {\n            console.log(\"yyfactorpoly: \" + firstParam + \" \" + secondParam + \" success\\nFACTOR=\" + AxPlusB);\n          }\n          // factor out negative sign (not req'd because A > 1)\n          //if 0\n          /*\n          if (isnegativeterm(A))\n            push(AxPlusB)\n            negate()\n            AxPlusB = pop()\n            push(partOfPolynomialFactoredSoFar)\n            negate_noexpand()\n            partOfPolynomialFactoredSoFar = pop()\n          */\n          //endif\n\n          // partOfPolynomialFactoredSoFar is the part of the polynomial that was factored so far,\n          // add the newly found factor to it. Note that we are not actually\n          // multiplying the polynomials fully, we are just leaving them\n          // expressed as (P1)*(P2), we are not expanding the product.\n          push(partOfPolynomialFactoredSoFar);\n          push(AxPlusB);\n          multiply_noexpand();\n          partOfPolynomialFactoredSoFar = pop();\n          // ok now on stack we have the coefficients of the\n          // remaining part of the polynomial still to factor.\n          // Divide it by the newly-found factor so that\n          // the stack then contains the coefficients of the\n          // polynomial part still left to factor.\n          yydivpoly(factpoly_expo, polycoeff, A, B);\n          while (factpoly_expo && isZeroAtomOrTensor(stack[polycoeff + factpoly_expo])) {\n            factpoly_expo--;\n          }\n          push(zero);\n          for (i = o = 0, ref = factpoly_expo; (0 <= ref ? o <= ref : o >= ref); i = 0 <= ref ? ++o : --o) {\n            push(stack[polycoeff + i]);\n            push(variable); // the free variable\n            push_integer(i);\n            power();\n            multiply();\n            add();\n          }\n          remainingPoly = pop();\n        }\n      //console.log(\"real branch remainingPoly: \" + remainingPoly)\n      } else if (whichRootsAreWeFinding === \"complex\") {\n        if (foundComplexRoot === 0) {\n          break;\n        } else {\n          // build the 2-degree polynomial out of the\n          // real solution that was just found.\n          push(A); // A\n          push(variable); // x\n          subtract();\n          //console.log(\"first factor: \" + stack[tos-1].toString())\n          push(A); // A\n          conjugate();\n          push(variable); // x\n          subtract();\n          //console.log(\"second factor: \" + stack[tos-1].toString())\n          multiply();\n          //if (factpoly_expo > 0 && isnegativeterm(stack[polycoeff+factpoly_expo]))\n          //  negate()\n          //  negate_noexpand()\n          secondDegreePloly = pop();\n          if (DEBUG) {\n            console.log(\"yyfactorpoly: \" + firstParam + \" \" + secondParam + \" success\\nFACTOR=\" + secondDegreePloly);\n          }\n          // factor out negative sign (not req'd because A > 1)\n          //if 0\n          /*\n          if (isnegativeterm(A))\n            push(secondDegreePloly)\n            negate()\n            secondDegreePloly = pop()\n            push(partOfPolynomialFactoredSoFar)\n            negate_noexpand()\n            partOfPolynomialFactoredSoFar = pop()\n          */\n          //endif\n\n          // partOfPolynomialFactoredSoFar is the part of the polynomial that was factored so far,\n          // add the newly found factor to it. Note that we are not actually\n          // multiplying the polynomials fully, we are just leaving them\n          // expressed as (P1)*(P2), we are not expanding the product.\n          push(partOfPolynomialFactoredSoFar);\n          previousFactorisation = pop();\n          //console.log(\"previousFactorisation: \" + previousFactorisation)\n          push(partOfPolynomialFactoredSoFar);\n          push(secondDegreePloly);\n          multiply_noexpand();\n          partOfPolynomialFactoredSoFar = pop();\n          if (remainingPoly == null) {\n            push(zero);\n            for (i = i1 = 0, ref1 = factpoly_expo; (0 <= ref1 ? i1 <= ref1 : i1 >= ref1); i = 0 <= ref1 ? ++i1 : --i1) {\n              push(stack[polycoeff + i]);\n              push(variable); // the free variable\n              push_integer(i);\n              power();\n              multiply();\n              add();\n            }\n            remainingPoly = pop();\n          }\n          //console.log(\"original polynomial (dividend): \" + remainingPoly)\n          dividend = remainingPoly;\n          //push(dividend)\n          //degree()\n          //startingDegree = pop()\n          push(dividend);\n          //console.log(\"dividing \" + stack[tos-1].toString() + \" by \" + secondDegreePloly)\n          push(secondDegreePloly); // divisor\n          push(variable); // X\n          divpoly();\n          remainingPoly = pop();\n          push(remainingPoly);\n          push(secondDegreePloly); // divisor\n          multiply();\n          checkingTheDivision = pop();\n          if (!equal(checkingTheDivision, dividend)) {\n            //push(dividend)\n            //gcd_sum()\n            //console.log(\"gcd top of stack: \" + stack[tos-1].toString())\n            if (DEBUG) {\n              console.log(\"we found a polynomial based on complex root and its conj but it doesn't divide the poly, quitting\");\n            }\n            if (DEBUG) {\n              console.log(\"so just returning previousFactorisation times dividend: \" + previousFactorisation + \" * \" + dividend);\n            }\n            push(previousFactorisation);\n            push(dividend);\n            prev_expanding = expanding;\n            expanding = 0;\n            yycondense();\n            expanding = prev_expanding;\n            multiply_noexpand();\n            partOfPolynomialFactoredSoFar = pop();\n            stack[h] = partOfPolynomialFactoredSoFar;\n            moveTos(h + 1);\n            restore();\n            return;\n          }\n//console.log(\"result: (still to be factored) \" + remainingPoly)\n\n          //push(remainingPoly)\n//degree()\n//remainingDegree = pop()\n/*\nif compare_numbers(startingDegree, remainingDegree)\n * ok even if we found a complex root that\n * together with the conjugate generates a poly in Z,\n * that doesn't mean that the division would end up in Z.\n * Example: 1+x^2+x^4+x^6 has +i and -i as one of its roots\n * so a factor is 1+x^2 ( = (x+i)*(x-i))\n * BUT \n */\n          for (i = j1 = 0, ref2 = factpoly_expo; (0 <= ref2 ? j1 <= ref2 : j1 >= ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n            pop();\n          }\n          coeff(variable, remainingPoly);\n          factpoly_expo -= 2;\n        }\n      }\n    }\n    //console.log(\"factpoly_expo: \" + factpoly_expo)\n    if (DEBUG) {\n      console.log(\"yyfactorpoly: \" + firstParam + \" \" + secondParam + \" building the remaining unfactored part of the polynomial\");\n    }\n    push(zero);\n    for (i = l1 = 0, ref3 = factpoly_expo; (0 <= ref3 ? l1 <= ref3 : l1 >= ref3); i = 0 <= ref3 ? ++l1 : --l1) {\n      push(stack[polycoeff + i]);\n      push(variable); // the free variable\n      push_integer(i);\n      power();\n      multiply();\n      add();\n    }\n    polynomial = pop();\n    if (DEBUG) {\n      console.log(\"yyfactorpoly: \" + firstParam + \" \" + secondParam + \" remaining unfactored part of the polynomial: \" + polynomial.toString());\n    }\n    push(polynomial);\n    prev_expanding = expanding;\n    expanding = 0;\n    yycondense();\n    expanding = prev_expanding;\n    polynomial = pop();\n    if (DEBUG) {\n      console.log(\"yyfactorpoly: \" + firstParam + \" \" + secondParam + \" new poly with extracted common factor: \" + polynomial.toString());\n    }\n    //debugger\n\n    // factor out negative sign\n    if (factpoly_expo > 0 && isnegativeterm(stack[polycoeff + factpoly_expo])) {\n      push(polynomial);\n      //prev_expanding = expanding\n      //expanding = 1\n      negate();\n      //expanding = prev_expanding\n      polynomial = pop();\n      push(partOfPolynomialFactoredSoFar);\n      negate_noexpand();\n      partOfPolynomialFactoredSoFar = pop();\n    }\n    push(partOfPolynomialFactoredSoFar);\n    push(polynomial);\n    multiply_noexpand();\n    partOfPolynomialFactoredSoFar = pop();\n    if (DEBUG) {\n      console.log(\"yyfactorpoly: \" + firstParam + \" \" + secondParam + \" result: \" + partOfPolynomialFactoredSoFar);\n    }\n    stack[h] = partOfPolynomialFactoredSoFar;\n    moveTos(h + 1);\n    return restore();\n  };\n\n  rationalize_coefficients = function(h) {\n    var i, i1, o, ratio, ratioInverse, ref, ref1, ref2, ref3;\n    // LCM of all polynomial coefficients\n    ratio = one;\n    for (i = o = ref = h, ref1 = tos; (ref <= ref1 ? o < ref1 : o > ref1); i = ref <= ref1 ? ++o : --o) {\n      push(stack[i]);\n      denominator();\n      push(ratio);\n      lcm();\n      ratio = pop();\n    }\n// multiply each coefficient by RESULT\n    for (i = i1 = ref2 = h, ref3 = tos; (ref2 <= ref3 ? i1 < ref3 : i1 > ref3); i = ref2 <= ref3 ? ++i1 : --i1) {\n      push(ratio);\n      push(stack[i]);\n      multiply();\n      stack[i] = pop();\n    }\n    // reciprocate RESULT\n    push(ratio);\n    reciprocate();\n    ratioInverse = pop();\n    if (DEBUG) {\n      console.log(\"rationalize_coefficients result: \" + ratioInverse.toString());\n    }\n    return ratioInverse;\n  };\n\n  get_factor_from_real_root = function(variable, factpoly_expo, polycoeff) {\n    var a0, an, evalPolyResult, h, i, i1, j, j1, l1, m1, na0, nan, o, polynomial, ref, ref1, ref2, ref3, ref4, rootsTries_i, rootsTries_j, testDenominator, testNumerator, testValue;\n    if (DEBUG) {\n      console.log(\"get_factor_from_real_root\");\n    }\n    i = 0;\n    j = 0;\n    h = 0;\n    a0 = 0;\n    an = 0;\n    na0 = 0;\n    nan = 0;\n    if (DEBUG) {\n      push(zero);\n      for (i = o = 0, ref = factpoly_expo; (0 <= ref ? o <= ref : o >= ref); i = 0 <= ref ? ++o : --o) {\n        push(stack[polycoeff + i]);\n        push(variable);\n        push_integer(i);\n        power();\n        multiply();\n        add();\n      }\n      polynomial = pop();\n      console.log(\"POLY=\" + polynomial);\n    }\n    h = tos;\n    an = tos;\n    push(stack[polycoeff + factpoly_expo]);\n    divisors_onstack();\n    nan = tos - an;\n    a0 = tos;\n    push(stack[polycoeff + 0]);\n    divisors_onstack();\n    na0 = tos - a0;\n    if (DEBUG) {\n      console.log(\"divisors of base term\");\n      for (i = i1 = 0, ref1 = na0; (0 <= ref1 ? i1 < ref1 : i1 > ref1); i = 0 <= ref1 ? ++i1 : --i1) {\n        console.log(\", \" + stack[a0 + i]);\n      }\n      console.log(\"divisors of leading term\");\n      for (i = j1 = 0, ref2 = nan; (0 <= ref2 ? j1 < ref2 : j1 > ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n        console.log(\", \" + stack[an + i]);\n      }\n    }\n// try roots\n    for (rootsTries_i = l1 = 0, ref3 = nan; (0 <= ref3 ? l1 < ref3 : l1 > ref3); rootsTries_i = 0 <= ref3 ? ++l1 : --l1) {\n      for (rootsTries_j = m1 = 0, ref4 = na0; (0 <= ref4 ? m1 < ref4 : m1 > ref4); rootsTries_j = 0 <= ref4 ? ++m1 : --m1) {\n        //if DEBUG then console.log \"nan: \" + nan + \" na0: \" + na0 + \" i: \" + rootsTries_i + \" j: \" + rootsTries_j\n        testNumerator = stack[an + rootsTries_i];\n        testDenominator = stack[a0 + rootsTries_j];\n        push(testDenominator);\n        push(testNumerator);\n        divide();\n        negate();\n        testValue = pop();\n        evalPolyResult = Evalpoly(factpoly_expo, polycoeff, testValue);\n        if (DEBUG) {\n          console.log(\"try A=\" + testNumerator);\n          console.log(\", B=\" + testDenominator);\n          console.log(\", root \" + variable);\n          console.log(\"=-B/A=\" + testValue);\n          console.log(\", POLY(\" + testValue);\n          console.log(\")=\" + evalPolyResult);\n        }\n        if (isZeroAtomOrTensor(evalPolyResult)) {\n          moveTos(h);\n          if (DEBUG) {\n            console.log(\"get_factor_from_real_root returning 1\");\n          }\n          return [1, testNumerator, testDenominator];\n        }\n        push(testDenominator);\n        negate();\n        testDenominator = pop();\n        push(testValue);\n        negate();\n        testValue = pop();\n        evalPolyResult = Evalpoly(factpoly_expo, polycoeff, testValue);\n        if (DEBUG) {\n          console.log(\"try A=\" + testNumerator);\n          console.log(\", B=\" + testDenominator);\n          console.log(\", root \" + variable);\n          console.log(\"=-B/A=\" + testValue);\n          console.log(\", POLY(\" + testValue);\n          console.log(\")=\" + evalPolyResult);\n        }\n        if (isZeroAtomOrTensor(evalPolyResult)) {\n          moveTos(h);\n          if (DEBUG) {\n            console.log(\"get_factor_from_real_root returning 1\");\n          }\n          return [1, testNumerator, testDenominator];\n        }\n      }\n    }\n    moveTos(h);\n    if (DEBUG) {\n      console.log(\"get_factor_from_real_root returning\");\n    }\n    return [0, null, null];\n  };\n\n  get_factor_from_complex_root = function(remainingPoly, factpoly_expo, polycoeff) {\n    var a0, an, evalPolyResult, h, i, i1, j, na0, nan, o, rootsTries_i, rootsTries_j, testValue;\n    i = 0;\n    j = 0;\n    h = 0;\n    a0 = 0;\n    an = 0;\n    na0 = 0;\n    nan = 0;\n    if (factpoly_expo <= 2) {\n      if (DEBUG) {\n        console.log(\"no more factoring via complex roots to be found in polynomial of degree <= 2\");\n      }\n      return [0, null];\n    }\n    if (DEBUG) {\n      console.log(\"complex root finding for POLY=\" + remainingPoly);\n    }\n    h = tos;\n    an = tos;\n    // trying -1^(2/3) which generates a polynomial in Z\n    // generates x^2 + 2x + 1\n    push_integer(-1);\n    push_rational(2, 3);\n    power();\n    rect();\n    testValue = pop();\n    if (DEBUG) {\n      console.log(\"complex root finding: trying with \" + testValue);\n    }\n    push(testValue);\n    evalPolyResult = Evalpoly(factpoly_expo, polycoeff, testValue);\n    if (DEBUG) {\n      console.log(\"complex root finding result: \" + evalPolyResult);\n    }\n    if (isZeroAtomOrTensor(evalPolyResult)) {\n      moveTos(h);\n      if (DEBUG) {\n        console.log(\"get_factor_from_complex_root returning 1\");\n      }\n      return [1, testValue];\n    }\n    // trying 1^(2/3) which generates a polynomial in Z\n    // http://www.wolframalpha.com/input/?i=(1)%5E(2%2F3)\n    // generates x^2 - 2x + 1\n    push_integer(1);\n    push_rational(2, 3);\n    power();\n    rect();\n    testValue = pop();\n    if (DEBUG) {\n      console.log(\"complex root finding: trying with \" + testValue);\n    }\n    push(testValue);\n    evalPolyResult = Evalpoly(factpoly_expo, polycoeff, testValue);\n    if (DEBUG) {\n      console.log(\"complex root finding result: \" + evalPolyResult);\n    }\n    if (isZeroAtomOrTensor(evalPolyResult)) {\n      moveTos(h);\n      if (DEBUG) {\n        console.log(\"get_factor_from_complex_root returning 1\");\n      }\n      return [1, testValue];\n    }\n// trying some simple complex numbers. All of these\n// generate polynomials in Z\n    for (rootsTries_i = o = -10; o <= 10; rootsTries_i = ++o) {\n      for (rootsTries_j = i1 = 1; i1 <= 5; rootsTries_j = ++i1) {\n        push_integer(rootsTries_i);\n        push_integer(rootsTries_j);\n        push(imaginaryunit);\n        multiply();\n        add();\n        rect();\n        testValue = pop();\n        if (DEBUG) {\n          console.log(\"complex root finding: trying simple complex combination \" + testValue);\n        }\n        push(testValue);\n        evalPolyResult = Evalpoly(factpoly_expo, polycoeff, testValue);\n        //console.log(\"complex root finding result: \" + evalPolyResult)\n        if (isZeroAtomOrTensor(evalPolyResult)) {\n          moveTos(h);\n          if (DEBUG) {\n            console.log(\"found complex root: \" + evalPolyResult);\n          }\n          return [1, testValue];\n        }\n      }\n    }\n    moveTos(h);\n    if (DEBUG) {\n      console.log(\"get_factor_from_complex_root returning 0\");\n    }\n    return [0, null];\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Divide a polynomial by Ax+B\n\n  //  Input:  on stack:  polycoeff  Dividend coefficients\n\n  //      factpoly_expo   as parameter\n\n  //      A    as parameter\n\n  //      B    as parameter\n\n  //  Output:   on stack: polycoeff  Contains quotient coefficients\n\n  //-----------------------------------------------------------------------------\n  yydivpoly = function(factpoly_expo, polycoeff, A, B) {\n    var Q, i, o, ref;\n    Q = zero;\n    for (i = o = ref = factpoly_expo; (ref <= 0 ? o < 0 : o > 0); i = ref <= 0 ? ++o : --o) {\n      push(stack[polycoeff + i]);\n      stack[polycoeff + i] = Q;\n      push(A);\n      divide();\n      Q = pop();\n      push(stack[polycoeff + i - 1]);\n      push(Q);\n      push(B);\n      multiply();\n      subtract();\n      stack[polycoeff + i - 1] = pop();\n    }\n    stack[polycoeff + 0] = Q;\n    if (DEBUG) {\n      return console.log(\"yydivpoly Q: \" + Q.toString());\n    }\n  };\n\n  Evalpoly = function(factpoly_expo, polycoeff, evaluateAt) {\n    var i, o, ref;\n    push(zero);\n    for (i = o = ref = factpoly_expo; (ref <= 0 ? o <= 0 : o >= 0); i = ref <= 0 ? ++o : --o) {\n      push(evaluateAt);\n      multiply();\n      push(stack[polycoeff + i]);\n      //if DEBUG\n      //  console.log(\"Evalpoly top of stack:\")\n      //  console.log stack[tos-i].toString()\n      add();\n    }\n    return pop();\n  };\n\n  // Push expression factors onto the stack. For example...\n\n  // Input\n\n  //       2\n  //     3x  + 2x + 1\n\n  // Output on stack\n\n  //     [  3  ]\n  //     [ x^2 ]\n  //     [  2  ]\n  //     [  x  ]\n  //     [  1  ]\n\n  // but not necessarily in that order. Returns the number of factors.\n\n  // Local U *p is OK here because no functional path to garbage collector.\n  factors = function(p) {\n    var h;\n    h = tos;\n    if (car(p) === symbol(ADD)) {\n      p = cdr(p);\n      while (iscons(p)) {\n        push_term_factors(car(p));\n        p = cdr(p);\n      }\n    } else {\n      push_term_factors(p);\n    }\n    return tos - h;\n  };\n\n  // Local U *p is OK here because no functional path to garbage collector.\n  push_term_factors = function(p) {\n    var results;\n    if (car(p) === symbol(MULTIPLY)) {\n      p = cdr(p);\n      results = [];\n      while (iscons(p)) {\n        push(car(p));\n        results.push(p = cdr(p));\n      }\n      return results;\n    } else {\n      return push(p);\n    }\n  };\n\n  Eval_filter = function() {\n    var results;\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p1 = cdr(p1);\n    results = [];\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n      filter();\n      results.push(p1 = cdr(p1));\n    }\n    return results;\n  };\n\n  filter = function() {\n    save();\n    p2 = pop();\n    p1 = pop();\n    filter_main();\n    return restore();\n  };\n\n  filter_main = function() {\n    if (car(p1) === symbol(ADD)) {\n      return filter_sum();\n    } else if (istensor(p1)) {\n      return filter_tensor();\n    } else if (Find(p1, p2)) {\n      return push_integer(0);\n    } else {\n      return push(p1);\n    }\n  };\n\n  filter_sum = function() {\n    var results;\n    push_integer(0);\n    p1 = cdr(p1);\n    results = [];\n    while (iscons(p1)) {\n      push(car(p1));\n      push(p2);\n      filter();\n      add();\n      results.push(p1 = cdr(p1));\n    }\n    return results;\n  };\n\n  filter_tensor = function() {\n    var i, i1, n, o, ref, ref1;\n    i = 0;\n    n = 0;\n    n = p1.tensor.nelem;\n    p3 = alloc_tensor(n);\n    p3.tensor.ndim = p1.tensor.ndim;\n    for (i = o = 0, ref = p1.tensor.ndim; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      p3.tensor.dim[i] = p1.tensor.dim[i];\n    }\n    for (i = i1 = 0, ref1 = n; (0 <= ref1 ? i1 < ref1 : i1 > ref1); i = 0 <= ref1 ? ++i1 : --i1) {\n      push(p1.tensor.elem[i]);\n      push(p2);\n      filter();\n      p3.tensor.elem[i] = pop();\n    }\n    return push(p3);\n  };\n\n  Eval_float = function() {\n    evaluatingAsFloats++;\n    push(cadr(p1));\n    Eval();\n    yyfloat();\n    Eval();\n    return evaluatingAsFloats--;\n  };\n\n  checkFloatHasWorkedOutCompletely = function(nodeToCheck) {\n    var numberOfEs, numberOfMults, numberOfPIs, numberOfPowers, numberOfSums;\n    numberOfPowers = countOccurrencesOfSymbol(symbol(POWER), nodeToCheck);\n    numberOfPIs = countOccurrencesOfSymbol(symbol(PI), nodeToCheck);\n    numberOfEs = countOccurrencesOfSymbol(symbol(E), nodeToCheck);\n    numberOfMults = countOccurrencesOfSymbol(symbol(MULTIPLY), nodeToCheck);\n    numberOfSums = countOccurrencesOfSymbol(symbol(ADD), nodeToCheck);\n    if (DEBUG) {\n      console.log(\"     ... numberOfPowers: \" + numberOfPowers);\n      console.log(\"     ... numberOfPIs: \" + numberOfPIs);\n      console.log(\"     ... numberOfEs: \" + numberOfEs);\n      console.log(\"     ... numberOfMults: \" + numberOfMults);\n      console.log(\"     ... numberOfSums: \" + numberOfSums);\n    }\n    if (numberOfPowers > 1 || numberOfPIs > 0 || numberOfEs > 0 || numberOfMults > 1 || numberOfSums > 1) {\n      return stop(\"float: some unevalued parts in \" + nodeToCheck);\n    }\n  };\n\n  zzfloat = function() {\n    save();\n    evaluatingAsFloats++;\n    //p1 = pop()\n    //push(cadr(p1))\n    //push(p1)\n    Eval();\n    yyfloat();\n    Eval();\n    evaluatingAsFloats--;\n    return restore();\n  };\n\n  // zzfloat doesn't necessarily result in a double\n  // , for example if there are variables. But\n  // in many of the tests there should be indeed\n  // a float, this line comes handy to highlight\n  // when that doesn't happen for those tests.\n  //checkFloatHasWorkedOutCompletely(stack[tos-1])\n  yyfloat = function() {\n    var h, i, o, ref;\n    i = 0;\n    h = 0;\n    evaluatingAsFloats++;\n    save();\n    p1 = pop();\n    if (iscons(p1)) {\n      h = tos;\n      while (iscons(p1)) {\n        push(car(p1));\n        yyfloat();\n        p1 = cdr(p1);\n      }\n      list(tos - h);\n    } else if (p1.k === TENSOR) {\n      push(p1);\n      copy_tensor();\n      p1 = pop();\n      for (i = o = 0, ref = p1.tensor.nelem; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n        push(p1.tensor.elem[i]);\n        yyfloat();\n        p1.tensor.elem[i] = pop();\n      }\n      push(p1);\n    } else if (p1.k === NUM) {\n      push(p1);\n      bignum_float();\n    } else if (p1 === symbol(PI)) {\n      push_double(Math.PI);\n    } else if (p1 === symbol(E)) {\n      push_double(Math.E);\n    } else {\n      push(p1);\n    }\n    restore();\n    return evaluatingAsFloats--;\n  };\n\n  Eval_floor = function() {\n    push(cadr(p1));\n    Eval();\n    return yfloor();\n  };\n\n  yfloor = function() {\n    save();\n    yyfloor();\n    return restore();\n  };\n\n  yyfloor = function() {\n    var d;\n    d = 0.0;\n    p1 = pop();\n    if (!isNumericAtom(p1)) {\n      push_symbol(FLOOR);\n      push(p1);\n      list(2);\n      return;\n    }\n    if (isdouble(p1)) {\n      d = Math.floor(p1.d);\n      push_double(d);\n      return;\n    }\n    if (isinteger(p1)) {\n      push(p1);\n      return;\n    }\n    p3 = new U();\n    p3.k = NUM;\n    p3.q.a = mdiv(p1.q.a, p1.q.b);\n    p3.q.b = mint(1);\n    push(p3);\n    if (isnegativenumber(p1)) {\n      push_integer(-1);\n      return add();\n    }\n  };\n\n  // 'for' function\n  /*\n  x=0\n  y=2\n  for(do(x=sqrt(2+x),y=2*y/x),k,1,9)\n  float(y)\n\n  X: k\n  B: 1...9\n\n  1st parameter is the body\n  2nd parameter is the variable to loop with\n  3rd and 4th are the limits\n\n  */\n  //define A p3\n  //define B p4\n  //define I p5\n  //define X p6\n  Eval_for = function() {\n    var i, j, k, loopingVariable, o, ref, ref1;\n    i = 0;\n    j = 0;\n    k = 0;\n    loopingVariable = caddr(p1);\n    if (!issymbol(loopingVariable)) {\n      stop(\"for: 2nd arg should be the variable to loop over\");\n    }\n    push(cadddr(p1));\n    Eval();\n    j = pop_integer();\n    if (isNaN(j)) {\n      push(p1);\n      return;\n    }\n    push(caddddr(p1));\n    Eval();\n    k = pop_integer();\n    if (isNaN(k)) {\n      push(p1);\n      return;\n    }\n    // remember contents of the index\n    // variable so we can put it back after the loop\n    p4 = get_binding(loopingVariable);\n    for (i = o = ref = j, ref1 = k; (ref <= ref1 ? o <= ref1 : o >= ref1); i = ref <= ref1 ? ++o : --o) {\n      push_integer(i);\n      p5 = pop();\n      set_binding(loopingVariable, p5);\n      push(cadr(p1));\n      Eval();\n      pop();\n    }\n    // put back the index variable to original content\n    set_binding(loopingVariable, p4);\n    // return value\n    return push_symbol(NIL);\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Author : philippe.billet@noos.fr\n\n  //  Gamma function gamma(x)\n\n  //-----------------------------------------------------------------------------\n  Eval_gamma = function() {\n    push(cadr(p1));\n    Eval();\n    return gamma();\n  };\n\n  gamma = function() {\n    save();\n    gammaf();\n    return restore();\n  };\n\n  gammaf = function() {\n    //  double d\n    p1 = pop();\n    if (isrational(p1) && MEQUAL(p1.q.a, 1) && MEQUAL(p1.q.b, 2)) {\n      if (evaluatingAsFloats) {\n        push_double(Math.PI);\n      } else {\n        push_symbol(PI);\n      }\n      push_rational(1, 2);\n      power();\n      return;\n    }\n    if (isrational(p1) && MEQUAL(p1.q.a, 3) && MEQUAL(p1.q.b, 2)) {\n      if (evaluatingAsFloats) {\n        push_double(Math.PI);\n      } else {\n        push_symbol(PI);\n      }\n      push_rational(1, 2);\n      power();\n      push_rational(1, 2);\n      multiply();\n      return;\n    }\n    \n    //  if (p1->k == DOUBLE) {\n    //    d = exp(lgamma(p1.d))\n    //    push_double(d)\n    //    return\n    //  }\n    if (isnegativeterm(p1)) {\n      if (evaluatingAsFloats) {\n        push_double(Math.PI);\n      } else {\n        push_symbol(PI);\n      }\n      push_integer(-1);\n      multiply();\n      if (evaluatingAsFloats) {\n        push_double(Math.PI);\n      } else {\n        push_symbol(PI);\n      }\n      push(p1);\n      multiply();\n      sine();\n      push(p1);\n      multiply();\n      push(p1);\n      negate();\n      gamma();\n      multiply();\n      divide();\n      return;\n    }\n    if (car(p1) === symbol(ADD)) {\n      gamma_of_sum();\n      return;\n    }\n    push_symbol(GAMMA);\n    push(p1);\n    list(2);\n  };\n\n  gamma_of_sum = function() {\n    p3 = cdr(p1);\n    if (isrational(car(p3)) && MEQUAL(car(p3).q.a, 1) && MEQUAL(car(p3).q.b, 1)) {\n      push(cadr(p3));\n      push(cadr(p3));\n      gamma();\n      return multiply();\n    } else {\n      if (isrational(car(p3)) && MEQUAL(car(p3).q.a, -1) && MEQUAL(car(p3).q.b, 1)) {\n        push(cadr(p3));\n        gamma();\n        push(cadr(p3));\n        push_integer(-1);\n        add();\n        return divide();\n      } else {\n        push_symbol(GAMMA);\n        push(p1);\n        list(2);\n      }\n    }\n  };\n\n  // Greatest common denominator\n  // can also be run on polynomials, however\n  // it works only on the integers and it works\n  // by factoring the polynomials (not Euclidean algorithm)\n  Eval_gcd = function() {\n    var results;\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p1 = cdr(p1);\n    results = [];\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n      gcd();\n      results.push(p1 = cdr(p1));\n    }\n    return results;\n  };\n\n  gcd = function() {\n    var prev_expanding;\n    prev_expanding = expanding;\n    save();\n    gcd_main();\n    restore();\n    return expanding = prev_expanding;\n  };\n\n  gcd_main = function() {\n    var polyVar;\n    expanding = 1;\n    p2 = pop();\n    p1 = pop();\n    if (DEBUG) {\n      console.log(\"gcd_main: p1: \" + p1 + \" p2: \" + p2);\n    }\n    if (equal(p1, p2)) {\n      push(p1);\n      return;\n    }\n    if (isrational(p1) && isrational(p2)) {\n      push(p1);\n      push(p2);\n      gcd_numbers();\n      return;\n    }\n    if ((polyVar = areunivarpolysfactoredorexpandedform(p1, p2))) {\n      gcd_polys(polyVar);\n      return;\n    }\n    if (car(p1) === symbol(ADD) && car(p2) === symbol(ADD)) {\n      gcd_sum_sum();\n      return;\n    }\n    if (car(p1) === symbol(ADD)) {\n      gcd_sum(p1);\n      p1 = pop();\n    }\n    if (car(p2) === symbol(ADD)) {\n      gcd_sum(p2);\n      p2 = pop();\n    }\n    if (car(p1) === symbol(MULTIPLY)) {\n      gcd_sum_product();\n      return;\n    }\n    if (car(p2) === symbol(MULTIPLY)) {\n      gcd_product_sum();\n      return;\n    }\n    if (car(p1) === symbol(MULTIPLY) && car(p2) === symbol(MULTIPLY)) {\n      gcd_product_product();\n      return;\n    }\n    return gcd_powers_with_same_base();\n  };\n\n  areunivarpolysfactoredorexpandedform = function(p1, p2) {\n    var polyVar;\n    if (DEBUG) {\n      console.log(\"areunivarpolysfactoredorexpandedform: p1: \" + p1 + \" p2: \" + p2);\n    }\n    if (polyVar = isunivarpolyfactoredorexpandedform(p1)) {\n      if (isunivarpolyfactoredorexpandedform(p2, polyVar)) {\n        return polyVar;\n      }\n    }\n    return false;\n  };\n\n  gcd_polys = function(polyVar) {\n    if (DEBUG) {\n      console.log(\"gcd_polys: p1: \" + p1 + \" polyVar: \" + polyVar);\n    }\n    // gcd of factors\n    push(p1);\n    push(polyVar);\n    factorpoly();\n    p1 = pop();\n    push(p2);\n    push(polyVar);\n    factorpoly();\n    p2 = pop();\n    if (DEBUG) {\n      console.log(\"GCD: factored polys:\");\n    }\n    if (DEBUG) {\n      console.log(\"  p1:\" + p1.toString());\n    }\n    if (DEBUG) {\n      console.log(\"  p2:\" + p2.toString());\n    }\n    // In case one of two polynomials can be factored,\n    // (and only in that case), then\n    // we'll need to run gcd_factors on the two polynomials.\n    // (In case neither of them can be factored there is no gcd).\n    // However, gcd_factors expects two _products_ , and\n    // in case _one_ of the polynomials can't be factored it will look\n    // like a sum instead of a product.\n    // So, we'll have to make that sum to look like a factor:\n    // let's just turn it into a product with 1.\n\n    // in case one of the two polys has been factored...\n    if (car(p1) === symbol(MULTIPLY) || car(p2) === symbol(MULTIPLY)) {\n      // then make sure that if one of them is a single\n      // factor, we take the sum and wrap it into a\n      // multiplication by 1\n      if (car(p1) !== symbol(MULTIPLY)) {\n        push_symbol(MULTIPLY);\n        push(p1);\n        push(one);\n        list(3);\n        p1 = pop();\n      }\n      if (car(p2) !== symbol(MULTIPLY)) {\n        push_symbol(MULTIPLY);\n        push(p2);\n        push(one);\n        list(3);\n        p2 = pop();\n      }\n    }\n    if (car(p1) === symbol(MULTIPLY) && car(p2) === symbol(MULTIPLY)) {\n      gcd_product_product();\n      return;\n    }\n    gcd_powers_with_same_base();\n    return true;\n  };\n\n  gcd_product_product = function() {\n    var results;\n    push(one);\n    p3 = cdr(p1);\n    results = [];\n    while (iscons(p3)) {\n      p4 = cdr(p2);\n      while (iscons(p4)) {\n        push(car(p3));\n        push(car(p4));\n        gcd();\n        multiply();\n        p4 = cdr(p4);\n      }\n      results.push(p3 = cdr(p3));\n    }\n    return results;\n  };\n\n  gcd_powers_with_same_base = function() {\n    if (car(p1) === symbol(POWER)) {\n      p3 = caddr(p1); // exponent\n      p1 = cadr(p1); // base\n    } else {\n      p3 = one;\n    }\n    if (car(p2) === symbol(POWER)) {\n      p4 = caddr(p2); // exponent\n      p2 = cadr(p2); // base\n    } else {\n      p4 = one;\n    }\n    if (!equal(p1, p2)) {\n      push(one);\n      return;\n    }\n    // are both exponents numerical?\n    if (isNumericAtom(p3) && isNumericAtom(p4)) {\n      push(p1);\n      if (lessp(p3, p4)) {\n        push(p3);\n      } else {\n        push(p4);\n      }\n      power();\n      return;\n    }\n    // are the exponents multiples of eah other?\n    push(p3);\n    push(p4);\n    divide();\n    p5 = pop();\n    if (isNumericAtom(p5)) {\n      push(p1);\n      // choose the smallest exponent\n      if (car(p3) === symbol(MULTIPLY) && isNumericAtom(cadr(p3))) {\n        p5 = cadr(p3);\n      } else {\n        p5 = one;\n      }\n      if (car(p4) === symbol(MULTIPLY) && isNumericAtom(cadr(p4))) {\n        p6 = cadr(p4);\n      } else {\n        p6 = one;\n      }\n      if (lessp(p5, p6)) {\n        push(p3);\n      } else {\n        push(p4);\n      }\n      power();\n      return;\n    }\n    push(p3);\n    push(p4);\n    subtract();\n    p5 = pop();\n    if (!isNumericAtom(p5)) {\n      push(one);\n      return;\n    }\n    // can't be equal because of test near beginning\n    push(p1);\n    if (isnegativenumber(p5)) {\n      push(p3);\n    } else {\n      push(p4);\n    }\n    return power();\n  };\n\n  // in this case gcd is used as a composite function, i.e. gcd(gcd(gcd...\n  gcd_sum_sum = function() {\n    if (length(p1) !== length(p2)) {\n      push(one);\n      return;\n    }\n    p3 = cdr(p1);\n    push(car(p3));\n    p3 = cdr(p3);\n    while (iscons(p3)) {\n      push(car(p3));\n      gcd();\n      p3 = cdr(p3);\n    }\n    p3 = pop();\n    p4 = cdr(p2);\n    push(car(p4));\n    p4 = cdr(p4);\n    while (iscons(p4)) {\n      push(car(p4));\n      gcd();\n      p4 = cdr(p4);\n    }\n    p4 = pop();\n    push(p1);\n    push(p3);\n    divide();\n    p5 = pop();\n    push(p2);\n    push(p4);\n    divide();\n    p6 = pop();\n    if (equal(p5, p6)) {\n      push(p5);\n      push(p3);\n      push(p4);\n      gcd();\n      return multiply();\n    } else {\n      return push(one);\n    }\n  };\n\n  gcd_sum = function(p) {\n    var results;\n    p = cdr(p);\n    push(car(p));\n    p = cdr(p);\n    results = [];\n    while (iscons(p)) {\n      push(car(p));\n      gcd();\n      results.push(p = cdr(p));\n    }\n    return results;\n  };\n\n  gcd_sum_product = function() {\n    var results;\n    push(one);\n    p3 = cdr(p1);\n    results = [];\n    while (iscons(p3)) {\n      push(car(p3));\n      push(p2);\n      gcd();\n      multiply();\n      results.push(p3 = cdr(p3));\n    }\n    return results;\n  };\n\n  gcd_product_sum = function() {\n    var results;\n    push(one);\n    p4 = cdr(p2);\n    results = [];\n    while (iscons(p4)) {\n      push(p1);\n      push(car(p4));\n      gcd();\n      multiply();\n      results.push(p4 = cdr(p4));\n    }\n    return results;\n  };\n\n  // Guess which symbol to use for derivative, integral, etc.\n  guess = function() {\n    var p;\n    p = pop();\n    push(p);\n    if (Find(p, symbol(SYMBOL_X))) {\n      return push_symbol(SYMBOL_X);\n    } else if (Find(p, symbol(SYMBOL_Y))) {\n      return push_symbol(SYMBOL_Y);\n    } else if (Find(p, symbol(SYMBOL_Z))) {\n      return push_symbol(SYMBOL_Z);\n    } else if (Find(p, symbol(SYMBOL_T))) {\n      return push_symbol(SYMBOL_T);\n    } else if (Find(p, symbol(SYMBOL_S))) {\n      return push_symbol(SYMBOL_S);\n    } else {\n      return push_symbol(SYMBOL_X);\n    }\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Hermite polynomial\n\n  //  Input:    tos-2    x  (can be a symbol or expr)\n\n  //      tos-1    n\n\n  //  Output:    Result on stack\n\n  //-----------------------------------------------------------------------------\n  hermite = function() {\n    save();\n    yyhermite();\n    return restore();\n  };\n\n  // uses the recurrence relation H(x,n+1)=2*x*H(x,n)-2*n*H(x,n-1)\n\n  //define X p1\n  //define N p2\n  //define Y p3\n  //define Y1 p4\n  //define Y0 p5\n  yyhermite = function() {\n    var n;\n    n = 0;\n    p2 = pop();\n    p1 = pop();\n    push(p2);\n    n = pop_integer();\n    if (n < 0 || isNaN(n)) {\n      push_symbol(HERMITE);\n      push(p1);\n      push(p2);\n      list(3);\n      return;\n    }\n    if (issymbol(p1)) {\n      return yyhermite2(n);\n    } else {\n      p3 = p1;\n      p1 = symbol(SECRETX);\n      yyhermite2(n);\n      p1 = p3;\n      push(symbol(SECRETX));\n      push(p1);\n      subst();\n      return Eval();\n    }\n  };\n\n  yyhermite2 = function(n) {\n    var i, o, ref, results;\n    i = 0;\n    push_integer(1);\n    push_integer(0);\n    p4 = pop();\n    results = [];\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      p5 = p4;\n      p4 = pop();\n      push(p1);\n      push(p4);\n      multiply();\n      push_integer(i);\n      push(p5);\n      multiply();\n      subtract();\n      push_integer(2);\n      results.push(multiply());\n    }\n    return results;\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Create a Hilbert matrix\n\n  //  Input:    Dimension on stack\n\n  //  Output:    Hilbert matrix on stack\n\n  //  Example:\n\n  //  > hilbert(5)\n  //  ((1,1/2,1/3,1/4),(1/2,1/3,1/4,1/5),(1/3,1/4,1/5,1/6),(1/4,1/5,1/6,1/7))\n\n  //-----------------------------------------------------------------------------\n\n  //define A p1\n  //define N p2\n\n  //define AELEM(i, j) A->u.tensor->elem[i * n + j]\n  hilbert = function() {\n    var i, i1, j, n, o, ref, ref1;\n    i = 0;\n    j = 0;\n    n = 0;\n    save();\n    p2 = pop();\n    push(p2);\n    n = pop_integer();\n    if (n < 2) {\n      push_symbol(HILBERT);\n      push(p2);\n      list(2);\n      restore();\n      return;\n    }\n    push_zero_matrix(n, n);\n    p1 = pop();\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      for (j = i1 = 0, ref1 = n; (0 <= ref1 ? i1 < ref1 : i1 > ref1); j = 0 <= ref1 ? ++i1 : --i1) {\n        push_integer(i + j + 1);\n        inverse();\n        p1.tensor.elem[i * n + j] = pop();\n      }\n    }\n    push(p1);\n    return restore();\n  };\n\n  DEBUG_IMAG = false;\n\n  Eval_imag = function() {\n    push(cadr(p1));\n    Eval();\n    return imag();\n  };\n\n  imag = function() {\n    save();\n    rect();\n    p1 = pop();\n    if (DEBUG_IMAG) {\n      console.log(\"IMAGE of \" + p1);\n    }\n    push(p1);\n    push(p1);\n    conjugate();\n    if (DEBUG_IMAG) {\n      console.log(\" image: conjugate result: \" + stack[tos - 1]);\n    }\n    subtract();\n    push_integer(2);\n    divide();\n    if (DEBUG_IMAG) {\n      console.log(\" image: 1st divide result: \" + stack[tos - 1]);\n    }\n    push(imaginaryunit);\n    divide();\n    if (DEBUG_IMAG) {\n      console.log(\" image: 2nd divide result: \" + stack[tos - 1]);\n    }\n    return restore();\n  };\n\n  // n is the total number of things on the stack. The first thing on the stack\n  // is the object to be indexed, followed by the indices themselves.\n\n  // called by Eval_index\n  index_function = function(n) {\n    var i, i1, j1, k, l1, m, m1, ndim, nelem, o, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, s, t;\n    i = 0;\n    k = 0;\n    m = 0;\n    ndim = 0;\n    nelem = 0;\n    t = 0;\n    save();\n    s = tos - n;\n    p1 = stack[s];\n    ndim = p1.tensor.ndim;\n    m = n - 1;\n    if (m > ndim) {\n      stop(\"too many indices for tensor\");\n    }\n    k = 0;\n    for (i = o = 0, ref = m; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      push(stack[s + i + 1]);\n      t = pop_integer();\n      if (t < 1 || t > p1.tensor.dim[i]) {\n        stop(\"index out of range\");\n      }\n      k = k * p1.tensor.dim[i] + t - 1;\n    }\n    if (ndim === m) {\n      moveTos(tos - n);\n      push(p1.tensor.elem[k]);\n      restore();\n      return;\n    }\n    for (i = i1 = ref1 = m, ref2 = ndim; (ref1 <= ref2 ? i1 < ref2 : i1 > ref2); i = ref1 <= ref2 ? ++i1 : --i1) {\n      k = k * p1.tensor.dim[i] + 0;\n    }\n    nelem = 1;\n    for (i = j1 = ref3 = m, ref4 = ndim; (ref3 <= ref4 ? j1 < ref4 : j1 > ref4); i = ref3 <= ref4 ? ++j1 : --j1) {\n      nelem *= p1.tensor.dim[i];\n    }\n    p2 = alloc_tensor(nelem);\n    p2.tensor.ndim = ndim - m;\n    for (i = l1 = ref5 = m, ref6 = ndim; (ref5 <= ref6 ? l1 < ref6 : l1 > ref6); i = ref5 <= ref6 ? ++l1 : --l1) {\n      p2.tensor.dim[i - m] = p1.tensor.dim[i];\n    }\n    for (i = m1 = 0, ref7 = nelem; (0 <= ref7 ? m1 < ref7 : m1 > ref7); i = 0 <= ref7 ? ++m1 : --m1) {\n      p2.tensor.elem[i] = p1.tensor.elem[k + i];\n    }\n    check_tensor_dimensions(p1);\n    check_tensor_dimensions(p2);\n    moveTos(tos - n);\n    push(p2);\n    return restore();\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Input:    n    Number of args on stack\n\n  //      tos-n    Right-hand value\n\n  //      tos-n+1    Left-hand value\n\n  //      tos-n+2    First index\n\n  //      .\n  //      .\n  //      .\n\n  //      tos-1    Last index\n\n  //  Output:    Result on stack\n\n  //-----------------------------------------------------------------------------\n\n  //define LVALUE p1\n  //define RVALUE p2\n  //define TMP p3\n  set_component = function(n) {\n    var i, i1, j1, k, l1, m, m1, n1, ndim, o, ref, ref1, ref2, ref3, ref4, ref5, ref6, s, t;\n    i = 0;\n    k = 0;\n    m = 0;\n    ndim = 0;\n    t = 0;\n    save();\n    if (n < 3) {\n      stop(\"error in indexed assign\");\n    }\n    s = tos - n;\n    p2 = stack[s];\n    p1 = stack[s + 1];\n    if (!istensor(p1)) { // p1 is LVALUE\n      stop(\"error in indexed assign: assigning to something that is not a tensor\");\n    }\n    ndim = p1.tensor.ndim;\n    m = n - 2;\n    if (m > ndim) {\n      stop(\"error in indexed assign\");\n    }\n    k = 0;\n    for (i = o = 0, ref = m; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      push(stack[s + i + 2]);\n      t = pop_integer();\n      if (t < 1 || t > p1.tensor.dim[i]) {\n        stop(\"error in indexed assign\\n\");\n      }\n      k = k * p1.tensor.dim[i] + t - 1;\n    }\n    for (i = i1 = ref1 = m, ref2 = ndim; (ref1 <= ref2 ? i1 < ref2 : i1 > ref2); i = ref1 <= ref2 ? ++i1 : --i1) {\n      k = k * p1.tensor.dim[i] + 0;\n    }\n    // copy\n    p3 = alloc_tensor(p1.tensor.nelem);\n    p3.tensor.ndim = p1.tensor.ndim;\n    for (i = j1 = 0, ref3 = p1.tensor.ndim; (0 <= ref3 ? j1 < ref3 : j1 > ref3); i = 0 <= ref3 ? ++j1 : --j1) {\n      p3.tensor.dim[i] = p1.tensor.dim[i];\n    }\n    for (i = l1 = 0, ref4 = p1.tensor.nelem; (0 <= ref4 ? l1 < ref4 : l1 > ref4); i = 0 <= ref4 ? ++l1 : --l1) {\n      p3.tensor.elem[i] = p1.tensor.elem[i];\n    }\n    check_tensor_dimensions(p1);\n    check_tensor_dimensions(p3);\n    p1 = p3;\n    if (ndim === m) {\n      if (istensor(p2)) { // p2 is RVALUE\n        stop(\"error in indexed assign\");\n      }\n      p1.tensor.elem[k] = p2;\n      check_tensor_dimensions(p1);\n      moveTos(tos - n);\n      push(p1);\n      restore();\n      return;\n    }\n    if (!istensor(p2)) { // p2 is RVALUE\n      stop(\"error in indexed assign\");\n    }\n    if (ndim - m !== p2.tensor.ndim) { // p2 is RVALUE\n      stop(\"error in indexed assign\");\n    }\n// p2 is RVALUE\n    for (i = m1 = 0, ref5 = p2.tensor.ndim; (0 <= ref5 ? m1 < ref5 : m1 > ref5); i = 0 <= ref5 ? ++m1 : --m1) {\n      if (p1.tensor.dim[m + i] !== p2.tensor.dim[i]) {\n        stop(\"error in indexed assign\");\n      }\n    }\n// p2 is RVALUE\n// copy rvalue\n    for (i = n1 = 0, ref6 = p2.tensor.nelem; (0 <= ref6 ? n1 < ref6 : n1 > ref6); i = 0 <= ref6 ? ++n1 : --n1) {\n      p1.tensor.elem[k + i] = p2.tensor.elem[i];\n    }\n    check_tensor_dimensions(p1);\n    check_tensor_dimensions(p2);\n    moveTos(tos - n);\n    push(p1);\n    return restore();\n  };\n\n  Eval_inner = function() {\n    var difference, i, i1, j1, l1, moretheArguments, o, operands, ref, ref1, ref2, ref3, refinedOperands, results, secondArgument, shift, theArguments;\n    \n    // if there are more than two arguments then\n    // reduce it to a more standard version\n    // of two arguments, which means we need to\n    // transform the arguments into a tree of\n    // inner products e.g.\n    // inner(a,b,c) becomes inner(a,inner(b,c))\n    // this is so we can get to a standard binary-tree\n    // version that is simpler to manipulate.\n    theArguments = [];\n    theArguments.push(car(cdr(p1)));\n    secondArgument = car(cdr(cdr(p1)));\n    if (secondArgument === symbol(NIL)) {\n      stop(\"pattern needs at least a template and a transformed version\");\n    }\n    moretheArguments = cdr(cdr(p1));\n    while (moretheArguments !== symbol(NIL)) {\n      theArguments.push(car(moretheArguments));\n      moretheArguments = cdr(moretheArguments);\n    }\n    // make it so e.g. inner(a,b,c) becomes inner(a,inner(b,c))\n    if (theArguments.length > 2) {\n      push_symbol(INNER);\n      push(theArguments[theArguments.length - 2]);\n      push(theArguments[theArguments.length - 1]);\n      list(3);\n      for (i = o = 2, ref = theArguments.length; (2 <= ref ? o < ref : o > ref); i = 2 <= ref ? ++o : --o) {\n        push_symbol(INNER);\n        swap();\n        push(theArguments[theArguments.length - i - 1]);\n        swap();\n        list(3);\n      }\n      p1 = pop();\n      Eval_inner();\n      return;\n    }\n    // TODO we have to take a look at the whole\n    // sequence of operands and make simplifications\n    // on that...\n    operands = [];\n    get_innerprod_factors(p1, operands);\n    //console.log \"printing operands --------\"\n    //for i in [0...operands.length]\n    //  console.log \"operand \" + i + \" : \" + operands[i]\n    refinedOperands = [];\n// removing all identity matrices\n    for (i = i1 = 0, ref1 = operands.length; (0 <= ref1 ? i1 < ref1 : i1 > ref1); i = 0 <= ref1 ? ++i1 : --i1) {\n      if (operands[i] === symbol(SYMBOL_IDENTITY_MATRIX)) {\n        continue;\n      } else {\n        refinedOperands.push(operands[i]);\n      }\n    }\n    operands = refinedOperands;\n    refinedOperands = [];\n    if (operands.length > 1) {\n      // removing all consecutive pairs of inverses\n      // so we can answer that inv(a)a results in the\n      // identity matrix. We want to catch symbolic inverses\n      // not numeric inverses, those will just take care\n      // of themselves when multiplied\n      shift = 0;\n      for (i = j1 = 0, ref2 = operands.length; (0 <= ref2 ? j1 < ref2 : j1 > ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n        //console.log \"comparing if \" + operands[i+shift] + \" and \" + operands[i+shift+1] + \" are inverses of each other\"\n        if ((i + shift + 1) <= (operands.length - 1)) {\n          if (!(isNumericAtomOrTensor(operands[i + shift]) || isNumericAtomOrTensor(operands[i + shift + 1]))) {\n            push(operands[i + shift]);\n            Eval();\n            inv();\n            push(operands[i + shift + 1]);\n            Eval();\n            subtract();\n            difference = pop();\n            //console.log \"result: \" + difference\n            if (isZeroAtomOrTensor(difference)) {\n              shift += 1;\n            } else {\n              refinedOperands.push(operands[i + shift]);\n            }\n          } else {\n            refinedOperands.push(operands[i + shift]);\n          }\n        } else {\n          break;\n        }\n        //console.log \"i: \" + i + \" shift: \" + shift + \" operands.length: \" + operands.length\n        if (i + shift === operands.length - 2) {\n          //console.log \"adding last operand 2 \"\n          refinedOperands.push(operands[operands.length - 1]);\n        }\n        if (i + shift >= operands.length - 1) {\n          break;\n        }\n      }\n      operands = refinedOperands;\n    }\n    //console.log \"refined operands --------\"\n    //for i in [0...refinedOperands.length]\n    //  console.log \"refined operand \" + i + \" : \" + refinedOperands[i]\n\n    //console.log \"stack[tos-1]: \" + stack[tos-1]\n\n    // now rebuild the arguments, just using the\n    // refined operands\n    push(symbol(INNER));\n    //console.log \"rebuilding the argument ----\"\n    if (operands.length > 0) {\n      for (i = l1 = 0, ref3 = operands.length; (0 <= ref3 ? l1 < ref3 : l1 > ref3); i = 0 <= ref3 ? ++l1 : --l1) {\n        //console.log \"pushing \" + operands[i]\n        push(operands[i]);\n      }\n    } else {\n      pop();\n      push(symbol(SYMBOL_IDENTITY_MATRIX));\n      return;\n    }\n    //console.log \"list(operands.length): \" + (operands.length+1)\n    list(operands.length + 1);\n    p1 = pop();\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p1 = cdr(p1);\n    results = [];\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n      inner();\n      results.push(p1 = cdr(p1));\n    }\n    return results;\n  };\n\n  // inner definition\n  inner = function() {\n    var arg1, arg2, arg3, subtractionResult;\n    save();\n    p2 = pop();\n    p1 = pop();\n    // more in general, when a and b are scalars,\n    // inner(a*M1, b*M2) is equal to\n    // a*b*inner(M1,M2), but of course we can only\n    // \"bring out\" in a and b the scalars, because\n    // it's the only commutative part.\n    // that's going to be trickier to do in general\n    // but let's start with just the signs.\n    if (isnegativeterm(p2) && isnegativeterm(p1)) {\n      push(p2);\n      negate();\n      p2 = pop();\n      push(p1);\n      negate();\n      p1 = pop();\n    }\n    // since inner is associative,\n    // put it in a canonical form i.e.\n    // inner(inner(a,b),c) ->\n    // inner(a,inner(b,c))\n    // so that we can recognise when they\n    // are equal.\n    if (isinnerordot(p1)) {\n      arg1 = car(cdr(p1)); //a\n      arg2 = car(cdr(cdr(p1))); //b\n      arg3 = p2;\n      p1 = arg1;\n      push(arg2);\n      push(arg3);\n      inner();\n      p2 = pop();\n    }\n    // Check if one of the operands is the identity matrix\n    // we could maybe use Eval_testeq here but\n    // this seems to suffice?\n    if (p1 === symbol(SYMBOL_IDENTITY_MATRIX)) {\n      push(p2);\n      restore();\n      return;\n    } else if (p2 === symbol(SYMBOL_IDENTITY_MATRIX)) {\n      push(p1);\n      restore();\n      return;\n    }\n    if (istensor(p1) && istensor(p2)) {\n      inner_f();\n    } else {\n      if (!(isNumericAtomOrTensor(p1) || isNumericAtomOrTensor(p2))) {\n        push(p1);\n        push(p2);\n        inv();\n        subtract();\n        subtractionResult = pop();\n        if (isZeroAtomOrTensor(subtractionResult)) {\n          push_symbol(SYMBOL_IDENTITY_MATRIX);\n          restore();\n          return;\n        }\n      }\n      // if either operand is a sum then distribute\n      // (if we are in expanding mode)\n      if (expanding && isadd(p1)) {\n        p1 = cdr(p1);\n        push(zero);\n        while (iscons(p1)) {\n          push(car(p1));\n          push(p2);\n          inner();\n          add();\n          p1 = cdr(p1);\n        }\n        restore();\n        return;\n      }\n      if (expanding && isadd(p2)) {\n        p2 = cdr(p2);\n        push(zero);\n        while (iscons(p2)) {\n          push(p1);\n          push(car(p2));\n          inner();\n          add();\n          p2 = cdr(p2);\n        }\n        restore();\n        return;\n      }\n      push(p1);\n      push(p2);\n      // there are 8 remaining cases here, since each of the\n      // two arguments can only be a scalar/tensor/unknown\n      // and the tensor - tensor case was caught\n      // upper in the code\n      if (istensor(p1) && isNumericAtom(p2)) {\n        // one case covered by this branch:\n        //   tensor - scalar\n        tensor_times_scalar();\n      } else if (isNumericAtom(p1) && istensor(p2)) {\n        // one case covered by this branch:\n        //   scalar - tensor\n        scalar_times_tensor();\n      } else {\n        if (isNumericAtom(p1) || isNumericAtom(p2)) {\n          // three cases covered by this branch:\n          //   unknown - scalar\n          //   scalar - unknown\n          //   scalar  - scalar\n          // in these cases a normal multiplication\n          // will be OK\n          multiply();\n        } else {\n          // three cases covered by this branch:\n          //   unknown - unknown\n          //   unknown - tensor\n          //   tensor  - unknown\n          // in this case we can't use normal\n          // multiplication.\n          pop();\n          pop();\n          push_symbol(INNER);\n          push(p1);\n          push(p2);\n          list(3);\n          restore();\n          return;\n        }\n      }\n    }\n    return restore();\n  };\n\n  // inner product of tensors p1 and p2\n  inner_f = function() {\n    var a, ak, b, bk, c, i, i1, j, j1, k, l1, m1, n, n1, ndim, o, o1, ref, ref1, ref2, ref3, ref4, ref5, ref6;\n    i = 0;\n    n = p1.tensor.dim[p1.tensor.ndim - 1];\n    if (n !== p2.tensor.dim[0]) {\n      debugger;\n      stop(\"inner: tensor dimension check\");\n    }\n    ndim = p1.tensor.ndim + p2.tensor.ndim - 2;\n    if (ndim > MAXDIM) {\n      stop(\"inner: rank of result exceeds maximum\");\n    }\n    a = p1.tensor.elem;\n    b = p2.tensor.elem;\n    //---------------------------------------------------------------------\n\n    //  ak is the number of rows in tensor A\n\n    //  bk is the number of columns in tensor B\n\n    //  Example:\n\n    //  A[3][3][4] B[4][4][3]\n\n    //    3  3        ak = 3 * 3 = 9\n\n    //                  4  3    bk = 4 * 3 = 12\n\n    //---------------------------------------------------------------------\n    ak = 1;\n    for (i = o = 0, ref = p1.tensor.ndim - 1; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      ak *= p1.tensor.dim[i];\n    }\n    bk = 1;\n    for (i = i1 = 1, ref1 = p2.tensor.ndim; (1 <= ref1 ? i1 < ref1 : i1 > ref1); i = 1 <= ref1 ? ++i1 : --i1) {\n      bk *= p2.tensor.dim[i];\n    }\n    p3 = alloc_tensor(ak * bk);\n    c = p3.tensor.elem;\n// new method copied from ginac http://www.ginac.de/\n    for (i = j1 = 0, ref2 = ak; (0 <= ref2 ? j1 < ref2 : j1 > ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n      for (j = l1 = 0, ref3 = n; (0 <= ref3 ? l1 < ref3 : l1 > ref3); j = 0 <= ref3 ? ++l1 : --l1) {\n        if (isZeroAtomOrTensor(a[i * n + j])) {\n          continue;\n        }\n        for (k = m1 = 0, ref4 = bk; (0 <= ref4 ? m1 < ref4 : m1 > ref4); k = 0 <= ref4 ? ++m1 : --m1) {\n          push(a[i * n + j]);\n          push(b[j * bk + k]);\n          multiply();\n          push(c[i * bk + k]);\n          add();\n          c[i * bk + k] = pop();\n        }\n      }\n    }\n    //---------------------------------------------------------------------\n\n    //  Note on understanding \"k * bk + j\"\n\n    //  k * bk because each element of a column is bk locations apart\n\n    //  + j because the beginnings of all columns are in the first bk \n    //  locations\n\n    //  Example: n = 2, bk = 6\n\n    //  b111  <- 1st element of 1st column\n    //  b112  <- 1st element of 2nd column\n    //  b113  <- 1st element of 3rd column\n    //  b121  <- 1st element of 4th column\n    //  b122  <- 1st element of 5th column\n    //  b123  <- 1st element of 6th column\n\n    //  b211  <- 2nd element of 1st column\n    //  b212  <- 2nd element of 2nd column\n    //  b213  <- 2nd element of 3rd column\n    //  b221  <- 2nd element of 4th column\n    //  b222  <- 2nd element of 5th column\n    //  b223  <- 2nd element of 6th column\n\n    //---------------------------------------------------------------------\n    if (ndim === 0) {\n      return push(p3.tensor.elem[0]);\n    } else {\n      p3.tensor.ndim = ndim;\n      j = 0;\n      for (i = n1 = 0, ref5 = p1.tensor.ndim - 1; (0 <= ref5 ? n1 < ref5 : n1 > ref5); i = 0 <= ref5 ? ++n1 : --n1) {\n        p3.tensor.dim[i] = p1.tensor.dim[i];\n      }\n      j = p1.tensor.ndim - 1;\n      for (i = o1 = 0, ref6 = p2.tensor.ndim - 1; (0 <= ref6 ? o1 < ref6 : o1 > ref6); i = 0 <= ref6 ? ++o1 : --o1) {\n        p3.tensor.dim[j + i] = p2.tensor.dim[i + 1];\n      }\n      return push(p3);\n    }\n  };\n\n  // Algebrite.run('c(b+a)inv((a+b))d').toString();\n  // Algebrite.run('c*(b+a)inv((a+b))d').toString();\n  // Algebrite.run('(c(b+a))(inv((a+b))d)').toString();\n  get_innerprod_factors = function(tree, factors_accumulator) {\n    if (!iscons(tree)) {\n      add_factor_to_accumulator(tree, factors_accumulator);\n      return;\n    }\n    if (cdr(tree) === symbol(NIL)) {\n      tree = get_innerprod_factors(car(tree), factors_accumulator);\n      return;\n    }\n    if (isinnerordot(tree)) {\n      // console.log \"there is inner at top, recursing on the operands\"\n      get_innerprod_factors(car(cdr(tree)), factors_accumulator);\n      get_innerprod_factors(cdr(cdr(tree)), factors_accumulator);\n      return;\n    }\n    return add_factor_to_accumulator(tree, factors_accumulator);\n  };\n\n  add_factor_to_accumulator = function(tree, factors_accumulator) {\n    if (tree !== symbol(NIL)) {\n      // console.log \">> adding to factors_accumulator: \" + tree\n      return factors_accumulator.push(tree);\n    }\n  };\n\n  itab = [\n    // 1\n    \"f(a,a*x)\",\n    // 9 (need a caveat for 7 so we can put 9 after 7)\n    \"f(1/x,log(x))\",\n    // 7\n    \"f(x^a,x^(a+1)/(a+1))\",\n    // five specialisations of case 7 for speed.\n    // Covers often-occurring exponents: each of\n    // these case ends up in a dedicated entry, so we\n    // only have to do one sure-shot match.\n    \"f(x^(-2),-x^(-1))\",\n    \"f(x^(-1/2),2*x^(1/2))\",\n    \"f(x^(1/2),2/3*x^(3/2))\",\n    \"f(x,x^2/2)\",\n    \"f(x^2,x^3/3)\",\n    // 12\n    \"f(exp(a*x),1/a*exp(a*x))\",\n    \"f(exp(a*x+b),1/a*exp(a*x+b))\",\n    \"f(x*exp(a*x^2),exp(a*x^2)/(2*a))\",\n    \"f(x*exp(a*x^2+b),exp(a*x^2+b)/(2*a))\",\n    // 14\n    \"f(log(a*x),x*log(a*x)-x)\",\n    // 15\n    \"f(a^x,a^x/log(a),or(not(number(a)),a>0))\",\n    // 16\n    \"f(1/(a+x^2),1/sqrt(a)*arctan(x/sqrt(a)),or(not(number(a)),a>0))\",\n    // 17\n    \"f(1/(a-x^2),1/sqrt(a)*arctanh(x/sqrt(a)))\",\n    // 19\n    \"f(1/sqrt(a-x^2),arcsin(x/(sqrt(a))))\",\n    // 20\n    \"f(1/sqrt(a+x^2),log(x+sqrt(a+x^2)))\",\n    // 27\n    \"f(1/(a+b*x),1/b*log(a+b*x))\",\n    // 28\n    \"f(1/(a+b*x)^2,-1/(b*(a+b*x)))\",\n    // 29\n    \"f(1/(a+b*x)^3,-1/(2*b)*1/(a+b*x)^2)\",\n    // 30\n    \"f(x/(a+b*x),x/b-a*log(a+b*x)/b/b)\",\n    // 31\n    \"f(x/(a+b*x)^2,1/b^2*(log(a+b*x)+a/(a+b*x)))\",\n    // 33\n    \"f(x^2/(a+b*x),1/b^2*(1/2*(a+b*x)^2-2*a*(a+b*x)+a^2*log(a+b*x)))\",\n    // 34\n    \"f(x^2/(a+b*x)^2,1/b^3*(a+b*x-2*a*log(a+b*x)-a^2/(a+b*x)))\",\n    // 35\n    \"f(x^2/(a+b*x)^3,1/b^3*(log(a+b*x)+2*a/(a+b*x)-1/2*a^2/(a+b*x)^2))\",\n    // 37\n    \"f(1/x*1/(a+b*x),-1/a*log((a+b*x)/x))\",\n    // 38\n    \"f(1/x*1/(a+b*x)^2,1/a*1/(a+b*x)-1/a^2*log((a+b*x)/x))\",\n    // 39\n    \"f(1/x*1/(a+b*x)^3,1/a^3*(1/2*((2*a+b*x)/(a+b*x))^2+log(x/(a+b*x))))\",\n    // 40\n    \"f(1/x^2*1/(a+b*x),-1/(a*x)+b/a^2*log((a+b*x)/x))\",\n    // 41\n    \"f(1/x^3*1/(a+b*x),(2*b*x-a)/(2*a^2*x^2)+b^2/a^3*log(x/(a+b*x)))\",\n    // 42\n    \"f(1/x^2*1/(a+b*x)^2,-(a+2*b*x)/(a^2*x*(a+b*x))+2*b/a^3*log((a+b*x)/x))\",\n    // 60\n    \"f(1/(a+b*x^2),1/sqrt(a*b)*arctan(x*sqrt(a*b)/a),or(not(number(a*b)),a*b>0))\",\n    // 61\n    \"f(1/(a+b*x^2),1/(2*sqrt(-a*b))*log((a+x*sqrt(-a*b))/(a-x*sqrt(-a*b))),or(not(number(a*b)),a*b<0))\",\n    // 62 is the same as 60\n    // 63\n    \"f(x/(a+b*x^2),1/2*1/b*log(a+b*x^2))\",\n    //64\n    \"f(x^2/(a+b*x^2),x/b-a/b*integral(1/(a+b*x^2),x))\",\n    //65\n    \"f(1/(a+b*x^2)^2,x/(2*a*(a+b*x^2))+1/2*1/a*integral(1/(a+b*x^2),x))\",\n    //66 is covered by 61\n    //70\n    \"f(1/x*1/(a+b*x^2),1/2*1/a*log(x^2/(a+b*x^2)))\",\n    //71\n    \"f(1/x^2*1/(a+b*x^2),-1/(a*x)-b/a*integral(1/(a+b*x^2),x))\",\n    //74\n    \"f(1/(a+b*x^3),1/3*1/a*(a/b)^(1/3)*(1/2*log(((a/b)^(1/3)+x)^3/(a+b*x^3))+sqrt(3)*arctan((2*x-(a/b)^(1/3))*(a/b)^(-1/3)/sqrt(3))))\",\n    //76\n    \"f(x^2/(a+b*x^3),1/3*1/b*log(a+b*x^3))\",\n    // float(defint(1/(2+3*X^4),X,0,pi)) gave wrong result.\n    // Also, the tests related to the indefinite integral\n    // fail since we rationalise expressions \"better\", so I'm thinking\n    // to take this out completely as it seemed to give the\n    // wrong results in the first place.\n    //77\n    //\"f(1/(a+b*x^4),1/2*1/a*(a/b/4)^(1/4)*(1/2*log((x^2+2*(a/b/4)^(1/4)*x+2*(a/b/4)^(1/2))/(x^2-2*(a/b/4)^(1/4)*x+2*(a/b/4)^(1/2)))+arctan(2*(a/b/4)^(1/4)*x/(2*(a/b/4)^(1/2)-x^2))),or(not(number(a*b)),a*b>0))\",\n    //78\n    //\"f(1/(a+b*x^4),1/2*(-a/b)^(1/4)/a*(1/2*log((x+(-a/b)^(1/4))/(x-(-a/b)^(1/4)))+arctan(x*(-a/b)^(-1/4))),or(not(number(a*b)),a*b<0))\",\n    //79\n    \"f(x/(a+b*x^4),1/2*sqrt(b/a)/b*arctan(x^2*sqrt(b/a)),or(not(number(a*b)),a*b>0))\",\n    //80\n    \"f(x/(a+b*x^4),1/4*sqrt(-b/a)/b*log((x^2-sqrt(-a/b))/(x^2+sqrt(-a/b))),or(not(number(a*b)),a*b<0))\",\n    // float(defint(X^2/(2+3*X^4),X,0,pi)) gave wrong result.\n    // Also, the tests related to the indefinite integral\n    // fail since we rationalise expressions \"better\", so I'm thinking\n    // to take this out completely as it seemed to give the\n    // wrong results in the first place.\n    //81\n    //\"f(x^2/(a+b*x^4),1/4*1/b*(a/b/4)^(-1/4)*(1/2*log((x^2-2*(a/b/4)^(1/4)*x+2*sqrt(a/b/4))/(x^2+2*(a/b/4)^(1/4)*x+2*sqrt(a/b/4)))+arctan(2*(a/b/4)^(1/4)*x/(2*sqrt(a/b/4)-x^2))),or(not(number(a*b)),a*b>0))\",\n    //82\n    //\"f(x^2/(a+b*x^4),1/4*1/b*(-a/b)^(-1/4)*(log((x-(-a/b)^(1/4))/(x+(-a/b)^(1/4)))+2*arctan(x*(-a/b)^(-1/4))),or(not(number(a*b)),a*b<0))\",\n    //83\n    \"f(x^3/(a+b*x^4),1/4*1/b*log(a+b*x^4))\",\n    //124\n    \"f(sqrt(a+b*x),2/3*1/b*sqrt((a+b*x)^3))\",\n    //125\n    \"f(x*sqrt(a+b*x),-2*(2*a-3*b*x)*sqrt((a+b*x)^3)/15/b^2)\",\n    //126\n    \"f(x^2*sqrt(a+b*x),2*(8*a^2-12*a*b*x+15*b^2*x^2)*sqrt((a+b*x)^3)/105/b^3)\",\n    //128\n    \"f(sqrt(a+b*x)/x,2*sqrt(a+b*x)+a*integral(1/x*1/sqrt(a+b*x),x))\",\n    //129\n    \"f(sqrt(a+b*x)/x^2,-sqrt(a+b*x)/x+b/2*integral(1/x*1/sqrt(a+b*x),x))\",\n    //131\n    \"f(1/sqrt(a+b*x),2*sqrt(a+b*x)/b)\",\n    //132\n    \"f(x/sqrt(a+b*x),-2/3*(2*a-b*x)*sqrt(a+b*x)/b^2)\",\n    //133\n    \"f(x^2/sqrt(a+b*x),2/15*(8*a^2-4*a*b*x+3*b^2*x^2)*sqrt(a+b*x)/b^3)\",\n    //135\n    \"f(1/x*1/sqrt(a+b*x),1/sqrt(a)*log((sqrt(a+b*x)-sqrt(a))/(sqrt(a+b*x)+sqrt(a))),or(not(number(a)),a>0))\",\n    //136\n    \"f(1/x*1/sqrt(a+b*x),2/sqrt(-a)*arctan(sqrt(-(a+b*x)/a)),or(not(number(a)),a<0))\",\n    //137\n    \"f(1/x^2*1/sqrt(a+b*x),-sqrt(a+b*x)/a/x-1/2*b/a*integral(1/x*1/sqrt(a+b*x),x))\",\n    //156\n    \"f(sqrt(x^2+a),1/2*(x*sqrt(x^2+a)+a*log(x+sqrt(x^2+a))))\",\n    //157\n    \"f(1/sqrt(x^2+a),log(x+sqrt(x^2+a)))\",\n    //158\n    \"f(1/x*1/sqrt(x^2+a),arcsec(x/sqrt(-a))/sqrt(-a),or(not(number(a)),a<0))\",\n    //159\n    \"f(1/x*1/sqrt(x^2+a),-1/sqrt(a)*log((sqrt(a)+sqrt(x^2+a))/x),or(not(number(a)),a>0))\",\n    //160\n    \"f(sqrt(x^2+a)/x,sqrt(x^2+a)-sqrt(a)*log((sqrt(a)+sqrt(x^2+a))/x),or(not(number(a)),a>0))\",\n    //161\n    \"f(sqrt(x^2+a)/x,sqrt(x^2+a)-sqrt(-a)*arcsec(x/sqrt(-a)),or(not(number(a)),a<0))\",\n    //162\n    \"f(x/sqrt(x^2+a),sqrt(x^2+a))\",\n    //163\n    \"f(x*sqrt(x^2+a),1/3*sqrt((x^2+a)^3))\",\n    //164 need an unexpanded version?\n    \"f(sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/4*(x*sqrt((x^2+a^(1/3))^3)+3/2*a^(1/3)*x*sqrt(x^2+a^(1/3))+3/2*a^(2/3)*log(x+sqrt(x^2+a^(1/3)))))\",\n    // match doesn't work for the following\n    \"f(sqrt(-a+x^6-3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/4*(x*sqrt((x^2-a^(1/3))^3)-3/2*a^(1/3)*x*sqrt(x^2-a^(1/3))+3/2*a^(2/3)*log(x+sqrt(x^2-a^(1/3)))))\",\n    //165\n    \"f(1/sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),x/a^(1/3)/sqrt(x^2+a^(1/3)))\",\n    //166\n    \"f(x/sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),-1/sqrt(x^2+a^(1/3)))\",\n    //167\n    \"f(x*sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/5*sqrt((x^2+a^(1/3))^5))\",\n    //168\n    \"f(x^2*sqrt(x^2+a),1/4*x*sqrt((x^2+a)^3)-1/8*a*x*sqrt(x^2+a)-1/8*a^2*log(x+sqrt(x^2+a)))\",\n    //169\n    \"f(x^3*sqrt(x^2+a),(1/5*x^2-2/15*a)*sqrt((x^2+a)^3),and(number(a),a>0))\",\n    //170\n    \"f(x^3*sqrt(x^2+a),sqrt((x^2+a)^5)/5-a*sqrt((x^2+a)^3)/3,and(number(a),a<0))\",\n    //171\n    \"f(x^2/sqrt(x^2+a),1/2*x*sqrt(x^2+a)-1/2*a*log(x+sqrt(x^2+a)))\",\n    //172\n    \"f(x^3/sqrt(x^2+a),1/3*sqrt((x^2+a)^3)-a*sqrt(x^2+a))\",\n    //173\n    \"f(1/x^2*1/sqrt(x^2+a),-sqrt(x^2+a)/a/x)\",\n    //174\n    \"f(1/x^3*1/sqrt(x^2+a),-1/2*sqrt(x^2+a)/a/x^2+1/2*log((sqrt(a)+sqrt(x^2+a))/x)/a^(3/2),or(not(number(a)),a>0))\",\n    //175\n    \"f(1/x^3*1/sqrt(x^2-a),1/2*sqrt(x^2-a)/a/x^2+1/2*1/(a^(3/2))*arcsec(x/(a^(1/2))),or(not(number(a)),a>0))\",\n    //176+\n    \"f(x^2*sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/6*x*sqrt((x^2+a^(1/3))^5)-1/24*a^(1/3)*x*sqrt((x^2+a^(1/3))^3)-1/16*a^(2/3)*x*sqrt(x^2+a^(1/3))-1/16*a*log(x+sqrt(x^2+a^(1/3))),or(not(number(a)),a>0))\",\n    //176-\n    \"f(x^2*sqrt(-a-3*a^(1/3)*x^4+3*a^(2/3)*x^2+x^6),1/6*x*sqrt((x^2-a^(1/3))^5)+1/24*a^(1/3)*x*sqrt((x^2-a^(1/3))^3)-1/16*a^(2/3)*x*sqrt(x^2-a^(1/3))+1/16*a*log(x+sqrt(x^2-a^(1/3))),or(not(number(a)),a>0))\",\n    //177+\n    \"f(x^3*sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/7*sqrt((x^2+a^(1/3))^7)-1/5*a^(1/3)*sqrt((x^2+a^(1/3))^5),or(not(number(a)),a>0))\",\n    //177-\n    \"f(x^3*sqrt(-a-3*a^(1/3)*x^4+3*a^(2/3)*x^2+x^6),1/7*sqrt((x^2-a^(1/3))^7)+1/5*a^(1/3)*sqrt((x^2-a^(1/3))^5),or(not(number(a)),a>0))\",\n    //196\n    \"f(1/(x-a)/sqrt(x^2-a^2),-sqrt(x^2-a^2)/a/(x-a))\",\n    //197\n    \"f(1/(x+a)/sqrt(x^2-a^2),sqrt(x^2-a^2)/a/(x+a))\",\n    //200+\n    \"f(sqrt(a-x^2),1/2*(x*sqrt(a-x^2)+a*arcsin(x/sqrt(abs(a)))))\",\n    //201    (seems to be handled somewhere else)\n    //202\n    \"f(1/x*1/sqrt(a-x^2),-1/sqrt(a)*log((sqrt(a)+sqrt(a-x^2))/x),or(not(number(a)),a>0))\",\n    //203\n    \"f(sqrt(a-x^2)/x,sqrt(a-x^2)-sqrt(a)*log((sqrt(a)+sqrt(a-x^2))/x),or(not(number(a)),a>0))\",\n    //204\n    \"f(x/sqrt(a-x^2),-sqrt(a-x^2))\",\n    //205\n    \"f(x*sqrt(a-x^2),-1/3*sqrt((a-x^2)^3))\",\n    //210\n    \"f(x^2*sqrt(a-x^2),-x/4*sqrt((a-x^2)^3)+1/8*a*(x*sqrt(a-x^2)+a*arcsin(x/sqrt(a))),or(not(number(a)),a>0))\",\n    //211\n    \"f(x^3*sqrt(a-x^2),(-1/5*x^2-2/15*a)*sqrt((a-x^2)^3),or(not(number(a)),a>0))\",\n    //214\n    \"f(x^2/sqrt(a-x^2),-x/2*sqrt(a-x^2)+a/2*arcsin(x/sqrt(a)),or(not(number(a)),a>0))\",\n    //215\n    \"f(1/x^2*1/sqrt(a-x^2),-sqrt(a-x^2)/a/x,or(not(number(a)),a>0))\",\n    //216\n    \"f(sqrt(a-x^2)/x^2,-sqrt(a-x^2)/x-arcsin(x/sqrt(a)),or(not(number(a)),a>0))\",\n    //217\n    \"f(sqrt(a-x^2)/x^3,-1/2*sqrt(a-x^2)/x^2+1/2*log((sqrt(a)+sqrt(a-x^2))/x)/sqrt(a),or(not(number(a)),a>0))\",\n    //218\n    \"f(sqrt(a-x^2)/x^4,-1/3*sqrt((a-x^2)^3)/a/x^3,or(not(number(a)),a>0))\",\n    // 273\n    \"f(sqrt(a*x^2+b),x*sqrt(a*x^2+b)/2+b*log(x*sqrt(a)+sqrt(a*x^2+b))/2/sqrt(a),and(number(a),a>0))\",\n    // 274\n    \"f(sqrt(a*x^2+b),x*sqrt(a*x^2+b)/2+b*arcsin(x*sqrt(-a/b))/2/sqrt(-a),and(number(a),a<0))\",\n    // 290\n    \"f(sin(a*x),-cos(a*x)/a)\",\n    // 291\n    \"f(cos(a*x),sin(a*x)/a)\",\n    // 292\n    \"f(tan(a*x),-log(cos(a*x))/a)\",\n    // 293\n    \"f(1/tan(a*x),log(sin(a*x))/a)\",\n    // 294\n    \"f(1/cos(a*x),log(tan(pi/4+a*x/2))/a)\",\n    // 295\n    \"f(1/sin(a*x),log(tan(a*x/2))/a)\",\n    // 296\n    \"f(sin(a*x)^2,x/2-sin(2*a*x)/(4*a))\",\n    // 297\n    \"f(sin(a*x)^3,-cos(a*x)*(sin(a*x)^2+2)/(3*a))\",\n    // 298\n    \"f(sin(a*x)^4,3/8*x-sin(2*a*x)/(4*a)+sin(4*a*x)/(32*a))\",\n    // 302\n    \"f(cos(a*x)^2,x/2+sin(2*a*x)/(4*a))\",\n    // 303\n    \"f(cos(a*x)^3,sin(a*x)*(cos(a*x)^2+2)/(3*a))\",\n    // 304\n    \"f(cos(a*x)^4,3/8*x+sin(2*a*x)/(4*a)+sin(4*a*x)/(32*a))\",\n    // 308\n    \"f(1/sin(a*x)^2,-1/(a*tan(a*x)))\",\n    // 312\n    \"f(1/cos(a*x)^2,tan(a*x)/a)\",\n    // 318\n    \"f(sin(a*x)*cos(a*x),sin(a*x)^2/(2*a))\",\n    // 320\n    \"f(sin(a*x)^2*cos(a*x)^2,-sin(4*a*x)/(32*a)+x/8)\",\n    // 326\n    \"f(sin(a*x)/cos(a*x)^2,1/(a*cos(a*x)))\",\n    // 327\n    \"f(sin(a*x)^2/cos(a*x),(log(tan(pi/4+a*x/2))-sin(a*x))/a)\",\n    // 328\n    \"f(cos(a*x)/sin(a*x)^2,-1/(a*sin(a*x)))\",\n    // 329\n    \"f(1/(sin(a*x)*cos(a*x)),log(tan(a*x))/a)\",\n    // 330\n    \"f(1/(sin(a*x)*cos(a*x)^2),(1/cos(a*x)+log(tan(a*x/2)))/a)\",\n    // 331\n    \"f(1/(sin(a*x)^2*cos(a*x)),(log(tan(pi/4+a*x/2))-1/sin(a*x))/a)\",\n    // 333\n    \"f(1/(sin(a*x)^2*cos(a*x)^2),-2/(a*tan(2*a*x)))\",\n    // 335\n    \"f(sin(a+b*x),-cos(a+b*x)/b)\",\n    // 336\n    \"f(cos(a+b*x),sin(a+b*x)/b)\",\n    // 337+ (with the addition of b)\n    \"f(1/(b+b*sin(a*x)),-tan(pi/4-a*x/2)/a/b)\",\n    // 337- (with the addition of b)\n    \"f(1/(b-b*sin(a*x)),tan(pi/4+a*x/2)/a/b)\",\n    // 338 (with the addition of b)\n    \"f(1/(b+b*cos(a*x)),tan(a*x/2)/a/b)\",\n    // 339 (with the addition of b)\n    \"f(1/(b-b*cos(a*x)),-1/tan(a*x/2)/a/b)\",\n    // 340\n    \"f(1/(a+b*sin(x)),1/sqrt(b^2-a^2)*log((a*tan(x/2)+b-sqrt(b^2-a^2))/(a*tan(x/2)+b+sqrt(b^2-a^2))),b^2-a^2)\", // check that b^2-a^2 is not zero\n    // 341\n    \"f(1/(a+b*cos(x)),1/sqrt(b^2-a^2)*log((sqrt(b^2-a^2)*tan(x/2)+a+b)/(sqrt(b^2-a^2)*tan(x/2)-a-b)),b^2-a^2)\", // check that b^2-a^2 is not zero\n    // 389\n    \"f(x*sin(a*x),sin(a*x)/a^2-x*cos(a*x)/a)\",\n    // 390\n    \"f(x^2*sin(a*x),2*x*sin(a*x)/a^2-(a^2*x^2-2)*cos(a*x)/a^3)\",\n    // 393\n    \"f(x*cos(a*x),cos(a*x)/a^2+x*sin(a*x)/a)\",\n    // 394\n    \"f(x^2*cos(a*x),2*x*cos(a*x)/a^2+(a^2*x^2-2)*sin(a*x)/a^3)\",\n    // 441\n    \"f(arcsin(a*x),x*arcsin(a*x)+sqrt(1-a^2*x^2)/a)\",\n    // 442\n    \"f(arccos(a*x),x*arccos(a*x)-sqrt(1-a^2*x^2)/a)\",\n    // 443\n    \"f(arctan(a*x),x*arctan(a*x)-1/2*log(1+a^2*x^2)/a)\",\n    // 485 (with addition of a)\n    // however commenting out since it's a duplicate of 14\n    // \"f(log(a*x),x*log(a*x)-x)\",\n    // 486 (with addition of a)\n    \"f(x*log(a*x),x^2*log(a*x)/2-x^2/4)\",\n    // 487 (with addition of a)\n    \"f(x^2*log(a*x),x^3*log(a*x)/3-1/9*x^3)\",\n    // 489\n    \"f(log(x)^2,x*log(x)^2-2*x*log(x)+2*x)\",\n    // 493 (with addition of a)\n    \"f(1/x*1/(a+log(x)),log(a+log(x)))\",\n    // 499\n    \"f(log(a*x+b),(a*x+b)*log(a*x+b)/a-x)\",\n    // 500\n    \"f(log(a*x+b)/x^2,a/b*log(x)-(a*x+b)*log(a*x+b)/b/x)\",\n    // 554\n    \"f(sinh(x),cosh(x))\",\n    // 555\n    \"f(cosh(x),sinh(x))\",\n    // 556\n    \"f(tanh(x),log(cosh(x)))\",\n    // 560\n    \"f(x*sinh(x),x*cosh(x)-sinh(x))\",\n    // 562\n    \"f(x*cosh(x),x*sinh(x)-cosh(x))\",\n    // 566\n    \"f(sinh(x)^2,sinh(2*x)/4-x/2)\",\n    // 569\n    \"f(tanh(x)^2,x-tanh(x))\",\n    // 572\n    \"f(cosh(x)^2,sinh(2*x)/4+x/2)\",\n    // ?\n    \"f(x^3*exp(a*x^2),exp(a*x^2)*(x^2/a-1/(a^2))/2)\",\n    // ?\n    \"f(x^3*exp(a*x^2+b),exp(a*x^2)*exp(b)*(x^2/a-1/(a^2))/2)\",\n    // ?\n    \"f(exp(a*x^2),-i*sqrt(pi)*erf(i*sqrt(a)*x)/sqrt(a)/2)\",\n    // ?\n    \"f(erf(a*x),x*erf(a*x)+exp(-a^2*x^2)/a/sqrt(pi))\",\n    // these are needed for the surface integral in the manual\n    \"f(x^2*(1-x^2)^(3/2),(x*sqrt(1-x^2)*(-8*x^4+14*x^2-3)+3*arcsin(x))/48)\",\n    \"f(x^2*(1-x^2)^(5/2),(x*sqrt(1-x^2)*(48*x^6-136*x^4+118*x^2-15)+15*arcsin(x))/384)\",\n    \"f(x^4*(1-x^2)^(3/2),(-x*sqrt(1-x^2)*(16*x^6-24*x^4+2*x^2+3)+3*arcsin(x))/128)\",\n    \"f(x*exp(a*x),exp(a*x)*(a*x-1)/(a^2))\",\n    \"f(x*exp(a*x+b),exp(a*x+b)*(a*x-1)/(a^2))\",\n    \"f(x^2*exp(a*x),exp(a*x)*(a^2*x^2-2*a*x+2)/(a^3))\",\n    \"f(x^2*exp(a*x+b),exp(a*x+b)*(a^2*x^2-2*a*x+2)/(a^3))\",\n    \"f(x^3*exp(a*x),exp(a*x)*x^3/a-3/a*integral(x^2*exp(a*x),x))\",\n    \"f(x^3*exp(a*x+b),exp(a*x+b)*x^3/a-3/a*integral(x^2*exp(a*x+b),x))\",\n    0\n  ];\n\n  //define F p3\n  //define X p4\n  //define N p5\n  Eval_integral = function() {\n    var doNothing, i, i1, n, o, ref, ref1;\n    i = 0;\n    n = 0;\n    // evaluate 1st arg to get function F\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    // evaluate 2nd arg and then...\n\n    // example    result of 2nd arg  what to do\n\n    // integral(f)    nil      guess X, N = nil\n    // integral(f,2)  2      guess X, N = 2\n    // integral(f,x)  x      X = x, N = nil\n    // integral(f,x,2)  x      X = x, N = 2\n    // integral(f,x,y)  x      X = x, N = y\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p2 = pop();\n    if (p2 === symbol(NIL)) {\n      guess();\n      push(symbol(NIL));\n    } else if (isNumericAtom(p2)) {\n      guess();\n      push(p2);\n    } else {\n      push(p2);\n      p1 = cdr(p1);\n      push(car(p1));\n      Eval();\n    }\n    p5 = pop();\n    p4 = pop();\n    p3 = pop();\n    while (1) {\n      // N might be a symbol instead of a number\n      if (isNumericAtom(p5)) {\n        push(p5);\n        n = pop_integer();\n        if (isNaN(n)) {\n          stop(\"nth integral: check n\");\n        }\n      } else {\n        n = 1;\n      }\n      push(p3);\n      if (n >= 0) {\n        for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n          push(p4);\n          integral();\n        }\n      } else {\n        n = -n;\n        for (i = i1 = 0, ref1 = n; (0 <= ref1 ? i1 < ref1 : i1 > ref1); i = 0 <= ref1 ? ++i1 : --i1) {\n          push(p4);\n          derivative();\n        }\n      }\n      p3 = pop();\n      // if N is nil then arglist is exhausted\n      if (p5 === symbol(NIL)) {\n        break;\n      }\n      // otherwise...\n\n      // N    arg1    what to do\n\n      // number  nil    break\n      // number  number    N = arg1, continue\n      // number  symbol    X = arg1, N = arg2, continue\n\n      // symbol  nil    X = N, N = nil, continue\n      // symbol  number    X = N, N = arg1, continue\n      // symbol  symbol    X = N, N = arg1, continue\n      if (isNumericAtom(p5)) {\n        p1 = cdr(p1);\n        push(car(p1));\n        Eval();\n        p5 = pop();\n        if (p5 === symbol(NIL)) {\n          break; // arglist exhausted\n        }\n        if (isNumericAtom(p5)) {\n          doNothing = 1; // N = arg1\n        } else {\n          p4 = p5;\n          p1 = cdr(p1);\n          push(car(p1));\n          Eval();\n          p5 = pop(); // N = arg2\n        }\n      } else {\n        p4 = p5;\n        p1 = cdr(p1);\n        push(car(p1));\n        Eval();\n        p5 = pop(); // N = arg1\n      }\n    }\n    return push(p3); // final result\n  };\n\n  integral = function() {\n    save();\n    p2 = pop();\n    p1 = pop();\n    if (car(p1) === symbol(ADD)) {\n      integral_of_sum();\n    } else if (car(p1) === symbol(MULTIPLY)) {\n      integral_of_product();\n    } else {\n      integral_of_form();\n    }\n    p1 = pop();\n    if (Find(p1, symbol(INTEGRAL))) {\n      stop(\"integral: sorry, could not find a solution\");\n    }\n    push(p1);\n    simplify();\n    Eval();\n    return restore();\n  };\n\n  integral_of_sum = function() {\n    var results;\n    p1 = cdr(p1);\n    push(car(p1));\n    push(p2);\n    integral();\n    p1 = cdr(p1);\n    results = [];\n    while (iscons(p1)) {\n      push(car(p1));\n      push(p2);\n      integral();\n      add();\n      results.push(p1 = cdr(p1));\n    }\n    return results;\n  };\n\n  integral_of_product = function() {\n    push(p1);\n    push(p2);\n    partition();\n    p1 = pop();\n    integral_of_form();\n    return multiply(); // multiply constant part\n  };\n\n  integral_of_form = function() {\n    var hc, tab;\n    hc = italu_hashcode(p1, p2).toFixed(6);\n    tab = hashed_itab[hc];\n    if (!tab) {\n      // debugger\n      // italu_hashcode(p1, p2)\n      push_symbol(INTEGRAL);\n      push(p1);\n      push(p2);\n      list(3);\n      return;\n    }\n    push(p1); // free variable\n    push(p2); // input expression\n    transform(tab, false);\n    p3 = pop();\n    if (p3 === symbol(NIL)) {\n      push_symbol(INTEGRAL);\n      push(p1);\n      push(p2);\n      return list(3);\n    } else {\n      return push(p3);\n    }\n  };\n\n  // Implementation of hash codes based on ITALU (An Integral Table Look-Up)\n  // https://ntrs.nasa.gov/archive/nasa/casi.ntrs.nasa.gov/19680004891.pdf\n  // see Appendix A, page 153\n\n  // The first two values are from the ITALU paper.\n  // The others are just arbitrary constants.\n  hashcode_values = {\n    'x': 0.95532,\n    'constexp': 1.43762,\n    'constant': 1.14416593629414332,\n    'constbase': 1.20364122304218824,\n    'sin': 1.73305482518303221,\n    'arcsin': 1.6483368529465804,\n    'cos': 1.058672123686340116,\n    'arccos': 1.8405225918106694,\n    'tan': 1.12249437762925064,\n    'arctan': 1.1297397925394962,\n    'sinh': 1.8176164926060078,\n    'cosh': 1.9404934661708022,\n    'tanh': 1.6421307715103121,\n    'log': 1.47744370135492387,\n    'erf': 1.0825269225702916\n  };\n\n  italu_hashcode = function(u, x) {\n    var half;\n    if (issymbol(u)) {\n      if (equal(u, x)) {\n        return hashcode_values.x;\n      } else {\n        return hashcode_values.constant;\n      }\n    } else if (iscons(u)) {\n      switch (symnum(car(u))) {\n        case ADD:\n          return hash_addition(cdr(u), x);\n        case MULTIPLY:\n          return hash_multiplication(cdr(u), x);\n        case POWER:\n          return hash_power(cadr(u), caddr(u), x);\n        case EXP:\n          return hash_power(symbol(E), cadr(u), x);\n        case SQRT:\n          push_double(0.5);\n          half = pop();\n          return hash_power(cadr(u), half, x);\n        default:\n          return hash_function(u, x);\n      }\n    }\n    return hashcode_values.constant;\n  };\n\n  hash_function = function(u, x) {\n    var arg_hash, base, name;\n    if (!Find(cadr(u), x)) {\n      return hashcode_values.constant;\n    }\n    name = car(u);\n    arg_hash = italu_hashcode(cadr(u), x);\n    base = hashcode_values[name.printname];\n    if (!base) {\n      throw new Error('Unsupported function ' + name.printname);\n    }\n    return Math.pow(base, arg_hash);\n  };\n\n  hash_addition = function(terms, x) {\n    var k, sum, term, term_hash, term_set, v;\n    term_set = {};\n    while (iscons(terms)) {\n      term = car(terms);\n      terms = cdr(terms);\n      term_hash = 0;\n      if (Find(term, x)) {\n        term_hash = italu_hashcode(term, x);\n      } else {\n        // The original algorithm would skip this,\n        // but recording that it was present helps\n        // prevent collisions.\n        term_hash = hashcode_values.constant;\n      }\n      term_set[term_hash.toFixed(6)] = true;\n    }\n    sum = 0;\n    for (k in term_set) {\n      if (!hasProp.call(term_set, k)) continue;\n      v = term_set[k];\n      sum = sum + parseFloat(k, 10);\n    }\n    return sum;\n  };\n\n  hash_multiplication = function(terms, x) {\n    var product, term;\n    product = 1;\n    while (iscons(terms)) {\n      term = car(terms);\n      terms = cdr(terms);\n      if (Find(term, x)) {\n        product = product * italu_hashcode(term, x);\n      }\n    }\n    return product;\n  };\n\n  hash_power = function(base, power, x) {\n    var base_hash, exp_hash;\n    base_hash = hashcode_values.constant;\n    exp_hash = hashcode_values.constexp;\n    if (Find(base, x)) {\n      base_hash = italu_hashcode(base, x);\n    }\n    if (Find(power, x)) {\n      exp_hash = italu_hashcode(power, x);\n    } else {\n      // constant to constant = constant\n      if (base_hash === hashcode_values.constant) {\n        return hashcode_values.constant;\n      }\n      if (isminusone(power)) {\n        exp_hash = -1;\n      } else if (isoneovertwo(power)) {\n        exp_hash = 0.5;\n      } else if (isminusoneovertwo(power)) {\n        exp_hash = -0.5;\n      } else if (equalq(power, 2, 1)) {\n        exp_hash = 2;\n      } else if (equalq(power, -2, 1)) {\n        exp_hash = -2;\n      }\n    }\n    return Math.pow(base_hash, exp_hash);\n  };\n\n  make_hashed_itab = function() {\n    var f, h, key, len, o, s, tab, u;\n    tab = {};\n    for (o = 0, len = itab.length; o < len; o++) {\n      s = itab[o];\n      if (!s) {\n        break;\n      }\n      scan_meta(s);\n      f = pop();\n      u = cadr(f);\n      h = italu_hashcode(u, symbol(METAX));\n      key = h.toFixed(6);\n      if (!tab[key]) {\n        tab[key] = [];\n      }\n      tab[key].push(s);\n    }\n    console.log('hashed_itab = ' + JSON.stringify(tab, null, 2));\n    return tab;\n  };\n\n  $.make_hashed_itab = make_hashed_itab;\n\n  // pre-calculated hashed integral table.\n  // in case the integral table is changed, use this\n  //   Algebrite.make_hashed_itab()\n  // and copy the resulting JSON in here.\n  hashed_itab = {\n    \"1.144166\": [\"f(a,a*x)\"],\n    \"1.046770\": [\"f(1/x,log(x))\"],\n    \"0.936400\": [\"f(x^a,x^(a+1)/(a+1))\"],\n    \"1.095727\": [\"f(x^(-2),-x^(-1))\"],\n    \"1.023118\": [\"f(x^(-1/2),2*x^(1/2))\"],\n    \"0.977405\": [\"f(x^(1/2),2/3*x^(3/2))\"],\n    \"0.955320\": [\"f(x,x^2/2)\"],\n    \"0.912636\": [\"f(x^2,x^3/3)\"],\n    \"1.137302\": [\"f(exp(a*x),1/a*exp(a*x))\", \"f(a^x,a^x/log(a),or(not(number(a)),a>0))\"],\n    \"1.326774\": [\"f(exp(a*x+b),1/a*exp(a*x+b))\"],\n    \"1.080259\": [\"f(x*exp(a*x^2),exp(a*x^2)/(2*a))\"],\n    \"1.260228\": [\"f(x*exp(a*x^2+b),exp(a*x^2+b)/(2*a))\"],\n    \"1.451902\": [\"f(log(a*x),x*log(a*x)-x)\"],\n    \"0.486192\": [\"f(1/(a+x^2),1/sqrt(a)*arctan(x/sqrt(a)),or(not(number(a)),a>0))\", \"f(1/(a-x^2),1/sqrt(a)*arctanh(x/sqrt(a)))\", \"f(1/(a+b*x^2),1/sqrt(a*b)*arctan(x*sqrt(a*b)/a),or(not(number(a*b)),a*b>0))\", \"f(1/(a+b*x^2),1/(2*sqrt(-a*b))*log((a+x*sqrt(-a*b))/(a-x*sqrt(-a*b))),or(not(number(a*b)),a*b<0))\"],\n    \"0.697274\": [\"f(1/sqrt(a-x^2),arcsin(x/(sqrt(a))))\", \"f(1/sqrt(a+x^2),log(x+sqrt(a+x^2)))\", \"f(1/sqrt(x^2+a),log(x+sqrt(x^2+a)))\"],\n    \"0.476307\": [\"f(1/(a+b*x),1/b*log(a+b*x))\"],\n    \"0.226868\": [\"f(1/(a+b*x)^2,-1/(b*(a+b*x)))\"],\n    \"2.904531\": [\"f(1/(a+b*x)^3,-1/(2*b)*1/(a+b*x)^2)\"],\n    \"0.455026\": [\"f(x/(a+b*x),x/b-a*log(a+b*x)/b/b)\"],\n    \"0.216732\": [\"f(x/(a+b*x)^2,1/b^2*(log(a+b*x)+a/(a+b*x)))\"],\n    \"0.434695\": [\"f(x^2/(a+b*x),1/b^2*(1/2*(a+b*x)^2-2*a*(a+b*x)+a^2*log(a+b*x)))\"],\n    \"0.207048\": [\"f(x^2/(a+b*x)^2,1/b^3*(a+b*x-2*a*log(a+b*x)-a^2/(a+b*x)))\"],\n    \"2.650781\": [\"f(x^2/(a+b*x)^3,1/b^3*(log(a+b*x)+2*a/(a+b*x)-1/2*a^2/(a+b*x)^2))\"],\n    \"0.498584\": [\"f(1/x*1/(a+b*x),-1/a*log((a+b*x)/x))\"],\n    \"0.237479\": [\"f(1/x*1/(a+b*x)^2,1/a*1/(a+b*x)-1/a^2*log((a+b*x)/x))\"],\n    \"3.040375\": [\"f(1/x*1/(a+b*x)^3,1/a^3*(1/2*((2*a+b*x)/(a+b*x))^2+log(x/(a+b*x))))\"],\n    \"0.521902\": [\"f(1/x^2*1/(a+b*x),-1/(a*x)+b/a^2*log((a+b*x)/x))\"],\n    \"0.446014\": [\"f(1/x^3*1/(a+b*x),(2*b*x-a)/(2*a^2*x^2)+b^2/a^3*log(x/(a+b*x)))\"],\n    \"0.248586\": [\"f(1/x^2*1/(a+b*x)^2,-(a+2*b*x)/(a^2*x*(a+b*x))+2*b/a^3*log((a+b*x)/x))\"],\n    \"0.464469\": [\"f(x/(a+b*x^2),1/2*1/b*log(a+b*x^2))\"],\n    \"0.443716\": [\"f(x^2/(a+b*x^2),x/b-a/b*integral(1/(a+b*x^2),x))\"],\n    \"0.236382\": [\"f(1/(a+b*x^2)^2,x/(2*a*(a+b*x^2))+1/2*1/a*integral(1/(a+b*x^2),x))\"],\n    \"0.508931\": [\"f(1/x*1/(a+b*x^2),1/2*1/a*log(x^2/(a+b*x^2)))\"],\n    \"0.532733\": [\"f(1/x^2*1/(a+b*x^2),-1/(a*x)-b/a*integral(1/(a+b*x^2),x))\"],\n    \"0.480638\": [\"f(1/(a+b*x^3),1/3*1/a*(a/b)^(1/3)*(1/2*log(((a/b)^(1/3)+x)^3/(a+b*x^3))+sqrt(3)*arctan((2*x-(a/b)^(1/3))*(a/b)^(-1/3)/sqrt(3))))\"],\n    \"0.438648\": [\"f(x^2/(a+b*x^3),1/3*1/b*log(a+b*x^3))\"],\n    \"0.459164\": [\"f(x/(a+b*x^4),1/2*sqrt(b/a)/b*arctan(x^2*sqrt(b/a)),or(not(number(a*b)),a*b>0))\", \"f(x/(a+b*x^4),1/4*sqrt(-b/a)/b*log((x^2-sqrt(-a/b))/(x^2+sqrt(-a/b))),or(not(number(a*b)),a*b<0))\"],\n    \"0.450070\": [\"f(x^3/(a+b*x^4),1/4*1/b*log(a+b*x^4))\"],\n    \"1.448960\": [\"f(sqrt(a+b*x),2/3*1/b*sqrt((a+b*x)^3))\"],\n    \"1.384221\": [\"f(x*sqrt(a+b*x),-2*(2*a-3*b*x)*sqrt((a+b*x)^3)/15/b^2)\"],\n    \"1.322374\": [\"f(x^2*sqrt(a+b*x),2*(8*a^2-12*a*b*x+15*b^2*x^2)*sqrt((a+b*x)^3)/105/b^3)\"],\n    \"1.516728\": [\"f(sqrt(a+b*x)/x,2*sqrt(a+b*x)+a*integral(1/x*1/sqrt(a+b*x),x))\"],\n    \"1.587665\": [\"f(sqrt(a+b*x)/x^2,-sqrt(a+b*x)/x+b/2*integral(1/x*1/sqrt(a+b*x),x))\"],\n    \"0.690150\": [\"f(1/sqrt(a+b*x),2*sqrt(a+b*x)/b)\"],\n    \"0.659314\": [\"f(x/sqrt(a+b*x),-2/3*(2*a-b*x)*sqrt(a+b*x)/b^2)\"],\n    \"0.629856\": [\"f(x^2/sqrt(a+b*x),2/15*(8*a^2-4*a*b*x+3*b^2*x^2)*sqrt(a+b*x)/b^3)\"],\n    \"0.722428\": [\"f(1/x*1/sqrt(a+b*x),1/sqrt(a)*log((sqrt(a+b*x)-sqrt(a))/(sqrt(a+b*x)+sqrt(a))),or(not(number(a)),a>0))\", \"f(1/x*1/sqrt(a+b*x),2/sqrt(-a)*arctan(sqrt(-(a+b*x)/a)),or(not(number(a)),a<0))\"],\n    \"0.756216\": [\"f(1/x^2*1/sqrt(a+b*x),-sqrt(a+b*x)/a/x-1/2*b/a*integral(1/x*1/sqrt(a+b*x),x))\"],\n    \"1.434156\": [\"f(sqrt(x^2+a),1/2*(x*sqrt(x^2+a)+a*log(x+sqrt(x^2+a))))\", \"f(sqrt(a-x^2),1/2*(x*sqrt(a-x^2)+a*arcsin(x/sqrt(abs(a)))))\", \"f(sqrt(a*x^2+b),x*sqrt(a*x^2+b)/2+b*log(x*sqrt(a)+sqrt(a*x^2+b))/2/sqrt(a),and(number(a),a>0))\", \"f(sqrt(a*x^2+b),x*sqrt(a*x^2+b)/2+b*arcsin(x*sqrt(-a/b))/2/sqrt(-a),and(number(a),a<0))\"],\n    \"0.729886\": [\"f(1/x*1/sqrt(x^2+a),arcsec(x/sqrt(-a))/sqrt(-a),or(not(number(a)),a<0))\", \"f(1/x*1/sqrt(x^2+a),-1/sqrt(a)*log((sqrt(a)+sqrt(x^2+a))/x),or(not(number(a)),a>0))\", \"f(1/x*1/sqrt(a-x^2),-1/sqrt(a)*log((sqrt(a)+sqrt(a-x^2))/x),or(not(number(a)),a>0))\"],\n    \"1.501230\": [\"f(sqrt(x^2+a)/x,sqrt(x^2+a)-sqrt(a)*log((sqrt(a)+sqrt(x^2+a))/x),or(not(number(a)),a>0))\", \"f(sqrt(x^2+a)/x,sqrt(x^2+a)-sqrt(-a)*arcsec(x/sqrt(-a)),or(not(number(a)),a<0))\", \"f(sqrt(a-x^2)/x,sqrt(a-x^2)-sqrt(a)*log((sqrt(a)+sqrt(a-x^2))/x),or(not(number(a)),a>0))\"],\n    \"0.666120\": [\"f(x/sqrt(x^2+a),sqrt(x^2+a))\", \"f(x/sqrt(a-x^2),-sqrt(a-x^2))\"],\n    \"1.370077\": [\"f(x*sqrt(x^2+a),1/3*sqrt((x^2+a)^3))\", \"f(x*sqrt(a-x^2),-1/3*sqrt((a-x^2)^3))\"],\n    \"1.730087\": [\"f(sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/4*(x*sqrt((x^2+a^(1/3))^3)+3/2*a^(1/3)*x*sqrt(x^2+a^(1/3))+3/2*a^(2/3)*log(x+sqrt(x^2+a^(1/3)))))\", \"f(sqrt(-a+x^6-3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/4*(x*sqrt((x^2-a^(1/3))^3)-3/2*a^(1/3)*x*sqrt(x^2-a^(1/3))+3/2*a^(2/3)*log(x+sqrt(x^2-a^(1/3)))))\"],\n    \"0.578006\": [\"f(1/sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),x/a^(1/3)/sqrt(x^2+a^(1/3)))\"],\n    \"0.552180\": [\"f(x/sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),-1/sqrt(x^2+a^(1/3)))\"],\n    \"1.652787\": [\"f(x*sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/5*sqrt((x^2+a^(1/3))^5))\"],\n    \"1.308862\": [\"f(x^2*sqrt(x^2+a),1/4*x*sqrt((x^2+a)^3)-1/8*a*x*sqrt(x^2+a)-1/8*a^2*log(x+sqrt(x^2+a)))\", \"f(x^2*sqrt(a-x^2),-x/4*sqrt((a-x^2)^3)+1/8*a*(x*sqrt(a-x^2)+a*arcsin(x/sqrt(a))),or(not(number(a)),a>0))\"],\n    \"1.342944\": [\"f(x^3*sqrt(x^2+a),(1/5*x^2-2/15*a)*sqrt((x^2+a)^3),and(number(a),a>0))\", \"f(x^3*sqrt(x^2+a),sqrt((x^2+a)^5)/5-a*sqrt((x^2+a)^3)/3,and(number(a),a<0))\", \"f(x^3*sqrt(a-x^2),(-1/5*x^2-2/15*a)*sqrt((a-x^2)^3),or(not(number(a)),a>0))\", \"f(sqrt(a-x^2)/x^3,-1/2*sqrt(a-x^2)/x^2+1/2*log((sqrt(a)+sqrt(a-x^2))/x)/sqrt(a),or(not(number(a)),a>0))\", \"f(sqrt(a-x^2)/x^4,-1/3*sqrt((a-x^2)^3)/a/x^3,or(not(number(a)),a>0))\"],\n    \"0.636358\": [\"f(x^2/sqrt(x^2+a),1/2*x*sqrt(x^2+a)-1/2*a*log(x+sqrt(x^2+a)))\", \"f(x^2/sqrt(a-x^2),-x/2*sqrt(a-x^2)+a/2*arcsin(x/sqrt(a)),or(not(number(a)),a>0))\"],\n    \"0.652928\": [\"f(x^3/sqrt(x^2+a),1/3*sqrt((x^2+a)^3)-a*sqrt(x^2+a))\", \"f(1/x^3*1/sqrt(x^2+a),-1/2*sqrt(x^2+a)/a/x^2+1/2*log((sqrt(a)+sqrt(x^2+a))/x)/a^(3/2),or(not(number(a)),a>0))\", \"f(1/x^3*1/sqrt(x^2-a),1/2*sqrt(x^2-a)/a/x^2+1/2*1/(a^(3/2))*arcsec(x/(a^(1/2))),or(not(number(a)),a>0))\"],\n    \"0.764022\": [\"f(1/x^2*1/sqrt(x^2+a),-sqrt(x^2+a)/a/x)\", \"f(1/x^2*1/sqrt(a-x^2),-sqrt(a-x^2)/a/x,or(not(number(a)),a>0))\"],\n    \"1.578940\": [\"f(x^2*sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/6*x*sqrt((x^2+a^(1/3))^5)-1/24*a^(1/3)*x*sqrt((x^2+a^(1/3))^3)-1/16*a^(2/3)*x*sqrt(x^2+a^(1/3))-1/16*a*log(x+sqrt(x^2+a^(1/3))),or(not(number(a)),a>0))\", \"f(x^2*sqrt(-a-3*a^(1/3)*x^4+3*a^(2/3)*x^2+x^6),1/6*x*sqrt((x^2-a^(1/3))^5)+1/24*a^(1/3)*x*sqrt((x^2-a^(1/3))^3)-1/16*a^(2/3)*x*sqrt(x^2-a^(1/3))+1/16*a*log(x+sqrt(x^2-a^(1/3))),or(not(number(a)),a>0))\"],\n    \"1.620055\": [\"f(x^3*sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/7*sqrt((x^2+a^(1/3))^7)-1/5*a^(1/3)*sqrt((x^2+a^(1/3))^5),or(not(number(a)),a>0))\", \"f(x^3*sqrt(-a-3*a^(1/3)*x^4+3*a^(2/3)*x^2+x^6),1/7*sqrt((x^2-a^(1/3))^7)+1/5*a^(1/3)*sqrt((x^2-a^(1/3))^5),or(not(number(a)),a>0))\"],\n    \"0.332117\": [\"f(1/(x-a)/sqrt(x^2-a^2),-sqrt(x^2-a^2)/a/(x-a))\", \"f(1/(x+a)/sqrt(x^2-a^2),sqrt(x^2-a^2)/a/(x+a))\"],\n    \"1.571443\": [\"f(sqrt(a-x^2)/x^2,-sqrt(a-x^2)/x-arcsin(x/sqrt(a)),or(not(number(a)),a>0))\"],\n    \"1.690994\": [\"f(sin(a*x),-cos(a*x)/a)\"],\n    \"1.055979\": [\"f(cos(a*x),sin(a*x)/a)\"],\n    \"1.116714\": [\"f(tan(a*x),-log(cos(a*x))/a)\"],\n    \"0.895484\": [\"f(1/tan(a*x),log(sin(a*x))/a)\"],\n    \"0.946989\": [\"f(1/cos(a*x),log(tan(pi/4+a*x/2))/a)\"],\n    \"0.591368\": [\"f(1/sin(a*x),log(tan(a*x/2))/a)\"],\n    \"2.859462\": [\"f(sin(a*x)^2,x/2-sin(2*a*x)/(4*a))\"],\n    \"2.128050\": [\"f(sin(a*x)^3,-cos(a*x)*(sin(a*x)^2+2)/(3*a))\", \"f(sin(a*x)^4,3/8*x-sin(2*a*x)/(4*a)+sin(4*a*x)/(32*a))\"],\n    \"1.115091\": [\"f(cos(a*x)^2,x/2+sin(2*a*x)/(4*a))\"],\n    \"1.081452\": [\"f(cos(a*x)^3,sin(a*x)*(cos(a*x)^2+2)/(3*a))\", \"f(cos(a*x)^4,3/8*x+sin(2*a*x)/(4*a)+sin(4*a*x)/(32*a))\"],\n    \"0.349716\": [\"f(1/sin(a*x)^2,-1/(a*tan(a*x)))\"],\n    \"0.896788\": [\"f(1/cos(a*x)^2,tan(a*x)/a)\"],\n    \"1.785654\": [\"f(sin(a*x)*cos(a*x),sin(a*x)^2/(2*a))\"],\n    \"3.188560\": [\"f(sin(a*x)^2*cos(a*x)^2,-sin(4*a*x)/(32*a)+x/8)\"],\n    \"1.516463\": [\"f(sin(a*x)/cos(a*x)^2,1/(a*cos(a*x)))\"],\n    \"2.707879\": [\"f(sin(a*x)^2/cos(a*x),(log(tan(pi/4+a*x/2))-sin(a*x))/a)\"],\n    \"0.369293\": [\"f(cos(a*x)/sin(a*x)^2,-1/(a*sin(a*x)))\"],\n    \"0.560019\": [\"f(1/(sin(a*x)*cos(a*x)),log(tan(a*x))/a)\"],\n    \"0.530332\": [\"f(1/(sin(a*x)*cos(a*x)^2),(1/cos(a*x)+log(tan(a*x/2)))/a)\"],\n    \"0.331177\": [\"f(1/(sin(a*x)^2*cos(a*x)),(log(tan(pi/4+a*x/2))-1/sin(a*x))/a)\"],\n    \"0.313621\": [\"f(1/(sin(a*x)^2*cos(a*x)^2),-2/(a*tan(2*a*x)))\"],\n    \"3.172365\": [\"f(sin(a+b*x),-cos(a+b*x)/b)\"],\n    \"1.127162\": [\"f(cos(a+b*x),sin(a+b*x)/b)\"],\n    \"0.352714\": [\"f(1/(b+b*sin(a*x)),-tan(pi/4-a*x/2)/a/b)\", \"f(1/(b-b*sin(a*x)),tan(pi/4+a*x/2)/a/b)\", \"f(1/(a+b*sin(x)),1/sqrt(b^2-a^2)*log((a*tan(x/2)+b-sqrt(b^2-a^2))/(a*tan(x/2)+b+sqrt(b^2-a^2))),b^2-a^2)\"],\n    \"0.454515\": [\"f(1/(b+b*cos(a*x)),tan(a*x/2)/a/b)\", \"f(1/(b-b*cos(a*x)),-1/tan(a*x/2)/a/b)\", \"f(1/(a+b*cos(x)),1/sqrt(b^2-a^2)*log((sqrt(b^2-a^2)*tan(x/2)+a+b)/(sqrt(b^2-a^2)*tan(x/2)-a-b)),b^2-a^2)\"],\n    \"1.615441\": [\"f(x*sin(a*x),sin(a*x)/a^2-x*cos(a*x)/a)\"],\n    \"1.543263\": [\"f(x^2*sin(a*x),2*x*sin(a*x)/a^2-(a^2*x^2-2)*cos(a*x)/a^3)\"],\n    \"1.008798\": [\"f(x*cos(a*x),cos(a*x)/a^2+x*sin(a*x)/a)\"],\n    \"0.963724\": [\"f(x^2*cos(a*x),2*x*cos(a*x)/a^2+(a^2*x^2-2)*sin(a*x)/a^3)\"],\n    \"1.611938\": [\"f(arcsin(a*x),x*arcsin(a*x)+sqrt(1-a^2*x^2)/a)\"],\n    \"1.791033\": [\"f(arccos(a*x),x*arccos(a*x)-sqrt(1-a^2*x^2)/a)\"],\n    \"1.123599\": [\"f(arctan(a*x),x*arctan(a*x)-1/2*log(1+a^2*x^2)/a)\"],\n    \"1.387031\": [\"f(x*log(a*x),x^2*log(a*x)/2-x^2/4)\"],\n    \"1.325058\": [\"f(x^2*log(a*x),x^3*log(a*x)/3-1/9*x^3)\"],\n    \"2.108018\": [\"f(log(x)^2,x*log(x)^2-2*x*log(x)+2*x)\"],\n    \"0.403214\": [\"f(1/x*1/(a+log(x)),log(a+log(x)))\"],\n    \"2.269268\": [\"f(log(a*x+b),(a*x+b)*log(a*x+b)/a-x)\"],\n    \"2.486498\": [\"f(log(a*x+b)/x^2,a/b*log(x)-(a*x+b)*log(a*x+b)/b/x)\"],\n    \"1.769733\": [\"f(sinh(x),cosh(x))\"],\n    \"1.883858\": [\"f(cosh(x),sinh(x))\"],\n    \"1.606140\": [\"f(tanh(x),log(cosh(x)))\"],\n    \"1.690661\": [\"f(x*sinh(x),x*cosh(x)-sinh(x))\"],\n    \"1.799688\": [\"f(x*cosh(x),x*sinh(x)-cosh(x))\"],\n    \"3.131954\": [\"f(sinh(x)^2,sinh(2*x)/4-x/2)\"],\n    \"2.579685\": [\"f(tanh(x)^2,x-tanh(x))\"],\n    \"3.548923\": [\"f(cosh(x)^2,sinh(2*x)/4+x/2)\"],\n    \"1.058866\": [\"f(x^3*exp(a*x^2),exp(a*x^2)*(x^2/a-1/(a^2))/2)\"],\n    \"1.235270\": [\"f(x^3*exp(a*x^2+b),exp(a*x^2)*exp(b)*(x^2/a-1/(a^2))/2)\"],\n    \"1.130783\": [\"f(exp(a*x^2),-i*sqrt(pi)*erf(i*sqrt(a)*x)/sqrt(a)/2)\"],\n    \"1.078698\": [\"f(erf(a*x),x*erf(a*x)+exp(-a^2*x^2)/a/sqrt(pi))\"],\n    \"2.573650\": [\"f(x^2*(1-x^2)^(3/2),(x*sqrt(1-x^2)*(-8*x^4+14*x^2-3)+3*arcsin(x))/48)\", \"f(x^2*(1-x^2)^(5/2),(x*sqrt(1-x^2)*(48*x^6-136*x^4+118*x^2-15)+15*arcsin(x))/384)\"],\n    \"2.640666\": [\"f(x^4*(1-x^2)^(3/2),(-x*sqrt(1-x^2)*(16*x^6-24*x^4+2*x^2+3)+3*arcsin(x))/128)\"],\n    \"1.086487\": [\"f(x*exp(a*x),exp(a*x)*(a*x-1)/(a^2))\"],\n    \"1.267493\": [\"f(x*exp(a*x+b),exp(a*x+b)*(a*x-1)/(a^2))\"],\n    \"1.037943\": [\"f(x^2*exp(a*x),exp(a*x)*(a^2*x^2-2*a*x+2)/(a^3))\"],\n    \"1.210862\": [\"f(x^2*exp(a*x+b),exp(a*x+b)*(a^2*x^2-2*a*x+2)/(a^3))\"],\n    \"1.064970\": [\"f(x^3*exp(a*x),exp(a*x)*x^3/a-3/a*integral(x^2*exp(a*x),x))\"],\n    \"1.242392\": [\"f(x^3*exp(a*x+b),exp(a*x+b)*x^3/a-3/a*integral(x^2*exp(a*x+b),x))\"]\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Input:    Matrix on stack (must have two dimensions but\n  //        it can be non-numerical)\n\n  //  Output:    Inverse on stack\n\n  //  Example:\n\n  //  > inv(((1,2),(3,4))\n  //  ((-2,1),(3/2,-1/2))\n\n  //  > inv(((a,b),(c,d))\n  //  ((d / (a d - b c),-b / (a d - b c)),(-c / (a d - b c),a / (a d - b c)))\n\n  //  Note:\n\n  //  THIS IS DIFFERENT FROM INVERSE OF AN EXPRESSION (inv)\n  //   Uses Gaussian elimination for numerical matrices.\n\n  //-----------------------------------------------------------------------------\n  INV_check_arg = function() {\n    if (!istensor(p1)) {\n      return 0;\n    } else if (p1.tensor.ndim !== 2) {\n      return 0;\n    } else if (p1.tensor.dim[0] !== p1.tensor.dim[1]) {\n      return 0;\n    } else {\n      return 1;\n    }\n  };\n\n  inv = function() {\n    var accumulator, eachEntry, i, n, o, ref;\n    i = 0;\n    n = 0;\n    //U **a\n    save();\n    p1 = pop();\n    // an inv just goes away when\n    // applied to another inv\n    if (isinv(p1)) {\n      push(car(cdr(p1)));\n      restore();\n      return;\n    }\n    // inverse goes away in case\n    // of identity matrix\n    if (isidentitymatrix(p1)) {\n      push(p1);\n      restore();\n      return;\n    }\n    // distribute the inverse of a dot\n    // if in expanding mode\n    // note that the distribution happens\n    // in reverse.\n    // The dot operator is not\n    // commutative, so, it matters.\n    if (expanding && isinnerordot(p1)) {\n      p1 = cdr(p1);\n      accumulator = [];\n      while (iscons(p1)) {\n        accumulator.push(car(p1));\n        p1 = cdr(p1);\n      }\n      for (eachEntry = o = ref = accumulator.length - 1; (ref <= 0 ? o <= 0 : o >= 0); eachEntry = ref <= 0 ? ++o : --o) {\n        push(accumulator[eachEntry]);\n        inv();\n        if (eachEntry !== accumulator.length - 1) {\n          inner();\n        }\n      }\n      restore();\n      return;\n    }\n    if (INV_check_arg() === 0) {\n      push_symbol(INV);\n      push(p1);\n      list(2);\n      restore();\n      return;\n    }\n    if (isNumericAtomOrTensor(p1)) {\n      yyinvg();\n    } else {\n      push(p1);\n      adj();\n      push(p1);\n      det();\n      p2 = pop();\n      if (isZeroAtomOrTensor(p2)) {\n        stop(\"inverse of singular matrix\");\n      }\n      push(p2);\n      divide();\n    }\n    return restore();\n  };\n\n  invg = function() {\n    save();\n    p1 = pop();\n    if (INV_check_arg() === 0) {\n      push_symbol(INVG);\n      push(p1);\n      list(2);\n      restore();\n      return;\n    }\n    yyinvg();\n    return restore();\n  };\n\n  // inverse using gaussian elimination\n  yyinvg = function() {\n    var h, i, i1, j, j1, l1, n, o, ref, ref1, ref2, ref3;\n    h = 0;\n    i = 0;\n    j = 0;\n    n = 0;\n    n = p1.tensor.dim[0];\n    h = tos;\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      for (j = i1 = 0, ref1 = n; (0 <= ref1 ? i1 < ref1 : i1 > ref1); j = 0 <= ref1 ? ++i1 : --i1) {\n        if (i === j) {\n          push(one);\n        } else {\n          push(zero);\n        }\n      }\n    }\n    for (i = j1 = 0, ref2 = n * n; (0 <= ref2 ? j1 < ref2 : j1 > ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n      push(p1.tensor.elem[i]);\n    }\n    INV_decomp(n);\n    p1 = alloc_tensor(n * n);\n    p1.tensor.ndim = 2;\n    p1.tensor.dim[0] = n;\n    p1.tensor.dim[1] = n;\n    for (i = l1 = 0, ref3 = n * n; (0 <= ref3 ? l1 < ref3 : l1 > ref3); i = 0 <= ref3 ? ++l1 : --l1) {\n      p1.tensor.elem[i] = stack[h + i];\n    }\n    moveTos(tos - 2 * n * n);\n    return push(p1);\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Input:    n * n unit matrix on stack\n\n  //      n * n operand on stack\n\n  //  Output:    n * n inverse matrix on stack\n\n  //      n * n garbage on stack\n\n  //      p2 mangled\n\n  //-----------------------------------------------------------------------------\n\n  //define A(i, j) stack[a + n * (i) + (j)]\n  //define U(i, j) stack[u + n * (i) + (j)]\n  INV_decomp = function(n) {\n    var a, d, i, i1, j, j1, l1, o, ref, ref1, ref2, ref3, ref4, results, u;\n    a = 0;\n    d = 0;\n    i = 0;\n    j = 0;\n    u = 0;\n    a = tos - n * n;\n    u = a - n * n;\n    results = [];\n    for (d = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); d = 0 <= ref ? ++o : --o) {\n      // diagonal element zero?\n      if (equal(stack[a + n * d + d], zero)) {\n// find a new row\n        for (i = i1 = ref1 = d + 1, ref2 = n; (ref1 <= ref2 ? i1 < ref2 : i1 > ref2); i = ref1 <= ref2 ? ++i1 : --i1) {\n          if (!equal(stack[a + n * i + d], zero)) {\n            break;\n          }\n        }\n        if (i === n) {\n          stop(\"inverse of singular matrix\");\n        }\n// exchange rows\n        for (j = j1 = 0, ref3 = n; (0 <= ref3 ? j1 < ref3 : j1 > ref3); j = 0 <= ref3 ? ++j1 : --j1) {\n          p2 = stack[a + n * d + j];\n          stack[a + n * d + j] = stack[a + n * i + j];\n          stack[a + n * i + j] = p2;\n          p2 = stack[u + n * d + j];\n          stack[u + n * d + j] = stack[u + n * i + j];\n          stack[u + n * i + j] = p2;\n        }\n      }\n      // multiply the pivot row by 1 / pivot\n      p2 = stack[a + n * d + d];\n      for (j = l1 = 0, ref4 = n; (0 <= ref4 ? l1 < ref4 : l1 > ref4); j = 0 <= ref4 ? ++l1 : --l1) {\n        if (j > d) {\n          push(stack[a + n * d + j]);\n          push(p2);\n          divide();\n          stack[a + n * d + j] = pop();\n        }\n        push(stack[u + n * d + j]);\n        push(p2);\n        divide();\n        stack[u + n * d + j] = pop();\n      }\n      results.push((function() {\n        var m1, ref5, results1;\n// clear out the column above and below the pivot\n        results1 = [];\n        for (i = m1 = 0, ref5 = n; (0 <= ref5 ? m1 < ref5 : m1 > ref5); i = 0 <= ref5 ? ++m1 : --m1) {\n          if (i === d) {\n            continue;\n          }\n          // multiplier\n          p2 = stack[a + n * i + d];\n          results1.push((function() {\n            var n1, ref6, results2;\n// add pivot row to i-th row\n            results2 = [];\n            for (j = n1 = 0, ref6 = n; (0 <= ref6 ? n1 < ref6 : n1 > ref6); j = 0 <= ref6 ? ++n1 : --n1) {\n              if (j > d) {\n                push(stack[a + n * i + j]);\n                push(stack[a + n * d + j]);\n                push(p2);\n                multiply();\n                subtract();\n                stack[a + n * i + j] = pop();\n              }\n              push(stack[u + n * i + j]);\n              push(stack[u + n * d + j]);\n              push(p2);\n              multiply();\n              subtract();\n              results2.push(stack[u + n * i + j] = pop());\n            }\n            return results2;\n          })());\n        }\n        return results1;\n      })());\n    }\n    return results;\n  };\n\n  DEBUG_IS = false;\n\n  // jsBoolToToInt = (p) ->\n  //   if p then 1 else 0\n\n  // p is a U\n  // this routine is a simple check on whether we have\n  // a basic zero in our hands. It doesn't perform any\n  // calculations or simplifications.\n  isZeroAtom = function(p) {\n    switch (p.k) {\n      case NUM:\n        return MZERO(p.q.a);\n      case DOUBLE:\n        return p.d === 0.0;\n      default:\n        return false;\n    }\n  };\n\n  // p is a U\n  // this routine is a simple check on whether we have\n  // a basic zero in our hands. It doesn't perform any\n  // calculations or simplifications.\n  isZeroTensor = function(p) {\n    var i, o, ref;\n    if (p.k !== TENSOR) {\n      return 0;\n    }\n    for (i = o = 0, ref = p.tensor.nelem; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      if (!isZeroAtomOrTensor(p.tensor.elem[i])) {\n        return 0;\n      }\n    }\n    return 1;\n  };\n\n  // p is a U\n  // this routine is a simple check on whether we have\n  // a basic zero in our hands. It doesn't perform any\n  // calculations or simplifications.\n  isZeroAtomOrTensor = function(p) {\n    return isZeroAtom(p) || isZeroTensor(p);\n  };\n\n  // This is a key routine to try to determine whether\n  // the argument looks like zero/false, or non-zero/true,\n  // or undetermined.\n  // This is useful in two instances:\n  //  * to determine if a predicate is true/false\n  //  * to determine if particular quantity is zero\n  // Note that if one wants to check if we have a simple\n  // zero atom or tensor in our hands, then the isZeroAtomOrTensor\n  // routine is sufficient.\n  isZeroLikeOrNonZeroLikeOrUndetermined = function(valueOrPredicate) {\n    var evalledArgument;\n    // push the argument\n    push(valueOrPredicate);\n    // just like Eval but turns assignments into\n    // equality checks\n    Eval_predicate();\n    evalledArgument = pop();\n    // OK first check if we already have\n    // a simple zero (or simple zero tensor)\n    if (isZeroAtomOrTensor(evalledArgument)) {\n      return 0;\n    }\n    // also check if we have a simple numeric value, or a tensor\n    // full of simple numeric values (i.e. straight doubles or fractions).\n    // In such cases, since we\n    // just excluded they are zero, then we take it as\n    // a \"true\"\n    if (isNumericAtomOrTensor(evalledArgument)) {\n      return 1;\n    }\n    // if we are here we are in the case of value that\n    // is not a zero and not a simple numeric value.\n    // e.g. stuff like\n    // 'sqrt(2)', or 'sin(45)' or '1+i', or 'a'\n    // so in such cases let's try to do a float()\n    // so we might get down to a simple numeric value\n    // in some of those cases\n    push(evalledArgument);\n    zzfloat();\n    evalledArgument = pop();\n    // anything that could be calculated down to a simple\n    // numeric value is now indeed either a \n    // double OR a double with an imaginary component\n    // e.g. 2.0 or 2.4 + i*5.6\n    // (Everything else are things that don't have a numeric\n    // value e.g. 'a+b')\n\n    // So, let's take care of the case where we have\n    // a simple numeric value with NO imaginary component,\n    // things like sqrt(2) or sin(PI)\n    // by doing the simple numeric\n    // values checks again\n    if (isZeroAtomOrTensor(evalledArgument)) {\n      return 0;\n    }\n    if (isNumericAtomOrTensor(evalledArgument)) {\n      return 1;\n    }\n    // here we still have cases of simple numeric values\n    // WITH an imaginary component e.g. '1+i',\n    // or things that don't have a numeric value e.g. 'a'\n\n    // so now let's take care of the imaginary numbers:\n    // since we JUST have to spot \"zeros\" we can just\n    // calculate the absolute value and re-do all the checks\n    // we just did\n    if (Find(evalledArgument, imaginaryunit)) {\n      push(evalledArgument);\n      absValFloat();\n      Eval_predicate();\n      evalledArgument = pop();\n      // re-do the simple-number checks...\n      if (isZeroAtomOrTensor(evalledArgument)) {\n        return 0;\n      }\n      if (isNumericAtomOrTensor(evalledArgument)) {\n        return 1;\n      }\n    }\n    // here we have stuff that is not reconducible to any\n    // numeric value (or tensor with numeric values) e.g.\n    // 'a+b', so it just means that we just don't know the\n    // truth value, so we have\n    // to leave the whole thing unevalled\n    return null;\n  };\n\n  // p is a U\n  isnegativenumber = function(p) {\n    switch (p.k) {\n      case NUM:\n        if (MSIGN(p.q.a) === -1) {\n          return 1;\n        }\n        break;\n      case DOUBLE:\n        if (p.d < 0.0) {\n          return 1;\n        }\n    }\n    return 0;\n  };\n\n  // p is a U\n  ispositivenumber = function(p) {\n    switch (p.k) {\n      case NUM:\n        if (MSIGN(p.q.a) === 1) {\n          return 1;\n        }\n        break;\n      case DOUBLE:\n        if (p.d > 0.0) {\n          return 1;\n        }\n    }\n    return 0;\n  };\n\n  // p is a U\n  isplustwo = function(p) {\n    switch (p.k) {\n      case NUM:\n        if (MEQUAL(p.q.a, 2) && MEQUAL(p.q.b, 1)) {\n          return 1;\n        }\n        break;\n      case DOUBLE:\n        if (p.d === 2.0) {\n          return 1;\n        }\n    }\n    return 0;\n  };\n\n  // p is a U\n  isplusone = function(p) {\n    switch (p.k) {\n      case NUM:\n        if (MEQUAL(p.q.a, 1) && MEQUAL(p.q.b, 1)) {\n          return 1;\n        }\n        break;\n      case DOUBLE:\n        if (p.d === 1.0) {\n          return 1;\n        }\n    }\n    return 0;\n  };\n\n  isminusone = function(p) {\n    switch (p.k) {\n      case NUM:\n        if (MEQUAL(p.q.a, -1) && MEQUAL(p.q.b, 1)) {\n          return 1;\n        }\n        break;\n      case DOUBLE:\n        if (p.d === -1.0) {\n          return 1;\n        }\n    }\n    return 0;\n  };\n\n  isone = function(p) {\n    return isplusone(p) || isminusone(p);\n  };\n\n  isinteger = function(p) {\n    if (p.k === NUM && MEQUAL(p.q.b, 1)) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  isintegerorintegerfloat = function(p) {\n    if (p.k === DOUBLE) {\n      if (p.d === Math.round(p.d)) {\n        return 1;\n      }\n      return 0;\n    }\n    return isinteger(p);\n  };\n\n  isnonnegativeinteger = function(p) {\n    if (isrational(p) && MEQUAL(p.q.b, 1) && MSIGN(p.q.a) === 1) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  isposint = function(p) {\n    if (isinteger(p) && MSIGN(p.q.a) === 1) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  // --------------------------------------\n  isunivarpolyfactoredorexpandedform = function(p, x) {\n    if (DEBUG) {\n      console.log(\"isunivarpolyfactoredorexpandedform: p: \" + p + \" x: \" + x);\n    }\n    if (x == null) {\n      push(p);\n      guess();\n      x = pop();\n      pop();\n    }\n    if (ispolyfactoredorexpandedform(p, x) && (Find(p, symbol(SYMBOL_X)) + Find(p, symbol(SYMBOL_Y)) + Find(p, symbol(SYMBOL_Z)) === 1)) {\n      return x;\n    } else {\n      return 0;\n    }\n  };\n\n  // --------------------------------------\n  // sometimes we want to check if we have a poly in our\n  // hands, however it's in factored form and we don't\n  // want to expand it.\n  ispolyfactoredorexpandedform = function(p, x) {\n    return ispolyfactoredorexpandedform_factor(p, x);\n  };\n\n  ispolyfactoredorexpandedform_factor = function(p, x) {\n    if (car(p) === symbol(MULTIPLY)) {\n      p = cdr(p);\n      while (iscons(p)) {\n        if (DEBUG) {\n          console.log(\"ispolyfactoredorexpandedform_factor testing \" + car(p));\n        }\n        if (!ispolyfactoredorexpandedform_power(car(p), x)) {\n          if (DEBUG) {\n            console.log(\"... tested negative:\" + car(p));\n          }\n          return 0;\n        }\n        p = cdr(p);\n      }\n      return 1;\n    } else {\n      return ispolyfactoredorexpandedform_power(p, x);\n    }\n  };\n\n  ispolyfactoredorexpandedform_power = function(p, x) {\n    if (car(p) === symbol(POWER)) {\n      if (DEBUG) {\n        console.log(\"ispolyfactoredorexpandedform_power (isposint(caddr(p)) \" + (isposint(caddr(p)), DEBUG ? console.log(\"ispolyfactoredorexpandedform_power ispolyexpandedform_expr(cadr(p), x)) \" + ispolyexpandedform_expr(cadr(p), x)) : void 0));\n      }\n      return isposint(caddr(p)) && ispolyexpandedform_expr(cadr(p), x);\n    } else {\n      if (DEBUG) {\n        console.log(\"ispolyfactoredorexpandedform_power not a power, testing if this is exp form: \" + p);\n      }\n      return ispolyexpandedform_expr(p, x);\n    }\n  };\n\n  // --------------------------------------\n  ispolyexpandedform = function(p, x) {\n    if (Find(p, x)) {\n      return ispolyexpandedform_expr(p, x);\n    } else {\n      return 0;\n    }\n  };\n\n  ispolyexpandedform_expr = function(p, x) {\n    if (car(p) === symbol(ADD)) {\n      p = cdr(p);\n      while (iscons(p)) {\n        if (!ispolyexpandedform_term(car(p), x)) {\n          return 0;\n        }\n        p = cdr(p);\n      }\n      return 1;\n    } else {\n      return ispolyexpandedform_term(p, x);\n    }\n  };\n\n  ispolyexpandedform_term = function(p, x) {\n    if (car(p) === symbol(MULTIPLY)) {\n      p = cdr(p);\n      while (iscons(p)) {\n        if (!ispolyexpandedform_factor(car(p), x)) {\n          return 0;\n        }\n        p = cdr(p);\n      }\n      return 1;\n    } else {\n      return ispolyexpandedform_factor(p, x);\n    }\n  };\n\n  ispolyexpandedform_factor = function(p, x) {\n    if (equal(p, x)) {\n      return 1;\n    }\n    if (car(p) === symbol(POWER) && equal(cadr(p), x)) {\n      if (isposint(caddr(p))) {\n        return 1;\n      } else {\n        return 0;\n      }\n    }\n    if (Find(p, x)) {\n      return 0;\n    } else {\n      return 1;\n    }\n  };\n\n  // --------------------------------------\n  isnegativeterm = function(p) {\n    if (isnegativenumber(p)) {\n      return 1;\n    } else if (car(p) === symbol(MULTIPLY) && isnegativenumber(cadr(p))) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  hasNegativeRationalExponent = function(p) {\n    if (car(p) === symbol(POWER) && isrational(car(cdr(cdr(p)))) && isnegativenumber(car(cdr(p)))) {\n      if (DEBUG_IS) {\n        console.log(\"hasNegativeRationalExponent: \" + p.toString() + \" has imaginary component\");\n      }\n      return 1;\n    } else {\n      if (DEBUG_IS) {\n        console.log(\"hasNegativeRationalExponent: \" + p.toString() + \" has NO imaginary component\");\n      }\n      return 0;\n    }\n  };\n\n  isimaginarynumberdouble = function(p) {\n    if ((car(p) === symbol(MULTIPLY) && length(p) === 3 && isdouble(cadr(p)) && hasNegativeRationalExponent(caddr(p))) || equal(p, imaginaryunit)) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  isimaginarynumber = function(p) {\n    if ((car(p) === symbol(MULTIPLY) && length(p) === 3 && isNumericAtom(cadr(p)) && equal(caddr(p), imaginaryunit)) || equal(p, imaginaryunit) || hasNegativeRationalExponent(caddr(p))) {\n      if (DEBUG_IS) {\n        console.log(\"isimaginarynumber: \" + p.toString() + \" is imaginary number\");\n      }\n      return 1;\n    } else {\n      if (DEBUG_IS) {\n        console.log(\"isimaginarynumber: \" + p.toString() + \" isn't an imaginary number\");\n      }\n      return 0;\n    }\n  };\n\n  iscomplexnumberdouble = function(p) {\n    if ((car(p) === symbol(ADD) && length(p) === 3 && isdouble(cadr(p)) && isimaginarynumberdouble(caddr(p))) || isimaginarynumberdouble(p)) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  iscomplexnumber = function(p) {\n    if (DEBUG_IS) {\n      debugger;\n    }\n    if ((car(p) === symbol(ADD) && length(p) === 3 && isNumericAtom(cadr(p)) && isimaginarynumber(caddr(p))) || isimaginarynumber(p)) {\n      if (DEBUG) {\n        console.log(\"iscomplexnumber: \" + p.toString() + \" is imaginary number\");\n      }\n      return 1;\n    } else {\n      if (DEBUG) {\n        console.log(\"iscomplexnumber: \" + p.toString() + \" is imaginary number\");\n      }\n      return 0;\n    }\n  };\n\n  iseveninteger = function(p) {\n    if (isinteger(p) && p.q.a.isEven()) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  isnegative = function(p) {\n    if (car(p) === symbol(ADD) && isnegativeterm(cadr(p))) {\n      return 1;\n    } else if (isnegativeterm(p)) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  // returns 1 if there's a symbol somewhere.\n  // not used anywhere.\n  // NOTE: PI and POWER are symbols,\n  // so for example 2^3 would be symbolic\n  // while -1^(1/2) i.e. 'i' is not, so this can\n  // be tricky to use.\n  issymbolic = function(p) {\n    if (issymbol(p)) {\n      return 1;\n    } else {\n      while (iscons(p)) {\n        if (issymbolic(car(p))) {\n          return 1;\n        }\n        p = cdr(p);\n      }\n      return 0;\n    }\n  };\n\n  // i.e. 2, 2^3, etc.\n  isintegerfactor = function(p) {\n    return isinteger(p) || car(p) === symbol(POWER) && isinteger(cadr(p)) && isinteger(caddr(p));\n  };\n\n  isNumberOneOverSomething = function(p) {\n    return isfraction(p) && MEQUAL(p.q.a.abs(), 1);\n  };\n\n  isoneover = function(p) {\n    return car(p) === symbol(POWER) && isminusone(caddr(p));\n  };\n\n  isfraction = function(p) {\n    return p.k === NUM && !MEQUAL(p.q.b, 1);\n  };\n\n  // p is a U, n an int\n  equaln = function(p, n) {\n    switch (p.k) {\n      case NUM:\n        return MEQUAL(p.q.a, n) && MEQUAL(p.q.b, 1);\n      case DOUBLE:\n        return p.d === n;\n      default:\n        return false;\n    }\n  };\n\n  // p is a U, a and b ints\n  equalq = function(p, a, b) {\n    switch (p.k) {\n      case NUM:\n        return MEQUAL(p.q.a, a) && MEQUAL(p.q.b, b);\n      case DOUBLE:\n        return p.d === a / b;\n      default:\n        return false;\n    }\n  };\n\n  // 1/2 ?\n  isoneovertwo = function(p) {\n    return equalq(p, 1, 2);\n  };\n\n  // -1/2 ?\n  isminusoneovertwo = function(p) {\n    return equalq(p, -1, 2);\n  };\n\n  // 1/sqrt(2) ?\n  isoneoversqrttwo = function(p) {\n    return car(p) === symbol(POWER) && equaln(cadr(p), 2) && equalq(caddr(p), -1, 2);\n  };\n\n  // -1/sqrt(2) ?\n  isminusoneoversqrttwo = function(p) {\n    return car(p) === symbol(MULTIPLY) && equaln(cadr(p), -1) && isoneoversqrttwo(caddr(p)) && length(p) === 3;\n  };\n\n  // sqrt(3)/2 ?\n  issqrtthreeovertwo = function(p) {\n    return car(p) === symbol(MULTIPLY) && isoneovertwo(cadr(p)) && issqrtthree(caddr(p)) && length(p) === 3;\n  };\n\n  // -sqrt(3)/2 ?\n  isminussqrtthreeovertwo = function(p) {\n    return car(p) === symbol(MULTIPLY) && isminusoneovertwo(cadr(p)) && issqrtthree(caddr(p)) && length(p) === 3;\n  };\n\n  // p == sqrt(3) ?\n  issqrtthree = function(p) {\n    return car(p) === symbol(POWER) && equaln(cadr(p), 3) && isoneovertwo(caddr(p));\n  };\n\n  isfloating = function(p) {\n    if (p.k === DOUBLE || p === symbol(FLOATF)) {\n      return 1;\n    }\n    while (iscons(p)) {\n      if (isfloating(car(p))) {\n        return 1;\n      }\n      p = cdr(p);\n    }\n    return 0;\n  };\n\n  isimaginaryunit = function(p) {\n    if (equal(p, imaginaryunit)) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  // n/2 * i * pi ?\n\n  // return value:\n\n  //  0  no\n\n  //  1  1\n\n  //  2  -1\n\n  //  3  i\n\n  //  4  -i\n  isquarterturn = function(p) {\n    var minussign, n;\n    n = 0;\n    minussign = 0;\n    if (car(p) !== symbol(MULTIPLY)) {\n      return 0;\n    }\n    if (equal(cadr(p), imaginaryunit)) {\n      if (caddr(p) !== symbol(PI)) {\n        return 0;\n      }\n      if (length(p) !== 3) {\n        return 0;\n      }\n      return 2;\n    }\n    if (!isNumericAtom(cadr(p))) {\n      return 0;\n    }\n    if (!equal(caddr(p), imaginaryunit)) {\n      return 0;\n    }\n    if (cadddr(p) !== symbol(PI)) {\n      return 0;\n    }\n    if (length(p) !== 4) {\n      return 0;\n    }\n    push(cadr(p));\n    push_integer(2);\n    multiply();\n    n = pop_integer();\n    if (isNaN(n)) {\n      return 0;\n    }\n    if (n < 1) {\n      minussign = 1;\n      n = -n;\n    }\n    switch (n % 4) {\n      case 0:\n        n = 1;\n        break;\n      case 1:\n        if (minussign) {\n          n = 4;\n        } else {\n          n = 3;\n        }\n        break;\n      case 2:\n        n = 2;\n        break;\n      case 3:\n        if (minussign) {\n          n = 3;\n        } else {\n          n = 4;\n        }\n    }\n    return n;\n  };\n\n  // special multiple of pi?\n\n  // returns for the following multiples of pi...\n\n  //  -4/2  -3/2  -2/2  -1/2  1/2  2/2  3/2  4/2\n\n  //  4  1  2  3  1  2  3  4\n  isnpi = function(p) {\n    var doNothing, n;\n    n = 0;\n    if (p === symbol(PI)) {\n      return 2;\n    }\n    if (car(p) === symbol(MULTIPLY) && isNumericAtom(cadr(p)) && caddr(p) === symbol(PI) && length(p) === 3) {\n      doNothing = 0;\n    } else {\n      return 0;\n    }\n    push(cadr(p));\n    push_integer(2);\n    multiply();\n    n = pop_integer();\n    if (isNaN(n)) {\n      return 0;\n    }\n    if (n < 0) {\n      n = 4 - (-n) % 4;\n    } else {\n      n = 1 + (n - 1) % 4;\n    }\n    return n;\n  };\n\n  $.isZeroAtomOrTensor = isZeroAtomOrTensor;\n\n  $.isnegativenumber = isnegativenumber;\n\n  $.isplusone = isplusone;\n\n  $.isminusone = isminusone;\n\n  $.isinteger = isinteger;\n\n  $.isnonnegativeinteger = isnonnegativeinteger;\n\n  $.isposint = isposint;\n\n  $.isnegativeterm = isnegativeterm;\n\n  $.isimaginarynumber = isimaginarynumber;\n\n  $.iscomplexnumber = iscomplexnumber;\n\n  $.iseveninteger = iseveninteger;\n\n  $.isnegative = isnegative;\n\n  $.issymbolic = issymbolic;\n\n  $.isintegerfactor = isintegerfactor;\n\n  $.isoneover = isoneover;\n\n  $.isfraction = isfraction;\n\n  $.isoneoversqrttwo = isoneoversqrttwo;\n\n  $.isminusoneoversqrttwo = isminusoneoversqrttwo;\n\n  $.isfloating = isfloating;\n\n  $.isimaginaryunit = isimaginaryunit;\n\n  $.isquarterturn = isquarterturn;\n\n  $.isnpi = isnpi;\n\n  Eval_isprime = function() {\n    push(cadr(p1));\n    Eval();\n    p1 = pop();\n    if (isnonnegativeinteger(p1) && mprime(p1.q.a)) {\n      return push_integer(1);\n    } else {\n      return push_integer(0);\n    }\n  };\n\n  Eval_laguerre = function() {\n    // 1st arg\n    push(cadr(p1));\n    Eval();\n    // 2nd arg\n    push(caddr(p1));\n    Eval();\n    // 3rd arg\n    push(cadddr(p1));\n    Eval();\n    p2 = pop();\n    if (p2 === symbol(NIL)) {\n      push_integer(0);\n    } else {\n      push(p2);\n    }\n    return laguerre();\n  };\n\n  //define X p1\n  //define N p2\n  //define K p3\n  //define Y p4\n  //define Y0 p5\n  //define Y1 p6\n  laguerre = function() {\n    var n;\n    n = 0;\n    save();\n    p3 = pop();\n    p2 = pop();\n    p1 = pop();\n    push(p2);\n    n = pop_integer();\n    if (n < 0 || isNaN(n)) {\n      push_symbol(LAGUERRE);\n      push(p1);\n      push(p2);\n      push(p3);\n      list(4);\n      restore();\n      return;\n    }\n    if (issymbol(p1)) {\n      laguerre2(n);\n    } else {\n      p4 = p1;\n      p1 = symbol(SECRETX);\n      laguerre2(n);\n      p1 = p4;\n      push(symbol(SECRETX));\n      push(p1);\n      subst();\n      Eval();\n    }\n    return restore();\n  };\n\n  laguerre2 = function(n) {\n    var i, o, ref, results;\n    i = 0;\n    push_integer(1);\n    push_integer(0);\n    p6 = pop();\n    results = [];\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      p5 = p6;\n      p6 = pop();\n      push_integer(2 * i + 1);\n      push(p1);\n      subtract();\n      push(p3);\n      add();\n      push(p6);\n      multiply();\n      push_integer(i);\n      push(p3);\n      add();\n      push(p5);\n      multiply();\n      subtract();\n      push_integer(i + 1);\n      results.push(divide());\n    }\n    return results;\n  };\n\n  // Find the least common multiple of two expressions.\n  Eval_lcm = function() {\n    var results;\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p1 = cdr(p1);\n    results = [];\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n      lcm();\n      results.push(p1 = cdr(p1));\n    }\n    return results;\n  };\n\n  lcm = function() {\n    var prev_expanding;\n    prev_expanding = expanding;\n    save();\n    yylcm();\n    restore();\n    return expanding = prev_expanding;\n  };\n\n  yylcm = function() {\n    expanding = 1;\n    p2 = pop();\n    p1 = pop();\n    push(p1);\n    push(p2);\n    gcd();\n    push(p1);\n    divide();\n    push(p2);\n    divide();\n    return inverse();\n  };\n\n  Eval_leading = function() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    p1 = pop();\n    if (p1 === symbol(NIL)) {\n      guess();\n    } else {\n      push(p1);\n    }\n    return leading();\n  };\n\n  //define P p1\n  //define X p2\n  //define N p3\n  leading = function() {\n    save();\n    p2 = pop();\n    p1 = pop();\n    push(p1); // N = degree of P\n    push(p2);\n    degree();\n    p3 = pop();\n    push(p1); // divide through by X ^ N\n    push(p2);\n    push(p3);\n    power();\n    divide();\n    push(p2); // remove terms that depend on X\n    filter();\n    return restore();\n  };\n\n  Eval_legendre = function() {\n    // 1st arg\n    push(cadr(p1));\n    Eval();\n    // 2nd arg\n    push(caddr(p1));\n    Eval();\n    // 3rd arg (optional)\n    push(cadddr(p1));\n    Eval();\n    p2 = pop();\n    if (p2 === symbol(NIL)) {\n      push_integer(0);\n    } else {\n      push(p2);\n    }\n    return legendre();\n  };\n\n  //define X p1\n  //define N p2\n  //define M p3\n  //define Y p4\n  //define Y0 p5\n  //define Y1 p6\n  legendre = function() {\n    save();\n    __legendre();\n    return restore();\n  };\n\n  __legendre = function() {\n    var m, n;\n    m = 0;\n    n = 0;\n    p3 = pop();\n    p2 = pop();\n    p1 = pop();\n    push(p2);\n    n = pop_integer();\n    push(p3);\n    m = pop_integer();\n    if (n < 0 || isNaN(n) || m < 0 || isNaN(m)) {\n      push_symbol(LEGENDRE);\n      push(p1);\n      push(p2);\n      push(p3);\n      list(4);\n      return;\n    }\n    if (issymbol(p1)) {\n      __legendre2(n, m);\n    } else {\n      p4 = p1;\n      p1 = symbol(SECRETX);\n      __legendre2(n, m);\n      p1 = p4;\n      push(symbol(SECRETX));\n      push(p1);\n      subst();\n      Eval();\n    }\n    return __legendre3(m);\n  };\n\n  __legendre2 = function(n, m) {\n    var i, i1, o, ref, ref1, results;\n    i = 0;\n    push_integer(1);\n    push_integer(0);\n    p6 = pop();\n//  i=1  p5 = 0 \n//    p6 = 1 \n//    ((2*i+1)*x*p6 - i*p5) / i = x\n\n//  i=2  p5 = 1\n//    p6 = x\n//    ((2*i+1)*x*p6 - i*p5) / i = -1/2 + 3/2*x^2\n\n//  i=3  p5 = x\n//    p6 = -1/2 + 3/2*x^2\n//    ((2*i+1)*x*p6 - i*p5) / i = -3/2*x + 5/2*x^3\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      p5 = p6;\n      p6 = pop();\n      push_integer(2 * i + 1);\n      push(p1);\n      multiply();\n      push(p6);\n      multiply();\n      push_integer(i);\n      push(p5);\n      multiply();\n      subtract();\n      push_integer(i + 1);\n      divide();\n    }\n    results = [];\n    for (i = i1 = 0, ref1 = m; (0 <= ref1 ? i1 < ref1 : i1 > ref1); i = 0 <= ref1 ? ++i1 : --i1) {\n      push(p1);\n      results.push(derivative());\n    }\n    return results;\n  };\n\n  // moveTos tos * (-1)^m * (1-x^2)^(m/2)\n  __legendre3 = function(m) {\n    if (m === 0) {\n      return;\n    }\n    if (car(p1) === symbol(COS)) {\n      push(cadr(p1));\n      sine();\n      square();\n    } else if (car(p1) === symbol(SIN)) {\n      push(cadr(p1));\n      cosine();\n      square();\n    } else {\n      push_integer(1);\n      push(p1);\n      square();\n      subtract();\n    }\n    push_integer(m);\n    push_rational(1, 2);\n    multiply();\n    power();\n    multiply();\n    if (m % 2) {\n      return negate();\n    }\n  };\n\n  // Create a list from n things on the stack.\n\n  // n is an integer\n  list = function(n) {\n    var listIterator, o, ref, results;\n    listIterator = 0;\n    push(symbol(NIL));\n    results = [];\n    for (listIterator = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); listIterator = 0 <= ref ? ++o : --o) {\n      results.push(cons());\n    }\n    return results;\n  };\n\n  // Natural logarithm.\n\n  // Note that we use the mathematics / Javascript / Mathematica\n  // convention that \"log\" is indeed the natural logarithm.\n\n  // In engineering, biology, astronomy, \"log\" can stand instead\n  // for the \"common\" logarithm i.e. base 10. Also note that Google\n  // calculations use log for the common logarithm.\n  Eval_log = function() {\n    push(cadr(p1));\n    Eval();\n    return logarithm();\n  };\n\n  logarithm = function() {\n    save();\n    yylog();\n    return restore();\n  };\n\n  yylog = function() {\n    var d;\n    d = 0.0;\n    p1 = pop();\n    if (p1 === symbol(E)) {\n      push_integer(1);\n      return;\n    }\n    if (equaln(p1, 1)) {\n      push_integer(0);\n      return;\n    }\n    if (isnegativenumber(p1)) {\n      push(p1);\n      negate();\n      logarithm();\n      push(imaginaryunit);\n      if (evaluatingAsFloats) {\n        push_double(Math.PI);\n      } else {\n        push_symbol(PI);\n      }\n      multiply();\n      add();\n      return;\n    }\n    if (isdouble(p1)) {\n      d = Math.log(p1.d);\n      push_double(d);\n      return;\n    }\n    // rational number and not an integer?\n    if (isfraction(p1)) {\n      push(p1);\n      numerator();\n      logarithm();\n      push(p1);\n      denominator();\n      logarithm();\n      subtract();\n      return;\n    }\n    // log(a ^ b) --> b log(a)\n    if (car(p1) === symbol(POWER)) {\n      push(caddr(p1));\n      push(cadr(p1));\n      logarithm();\n      multiply();\n      return;\n    }\n    // log(a * b) --> log(a) + log(b)\n    if (car(p1) === symbol(MULTIPLY)) {\n      push_integer(0);\n      p1 = cdr(p1);\n      while (iscons(p1)) {\n        push(car(p1));\n        logarithm();\n        add();\n        p1 = cdr(p1);\n      }\n      return;\n    }\n    push_symbol(LOG);\n    push(p1);\n    return list(2);\n  };\n\n  // now this might be a little confusing, so a\n  // clarification is in order.\n  // First off, at the scripting level most things\n  // as they are handled get evalled.\n  // That means that they are recursively \"calculated\"\n  // as much as possible, i.e. variables are recursively\n  // looked up for their values, operators are applied,\n  // functions are ivoked, etc.\n  // I.e. while scripting, most things are\n  // evalled all the times.\n  // e.g. if I type\n  //   x = 1+1\n  // then x is actually assigned 2, not 1+1\n  // Something that helps a little is \"quote\", e.g.\n  // If I assign\n  //   x = quote(1+1)\n  // then x actually contains 1+1, not 2.\n  // But then x is evaluated as soon as I type\n  //   x // gives \"2\" as x is evaluated\n\n  // Evaluation is great, but sometimes one wants\n  // to look at the actual structure of an expression\n  // or a content of a variable, without those\n  // being evaluated first.\n\n  // for example I might type\n  //   x = a + b\n  //   a = 1\n  //   b = 2\n  // and from this point on printing the actual\n  // structure of x is impossible, because from\n  // now on any evaluation of x will give \"3\"\n  // You might say \"but you have x defined up there,\n  // what's the point of printing it out?\", to which\n  // the answer is that one might do further\n  // substitutions or transformations of special kind\n  // to x. One might want to look at the structure\n  // and it might be complex or impossible.\n\n  // So this function does that.\n  // If it's passed a variable, then it\n  // DOES NOT eval the variable, RATHER\n  // it prints the content of the variable without\n  // evaluating it.\n  // In the other cases it works like \"quote\" e.g.\n  // it just gives the argument as is, again without\n  // evaluating it.\n\n  // In the following examples, for brevity, I just\n  // use\n  //   x = quote(1+2)\n  // instead of this:\n  //   x = a + b\n  //   a = 1\n  //   b = 2\n  // to put a structure in x that is easy to see whether\n  // it's avaulated or not.\n\n  // So lookup allows this:\n  //   x = quote(1+2)\n  //   print(lookup(x)) # gives 1+2\n\n  // Note that there would be potentially a way\n  // to achieve a similar result, you could do:\n  //   x = quote(quote(1+2))\n  //   print(x)\n  // but you can't always control x to contain\n  // two quotes like that...\n  // note how two \"quotes\" are needed because\n  // if you just put one, then\n  // x would indeed contain 1+2 instead of 3,\n  // but then print would evaluate that to 3:\n  //   x = quote(1+2) # now x contains 1+2, not 3\n  //   print(x) # but x evaluated here to 3\n\n  // Other workarounds would not work:\n  //   x = quote(1+2)\n  //   print(quote(x))\n  // would not work because quote(x) literally means 'x'\n  // so 'x' is printed instead of its content.\n\n  // Note also that lookup allows you to copy\n  // the structure of a variable to another:\n  //   x = a + b\n  //   a = 1\n  //   b = 2\n  // now:\n  //   y = x # y contains the number 3 and prints to 3\n  //   y = lookup(x) # y contains \"a+b\" and prints to 3\n  //   y = quote(x) # y contains \"x\" and prints to 3\n  // note that in the first and second case y is\n  // independent from x, i.e. changing x doesn't change y\n  // while in the last case it is.\n\n  // Another similar simple example is when doing something\n  // like this:\n  //    x = y\n  //    y = z\n  //    x\n  //       => gives z\n  //    lookup(x)\n  //       => gives y\n  //          i.e. lookup allows you to see the immediate\n  //          content of x, rather than the evaluation which\n  //          would end up in x -> y -> z\n  // Note that if you invert the order of the assignments i.e.\n  //    y = z\n  //    x = y\n  // Then at this point x immediately contains z, since the\n  // assignment x = y is not quoted, hence y is evaluated to z\n  // when assigned to x.\n  //    lookup(x)\n  //       => gives z\n  Eval_lookup = function() {\n    p1 = cadr(p1);\n    if (!iscons(p1) && cadr(p1).k === SYM) {\n      p1 = get_binding(p1);\n    }\n    return push(p1); // Bignum addition and subtraction\n  };\n\n  \n  //static unsigned int *addf(unsigned int *, unsigned int *)\n  //static unsigned int *subf(unsigned int *, unsigned int *)\n  //static int ucmp(unsigned int *, unsigned int *)\n  madd = function(a, b) {\n    return a.add(b);\n  };\n\n  msub = function(a, b) {\n    return a.subtract(b);\n  };\n\n  addf = function(a, b) {\n    return a.add(b);\n  };\n\n  subf = function(a, b) {\n    return a.subtract(b);\n  };\n\n  // unsigned compare\n  ucmp = function(a, b) {\n    return a.compareAbs(b);\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Bignum GCD\n\n  //  Uses the binary GCD algorithm.\n\n  //  See \"The Art of Computer Programming\" p. 338.\n\n  //  mgcd always returns a positive value\n\n  //  mgcd(0, 0) = 0\n\n  //  mgcd(u, 0) = |u|\n\n  //  mgcd(0, v) = |v|\n\n  //-----------------------------------------------------------------------------\n  mgcd = function(u, v) {\n    return bigInt.gcd(u, v);\n  };\n\n  //if SELFTEST\n\n  // s is a string\n  new_string = function(s) {\n    var theNewString;\n    theNewString = new U();\n    theNewString.k = STR;\n    theNewString.str = s;\n    return theNewString;\n  };\n\n  out_of_memory = function() {\n    return stop(\"out of memory\");\n  };\n\n  // both ints\n  push_zero_matrix = function(i, j) {\n    push(alloc_tensor(i * j));\n    stack[tos - 1].tensor.ndim = 2;\n    stack[tos - 1].tensor.dim[0] = i;\n    return stack[tos - 1].tensor.dim[1] = j;\n  };\n\n  push_identity_matrix = function(n) {\n    var i, o, ref;\n    push_zero_matrix(n, n);\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      stack[tos - 1].tensor.elem[i * n + i] = one;\n    }\n    return check_tensor_dimensions(stack[tos - 1]);\n  };\n\n  push_cars = function(p) {\n    var results;\n    results = [];\n    while (iscons(p)) {\n      push(car(p));\n      results.push(p = cdr(p));\n    }\n    return results;\n  };\n\n  // see cmp_expr definition, this\n  // function alone just does simple structure comparison\n  // or compares numbers (either rationals or integers or doubles)\n  // but can't be used alone to test\n  // more complex mathematical equalities...\n  equal = function(p1, p2) {\n    if (cmp_expr(p1, p2) === 0) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  lessp = function(p1, p2) {\n    if (cmp_expr(p1, p2) < 0) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  sign = function(n) {\n    if (n < 0) {\n      return -1;\n    } else if (n > 0) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  // compares whether two expressions\n  // have the same structure.\n  // For example this method alone\n  // would compare \"1+1\" and \"2\"\n  // as different.\n  // It just so happens though that one oftens\n  // evaluates the two sides before passing them\n  // to this function, so chances are that the two\n  // sides have the same normal form.\n  // Even a simple evaluation might not cut it\n  // though... a simplification of both sides\n  // would then help. And even that might not\n  // cut it in some cases...\n  cmp_expr = function(p1, p2) {\n    var n;\n    n = 0;\n    if (p1 === p2) {\n      return 0;\n    }\n    if (p1 === symbol(NIL)) {\n      return -1;\n    }\n    if (p2 === symbol(NIL)) {\n      return 1;\n    }\n    if (isNumericAtom(p1) && isNumericAtom(p2)) {\n      return sign(compare_numbers(p1, p2));\n    }\n    if (isNumericAtom(p1)) {\n      return -1;\n    }\n    if (isNumericAtom(p2)) {\n      return 1;\n    }\n    if (isstr(p1) && isstr(p2)) {\n      return sign(strcmp(p1.str, p2.str));\n    }\n    if (isstr(p1)) {\n      return -1;\n    }\n    if (isstr(p2)) {\n      return 1;\n    }\n    if (issymbol(p1) && issymbol(p2)) {\n      return sign(strcmp(get_printname(p1), get_printname(p2)));\n    }\n    if (issymbol(p1)) {\n      return -1;\n    }\n    if (issymbol(p2)) {\n      return 1;\n    }\n    if (istensor(p1) && istensor(p2)) {\n      return compare_tensors(p1, p2);\n    }\n    if (istensor(p1)) {\n      return -1;\n    }\n    if (istensor(p2)) {\n      return 1;\n    }\n    // recursion here\n    while (iscons(p1) && iscons(p2)) {\n      n = cmp_expr(car(p1), car(p2));\n      if (n !== 0) {\n        return n;\n      }\n      p1 = cdr(p1);\n      p2 = cdr(p2);\n    }\n    if (iscons(p2)) {\n      return -1;\n    }\n    if (iscons(p1)) {\n      return 1;\n    }\n    return 0;\n  };\n\n  length = function(p) {\n    var n;\n    n = 0;\n    while (iscons(p)) {\n      p = cdr(p);\n      n++;\n    }\n    return n;\n  };\n\n  unique = function(p) {\n    save();\n    p1 = symbol(NIL);\n    p2 = symbol(NIL);\n    unique_f(p);\n    if (p2 !== symbol(NIL)) {\n      p1 = symbol(NIL);\n    }\n    p = p1;\n    restore();\n    return p;\n  };\n\n  unique_f = function(p) {\n    if (isstr(p)) {\n      if (p1 === symbol(NIL)) {\n        p1 = p;\n      } else if (p !== p1) {\n        p2 = p;\n      }\n      return;\n    }\n    while (iscons(p)) {\n      unique_f(car(p));\n      if (p2 !== symbol(NIL)) {\n        return;\n      }\n      p = cdr(p);\n    }\n  };\n\n  ssqrt = function() {\n    push_rational(1, 2);\n    return power();\n  };\n\n  yyexpand = function() {\n    var prev_expanding;\n    prev_expanding = expanding;\n    expanding = 1;\n    Eval();\n    return expanding = prev_expanding;\n  };\n\n  exponential = function() {\n    push_symbol(E);\n    swap();\n    return power();\n  };\n\n  square = function() {\n    push_integer(2);\n    return power();\n  };\n\n  //__cmp = (p1, p2) ->\n  //  return cmp_expr(p1, p2)\n\n  // n an integer\n  sort_stack = function(n) {\n    var h, subsetOfStack;\n    //qsort(stack + tos - n, n, sizeof (U *), __cmp)\n    h = tos - n;\n    subsetOfStack = stack.slice(h, h + n);\n    subsetOfStack.sort(cmp_expr);\n    return stack = stack.slice(0, h).concat(subsetOfStack).concat(stack.slice(h + n));\n  };\n\n  $.equal = equal;\n\n  $.length = length;\n\n  // Bignum multiplication and division\n  mmul = function(a, b) {\n    return a.multiply(b);\n  };\n\n  mdiv = function(a, b) {\n    return a.divide(b);\n  };\n\n  // a = a + b\n  /*\n  static void\n  addf(unsigned int *a, unsigned int *b, int len)\n  {\n    int i\n    long long t = 0; # can be signed or unsigned \n    for (i = 0; i < len; i++) {\n      t += (long long) a[i] + b[i]\n      a[i] = (unsigned int) t\n      t >>= 32\n    }\n  }\n\n  // a = a - b\n\n  static void\n  subf(unsigned int *a, unsigned int *b, int len)\n  {\n    int i\n    long long t = 0; # must be signed\n    for (i = 0; i < len; i++) {\n      t += (long long) a[i] - b[i]\n      a[i] = (unsigned int) t\n      t >>= 32\n    }\n  }\n\n  // a = b * c\n\n  // 0xffffffff + 0xffffffff * 0xffffffff == 0xffffffff00000000\n\n  static void\n  mulf(unsigned int *a, unsigned int *b, int len, unsigned int c)\n  {\n    int i\n    unsigned long long t = 0; # must be unsigned\n    for (i = 0; i < len; i++) {\n      t += (unsigned long long) b[i] * c\n      a[i] = (unsigned int) t\n      t >>= 32\n    }\n    a[i] = (unsigned int) t\n  }\n  */\n  mmod = function(a, b) {\n    return a.mod(b);\n  };\n\n  // return both quotient and remainder of a/b\n  // we'd have this method as divmod(number)\n  // but obviously doesn't change the passed parameters\n  mdivrem = function(a, b) {\n    var toReturn;\n    toReturn = a.divmod(b);\n    return [toReturn.quotient, toReturn.remainder];\n  };\n\n  //if SELFTEST\n\n  // small integer tests\n  Eval_mod = function() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    return mod();\n  };\n\n  mod = function() {\n    var n;\n    n = 0;\n    save();\n    p2 = pop();\n    p1 = pop();\n    if (isZeroAtomOrTensor(p2)) {\n      stop(\"mod function: divide by zero\");\n    }\n    if (!isNumericAtom(p1) || !isNumericAtom(p2)) {\n      push_symbol(MOD);\n      push(p1);\n      push(p2);\n      list(3);\n      restore();\n      return;\n    }\n    if (isdouble(p1)) {\n      push(p1);\n      n = pop_integer();\n      if (isNaN(n)) {\n        stop(\"mod function: cannot convert float value to integer\");\n      }\n      push_integer(n);\n      p1 = pop();\n    }\n    if (isdouble(p2)) {\n      push(p2);\n      n = pop_integer();\n      if (isNaN(n)) {\n        stop(\"mod function: cannot convert float value to integer\");\n      }\n      push_integer(n);\n      p2 = pop();\n    }\n    if (!isinteger(p1) || !isinteger(p2)) {\n      stop(\"mod function: integer arguments expected\");\n    }\n    p3 = new U();\n    p3.k = NUM;\n    p3.q.a = mmod(p1.q.a, p2.q.a);\n    p3.q.b = mint(1);\n    push(p3);\n    return restore();\n  };\n\n  // Bignum power\n\n  // a is a bigint, n is a small normal int\n  mpow = function(a, n) {\n    return a.pow(n);\n  };\n\n  //if SELFTEST\n\n  // Bignum prime test (returns 1 if prime, 0 if not)\n\n  // Uses Algorithm P (probabilistic primality test) from p. 395 of\n  // \"The Art of Computer Programming, Volume 2\" by Donald E. Knuth.\n  mprime = function(n) {\n    return n.isProbablePrime();\n  };\n\n  //if SELFTEST\n\n  //-----------------------------------------------------------------------------\n\n  //  Bignum root\n\n  //  Returns null pointer if not perfect root.\n\n  //  The sign of the radicand is ignored.\n\n  //-----------------------------------------------------------------------------\n  mroot = function(n, index) {\n    var i, j, k, o, ref, x, y;\n    // this doesn't quite work\n    //return n.pow(1/index +  0.0000000000000001)\n\n    // sign of radicand ignored\n    n = n.abs();\n    i = 0;\n    j = 0;\n    k = 0;\n    if (index === 0) {\n      stop(\"root index is zero\");\n    }\n    // count number of bits\n    k = 0;\n    while (n.shiftRight(k) > 0) {\n      k++;\n    }\n    if (k === 0) {\n      return mint(0);\n    }\n    // initial guess\n    k = Math.floor((k - 1) / index);\n    j = Math.floor(k / 32 + 1);\n    x = bigInt(j);\n    for (i = o = 0, ref = j; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      // zero-out the ith bit\n      x = x.and(bigInt(1).shiftLeft(i).not());\n    }\n    while (k >= 0) {\n      // set the kth bit\n      x = x.or(bigInt(1).shiftLeft(k));\n      y = mpow(x, index);\n      switch (mcmp(y, n)) {\n        case 0:\n          return x;\n        case 1:\n          //mp_clr_bit(x, k)\n          // clear the kth bit\n          x = x.and(bigInt(1).shiftLeft(k).not());\n      }\n      k--;\n    }\n    return 0;\n  };\n\n  //if SELFTEST\n\n  // Symbolic multiplication\n\n  // multiplication is commutative, so it can't be used\n  // e.g. on two matrices.\n  // But it can be used, say, on a scalar and a matrix.,\n  // so the output of a multiplication is not\n  // always a scalar.\n\n  //extern void append(void)\n  //static void parse_p1(void)\n  //static void parse_p2(void)\n  //static void __normalize_radical_factors(int)\n  DEBUG_MULTIPLY = false;\n\n  Eval_multiply = function() {\n    var results;\n    push(cadr(p1));\n    Eval();\n    p1 = cddr(p1);\n    results = [];\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n      multiply();\n      results.push(p1 = cdr(p1));\n    }\n    return results;\n  };\n\n  // this one doesn't eval the factors,\n  // so you pass i*(-1)^(1/2), it wouldnt't\n  // give -1, because i is not evalled\n  multiply = function() {\n    if (esc_flag) {\n      stop(\"escape key stop\");\n    }\n    if (isNumericAtom(stack[tos - 2]) && isNumericAtom(stack[tos - 1])) {\n      return multiply_numbers();\n    } else {\n      save();\n      yymultiply();\n      return restore();\n    }\n  };\n\n  yymultiply = function() {\n    var h, i, n, o, ref, ref1;\n    h = 0;\n    i = 0;\n    n = 0;\n    // pop operands\n    p2 = pop();\n    p1 = pop();\n    h = tos;\n    // is either operand zero?\n    if (isZeroAtom(p1) || isZeroAtom(p2)) {\n      if (evaluatingAsFloats) {\n        push_double(0.0);\n      } else {\n        push(zero);\n      }\n      return;\n    }\n    // is either operand a sum?\n\n    //console.log(\"yymultiply: expanding: \" + expanding)\n    if (expanding && isadd(p1)) {\n      p1 = cdr(p1);\n      if (evaluatingAsFloats) {\n        push_double(0.0);\n      } else {\n        push(zero);\n      }\n      while (iscons(p1)) {\n        push(car(p1));\n        push(p2);\n        multiply();\n        add();\n        p1 = cdr(p1);\n      }\n      return;\n    }\n    if (expanding && isadd(p2)) {\n      p2 = cdr(p2);\n      if (evaluatingAsFloats) {\n        push_double(0.0);\n      } else {\n        push(zero);\n      }\n      while (iscons(p2)) {\n        push(p1);\n        push(car(p2));\n        multiply();\n        add();\n        p2 = cdr(p2);\n      }\n      return;\n    }\n    if (!istensor(p1) && istensor(p2)) {\n      push(p1);\n      push(p2);\n      scalar_times_tensor();\n      return;\n    }\n    // tensor times scalar?\n    if (istensor(p1) && !istensor(p2)) {\n      push(p1);\n      push(p2);\n      tensor_times_scalar();\n      return;\n    }\n    // adjust operands\n    if (car(p1) === symbol(MULTIPLY)) {\n      p1 = cdr(p1);\n    } else {\n      push(p1);\n      list(1);\n      p1 = pop();\n    }\n    if (car(p2) === symbol(MULTIPLY)) {\n      p2 = cdr(p2);\n    } else {\n      push(p2);\n      list(1);\n      p2 = pop();\n    }\n    // handle numerical coefficients\n    if (isNumericAtom(car(p1)) && isNumericAtom(car(p2))) {\n      push(car(p1));\n      push(car(p2));\n      multiply_numbers();\n      p1 = cdr(p1);\n      p2 = cdr(p2);\n    } else if (isNumericAtom(car(p1))) {\n      push(car(p1));\n      p1 = cdr(p1);\n    } else if (isNumericAtom(car(p2))) {\n      push(car(p2));\n      p2 = cdr(p2);\n    } else {\n      if (evaluatingAsFloats) {\n        push_double(1.0);\n      } else {\n        push(one);\n      }\n    }\n    parse_p1();\n    parse_p2();\n    while (iscons(p1) && iscons(p2)) {\n      //    if (car(p1)->gamma && car(p2)->gamma) {\n      //      combine_gammas(h)\n      //      p1 = cdr(p1)\n      //      p2 = cdr(p2)\n      //      parse_p1()\n      //      parse_p2()\n      //      continue\n      //    }\n      if (caar(p1) === symbol(OPERATOR) && caar(p2) === symbol(OPERATOR)) {\n        push_symbol(OPERATOR);\n        push(cdar(p1));\n        push(cdar(p2));\n        append();\n        cons();\n        p1 = cdr(p1);\n        p2 = cdr(p2);\n        parse_p1();\n        parse_p2();\n        continue;\n      }\n      switch (cmp_expr(p3, p4)) {\n        case -1:\n          push(car(p1));\n          p1 = cdr(p1);\n          parse_p1();\n          break;\n        case 1:\n          push(car(p2));\n          p2 = cdr(p2);\n          parse_p2();\n          break;\n        case 0:\n          combine_factors(h);\n          p1 = cdr(p1);\n          p2 = cdr(p2);\n          parse_p1();\n          parse_p2();\n          break;\n        default:\n          stop(\"internal error 2\");\n      }\n    }\n    // push remaining factors, if any\n    while (iscons(p1)) {\n      push(car(p1));\n      p1 = cdr(p1);\n    }\n    while (iscons(p2)) {\n      push(car(p2));\n      p2 = cdr(p2);\n    }\n    // normalize radical factors\n\n    // example: 2*2(-1/2) -> 2^(1/2)\n\n    // must be done after merge because merge may produce radical\n\n    // example: 2^(1/2-a)*2^a -> 2^(1/2)\n    __normalize_radical_factors(h);\n    // this hack should not be necessary, unless power returns a multiply\n\n    //for (i = h; i < tos; i++) {\n    //  if (car(stack[i]) == symbol(MULTIPLY)) {\n    //    multiply_all(tos - h)\n    //    return\n    //  }\n    //}\n    if (expanding) {\n      for (i = o = ref = h, ref1 = tos; (ref <= ref1 ? o < ref1 : o > ref1); i = ref <= ref1 ? ++o : --o) {\n        if (isadd(stack[i])) {\n          multiply_all(tos - h);\n          return;\n        }\n      }\n    }\n    // n is the number of result factors on the stack\n    n = tos - h;\n    if (n === 1) {\n      return;\n    }\n    // discard integer 1\n    if (isrational(stack[h]) && equaln(stack[h], 1)) {\n      if (n === 2) {\n        p7 = pop();\n        pop();\n        push(p7);\n      } else {\n        stack[h] = symbol(MULTIPLY);\n        list(n);\n      }\n      return;\n    }\n    list(n);\n    p7 = pop();\n    push_symbol(MULTIPLY);\n    push(p7);\n    return cons();\n  };\n\n  // Decompose a factor into base and power.\n\n  // input:  car(p1)    factor\n\n  // output:  p3    factor's base\n\n  //    p5    factor's power (possibly 1)\n  parse_p1 = function() {\n    p3 = car(p1);\n    p5 = evaluatingAsFloats ? one_as_double : one;\n    if (car(p3) === symbol(POWER)) {\n      p5 = caddr(p3);\n      return p3 = cadr(p3);\n    }\n  };\n\n  // Decompose a factor into base and power.\n\n  // input:  car(p2)    factor\n\n  // output:  p4    factor's base\n\n  //    p6    factor's power (possibly 1)\n  parse_p2 = function() {\n    p4 = car(p2);\n    p6 = evaluatingAsFloats ? one_as_double : one;\n    if (car(p4) === symbol(POWER)) {\n      p6 = caddr(p4);\n      return p4 = cadr(p4);\n    }\n  };\n\n  // h an integer\n  combine_factors = function(h) {\n    push(p4);\n    push(p5);\n    push(p6);\n    add();\n    power();\n    p7 = pop();\n    if (isNumericAtom(p7)) {\n      push(stack[h]);\n      push(p7);\n      multiply_numbers();\n      return stack[h] = pop();\n    } else if (car(p7) === symbol(MULTIPLY)) {\n      // power can return number * factor (i.e. -1 * i)\n      if (isNumericAtom(cadr(p7)) && cdddr(p7) === symbol(NIL)) {\n        push(stack[h]);\n        push(cadr(p7));\n        multiply_numbers();\n        stack[h] = pop();\n        return push(caddr(p7));\n      } else {\n        return push(p7);\n      }\n    } else {\n      return push(p7);\n    }\n  };\n\n  gp = [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, -6, -7, -8, -3, -4, -5, 13, 14, 15, -16, 9, 10, 11, -12], [0, 0, 6, -1, -11, 10, -2, -15, 14, 12, -5, 4, -9, 16, -8, 7, -13], [0, 0, 7, 11, -1, -9, 15, -2, -13, 5, 12, -3, -10, 8, 16, -6, -14], [0, 0, 8, -10, 9, -1, -14, 13, -2, -4, 3, 12, -11, -7, 6, 16, -15], [0, 0, 3, 2, 15, -14, 1, 11, -10, 16, -8, 7, 13, 12, -5, 4, 9], [0, 0, 4, -15, 2, 13, -11, 1, 9, 8, 16, -6, 14, 5, 12, -3, 10], [0, 0, 5, 14, -13, 2, 10, -9, 1, -7, 6, 16, 15, -4, 3, 12, 11], [0, 0, 13, 12, -5, 4, 16, -8, 7, -1, -11, 10, -3, -2, -15, 14, -6], [0, 0, 14, 5, 12, -3, 8, 16, -6, 11, -1, -9, -4, 15, -2, -13, -7], [0, 0, 15, -4, 3, 12, -7, 6, 16, -10, 9, -1, -5, -14, 13, -2, -8], [0, 0, 16, -9, -10, -11, -13, -14, -15, -3, -4, -5, 1, -6, -7, -8, 2], [0, 0, 9, -16, 8, -7, -12, 5, -4, -2, -15, 14, 6, -1, -11, 10, 3], [0, 0, 10, -8, -16, 6, -5, -12, 3, 15, -2, -13, 7, 11, -1, -9, 4], [0, 0, 11, 7, -6, -16, 4, -3, -12, -14, 13, -2, 8, -10, 9, -1, 5], [0, 0, 12, 13, 14, 15, 9, 10, 11, -6, -7, -8, -2, -3, -4, -5, -1]];\n\n  //if 0\n\n  // h an int\n  combine_gammas = function(h) {\n    var n;\n    n = gp[Math.floor(p1.gamma)][Math.floor(p2.gamma)];\n    if (n < 0) {\n      n = -n;\n      push(stack[h]);\n      negate();\n      stack[h] = pop();\n    }\n    if (n > 1) {\n      return push(_gamma[n]);\n    }\n  };\n\n  // this is useful for example when you are just adding/removing\n  // factors from an already factored quantity.\n  // e.g. if you factored x^2 + 3x + 2 into (x+1)(x+2)\n  // and you want to divide by (x+1) , i.e. you multiply by (x-1)^-1,\n  // then there is no need to expand.\n  multiply_noexpand = function() {\n    var prev_expanding;\n    prev_expanding = expanding;\n    expanding = 0;\n    multiply();\n    return expanding = prev_expanding;\n  };\n\n  // multiply n factors on stack\n\n  // n an integer\n  multiply_all = function(n) {\n    var h, i, o, ref;\n    i = 0;\n    if (n === 1) {\n      return;\n    }\n    if (n === 0) {\n      push(evaluatingAsFloats ? one_as_double : one);\n      return;\n    }\n    h = tos - n;\n    push(stack[h]);\n    for (i = o = 1, ref = n; (1 <= ref ? o < ref : o > ref); i = 1 <= ref ? ++o : --o) {\n      push(stack[h + i]);\n      multiply();\n    }\n    stack[h] = pop();\n    return moveTos(h + 1);\n  };\n\n  // n an integer\n  multiply_all_noexpand = function(n) {\n    var prev_expanding;\n    prev_expanding = expanding;\n    expanding = 0;\n    multiply_all(n);\n    return expanding = prev_expanding;\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Symbolic division, or numeric division if doubles are found.\n\n  //  Input:    Dividend and divisor on stack\n\n  //  Output:    Quotient on stack\n\n  //-----------------------------------------------------------------------------\n  divide = function() {\n    if (isNumericAtom(stack[tos - 2]) && isNumericAtom(stack[tos - 1])) {\n      return divide_numbers();\n    } else {\n      inverse();\n      return multiply();\n    }\n  };\n\n  // this is different from inverse of a matrix (inv)!\n  inverse = function() {\n    if (isNumericAtom(stack[tos - 1])) {\n      return invert_number();\n    } else {\n      push_integer(-1);\n      return power();\n    }\n  };\n\n  reciprocate = function() {\n    return inverse();\n  };\n\n  negate = function() {\n    if (isNumericAtom(stack[tos - 1])) {\n      return negate_number();\n    } else {\n      if (evaluatingAsFloats) {\n        push_double(-1.0);\n      } else {\n        push_integer(-1);\n      }\n      return multiply();\n    }\n  };\n\n  negate_expand = function() {\n    var prev_expanding;\n    prev_expanding = expanding;\n    expanding = 1;\n    negate();\n    return expanding = prev_expanding;\n  };\n\n  negate_noexpand = function() {\n    var prev_expanding;\n    prev_expanding = expanding;\n    expanding = 0;\n    negate();\n    return expanding = prev_expanding;\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Normalize radical factors\n\n  //  Input:    stack[h]  Coefficient factor, possibly 1\n\n  //      stack[h + 1]  Second factor\n\n  //      stack[tos - 1]  Last factor\n\n  //  Output:    Reduced coefficent and normalized radicals (maybe)\n\n  //  Example:  2*2^(-1/2) -> 2^(1/2)\n\n  //  (power number number) is guaranteed to have the following properties:\n\n  //  1. Base is an integer\n\n  //  2. Absolute value of exponent < 1\n\n  //  These properties are assured by the power function.\n\n  //-----------------------------------------------------------------------------\n\n  //define A p1\n  //define B p2\n\n  //define BASE p3\n  //define EXPO p4\n\n  //define TMP p5\n\n  // h is an int\n  __normalize_radical_factors = function(h) {\n    var i, i1, j1, o, ref, ref1, ref2, ref3, ref4, ref5;\n    i = 0;\n    // if coeff is 1 or floating then don't bother\n    if (isplusone(stack[h]) || isminusone(stack[h]) || isdouble(stack[h])) {\n      return;\n    }\n// if no radicals then don't bother\n    for (i = o = ref = h + 1, ref1 = tos; (ref <= ref1 ? o < ref1 : o > ref1); i = ref <= ref1 ? ++o : --o) {\n      if (__is_radical_number(stack[i])) {\n        break;\n      }\n    }\n    if (i === tos) {\n      return;\n    }\n    // ok, try to simplify\n    save();\n    // numerator\n    push(stack[h]);\n    mp_numerator();\n    if (DEBUG_MULTIPLY) {\n      console.log(\"__normalize_radical_factors numerator: \" + stack[tos - 1]);\n    }\n    p1 = pop();\n    for (i = i1 = ref2 = h + 1, ref3 = tos; (ref2 <= ref3 ? i1 < ref3 : i1 > ref3); i = ref2 <= ref3 ? ++i1 : --i1) {\n      if (isplusone(p1) || isminusone(p1)) { // p1 is A\n        break;\n      }\n      if (!__is_radical_number(stack[i])) {\n        continue;\n      }\n      p3 = cadr(stack[i]);\n      p4 = caddr(stack[i]);\n      if (!isnegativenumber(p4)) { //p4 is EXPO\n        continue;\n      }\n      // numerator divisible by p3 (base)?\n      push(p1);\n      push(p3);\n      divide();\n      p5 = pop();\n      if (!isinteger(p5)) { //p5 is TMP\n        continue;\n      }\n      // reduce numerator\n      p1 = p5;\n      push_symbol(POWER);\n      push(p3);\n      push(evaluatingAsFloats ? one_as_double : one);\n      push(p4);\n      add();\n      list(3);\n      stack[i] = pop();\n    }\n    // denominator\n    push(stack[h]);\n    mp_denominator();\n    if (DEBUG_MULTIPLY) {\n      console.log(\"__normalize_radical_factors denominator: \" + stack[tos - 1]);\n    }\n    p2 = pop();\n    for (i = j1 = ref4 = h + 1, ref5 = tos; (ref4 <= ref5 ? j1 < ref5 : j1 > ref5); i = ref4 <= ref5 ? ++j1 : --j1) {\n      if (isplusone(p2)) { // p2 is B\n        break;\n      }\n      if (!__is_radical_number(stack[i])) {\n        continue;\n      }\n      p3 = cadr(stack[i]);\n      p4 = caddr(stack[i]);\n      if (isnegativenumber(p4)) { //p4 is EXPO\n        continue;\n      }\n      // denominator divisible by p3? #p3 is BASE\n      push(p2);\n      push(p3);\n      divide();\n      p5 = pop();\n      if (!isinteger(p5)) { //p5 is TMP\n        continue;\n      }\n      if (DEBUG_MULTIPLY) {\n        console.log(\"__new radical p5: \" + p5.toString());\n      }\n      if (DEBUG_MULTIPLY) {\n        console.log(\"__new radical top stack: \" + stack[tos - 1]);\n      }\n      // reduce denominator\n      p2 = p5;\n      push_symbol(POWER);\n      push(p3);\n      push(p4);\n      if (DEBUG_MULTIPLY) {\n        console.log(\"__new radical p3: \" + p3.toString());\n      }\n      if (DEBUG_MULTIPLY) {\n        console.log(\"__new radical p4: \" + p4.toString());\n      }\n      push(one);\n      subtract();\n      if (dontCreateNewRadicalsInDenominatorWhenEvalingMultiplication) {\n        if (isinteger(p3) && !isinteger(stack[tos - 1]) && isnegativenumber(stack[tos - 1])) {\n          // bail out,\n          // we want to avoid going ahead with the subtraction of\n          // the exponents, because that would turn a perfectly good\n          // integer exponent in the denominator into a fractional one\n          // i.e. a radical.\n          // Note that this only prevents new radicals ending up\n          // in the denominator, it doesn't fix existing ones.\n          pop();\n          pop();\n          pop();\n          push(p1);\n          push(p3);\n          divide();\n          p1 = pop();\n          break;\n        }\n      }\n      if (DEBUG_MULTIPLY) {\n        console.log(\"__new radical exponent: \" + stack[tos - 1]);\n      }\n      list(3);\n      stack[i] = pop();\n    }\n    // reconstitute the coefficient\n    push(p1);\n    push(p2);\n    divide();\n    stack[h] = pop();\n    return restore();\n  };\n\n  // don't include i\n  // p is a U\n  // TODO should this be in is.coffee ?\n  __is_radical_number = function(p) {\n    // don't use i\n    return car(p) === symbol(POWER) && isNumericAtom(cadr(p)) && isfraction(caddr(p)) && !isminusone(cadr(p));\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  > a*hilbert(2)\n  //  ((a,1/2*a),(1/2*a,1/3*a))\n\n  //  Note that \"a\" is presumed to be a scalar. Is this correct?\n\n  //  Yes, because \"*\" has no meaning if \"a\" is a tensor.\n  //  To multiply tensors, \"dot\" or \"outer\" should be used.\n\n  //  > dot(a,hilbert(2))\n  //  dot(a,((1,1/2),(1/2,1/3)))\n\n  //  In this case \"a\" could be a scalar or tensor so the result is not\n  //  expanded.\n\n  //-----------------------------------------------------------------------------\n\n  // find the roots of a polynomial numerically\n  NROOTS_YMAX = 101;\n\n  NROOTS_DELTA = 1.0e-6;\n\n  NROOTS_EPSILON = 1.0e-9;\n\n  NROOTS_ABS = function(z) {\n    return Math.sqrt(z.r * z.r + z.i * z.i);\n  };\n\n  // random between -2 and 2\n  theRandom = 0.0;\n\n  NROOTS_RANDOM = function() {\n    //theRandom += 0.2\n    //return theRandom\n    return 4.0 * Math.random() - 2.0;\n  };\n\n  numericRootOfPolynomial = (function() {\n    class numericRootOfPolynomial {};\n\n    numericRootOfPolynomial.prototype.r = 0.0;\n\n    numericRootOfPolynomial.prototype.i = 0.0;\n\n    return numericRootOfPolynomial;\n\n  }).call(this);\n\n  nroots_a = new numericRootOfPolynomial();\n\n  nroots_b = new numericRootOfPolynomial();\n\n  nroots_x = new numericRootOfPolynomial();\n\n  nroots_y = new numericRootOfPolynomial();\n\n  nroots_fa = new numericRootOfPolynomial();\n\n  nroots_fb = new numericRootOfPolynomial();\n\n  nroots_dx = new numericRootOfPolynomial();\n\n  nroots_df = new numericRootOfPolynomial();\n\n  nroots_c = [];\n\n  for (initNRoots = o = 0, ref = NROOTS_YMAX; (0 <= ref ? o < ref : o > ref); initNRoots = 0 <= ref ? ++o : --o) {\n    nroots_c[initNRoots] = new numericRootOfPolynomial();\n  }\n\n  Eval_nroots = function() {\n    var h, i, i1, j1, k, l1, n, ref1, ref2, ref3;\n    h = 0;\n    i = 0;\n    k = 0;\n    n = 0;\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    p2 = pop();\n    if (p2 === symbol(NIL)) {\n      guess();\n    } else {\n      push(p2);\n    }\n    p2 = pop();\n    p1 = pop();\n    if (!ispolyexpandedform(p1, p2)) {\n      stop(\"nroots: polynomial?\");\n    }\n    // mark the stack\n    h = tos;\n    // get the coefficients\n    n = coeff(p2, p1);\n    if (n > NROOTS_YMAX) {\n      stop(\"nroots: degree?\");\n    }\n// convert the coefficients to real and imaginary doubles\n    for (i = i1 = 0, ref1 = n; (0 <= ref1 ? i1 < ref1 : i1 > ref1); i = 0 <= ref1 ? ++i1 : --i1) {\n      push(stack[h + i]);\n      real();\n      yyfloat();\n      Eval();\n      p1 = pop();\n      push(stack[h + i]);\n      imag();\n      yyfloat();\n      Eval();\n      p2 = pop();\n      if (!isdouble(p1) || !isdouble(p2)) {\n        stop(\"nroots: coefficients?\");\n      }\n      nroots_c[i].r = p1.d;\n      nroots_c[i].i = p2.d;\n    }\n    // pop the coefficients\n    moveTos(h);\n    // n is the number of coefficients, n = deg(p) + 1\n    monic(n);\n    for (k = j1 = ref2 = n; j1 > 1; k = j1 += -1) {\n      findroot(k);\n      if (Math.abs(nroots_a.r) < NROOTS_DELTA) {\n        nroots_a.r = 0.0;\n      }\n      if (Math.abs(nroots_a.i) < NROOTS_DELTA) {\n        nroots_a.i = 0.0;\n      }\n      push_double(nroots_a.r);\n      push_double(nroots_a.i);\n      push(imaginaryunit);\n      multiply();\n      add();\n      NROOTS_divpoly(k);\n    }\n    // now make n equal to the number of roots\n    n = tos - h;\n    if (n > 1) {\n      sort_stack(n);\n      p1 = alloc_tensor(n);\n      p1.tensor.ndim = 1;\n      p1.tensor.dim[0] = n;\n      for (i = l1 = 0, ref3 = n; (0 <= ref3 ? l1 < ref3 : l1 > ref3); i = 0 <= ref3 ? ++l1 : --l1) {\n        p1.tensor.elem[i] = stack[h + i];\n      }\n      moveTos(h);\n      return push(p1);\n    }\n  };\n\n  // divide the polynomial by its leading coefficient\n  monic = function(n) {\n    var i1, k, ref1, t;\n    k = 0;\n    t = 0.0;\n    nroots_y.r = nroots_c[n - 1].r;\n    nroots_y.i = nroots_c[n - 1].i;\n    t = nroots_y.r * nroots_y.r + nroots_y.i * nroots_y.i;\n    for (k = i1 = 0, ref1 = n - 1; (0 <= ref1 ? i1 < ref1 : i1 > ref1); k = 0 <= ref1 ? ++i1 : --i1) {\n      nroots_c[k].r = (nroots_c[k].r * nroots_y.r + nroots_c[k].i * nroots_y.i) / t;\n      nroots_c[k].i = (nroots_c[k].i * nroots_y.r - nroots_c[k].r * nroots_y.i) / t;\n    }\n    nroots_c[n - 1].r = 1.0;\n    return nroots_c[n - 1].i = 0.0;\n  };\n\n  // uses the secant method\n  findroot = function(n) {\n    var i1, j, j1, k, nrabs, t;\n    j = 0;\n    k = 0;\n    t = 0.0;\n    if (NROOTS_ABS(nroots_c[0]) < NROOTS_DELTA) {\n      nroots_a.r = 0.0;\n      nroots_a.i = 0.0;\n      return;\n    }\n    for (j = i1 = 0; i1 < 100; j = ++i1) {\n      nroots_a.r = NROOTS_RANDOM();\n      nroots_a.i = NROOTS_RANDOM();\n      compute_fa(n);\n      nroots_b.r = nroots_a.r;\n      nroots_b.i = nroots_a.i;\n      nroots_fb.r = nroots_fa.r;\n      nroots_fb.i = nroots_fa.i;\n      nroots_a.r = NROOTS_RANDOM();\n      nroots_a.i = NROOTS_RANDOM();\n      for (k = j1 = 0; j1 < 1000; k = ++j1) {\n        compute_fa(n);\n        nrabs = NROOTS_ABS(nroots_fa);\n        if (DEBUG) {\n          console.log(\"nrabs: \" + nrabs);\n        }\n        if (nrabs < NROOTS_EPSILON) {\n          return;\n        }\n        if (NROOTS_ABS(nroots_fa) < NROOTS_ABS(nroots_fb)) {\n          nroots_x.r = nroots_a.r;\n          nroots_x.i = nroots_a.i;\n          nroots_a.r = nroots_b.r;\n          nroots_a.i = nroots_b.i;\n          nroots_b.r = nroots_x.r;\n          nroots_b.i = nroots_x.i;\n          nroots_x.r = nroots_fa.r;\n          nroots_x.i = nroots_fa.i;\n          nroots_fa.r = nroots_fb.r;\n          nroots_fa.i = nroots_fb.i;\n          nroots_fb.r = nroots_x.r;\n          nroots_fb.i = nroots_x.i;\n        }\n        // dx = nroots_b - nroots_a\n        nroots_dx.r = nroots_b.r - nroots_a.r;\n        nroots_dx.i = nroots_b.i - nroots_a.i;\n        // df = fb - fa\n        nroots_df.r = nroots_fb.r - nroots_fa.r;\n        nroots_df.i = nroots_fb.i - nroots_fa.i;\n        // y = dx / df\n        t = nroots_df.r * nroots_df.r + nroots_df.i * nroots_df.i;\n        if (t === 0.0) {\n          break;\n        }\n        nroots_y.r = (nroots_dx.r * nroots_df.r + nroots_dx.i * nroots_df.i) / t;\n        nroots_y.i = (nroots_dx.i * nroots_df.r - nroots_dx.r * nroots_df.i) / t;\n        // a = b - y * fb\n        nroots_a.r = nroots_b.r - (nroots_y.r * nroots_fb.r - nroots_y.i * nroots_fb.i);\n        nroots_a.i = nroots_b.i - (nroots_y.r * nroots_fb.i + nroots_y.i * nroots_fb.r);\n      }\n    }\n    return stop(\"nroots: convergence error\");\n  };\n\n  compute_fa = function(n) {\n    var i1, k, ref1, results, t;\n    k = 0;\n    t = 0.0;\n    // x = a\n    nroots_x.r = nroots_a.r;\n    nroots_x.i = nroots_a.i;\n    // fa = c0 + c1 * x\n    nroots_fa.r = nroots_c[0].r + nroots_c[1].r * nroots_x.r - nroots_c[1].i * nroots_x.i;\n    nroots_fa.i = nroots_c[0].i + nroots_c[1].r * nroots_x.i + nroots_c[1].i * nroots_x.r;\n    results = [];\n    for (k = i1 = 2, ref1 = n; (2 <= ref1 ? i1 < ref1 : i1 > ref1); k = 2 <= ref1 ? ++i1 : --i1) {\n      // x = a * x\n      t = nroots_a.r * nroots_x.r - nroots_a.i * nroots_x.i;\n      nroots_x.i = nroots_a.r * nroots_x.i + nroots_a.i * nroots_x.r;\n      nroots_x.r = t;\n      // fa += c[k] * x\n      nroots_fa.r += nroots_c[k].r * nroots_x.r - nroots_c[k].i * nroots_x.i;\n      results.push(nroots_fa.i += nroots_c[k].r * nroots_x.i + nroots_c[k].i * nroots_x.r);\n    }\n    return results;\n  };\n\n  // divide the polynomial by x - a\n  NROOTS_divpoly = function(n) {\n    var i1, j1, k, ref1, ref2, results;\n    k = 0;\n    for (k = i1 = ref1 = n - 1; (ref1 <= 0 ? i1 < 0 : i1 > 0); k = ref1 <= 0 ? ++i1 : --i1) {\n      nroots_c[k - 1].r += nroots_c[k].r * nroots_a.r - nroots_c[k].i * nroots_a.i;\n      nroots_c[k - 1].i += nroots_c[k].i * nroots_a.r + nroots_c[k].r * nroots_a.i;\n    }\n    if (NROOTS_ABS(nroots_c[0]) > NROOTS_DELTA) {\n      stop(\"nroots: residual error\");\n    }\n    results = [];\n    for (k = j1 = 0, ref2 = n - 1; (0 <= ref2 ? j1 < ref2 : j1 > ref2); k = 0 <= ref2 ? ++j1 : --j1) {\n      nroots_c[k].r = nroots_c[k + 1].r;\n      results.push(nroots_c[k].i = nroots_c[k + 1].i);\n    }\n    return results;\n  };\n\n  Eval_numerator = function() {\n    push(cadr(p1));\n    Eval();\n    return numerator();\n  };\n\n  numerator = function() {\n    var h, theArgument;\n    h = 0;\n    theArgument = pop();\n    if (car(theArgument) === symbol(ADD)) {\n      push(theArgument);\n      //console.trace \"rationalising \"\n      rationalize();\n      theArgument = pop();\n    }\n    //console.log \"rationalised: \" + theArgument\n    if (car(theArgument) === symbol(MULTIPLY) && !isplusone(car(cdr(theArgument)))) {\n      h = tos;\n      theArgument = cdr(theArgument);\n      //console.log \"theArgument inside multiply: \" + theArgument\n      //console.log \"first term: \" + car(theArgument)\n      while (iscons(theArgument)) {\n        push(car(theArgument));\n        numerator();\n        theArgument = cdr(theArgument);\n      }\n      return multiply_all(tos - h);\n    } else if (isrational(theArgument)) {\n      push(theArgument);\n      return mp_numerator();\n    } else if (car(theArgument) === symbol(POWER) && isnegativeterm(caddr(theArgument))) {\n      return push(one);\n    } else {\n      return push(theArgument);\n    }\n  };\n\n  // Outer product of tensors\n  Eval_outer = function() {\n    var results;\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p1 = cdr(p1);\n    results = [];\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n      outer();\n      results.push(p1 = cdr(p1));\n    }\n    return results;\n  };\n\n  outer = function() {\n    save();\n    p2 = pop();\n    p1 = pop();\n    if (istensor(p1) && istensor(p2)) {\n      yyouter();\n    } else {\n      push(p1);\n      push(p2);\n      if (istensor(p1)) {\n        tensor_times_scalar();\n      } else if (istensor(p2)) {\n        scalar_times_tensor();\n      } else {\n        multiply();\n      }\n    }\n    return restore();\n  };\n\n  yyouter = function() {\n    var i, i1, j, j1, k, l1, m1, ndim, nelem, ref1, ref2, ref3, ref4;\n    i = 0;\n    j = 0;\n    k = 0;\n    ndim = 0;\n    nelem = 0;\n    ndim = p1.tensor.ndim + p2.tensor.ndim;\n    if (ndim > MAXDIM) {\n      stop(\"outer: rank of result exceeds maximum\");\n    }\n    nelem = p1.tensor.nelem * p2.tensor.nelem;\n    p3 = alloc_tensor(nelem);\n    p3.tensor.ndim = ndim;\n    for (i = i1 = 0, ref1 = p1.tensor.ndim; (0 <= ref1 ? i1 < ref1 : i1 > ref1); i = 0 <= ref1 ? ++i1 : --i1) {\n      p3.tensor.dim[i] = p1.tensor.dim[i];\n    }\n    j = i;\n    for (i = j1 = 0, ref2 = p2.tensor.ndim; (0 <= ref2 ? j1 < ref2 : j1 > ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n      p3.tensor.dim[j + i] = p2.tensor.dim[i];\n    }\n    k = 0;\n    for (i = l1 = 0, ref3 = p1.tensor.nelem; (0 <= ref3 ? l1 < ref3 : l1 > ref3); i = 0 <= ref3 ? ++l1 : --l1) {\n      for (j = m1 = 0, ref4 = p2.tensor.nelem; (0 <= ref4 ? m1 < ref4 : m1 > ref4); j = 0 <= ref4 ? ++m1 : --m1) {\n        push(p1.tensor.elem[i]);\n        push(p2.tensor.elem[j]);\n        multiply();\n        p3.tensor.elem[k++] = pop();\n      }\n    }\n    return push(p3);\n  };\n\n  partition = function() {\n    save();\n    p2 = pop();\n    p1 = pop();\n    push_integer(1);\n    p3 = pop();\n    p4 = p3;\n    p1 = cdr(p1);\n    while (iscons(p1)) {\n      if (Find(car(p1), p2)) {\n        push(p4);\n        push(car(p1));\n        multiply();\n        p4 = pop();\n      } else {\n        push(p3);\n        push(car(p1));\n        multiply();\n        p3 = pop();\n      }\n      p1 = cdr(p1);\n    }\n    push(p3);\n    push(p4);\n    return restore();\n  };\n\n  /*\n    Add a pattern i.e. a substitution rule.\n    Substitution rule needs a template as first argument\n    and what to transform it to as second argument.\n    Optional third argument is a boolean test which\n    adds conditions to when the rule is applied.\n  */\n  // same as Eval_pattern but only leaves\n  // NIL on stack at return, hence gives no\n  // printout\n  Eval_silentpattern = function() {\n    Eval_pattern();\n    pop();\n    return push_symbol(NIL);\n  };\n\n  Eval_pattern = function() {\n    var firstArgument, patternPosition, secondArgument, stringKey, thirdArgument;\n    if (!iscons(cdr(p1))) {\n      stop(\"pattern needs at least a template and a transformed version\");\n    }\n    firstArgument = car(cdr(p1));\n    secondArgument = car(cdr(cdr(p1)));\n    if (secondArgument === symbol(NIL)) {\n      stop(\"pattern needs at least a template and a transformed version\");\n    }\n    if (!iscons(cdr(cdr(p1)))) {\n      thirdArgument = symbol(NIL);\n    } else {\n      thirdArgument = car(cdr(cdr(cdr(p1))));\n    }\n    if (equal(firstArgument, secondArgument)) {\n      stop(\"recursive pattern\");\n    }\n    // console.log \"Eval_pattern of \" + cdr(p1)\n    // this is likely to create garbage collection\n    // problems in the C version as it's an\n    // untracked reference\n    stringKey = \"template: \" + print_list(firstArgument);\n    stringKey += \" tests: \" + print_list(thirdArgument);\n    if (DEBUG) {\n      console.log(\"pattern stringkey: \" + stringKey);\n    }\n    patternPosition = userSimplificationsInStringForm.indexOf(stringKey);\n    // if pattern is not there yet, add it, otherwise replace it\n    if (patternPosition === -1) {\n      //console.log \"adding pattern because it doesn't exist: \" + cdr(p1)\n      userSimplificationsInStringForm.push(stringKey);\n      userSimplificationsInListForm.push(cdr(p1));\n    } else {\n      if (DEBUG) {\n        console.log(\"pattern already exists, replacing. \" + cdr(p1));\n      }\n      userSimplificationsInStringForm[patternPosition] = stringKey;\n      userSimplificationsInListForm[patternPosition] = cdr(p1);\n    }\n    // return the pattern node itself so we can\n    // give some printout feedback\n    push_symbol(PATTERN);\n    push(cdr(p1));\n    return list(2);\n  };\n\n  do_clearPatterns = function() {\n    userSimplificationsInListForm = [];\n    return userSimplificationsInStringForm = [];\n  };\n\n  Eval_clearpatterns = function() {\n    // this is likely to create garbage collection\n    // problems in the C version as it's an\n    // untracked reference\n    do_clearPatterns();\n    \n    // return nothing\n    return push_symbol(NIL);\n  };\n\n  Eval_patternsinfo = function() {\n    var patternsinfoToBePrinted;\n    patternsinfoToBePrinted = patternsinfo();\n    if (patternsinfoToBePrinted !== \"\") {\n      return push(new_string(patternsinfoToBePrinted));\n    } else {\n      return push_symbol(NIL);\n    }\n  };\n\n  patternsinfo = function() {\n    var i, i1, len, patternsinfoToBePrinted;\n    patternsinfoToBePrinted = \"\";\n    for (i1 = 0, len = userSimplificationsInListForm.length; i1 < len; i1++) {\n      i = userSimplificationsInListForm[i1];\n      patternsinfoToBePrinted += userSimplificationsInListForm + \"\\n\";\n    }\n    return patternsinfoToBePrinted;\n  };\n\n  Eval_polar = function() {\n    push(cadr(p1));\n    Eval();\n    return polar();\n  };\n\n  polar = function() {\n    // there are points where we turn polar\n    // representations into rect, we set a \"stack flag\"\n    // here to avoid that, so we don't undo the\n    // work that we are trying to do.\n    evaluatingPolar++;\n    save();\n    p1 = pop();\n    push(p1);\n    abs();\n    push(imaginaryunit);\n    push(p1);\n    arg();\n    multiply();\n    exponential();\n    multiply();\n    evaluatingPolar--;\n    return restore();\n  };\n\n  // Factor using the Pollard rho method\n  n_factor_number = 0;\n\n  factor_number = function() {\n    var h;\n    h = 0;\n    save();\n    p1 = pop();\n    // 0 or 1?\n    if (equaln(p1, 0) || equaln(p1, 1) || equaln(p1, -1)) {\n      push(p1);\n      restore();\n      return;\n    }\n    n_factor_number = p1.q.a;\n    h = tos;\n    factor_a();\n    if (tos - h > 1) {\n      list(tos - h);\n      push_symbol(MULTIPLY);\n      swap();\n      cons();\n    }\n    return restore();\n  };\n\n  // factor using table look-up, then switch to rho method if necessary\n\n  // From TAOCP Vol. 2 by Knuth, p. 380 (Algorithm A)\n  factor_a = function() {\n    var i1, k;\n    k = 0;\n    if (n_factor_number.isNegative()) {\n      n_factor_number = setSignTo(n_factor_number, 1);\n      push_integer(-1);\n    }\n    for (k = i1 = 0; i1 < 10000; k = ++i1) {\n      try_kth_prime(k);\n      // if n_factor_number is 1 then we're done\n      if (n_factor_number.compare(1) === 0) {\n        return;\n      }\n    }\n    return factor_b();\n  };\n\n  try_kth_prime = function(k) {\n    var count, d, q, r;\n    count = 0;\n    d = mint(primetab[k]);\n    count = 0;\n    while (1) {\n      // if n_factor_number is 1 then we're done\n      if (n_factor_number.compare(1) === 0) {\n        if (count) {\n          push_factor(d, count);\n        }\n        return;\n      }\n      [q, r] = mdivrem(n_factor_number, d);\n      // continue looping while remainder is zero\n      if (r.isZero()) {\n        count++;\n        n_factor_number = q;\n      } else {\n        break;\n      }\n    }\n    if (count) {\n      push_factor(d, count);\n    }\n    // q = n_factor_number/d, hence if q < d then\n    // n_factor_number < d^2 so n_factor_number is prime\n    if (mcmp(q, d) === -1) {\n      push_factor(n_factor_number, 1);\n      return n_factor_number = mint(1);\n    }\n  };\n\n  // From TAOCP Vol. 2 by Knuth, p. 385 (Algorithm B)\n  factor_b = function() {\n    var bigint_one, g, k, l, t, x, xprime;\n    k = 0;\n    l = 0;\n    bigint_one = mint(1);\n    x = mint(5);\n    xprime = mint(2);\n    k = 1;\n    l = 1;\n    while (1) {\n      if (mprime(n_factor_number)) {\n        push_factor(n_factor_number, 1);\n        return 0;\n      }\n      while (1) {\n        if (esc_flag) {\n          stop(\"esc\");\n        }\n        // g = gcd(x' - x, n_factor_number)\n        t = msub(xprime, x);\n        t = setSignTo(t, 1);\n        g = mgcd(t, n_factor_number);\n        if (MEQUAL(g, 1)) {\n          if (--k === 0) {\n            xprime = x;\n            l *= 2;\n            k = l;\n          }\n          // x = (x ^ 2 + 1) mod n_factor_number\n          t = mmul(x, x);\n          x = madd(t, bigint_one);\n          t = mmod(x, n_factor_number);\n          x = t;\n          continue;\n        }\n        push_factor(g, 1);\n        if (mcmp(g, n_factor_number) === 0) {\n          return -1;\n        }\n        // n_factor_number = n_factor_number / g\n        t = mdiv(n_factor_number, g);\n        n_factor_number = t;\n        // x = x mod n_factor_number\n        t = mmod(x, n_factor_number);\n        x = t;\n        // xprime = xprime mod n_factor_number\n        t = mmod(xprime, n_factor_number);\n        xprime = t;\n        break;\n      }\n    }\n  };\n\n  push_factor = function(d, count) {\n    p1 = new U();\n    p1.k = NUM;\n    p1.q.a = d;\n    p1.q.b = mint(1);\n    push(p1);\n    if (count > 1) {\n      push_symbol(POWER);\n      swap();\n      p1 = new U();\n      p1.k = NUM;\n      p1.q.a = mint(count);\n      p1.q.b = mint(1);\n      push(p1);\n      return list(3);\n    }\n  };\n\n  DEBUG_POWER = false;\n\n  Eval_power = function() {\n    if (DEBUG_POWER) {\n      debugger;\n    }\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    return power();\n  };\n\n  power = function() {\n    save();\n    yypower();\n    return restore();\n  };\n\n  yypower = function() {\n    var b_isEven_and_c_isItsInverse, hopefullySimplified, inputBase, inputExp, isThisOne, is_a_moreThanZero, n;\n    if (DEBUG_POWER) {\n      debugger;\n    }\n    n = 0;\n    p2 = pop(); // exponent\n    p1 = pop(); // base\n    inputExp = p2;\n    inputBase = p1;\n    //debugger\n    if (DEBUG_POWER) {\n      console.log(\"POWER: \" + p1 + \" ^ \" + p2);\n    }\n    // first, some very basic simplifications right away\n\n    //  1 ^ a    ->  1\n    //  a ^ 0    ->  1\n    if (equal(p1, one) || isZeroAtomOrTensor(p2)) {\n      if (evaluatingAsFloats) {\n        push_double(1.0);\n      } else {\n        push(one);\n      }\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n      return;\n    }\n    //  a ^ 1    ->  a\n    if (equal(p2, one)) {\n      push(p1);\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n      return;\n    }\n    //   -1 ^ -1    ->  -1\n    if (isminusone(p1) && isminusone(p2)) {\n      if (evaluatingAsFloats) {\n        push_double(1.0);\n      } else {\n        push(one);\n      }\n      negate();\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n      return;\n    }\n    //   -1 ^ 1/2  ->  i\n    if (isminusone(p1) && (isoneovertwo(p2))) {\n      push(imaginaryunit);\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n      return;\n    }\n    //   -1 ^ -1/2  ->  -i\n    if (isminusone(p1) && isminusoneovertwo(p2)) {\n      push(imaginaryunit);\n      negate();\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n      return;\n    }\n    //   -1 ^ rational\n    if (isminusone(p1) && !isdouble(p1) && isrational(p2) && !isinteger(p2) && ispositivenumber(p2) && !evaluatingAsFloats) {\n      if (DEBUG_POWER) {\n        console.log(\"   power: -1 ^ rational\");\n      }\n      if (DEBUG_POWER) {\n        console.log(\" trick: p2.q.a , p2.q.b \" + p2.q.a + \" , \" + p2.q.b);\n      }\n      if (p2.q.a < p2.q.b) {\n        push_symbol(POWER);\n        push(p1);\n        push(p2);\n        list(3);\n      } else {\n        push_symbol(MULTIPLY);\n        push(p1);\n        push_symbol(POWER);\n        push(p1);\n        push_rational(p2.q.a.mod(p2.q.b), p2.q.b);\n        list(3);\n        list(3);\n        if (DEBUG_POWER) {\n          console.log(\" trick applied : \" + stack[tos - 1]);\n        }\n      }\n      // evaluates clock form into\n      // rectangular form. This seems to give\n      // slightly better form to some test results.\n      rect();\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n      return;\n    }\n    // both base and exponent are rational numbers?\n    if (isrational(p1) && isrational(p2)) {\n      if (DEBUG_POWER) {\n        console.log(\"   power: isrational(p1) && isrational(p2)\");\n      }\n      push(p1);\n      push(p2);\n      qpow();\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n      return;\n    }\n    // both base and exponent are either rational or double?\n    if (isNumericAtom(p1) && isNumericAtom(p2)) {\n      if (DEBUG_POWER) {\n        console.log(\"   power: both base and exponent are either rational or double \");\n      }\n      if (DEBUG_POWER) {\n        console.log(\"POWER - isNumericAtom(p1) && isNumericAtom(p2)\");\n      }\n      push(p1);\n      push(p2);\n      dpow();\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n      return;\n    }\n    if (istensor(p1)) {\n      if (DEBUG_POWER) {\n        console.log(\"   power: istensor(p1) \");\n      }\n      power_tensor();\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n      return;\n    }\n    // if we only assume variables to be real, then |a|^2 = a^2\n    // (if x is complex this doesn't hold e.g. i, which makes 1 and -1\n    if (car(p1) === symbol(ABS) && iseveninteger(p2) && !isZeroAtomOrTensor(get_binding(symbol(ASSUME_REAL_VARIABLES)))) {\n      if (DEBUG_POWER) {\n        console.log(\"   power: even power of absolute of real value \");\n      }\n      push(cadr(p1));\n      push(p2);\n      power();\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n      return;\n    }\n    // e^log(...)\n    if (p1 === symbol(E) && car(p2) === symbol(LOG)) {\n      push(cadr(p2));\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n      return;\n    }\n    // e^some_float\n    if (p1 === symbol(E) && isdouble(p2)) {\n      if (DEBUG_POWER) {\n        console.log(\"   power: p1 == symbol(E) && isdouble(p2) \");\n      }\n      push_double(Math.exp(p2.d));\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n      return;\n    }\n    // complex number in exponential form, get it to rectangular\n    // but only if we are not in the process of calculating a polar form,\n    // otherwise we'd just undo the work we want to do\n    if (p1 === symbol(E) && Find(p2, imaginaryunit) !== 0 && Find(p2, symbol(PI)) !== 0 && !evaluatingPolar) {\n      push_symbol(POWER);\n      push(p1);\n      push(p2);\n      list(3);\n      if (DEBUG_POWER) {\n        console.log(\"   power: turning complex exponential to rect: \" + stack[tos - 1]);\n      }\n      rect();\n      hopefullySimplified = pop();\n      if (Find(hopefullySimplified, symbol(PI)) === 0) {\n        if (DEBUG_POWER) {\n          console.log(\"   power: turned complex exponential to rect: \" + hopefullySimplified);\n        }\n        push(hopefullySimplified);\n        return;\n      }\n    }\n    //  (a * b) ^ c  ->  (a ^ c) * (b ^ c)\n    // note that we can't in general do this, for example\n    // sqrt(x*y) != x^(1/2) y^(1/2) (counterexample\" x = -1 and y = -1)\n    // BUT we can carve-out here some cases where this\n    // transformation is correct\n    if (car(p1) === symbol(MULTIPLY) && isinteger(p2)) {\n      if (DEBUG_POWER) {\n        console.log(\"   power: (a * b) ^ c  ->  (a ^ c) * (b ^ c) \");\n      }\n      p1 = cdr(p1);\n      push(car(p1));\n      push(p2);\n      power();\n      p1 = cdr(p1);\n      while (iscons(p1)) {\n        push(car(p1));\n        push(p2);\n        power();\n        multiply();\n        p1 = cdr(p1);\n      }\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n      return;\n    }\n    // (a ^ b) ^ c  ->  a ^ (b * c)\n    // note that we can't in general do this, for example\n    // sqrt(x^y) !=  x^(1/2 y) (counterexample x = -1)\n    // BUT we can carve-out here some cases where this\n    // transformation is correct\n\n    // simple numeric check to see if a is a number > 0\n    is_a_moreThanZero = false;\n    if (isNumericAtom(cadr(p1))) {\n      is_a_moreThanZero = sign(compare_numbers(cadr(p1), zero));\n    }\n    if (car(p1) === symbol(POWER) && (isinteger(p2) || is_a_moreThanZero)) { // when a is >= 0\n      push(cadr(p1));\n      push(caddr(p1));\n      push(p2);\n      multiply();\n      power();\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n      return;\n    }\n    b_isEven_and_c_isItsInverse = false;\n    if (iseveninteger(caddr(p1))) {\n      push(caddr(p1));\n      push(p2);\n      multiply();\n      isThisOne = pop();\n      if (isone(isThisOne)) {\n        b_isEven_and_c_isItsInverse = true;\n      }\n    }\n    if (car(p1) === symbol(POWER) && b_isEven_and_c_isItsInverse) {\n      if (DEBUG_POWER) {\n        console.log(\"   power: car(p1) == symbol(POWER) && b_isEven_and_c_isItsInverse \");\n      }\n      push(cadr(p1));\n      abs();\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n      return;\n    }\n    //  when expanding,\n    //  (a + b) ^ n  ->  (a + b) * (a + b) ...\n    if (expanding && isadd(p1) && isNumericAtom(p2)) {\n      push(p2);\n      n = pop_integer();\n      if (n > 1 && !isNaN(n)) {\n        if (DEBUG_POWER) {\n          console.log(\"   power: expanding && isadd(p1) && isNumericAtom(p2) \");\n        }\n        power_sum(n);\n        if (DEBUG_POWER) {\n          console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n        }\n        return;\n      }\n    }\n    //  sin(x) ^ 2n -> (1 - cos(x) ^ 2) ^ n\n    if (trigmode === 1 && car(p1) === symbol(SIN) && iseveninteger(p2)) {\n      if (DEBUG_POWER) {\n        console.log(\"   power: trigmode == 1 && car(p1) == symbol(SIN) && iseveninteger(p2) \");\n      }\n      push_integer(1);\n      push(cadr(p1));\n      cosine();\n      push_integer(2);\n      power();\n      subtract();\n      push(p2);\n      push_rational(1, 2);\n      multiply();\n      power();\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n      return;\n    }\n    //  cos(x) ^ 2n -> (1 - sin(x) ^ 2) ^ n\n    if (trigmode === 2 && car(p1) === symbol(COS) && iseveninteger(p2)) {\n      if (DEBUG_POWER) {\n        console.log(\"   power: trigmode == 2 && car(p1) == symbol(COS) && iseveninteger(p2) \");\n      }\n      push_integer(1);\n      push(cadr(p1));\n      sine();\n      push_integer(2);\n      power();\n      subtract();\n      push(p2);\n      push_rational(1, 2);\n      multiply();\n      power();\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n      return;\n    }\n    // complex number? (just number, not expression)\n    if (iscomplexnumber(p1)) {\n      if (DEBUG_POWER) {\n        console.log(\" power - handling the case (a + ib) ^ n\");\n      }\n      // integer power?\n\n      // n will be negative here, positive n already handled\n      if (isinteger(p2)) {\n        //               /        \\  n\n        //         -n   |  a - ib  |\n        // (a + ib)   = | -------- |\n        //              |   2   2  |\n        //               \\ a + b  /\n        push(p1);\n        conjugate();\n        p3 = pop();\n        push(p3);\n        // gets the denominator\n        push(p3);\n        push(p1);\n        multiply();\n        divide();\n        if (!isone(p2)) {\n          push(p2);\n          negate();\n          power();\n        }\n        if (DEBUG_POWER) {\n          console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n        }\n        return;\n      }\n      // noninteger or floating power?\n      if (isNumericAtom(p2)) {\n        push(p1);\n        abs();\n        push(p2);\n        power();\n        push_integer(-1);\n        push(p1);\n        arg();\n        push(p2);\n        multiply();\n        if (evaluatingAsFloats || (iscomplexnumberdouble(p1) && isdouble(p2))) {\n          // remember that the \"double\" type is\n          // toxic, i.e. it propagates, so we do\n          // need to evaluate PI to its actual double\n          // value\n          push_double(Math.PI);\n        } else {\n          //console.log(\"power pushing PI when p1 is: \" + p1 + \" and p2 is:\" + p2)\n          push(symbol(PI));\n        }\n        divide();\n        power();\n        multiply();\n        // if we calculate the power making use of arctan:\n        //  * it prevents nested radicals from being simplified\n        //  * results become really hard to manipulate afterwards\n        //  * we can't go back to other forms.\n        // so leave the power as it is.\n        if (avoidCalculatingPowersIntoArctans) {\n          if (Find(stack[tos - 1], symbol(ARCTAN))) {\n            pop();\n            push_symbol(POWER);\n            push(p1);\n            push(p2);\n            list(3);\n          }\n        }\n        if (DEBUG_POWER) {\n          console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n        }\n        return;\n      }\n    }\n    \n    //push(p1)\n    //abs()\n    //push(p2)\n    //power()\n    //push(symbol(E))\n    //push(p1)\n    //arg()\n    //push(p2)\n    //multiply()\n    //push(imaginaryunit)\n    //multiply()\n    //power()\n    //multiply()\n\n    if (simplify_polar()) {\n      if (DEBUG_POWER) {\n        console.log(\"   power: using simplify_polar\");\n      }\n      return;\n    }\n    if (DEBUG_POWER) {\n      console.log(\"   power: nothing can be done \");\n    }\n    push_symbol(POWER);\n    push(p1);\n    push(p2);\n    list(3);\n    if (DEBUG_POWER) {\n      return console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n    }\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Compute the power of a sum\n\n  //  Input:    p1  sum\n\n  //      n  exponent\n\n  //  Output:    Result on stack\n\n  //  Note:\n\n  //  Uses the multinomial series (see Math World)\n\n  //                          n              n!          n1   n2       nk\n  //  (a1 + a2 + ... + ak)  = sum (--------------- a1   a2   ... ak  )\n  //                               n1! n2! ... nk!\n\n  //  The sum is over all n1 ... nk such that n1 + n2 + ... + nk = n.\n\n  //-----------------------------------------------------------------------------\n\n  // first index is the term number 0..k-1, second index is the exponent 0..n\n\n  //define A(i, j) frame[(i) * (n + 1) + (j)]\n  power_sum = function(n) {\n    var a, i, i1, j, j1, k, l1, ref1, ref2, ref3;\n    a = [];\n    i = 0;\n    j = 0;\n    k = 0;\n    // number of terms in the sum\n    k = length(p1) - 1;\n    // local frame\n    push_frame(k * (n + 1));\n    // array of powers\n    p1 = cdr(p1);\n    for (i = i1 = 0, ref1 = k; (0 <= ref1 ? i1 < ref1 : i1 > ref1); i = 0 <= ref1 ? ++i1 : --i1) {\n      for (j = j1 = 0, ref2 = n; (0 <= ref2 ? j1 <= ref2 : j1 >= ref2); j = 0 <= ref2 ? ++j1 : --j1) {\n        push(car(p1));\n        push_integer(j);\n        power();\n        stack[frame + i * (n + 1) + j] = pop();\n      }\n      p1 = cdr(p1);\n    }\n    push_integer(n);\n    factorial();\n    p1 = pop();\n    for (i = l1 = 0, ref3 = k; (0 <= ref3 ? l1 < ref3 : l1 > ref3); i = 0 <= ref3 ? ++l1 : --l1) {\n      a[i] = 0;\n    }\n    push(zero);\n    multinomial_sum(k, n, a, 0, n);\n    return pop_frame(k * (n + 1));\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Compute multinomial sum\n\n  //  Input:    k  number of factors\n\n  //      n  overall exponent\n\n  //      a  partition array\n\n  //      i  partition array index\n\n  //      m  partition remainder\n\n  //      p1  n!\n\n  //      A  factor array\n\n  //  Output:    Result on stack\n\n  //  Note:\n\n  //  Uses recursive descent to fill the partition array.\n\n  //-----------------------------------------------------------------------------\n\n  //int k, int n, int *a, int i, int m\n  multinomial_sum = function(k, n, a, i, m) {\n    var i1, j, j1, l1, ref1, ref2, ref3;\n    j = 0;\n    if (i < k - 1) {\n      for (j = i1 = 0, ref1 = m; (0 <= ref1 ? i1 <= ref1 : i1 >= ref1); j = 0 <= ref1 ? ++i1 : --i1) {\n        a[i] = j;\n        multinomial_sum(k, n, a, i + 1, m - j);\n      }\n      return;\n    }\n    a[i] = m;\n    // coefficient\n    push(p1);\n    for (j = j1 = 0, ref2 = k; (0 <= ref2 ? j1 < ref2 : j1 > ref2); j = 0 <= ref2 ? ++j1 : --j1) {\n      push_integer(a[j]);\n      factorial();\n      divide();\n    }\n// factors\n    for (j = l1 = 0, ref3 = k; (0 <= ref3 ? l1 < ref3 : l1 > ref3); j = 0 <= ref3 ? ++l1 : --l1) {\n      push(stack[frame + j * (n + 1) + a[j]]);\n      multiply();\n    }\n    return add();\n  };\n\n  // exp(n/2 i pi) ?\n\n  // p2 is the exponent expression\n\n  // clobbers p3\n  simplify_polar = function() {\n    var doNothing, n;\n    n = 0;\n    n = isquarterturn(p2);\n    switch (n) {\n      case 0:\n        doNothing = 1;\n        break;\n      case 1:\n        push_integer(1);\n        return 1;\n      case 2:\n        push_integer(-1);\n        return 1;\n      case 3:\n        push(imaginaryunit);\n        return 1;\n      case 4:\n        push(imaginaryunit);\n        negate();\n        return 1;\n    }\n    if (car(p2) === symbol(ADD)) {\n      p3 = cdr(p2);\n      while (iscons(p3)) {\n        n = isquarterturn(car(p3));\n        if (n) {\n          break;\n        }\n        p3 = cdr(p3);\n      }\n      switch (n) {\n        case 0:\n          return 0;\n        case 1:\n          push_integer(1);\n          break;\n        case 2:\n          push_integer(-1);\n          break;\n        case 3:\n          push(imaginaryunit);\n          break;\n        case 4:\n          push(imaginaryunit);\n          negate();\n      }\n      push(p2);\n      push(car(p3));\n      subtract();\n      exponential();\n      multiply();\n      return 1;\n    }\n    return 0;\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Look up the nth prime\n\n  //  Input:    n on stack (0 < n < 10001)\n\n  //  Output:    nth prime on stack\n\n  //-----------------------------------------------------------------------------\n  Eval_prime = function() {\n    push(cadr(p1));\n    Eval();\n    return prime();\n  };\n\n  prime = function() {\n    var n;\n    n = 0;\n    n = pop_integer();\n    if (n < 1 || n > MAXPRIMETAB) {\n      stop(\"prime: Argument out of range.\");\n    }\n    n = primetab[n - 1];\n    return push_integer(n);\n  };\n\n  power_str = \"^\";\n\n  codeGen = false;\n\n  // this is only invoked when user invokes\n  // \"print\" explicitly\n  Eval_print = function() {\n    stringsEmittedByUserPrintouts += _print(cdr(p1), printMode);\n    return push(symbol(NIL));\n  };\n\n  // this is only invoked when user invokes\n  // \"print2dascii\" explicitly\n  Eval_print2dascii = function() {\n    stringsEmittedByUserPrintouts += _print(cdr(p1), PRINTMODE_2DASCII);\n    return push(symbol(NIL));\n  };\n\n  // this is only invoked when user invokes\n  // \"printcomputer\" explicitly\n  Eval_printcomputer = function() {\n    stringsEmittedByUserPrintouts += _print(cdr(p1), PRINTMODE_COMPUTER);\n    return push(symbol(NIL));\n  };\n\n  // this is only invoked when user invokes\n  // \"printlatex\" explicitly\n  Eval_printlatex = function() {\n    stringsEmittedByUserPrintouts += _print(cdr(p1), PRINTMODE_LATEX);\n    return push(symbol(NIL));\n  };\n\n  // this is only invoked when user invokes\n  // \"printhuman\" explicitly\n  Eval_printhuman = function() {\n    var original_test_flag;\n    // test flag needs to be suspended\n    // because otherwise \"printcomputer\" mode\n    // will happen.\n    original_test_flag = test_flag;\n    test_flag = 0;\n    stringsEmittedByUserPrintouts += _print(cdr(p1), PRINTMODE_HUMAN);\n    test_flag = original_test_flag;\n    return push(symbol(NIL));\n  };\n\n  // this is only invoked when user invokes\n  // \"printlist\" explicitly\n  Eval_printlist = function() {\n    var beenPrinted;\n    beenPrinted = _print(cdr(p1), PRINTMODE_LIST);\n    stringsEmittedByUserPrintouts += beenPrinted;\n    return push(symbol(NIL));\n  };\n\n  _print = function(p, passedPrintMode) {\n    var accumulator, origPrintMode;\n    accumulator = \"\";\n    while (iscons(p)) {\n      push(car(p));\n      Eval();\n      p2 = pop();\n      origPrintMode = printMode;\n      if (passedPrintMode === PRINTMODE_COMPUTER) {\n        printMode = PRINTMODE_COMPUTER;\n        accumulator = printline(p2);\n        rememberPrint(accumulator, LAST_FULL_PRINT);\n      } else if (passedPrintMode === PRINTMODE_HUMAN) {\n        printMode = PRINTMODE_HUMAN;\n        accumulator = printline(p2);\n        rememberPrint(accumulator, LAST_PLAIN_PRINT);\n      } else if (passedPrintMode === PRINTMODE_2DASCII) {\n        printMode = PRINTMODE_2DASCII;\n        accumulator = print2dascii(p2);\n        rememberPrint(accumulator, LAST_2DASCII_PRINT);\n      } else if (passedPrintMode === PRINTMODE_LATEX) {\n        printMode = PRINTMODE_LATEX;\n        accumulator = printline(p2);\n        rememberPrint(accumulator, LAST_LATEX_PRINT);\n      } else if (passedPrintMode === PRINTMODE_LIST) {\n        printMode = PRINTMODE_LIST;\n        accumulator = print_list(p2);\n        rememberPrint(accumulator, LAST_LIST_PRINT);\n      }\n      printMode = origPrintMode;\n      p = cdr(p);\n    }\n    if (DEBUG) {\n      console.log(\"emttedString from display: \" + stringsEmittedByUserPrintouts);\n    }\n    return accumulator;\n  };\n\n  rememberPrint = function(theString, theTypeOfPrint) {\n    var parsedString;\n    scan('\"' + theString + '\"');\n    parsedString = pop();\n    return set_binding(symbol(theTypeOfPrint), parsedString);\n  };\n\n  print_str = function(s) {\n    if (DEBUG) {\n      console.log(\"emttedString from print_str: \" + stringsEmittedByUserPrintouts);\n    }\n    return s;\n  };\n\n  print_char = function(c) {\n    return c;\n  };\n\n  collectLatexStringFromReturnValue = function(p) {\n    var origPrintMode, originalCodeGen, returnedString;\n    origPrintMode = printMode;\n    printMode = PRINTMODE_LATEX;\n    originalCodeGen = codeGen;\n    codeGen = false;\n    returnedString = print_expr(p);\n    // some variables might contain underscores, escape those\n    returnedString = returnedString.replace(/_/g, \"\\\\_\");\n    printMode = origPrintMode;\n    codeGen = originalCodeGen;\n    if (DEBUG) {\n      console.log(\"emttedString from collectLatexStringFromReturnValue: \" + stringsEmittedByUserPrintouts);\n    }\n    return returnedString;\n  };\n\n  printline = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_expr(p);\n    return accumulator;\n  };\n\n  print_base_of_denom = function(p1) {\n    var accumulator;\n    accumulator = \"\";\n    if (isfraction(p1) || car(p1) === symbol(ADD) || car(p1) === symbol(MULTIPLY) || car(p1) === symbol(POWER) || lessp(p1, zero)) { // p1 is BASE\n      accumulator += print_char('(');\n      accumulator += print_expr(p1);\n      accumulator += print_char(')');\n    } else {\n      accumulator += print_expr(p1); // p1 is BASE\n    }\n    return accumulator;\n  };\n\n  print_expo_of_denom = function(p2) {\n    var accumulator;\n    accumulator = \"\";\n    if (isfraction(p2) || car(p2) === symbol(ADD) || car(p2) === symbol(MULTIPLY) || car(p2) === symbol(POWER)) { // p2 is EXPO\n      accumulator += print_char('(');\n      accumulator += print_expr(p2);\n      accumulator += print_char(')');\n    } else {\n      accumulator += print_expr(p2); // p2 is EXPO\n    }\n    return accumulator;\n  };\n\n  // prints stuff after the divide symbol \"/\"\n\n  // d is the number of denominators\n\n  //define BASE p1\n  //define EXPO p2\n  print_denom = function(p, d) {\n    var accumulator;\n    accumulator = \"\";\n    save();\n    p1 = cadr(p);\n    p2 = caddr(p);\n    if (isminusone(p2)) { // p2 is EXPO\n      accumulator += print_base_of_denom(p1);\n      restore();\n      return accumulator;\n    }\n    if (d === 1) { // p2 is EXPO\n      accumulator += print_char('(');\n    }\n    // prepare the exponent\n    // (needs to be negated)\n    // before printing it out\n    push(p2);\n    negate();\n    p2 = pop();\n    accumulator += print_power(p1, p2);\n    if (d === 1) {\n      accumulator += print_char(')');\n    }\n    restore();\n    return accumulator;\n  };\n\n  //define A p3\n  //define B p4\n  print_a_over_b = function(p) {\n    var accumulator, d, doNothing, n;\n    accumulator = \"\";\n    flag = 0;\n    n = 0;\n    d = 0;\n    save();\n    // count numerators and denominators\n    n = 0;\n    d = 0;\n    p1 = cdr(p);\n    p2 = car(p1);\n    if (isrational(p2)) {\n      push(p2);\n      mp_numerator();\n      absval();\n      p3 = pop();\n      push(p2);\n      mp_denominator();\n      p4 = pop();\n      if (!isplusone(p3)) { // p3 is A\n        n++;\n      }\n      if (!isplusone(p4)) { // p4 is B\n        d++;\n      }\n      p1 = cdr(p1);\n    } else {\n      p3 = one;\n      p4 = one; // p4 is B\n    }\n    while (iscons(p1)) {\n      p2 = car(p1);\n      if (is_denominator(p2)) {\n        d++;\n      } else {\n        n++;\n      }\n      p1 = cdr(p1);\n    }\n    //debugger\n    if (printMode === PRINTMODE_LATEX) {\n      accumulator += print_str('\\\\frac{');\n    }\n    if (n === 0) {\n      accumulator += print_char('1');\n    } else {\n      flag = 0;\n      p1 = cdr(p);\n      if (isrational(car(p1))) {\n        p1 = cdr(p1);\n      }\n      if (!isplusone(p3)) { // p3 is A\n        accumulator += print_factor(p3);\n        flag = 1;\n      }\n      while (iscons(p1)) {\n        p2 = car(p1);\n        if (is_denominator(p2)) {\n          doNothing = 1;\n        } else {\n          if (flag) {\n            accumulator += print_multiply_sign();\n          }\n          accumulator += print_factor(p2);\n          flag = 1;\n        }\n        p1 = cdr(p1);\n      }\n    }\n    if (printMode === PRINTMODE_LATEX) {\n      accumulator += print_str('}{');\n    } else if (printMode === PRINTMODE_HUMAN && !test_flag) {\n      accumulator += print_str(\" / \");\n    } else {\n      accumulator += print_str(\"/\");\n    }\n    if (d > 1 && printMode !== PRINTMODE_LATEX) {\n      accumulator += print_char('(');\n    }\n    flag = 0;\n    p1 = cdr(p);\n    if (isrational(car(p1))) {\n      p1 = cdr(p1);\n    }\n    if (!isplusone(p4)) { // p4 is B\n      accumulator += print_factor(p4);\n      flag = 1;\n    }\n    while (iscons(p1)) {\n      p2 = car(p1);\n      if (is_denominator(p2)) {\n        if (flag) {\n          accumulator += print_multiply_sign();\n        }\n        accumulator += print_denom(p2, d);\n        flag = 1;\n      }\n      p1 = cdr(p1);\n    }\n    if (d > 1 && printMode !== PRINTMODE_LATEX) {\n      accumulator += print_char(')');\n    }\n    if (printMode === PRINTMODE_LATEX) {\n      accumulator += print_str('}');\n    }\n    restore();\n    return accumulator;\n  };\n\n  print_expr = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    if (isadd(p)) {\n      p = cdr(p);\n      if (sign_of_term(car(p)) === '-') {\n        accumulator += print_str(\"-\");\n      }\n      accumulator += print_term(car(p));\n      p = cdr(p);\n      while (iscons(p)) {\n        if (sign_of_term(car(p)) === '+') {\n          if (printMode === PRINTMODE_HUMAN && !test_flag) {\n            accumulator += print_str(\" + \");\n          } else {\n            accumulator += print_str(\"+\");\n          }\n        } else {\n          if (printMode === PRINTMODE_HUMAN && !test_flag) {\n            accumulator += print_str(\" - \");\n          } else {\n            accumulator += print_str(\"-\");\n          }\n        }\n        accumulator += print_term(car(p));\n        p = cdr(p);\n      }\n    } else {\n      if (sign_of_term(p) === '-') {\n        accumulator += print_str(\"-\");\n      }\n      accumulator += print_term(p);\n    }\n    return accumulator;\n  };\n\n  sign_of_term = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    if (car(p) === symbol(MULTIPLY) && isNumericAtom(cadr(p)) && lessp(cadr(p), zero)) {\n      accumulator += '-';\n    } else if (isNumericAtom(p) && lessp(p, zero)) {\n      accumulator += '-';\n    } else {\n      accumulator += '+';\n    }\n    return accumulator;\n  };\n\n  print_term = function(p) {\n    var accumulator, denom, numberOneOverSomething, origAccumulator, previousFactorWasANumber;\n    accumulator = \"\";\n    if (car(p) === symbol(MULTIPLY) && any_denominators(p)) {\n      accumulator += print_a_over_b(p);\n      return accumulator;\n    }\n    if (car(p) === symbol(MULTIPLY)) {\n      p = cdr(p);\n      // coeff -1?\n      if (isminusone(car(p))) {\n        //      print_char('-')\n        p = cdr(p);\n      }\n      previousFactorWasANumber = false;\n      // print the first factor ------------\n      if (isNumericAtom(car(p))) {\n        previousFactorWasANumber = true;\n      }\n      // this numberOneOverSomething thing is so that\n      // we show things of the form\n      //   numericFractionOfForm1/something * somethingElse\n      // as\n      //   somethingElse / something\n      // so for example 1/2 * sqrt(2) is rendered as\n      //   sqrt(2)/2\n      // rather than the first form, which looks confusing.\n      // NOTE that you might want to avoid this\n      // when printing polynomials, as it could be nicer\n      // to show the numeric coefficients well separated from\n      // the variable, but we'll see when we'll\n      // come to it if it's an issue.\n      numberOneOverSomething = false;\n      if (printMode === PRINTMODE_LATEX && iscons(cdr(p)) && isNumberOneOverSomething(car(p))) {\n        numberOneOverSomething = true;\n        denom = car(p).q.b.toString();\n      }\n      if (numberOneOverSomething) {\n        origAccumulator = accumulator;\n        accumulator = \"\";\n      } else {\n        accumulator += print_factor(car(p));\n      }\n      p = cdr(p);\n      // print all the other factors -------\n      while (iscons(p)) {\n        // check if we end up having a case where two numbers\n        // are next to each other. In those cases, latex needs\n        // to insert a \\cdot otherwise they end up\n        // right next to each other and read like one big number\n        if (printMode === PRINTMODE_LATEX) {\n          if (previousFactorWasANumber) {\n            // if what comes next is a power and the base\n            // is a number, then we are in the case\n            // of consecutive numbers.\n            // Note that sqrt() i.e when exponent is 1/2\n            // doesn't count because the radical gives\n            // a nice graphical separation already.\n            if (caar(p) === symbol(POWER)) {\n              if (isNumericAtom(car(cdr(car(p))))) {\n                if (!isfraction(car(cdr(cdr(car(p)))))) {\n                  accumulator += \" \\\\cdot \";\n                }\n              }\n            }\n          }\n        }\n        accumulator += print_multiply_sign();\n        accumulator += print_factor(car(p), false, true);\n        previousFactorWasANumber = false;\n        if (isNumericAtom(car(p))) {\n          previousFactorWasANumber = true;\n        }\n        p = cdr(p);\n      }\n      if (numberOneOverSomething) {\n        accumulator = origAccumulator + \"\\\\frac{\" + accumulator + \"}{\" + denom + \"}\";\n      }\n    } else {\n      accumulator += print_factor(p);\n    }\n    return accumulator;\n  };\n\n  print_subexpr = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_char('(');\n    accumulator += print_expr(p);\n    accumulator += print_char(')');\n    return accumulator;\n  };\n\n  print_factorial_function = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    p = cadr(p);\n    if (isfraction(p) || car(p) === symbol(ADD) || car(p) === symbol(MULTIPLY) || car(p) === symbol(POWER) || car(p) === symbol(FACTORIAL)) {\n      accumulator += print_subexpr(p);\n    } else {\n      accumulator += print_expr(p);\n    }\n    accumulator += print_char('!');\n    return accumulator;\n  };\n\n  print_ABS_latex = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_str(\"\\\\left |\");\n    accumulator += print_expr(cadr(p));\n    accumulator += print_str(\" \\\\right |\");\n    return accumulator;\n  };\n\n  print_BINOMIAL_latex = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_str(\"\\\\binom{\");\n    accumulator += print_expr(cadr(p));\n    accumulator += print_str(\"}{\");\n    accumulator += print_expr(caddr(p));\n    accumulator += print_str(\"} \");\n    return accumulator;\n  };\n\n  print_DOT_latex = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_expr(cadr(p));\n    accumulator += print_str(\" \\\\cdot \");\n    accumulator += print_expr(caddr(p));\n    return accumulator;\n  };\n\n  print_DOT_codegen = function(p) {\n    var accumulator;\n    accumulator = \"dot(\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \", \";\n    accumulator += print_expr(caddr(p));\n    accumulator += \")\";\n    return accumulator;\n  };\n\n  print_SIN_codegen = function(p) {\n    var accumulator;\n    accumulator = \"Math.sin(\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \")\";\n    return accumulator;\n  };\n\n  print_COS_codegen = function(p) {\n    var accumulator;\n    accumulator = \"Math.cos(\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \")\";\n    return accumulator;\n  };\n\n  print_TAN_codegen = function(p) {\n    var accumulator;\n    accumulator = \"Math.tan(\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \")\";\n    return accumulator;\n  };\n\n  print_ARCSIN_codegen = function(p) {\n    var accumulator;\n    accumulator = \"Math.asin(\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \")\";\n    return accumulator;\n  };\n\n  print_ARCCOS_codegen = function(p) {\n    var accumulator;\n    accumulator = \"Math.acos(\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \")\";\n    return accumulator;\n  };\n\n  print_ARCTAN_codegen = function(p) {\n    var accumulator;\n    accumulator = \"Math.atan(\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \")\";\n    return accumulator;\n  };\n\n  print_SQRT_latex = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_str(\"\\\\sqrt{\");\n    accumulator += print_expr(cadr(p));\n    accumulator += print_str(\"} \");\n    return accumulator;\n  };\n\n  print_TRANSPOSE_latex = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_str(\"{\");\n    if (iscons(cadr(p))) {\n      accumulator += print_str('(');\n    }\n    accumulator += print_expr(cadr(p));\n    if (iscons(cadr(p))) {\n      accumulator += print_str(')');\n    }\n    accumulator += print_str(\"}\");\n    accumulator += print_str(\"^T\");\n    return accumulator;\n  };\n\n  print_TRANSPOSE_codegen = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_str(\"transpose(\");\n    accumulator += print_expr(cadr(p));\n    accumulator += print_str(')');\n    return accumulator;\n  };\n\n  print_UNIT_codegen = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_str(\"identity(\");\n    accumulator += print_expr(cadr(p));\n    accumulator += print_str(')');\n    return accumulator;\n  };\n\n  print_INV_latex = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_str(\"{\");\n    if (iscons(cadr(p))) {\n      accumulator += print_str('(');\n    }\n    accumulator += print_expr(cadr(p));\n    if (iscons(cadr(p))) {\n      accumulator += print_str(')');\n    }\n    accumulator += print_str(\"}\");\n    accumulator += print_str(\"^{-1}\");\n    return accumulator;\n  };\n\n  print_INV_codegen = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_str(\"inv(\");\n    accumulator += print_expr(cadr(p));\n    accumulator += print_str(')');\n    return accumulator;\n  };\n\n  print_DEFINT_latex = function(p) {\n    var accumulator, functionBody, i, i1, numberOfIntegrals, originalIntegral, ref1, theIntegral, theVariable;\n    accumulator = \"\";\n    functionBody = car(cdr(p));\n    p = cdr(p);\n    originalIntegral = p;\n    numberOfIntegrals = 0;\n    while (iscons(cdr(cdr(p)))) {\n      numberOfIntegrals++;\n      theIntegral = cdr(cdr(p));\n      accumulator += print_str(\"\\\\int^{\");\n      accumulator += print_expr(car(cdr(theIntegral)));\n      accumulator += print_str(\"}_{\");\n      accumulator += print_expr(car(theIntegral));\n      accumulator += print_str(\"} \\\\! \");\n      p = cdr(theIntegral);\n    }\n    accumulator += print_expr(functionBody);\n    accumulator += print_str(\" \\\\,\");\n    p = originalIntegral;\n    for (i = i1 = 1, ref1 = numberOfIntegrals; (1 <= ref1 ? i1 <= ref1 : i1 >= ref1); i = 1 <= ref1 ? ++i1 : --i1) {\n      theVariable = cdr(p);\n      accumulator += print_str(\" \\\\mathrm{d} \");\n      accumulator += print_expr(car(theVariable));\n      if (i < numberOfIntegrals) {\n        accumulator += print_str(\" \\\\, \");\n      }\n      p = cdr(cdr(theVariable));\n    }\n    return accumulator;\n  };\n\n  print_tensor = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_tensor_inner(p, 0, 0)[1];\n    return accumulator;\n  };\n\n  // j scans the dimensions\n  // k is an increment for all the printed elements\n  //   since they are all together in sequence in one array\n  print_tensor_inner = function(p, j, k) {\n    var accumulator, i, i1, j1, ref1, ref2, retString;\n    accumulator = \"\";\n    accumulator += print_str(\"[\");\n    // only the last dimension prints the actual elements\n    // e.g. in a matrix, the first dimension contains\n    // vectors, not elements, and the second dimension\n    // actually contains the elements\n\n    // if not the last dimension, we are just printing wrappers\n    // and recursing down i.e. we print the next dimension\n    if (j < p.tensor.ndim - 1) {\n      for (i = i1 = 0, ref1 = p.tensor.dim[j]; (0 <= ref1 ? i1 < ref1 : i1 > ref1); i = 0 <= ref1 ? ++i1 : --i1) {\n        [k, retString] = print_tensor_inner(p, j + 1, k);\n        accumulator += retString;\n        // add separator between elements dimensions\n        // \"above\" the inner-most dimension\n        if (i !== p.tensor.dim[j] - 1) {\n          accumulator += print_str(\",\");\n        }\n      }\n    } else {\n// if we reached the last dimension, we print the actual\n// elements\n      for (i = j1 = 0, ref2 = p.tensor.dim[j]; (0 <= ref2 ? j1 < ref2 : j1 > ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n        accumulator += print_expr(p.tensor.elem[k]);\n        // add separator between elements in the\n        // inner-most dimension\n        if (i !== p.tensor.dim[j] - 1) {\n          accumulator += print_str(\",\");\n        }\n        k++;\n      }\n    }\n    accumulator += print_str(\"]\");\n    return [k, accumulator];\n  };\n\n  print_tensor_latex = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    if (p.tensor.ndim <= 2) {\n      accumulator += print_tensor_inner_latex(true, p, 0, 0)[1];\n    }\n    return accumulator;\n  };\n\n  // firstLevel is needed because printing a matrix\n  // is not exactly an elegant recursive procedure:\n  // the vector on the first level prints the latex\n  // \"wrap\", while the vectors that make up the\n  // rows don't. so it's a bit asymmetric and this\n  // flag helps.\n  // j scans the dimensions\n  // k is an increment for all the printed elements\n  //   since they are all together in sequence in one array\n  print_tensor_inner_latex = function(firstLevel, p, j, k) {\n    var accumulator, i, i1, j1, ref1, ref2, retString;\n    accumulator = \"\";\n    // open the outer latex wrap\n    if (firstLevel) {\n      accumulator += \"\\\\begin{bmatrix} \";\n    }\n    // only the last dimension prints the actual elements\n    // e.g. in a matrix, the first dimension contains\n    // vectors, not elements, and the second dimension\n    // actually contains the elements\n\n    // if not the last dimension, we are just printing wrappers\n    // and recursing down i.e. we print the next dimension\n    if (j < p.tensor.ndim - 1) {\n      for (i = i1 = 0, ref1 = p.tensor.dim[j]; (0 <= ref1 ? i1 < ref1 : i1 > ref1); i = 0 <= ref1 ? ++i1 : --i1) {\n        [k, retString] = print_tensor_inner_latex(0, p, j + 1, k);\n        accumulator += retString;\n        if (i !== p.tensor.dim[j] - 1) {\n          // add separator between rows\n          accumulator += print_str(\" \\\\\\\\ \");\n        }\n      }\n    } else {\n// if we reached the last dimension, we print the actual\n// elements\n      for (i = j1 = 0, ref2 = p.tensor.dim[j]; (0 <= ref2 ? j1 < ref2 : j1 > ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n        accumulator += print_expr(p.tensor.elem[k]);\n        // separator between elements in each row\n        if (i !== p.tensor.dim[j] - 1) {\n          accumulator += print_str(\" & \");\n        }\n        k++;\n      }\n    }\n    // close the outer latex wrap\n    if (firstLevel) {\n      accumulator += \" \\\\end{bmatrix}\";\n    }\n    return [k, accumulator];\n  };\n\n  print_SUM_latex = function(p) {\n    var accumulator;\n    accumulator = \"\\\\sum_{\";\n    accumulator += print_expr(caddr(p));\n    accumulator += \"=\";\n    accumulator += print_expr(cadddr(p));\n    accumulator += \"}^{\";\n    accumulator += print_expr(caddddr(p));\n    accumulator += \"}{\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \"}\";\n    return accumulator;\n  };\n\n  print_SUM_codegen = function(p) {\n    var accumulator, body, lowerlimit, upperlimit, variable;\n    body = cadr(p);\n    variable = caddr(p);\n    lowerlimit = cadddr(p);\n    upperlimit = caddddr(p);\n    accumulator = \"(function(){\" + \" var \" + variable + \"; \" + \" var holderSum = 0; \" + \" var lowerlimit = \" + print_expr(lowerlimit) + \"; \" + \" var upperlimit = \" + print_expr(upperlimit) + \"; \" + \" for (\" + variable + \" = lowerlimit; \" + variable + \" < upperlimit; \" + variable + \"++) { \" + \"   holderSum += \" + print_expr(body) + \";\" + \" } \" + \" return holderSum;\" + \"})()\";\n    return accumulator;\n  };\n\n  print_TEST_latex = function(p) {\n    var accumulator;\n    accumulator = \"\\\\left\\\\{ \\\\begin{array}{ll}\";\n    p = cdr(p);\n    while (iscons(p)) {\n      // odd number of parameters means that the\n      // last argument becomes the default case\n      // i.e. the one without a test.\n      if (cdr(p) === symbol(NIL)) {\n        accumulator += \"{\";\n        accumulator += print_expr(car(p));\n        accumulator += \"} & otherwise \";\n        accumulator += \" \\\\\\\\\\\\\\\\\";\n        break;\n      }\n      accumulator += \"{\";\n      accumulator += print_expr(cadr(p));\n      accumulator += \"} & if & \";\n      accumulator += print_expr(car(p));\n      accumulator += \" \\\\\\\\\\\\\\\\\";\n      // test unsuccessful, continue to the\n      // next pair of test,value\n      p = cddr(p);\n    }\n    accumulator = accumulator.substring(0, accumulator.length - 4);\n    return accumulator += \"\\\\end{array} \\\\right.\";\n  };\n\n  print_TEST_codegen = function(p) {\n    var accumulator, howManyIfs;\n    accumulator = \"(function(){\";\n    p = cdr(p);\n    howManyIfs = 0;\n    while (iscons(p)) {\n      // odd number of parameters means that the\n      // last argument becomes the default case\n      // i.e. the one without a test.\n      if (cdr(p) === symbol(NIL)) {\n        accumulator += \"else {\";\n        accumulator += \"return (\" + print_expr(car(p)) + \");\";\n        accumulator += \"}\";\n        break;\n      }\n      if (howManyIfs) {\n        accumulator += \" else \";\n      }\n      accumulator += \"if (\" + print_expr(car(p)) + \"){\";\n      accumulator += \"return (\" + print_expr(cadr(p)) + \");\";\n      accumulator += \"}\";\n      // test unsuccessful, continue to the\n      // next pair of test,value\n      howManyIfs++;\n      p = cddr(p);\n    }\n    accumulator += \"})()\";\n    return accumulator;\n  };\n\n  print_TESTLT_latex = function(p) {\n    var accumulator;\n    accumulator = \"{\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \"}\";\n    accumulator += \" < \";\n    accumulator += \"{\";\n    accumulator += print_expr(caddr(p));\n    return accumulator += \"}\";\n  };\n\n  print_TESTLE_latex = function(p) {\n    var accumulator;\n    accumulator = \"{\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \"}\";\n    accumulator += \" \\\\leq \";\n    accumulator += \"{\";\n    accumulator += print_expr(caddr(p));\n    return accumulator += \"}\";\n  };\n\n  print_TESTGT_latex = function(p) {\n    var accumulator;\n    accumulator = \"{\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \"}\";\n    accumulator += \" > \";\n    accumulator += \"{\";\n    accumulator += print_expr(caddr(p));\n    return accumulator += \"}\";\n  };\n\n  print_TESTGE_latex = function(p) {\n    var accumulator;\n    accumulator = \"{\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \"}\";\n    accumulator += \" \\\\geq \";\n    accumulator += \"{\";\n    accumulator += print_expr(caddr(p));\n    return accumulator += \"}\";\n  };\n\n  print_TESTEQ_latex = function(p) {\n    var accumulator;\n    accumulator = \"{\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \"}\";\n    accumulator += \" = \";\n    accumulator += \"{\";\n    accumulator += print_expr(caddr(p));\n    return accumulator += \"}\";\n  };\n\n  print_FOR_codegen = function(p) {\n    var accumulator, body, lowerlimit, upperlimit, variable;\n    body = cadr(p);\n    variable = caddr(p);\n    lowerlimit = cadddr(p);\n    upperlimit = caddddr(p);\n    accumulator = \"(function(){\" + \" var \" + variable + \"; \" + \" var lowerlimit = \" + print_expr(lowerlimit) + \"; \" + \" var upperlimit = \" + print_expr(upperlimit) + \"; \" + \" for (\" + variable + \" = lowerlimit; \" + variable + \" < upperlimit; \" + variable + \"++) { \" + \"   \" + print_expr(body) + \" } \" + \"})()\";\n    return accumulator;\n  };\n\n  print_DO_codegen = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    p = cdr(p);\n    while (iscons(p)) {\n      accumulator += print_expr(car(p));\n      p = cdr(p);\n    }\n    return accumulator;\n  };\n\n  print_SETQ_codegen = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \" = \";\n    accumulator += print_expr(caddr(p));\n    accumulator += \"; \";\n    return accumulator;\n  };\n\n  print_PRODUCT_latex = function(p) {\n    var accumulator;\n    accumulator = \"\\\\prod_{\";\n    accumulator += print_expr(caddr(p));\n    accumulator += \"=\";\n    accumulator += print_expr(cadddr(p));\n    accumulator += \"}^{\";\n    accumulator += print_expr(caddddr(p));\n    accumulator += \"}{\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \"}\";\n    return accumulator;\n  };\n\n  print_PRODUCT_codegen = function(p) {\n    var accumulator, body, lowerlimit, upperlimit, variable;\n    body = cadr(p);\n    variable = caddr(p);\n    lowerlimit = cadddr(p);\n    upperlimit = caddddr(p);\n    accumulator = \"(function(){\" + \" var \" + variable + \"; \" + \" var holderProduct = 1; \" + \" var lowerlimit = \" + print_expr(lowerlimit) + \"; \" + \" var upperlimit = \" + print_expr(upperlimit) + \"; \" + \" for (\" + variable + \" = lowerlimit; \" + variable + \" < upperlimit; \" + variable + \"++) { \" + \"   holderProduct *= \" + print_expr(body) + \";\" + \" } \" + \" return holderProduct;\" + \"})()\";\n    return accumulator;\n  };\n\n  print_base = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    if (isadd(cadr(p)) || caadr(p) === symbol(MULTIPLY) || caadr(p) === symbol(POWER) || isnegativenumber(cadr(p))) {\n      accumulator += print_str('(');\n      accumulator += print_expr(cadr(p));\n      accumulator += print_str(')');\n    } else if (isNumericAtom(cadr(p)) && (lessp(cadr(p), zero) || isfraction(cadr(p)))) {\n      accumulator += print_str('(');\n      accumulator += print_factor(cadr(p));\n      accumulator += print_str(')');\n    } else {\n      accumulator += print_factor(cadr(p));\n    }\n    return accumulator;\n  };\n\n  print_exponent = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    if (iscons(caddr(p)) || isfraction(caddr(p)) || (isNumericAtom(caddr(p)) && lessp(caddr(p), zero))) {\n      accumulator += print_str('(');\n      accumulator += print_expr(caddr(p));\n      accumulator += print_str(')');\n    } else {\n      accumulator += print_factor(caddr(p));\n    }\n    return accumulator;\n  };\n\n  print_power = function(base, exponent) {\n    var accumulator, denomExponent, newExponent, numExponent;\n    accumulator = \"\";\n    //debugger\n    if (DEBUG) {\n      console.log(\"power base: \" + base + \" \" + \" exponent: \" + exponent);\n    }\n    // quick check is this is actually a square root.\n    if (isoneovertwo(exponent)) {\n      if (equaln(base, 2)) {\n        if (codeGen) {\n          accumulator += print_str(\"Math.SQRT2\");\n          return accumulator;\n        }\n      } else {\n        if (printMode === PRINTMODE_LATEX) {\n          accumulator += print_str(\"\\\\sqrt{\");\n          accumulator += print_expr(base);\n          accumulator += print_str(\"}\");\n          return accumulator;\n        } else if (codeGen) {\n          accumulator += print_str(\"Math.sqrt(\");\n          accumulator += print_expr(base);\n          accumulator += print_str(')');\n          return accumulator;\n        }\n      }\n    }\n    if ((equaln(get_binding(symbol(PRINT_LEAVE_E_ALONE)), 1)) && base === symbol(E)) {\n      if (codeGen) {\n        accumulator += print_str(\"Math.exp(\");\n        accumulator += print_expo_of_denom(exponent);\n        accumulator += print_str(')');\n        return accumulator;\n      }\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_str(\"e^{\");\n        accumulator += print_expr(exponent);\n        accumulator += print_str(\"}\");\n      } else {\n        accumulator += print_str(\"exp(\");\n        accumulator += print_expr(exponent);\n        accumulator += print_str(')');\n      }\n      return accumulator;\n    }\n    if (codeGen) {\n      accumulator += print_str(\"Math.pow(\");\n      accumulator += print_base_of_denom(base);\n      accumulator += print_str(\", \");\n      accumulator += print_expo_of_denom(exponent);\n      accumulator += print_str(')');\n      return accumulator;\n    }\n    if ((equaln(get_binding(symbol(PRINT_LEAVE_X_ALONE)), 0)) || base.printname !== \"x\") {\n      // if the exponent is negative then\n      // we invert the base BUT we don't do\n      // that if the base is \"e\", because for\n      // example when trigonometric functions are\n      // expressed in terms of exponential functions\n      // that would be really confusing, one wants to\n      // keep \"e\" as the base and the negative exponent\n      if (base !== symbol(E)) {\n        if (isminusone(exponent)) {\n          if (printMode === PRINTMODE_LATEX) {\n            accumulator += print_str(\"\\\\frac{1}{\");\n          } else if (printMode === PRINTMODE_HUMAN && !test_flag) {\n            accumulator += print_str(\"1 / \");\n          } else {\n            accumulator += print_str(\"1/\");\n          }\n          if (iscons(base) && printMode !== PRINTMODE_LATEX) {\n            accumulator += print_str('(');\n            accumulator += print_expr(base);\n            accumulator += print_str(')');\n          } else {\n            accumulator += print_expr(base);\n          }\n          if (printMode === PRINTMODE_LATEX) {\n            accumulator += print_str(\"}\");\n          }\n          return accumulator;\n        }\n        if (isnegativeterm(exponent)) {\n          if (printMode === PRINTMODE_LATEX) {\n            accumulator += print_str(\"\\\\frac{1}{\");\n          } else if (printMode === PRINTMODE_HUMAN && !test_flag) {\n            accumulator += print_str(\"1 / \");\n          } else {\n            accumulator += print_str(\"1/\");\n          }\n          push(exponent);\n          push_integer(-1);\n          multiply();\n          newExponent = pop();\n          if (iscons(base) && printMode !== PRINTMODE_LATEX) {\n            accumulator += print_str('(');\n            accumulator += print_power(base, newExponent);\n            accumulator += print_str(')');\n          } else {\n            accumulator += print_power(base, newExponent);\n          }\n          if (printMode === PRINTMODE_LATEX) {\n            accumulator += print_str(\"}\");\n          }\n          return accumulator;\n        }\n      }\n      if (isfraction(exponent) && printMode === PRINTMODE_LATEX) {\n        accumulator += print_str(\"\\\\sqrt\");\n        push(exponent);\n        denominator();\n        denomExponent = pop();\n        if (!isplustwo(denomExponent)) {\n          accumulator += print_str(\"[\");\n          accumulator += print_expr(denomExponent);\n          accumulator += print_str(\"]\");\n        }\n        accumulator += print_str(\"{\");\n        push(exponent);\n        numerator();\n        numExponent = pop();\n        exponent = numExponent;\n        accumulator += print_power(base, exponent);\n        accumulator += print_str(\"}\");\n        return accumulator;\n      }\n    }\n    if (printMode === PRINTMODE_LATEX && isplusone(exponent)) {\n      // if we are in latex mode we turn many\n      // radicals into a radix sign with a power\n      // underneath, and the power is often one\n      // (e.g. square root turns into a radical\n      // with a power one underneath) so handle\n      // this case simply here, just print the base\n      accumulator += print_expr(base);\n    } else {\n      // print the base,\n      // determining if it needs to be\n      // wrapped in parentheses or not\n      if (isadd(base) || isnegativenumber(base)) {\n        accumulator += print_str('(');\n        accumulator += print_expr(base);\n        accumulator += print_str(')');\n      } else if (car(base) === symbol(MULTIPLY) || car(base) === symbol(POWER)) {\n        if (printMode !== PRINTMODE_LATEX) {\n          accumulator += print_str('(');\n        }\n        accumulator += print_factor(base, true);\n        if (printMode !== PRINTMODE_LATEX) {\n          accumulator += print_str(')');\n        }\n      } else if (isNumericAtom(base) && (lessp(base, zero) || isfraction(base))) {\n        accumulator += print_str('(');\n        accumulator += print_factor(base);\n        accumulator += print_str(')');\n      } else {\n        accumulator += print_factor(base);\n      }\n      // print the power symbol\n      //debugger\n      if (printMode === PRINTMODE_HUMAN && !test_flag) {\n        //print_str(\" ^ \")\n        accumulator += print_str(power_str);\n      } else {\n        accumulator += print_str(\"^\");\n      }\n      // print the exponent\n      if (printMode === PRINTMODE_LATEX) {\n        // in latex mode, one can omit the curly braces\n        // wrapping the exponent if the exponent is only\n        // one character long\n        if (print_expr(exponent).length > 1) {\n          accumulator += print_str(\"{\");\n          accumulator += print_expr(exponent);\n          accumulator += print_str(\"}\");\n        } else {\n          accumulator += print_expr(exponent);\n        }\n      } else if (iscons(exponent) || isfraction(exponent) || (isNumericAtom(exponent) && lessp(exponent, zero))) {\n        accumulator += print_str('(');\n        accumulator += print_expr(exponent);\n        accumulator += print_str(')');\n      } else {\n        accumulator += print_factor(exponent);\n      }\n    }\n    return accumulator;\n  };\n\n  print_index_function = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    p = cdr(p);\n    if (caar(p) === symbol(ADD) || caar(p) === symbol(MULTIPLY) || caar(p) === symbol(POWER) || caar(p) === symbol(FACTORIAL)) {\n      accumulator += print_subexpr(car(p));\n    } else {\n      accumulator += print_expr(car(p));\n    }\n    accumulator += print_str('[');\n    p = cdr(p);\n    if (iscons(p)) {\n      accumulator += print_expr(car(p));\n      p = cdr(p);\n      while (iscons(p)) {\n        accumulator += print_str(',');\n        accumulator += print_expr(car(p));\n        p = cdr(p);\n      }\n    }\n    accumulator += print_str(']');\n    return accumulator;\n  };\n\n  print_factor = function(p, omitParens, pastFirstFactor) {\n    var accumulator, base, exponent, fbody, parameters, returned;\n    // debugger\n    accumulator = \"\";\n    if (isNumericAtom(p)) {\n      // in an evaluated term, all the numeric parts\n      // are at the beginning of the term.\n      // When printing the EXPRESSION,\n      // we peek into the first factor of the term and we\n      // look at whether it's a number less then zero.\n      // if it is, we print the \"-\" as the \"leading\" part of the\n      // print of the EXPRESSION, and then we proceed printint the factors\n      // of the term. This means that when we come here, we must\n      // skip printing the minus if the number is negative,\n      // because it's already been printed.\n      if (pastFirstFactor && lessp(p, zero)) {\n        accumulator += '(';\n      }\n      accumulator += print_number(p, pastFirstFactor);\n      if (pastFirstFactor && lessp(p, zero)) {\n        accumulator += ')';\n      }\n      return accumulator;\n    }\n    if (isstr(p)) {\n      accumulator += print_str(\"\\\"\");\n      accumulator += print_str(p.str);\n      accumulator += print_str(\"\\\"\");\n      return accumulator;\n    }\n    if (istensor(p)) {\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_tensor_latex(p);\n      } else {\n        accumulator += print_tensor(p);\n      }\n      return accumulator;\n    }\n    if (car(p) === symbol(MULTIPLY)) {\n      if (!omitParens) {\n        if (sign_of_term(p) === '-' || printMode !== PRINTMODE_LATEX) {\n          if (printMode === PRINTMODE_LATEX) {\n            accumulator += print_str(\" \\\\left (\");\n          } else {\n            accumulator += print_str('(');\n          }\n        }\n      }\n      accumulator += print_expr(p);\n      if (!omitParens) {\n        if (sign_of_term(p) === '-' || printMode !== PRINTMODE_LATEX) {\n          if (printMode === PRINTMODE_LATEX) {\n            accumulator += print_str(\" \\\\right ) \");\n          } else {\n            accumulator += print_str(')');\n          }\n        }\n      }\n      return accumulator;\n    } else if (isadd(p)) {\n      if (!omitParens) {\n        accumulator += print_str('(');\n      }\n      accumulator += print_expr(p);\n      if (!omitParens) {\n        accumulator += print_str(')');\n      }\n      return accumulator;\n    }\n    if (car(p) === symbol(POWER)) {\n      base = cadr(p);\n      exponent = caddr(p);\n      accumulator += print_power(base, exponent);\n      return accumulator;\n    }\n    //  if (car(p) == _list) {\n    //    print_str(\"{\")\n    //    p = cdr(p)\n    //    if (iscons(p)) {\n    //      print_expr(car(p))\n    //      p = cdr(p)\n    //    }\n    //    while (iscons(p)) {\n    //      print_str(\",\")\n    //      print_expr(car(p))\n    //      p = cdr(p)\n    //    }\n    //    print_str(\"}\")\n    //    return\n    //  }\n    if (car(p) === symbol(FUNCTION)) {\n      fbody = cadr(p);\n      if (!codeGen) {\n        parameters = caddr(p);\n        accumulator += print_str(\"function \");\n        if (DEBUG) {\n          console.log(\"emittedString from print_factor \" + stringsEmittedByUserPrintouts);\n        }\n        returned = print_list(parameters);\n        accumulator += returned;\n        accumulator += print_str(\" -> \");\n      }\n      accumulator += print_expr(fbody);\n      return accumulator;\n    }\n    if (car(p) === symbol(PATTERN)) {\n      accumulator += print_expr(caadr(p));\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_str(\" \\\\rightarrow \");\n      } else {\n        if (printMode === PRINTMODE_HUMAN && !test_flag) {\n          accumulator += print_str(\" -> \");\n        } else {\n          accumulator += print_str(\"->\");\n        }\n      }\n      accumulator += print_expr(car(cdr(cadr(p))));\n      return accumulator;\n    }\n    if (car(p) === symbol(INDEX) && issymbol(cadr(p))) {\n      accumulator += print_index_function(p);\n      return accumulator;\n    }\n    if (car(p) === symbol(FACTORIAL)) {\n      accumulator += print_factorial_function(p);\n      return accumulator;\n    } else if (car(p) === symbol(ABS) && printMode === PRINTMODE_LATEX) {\n      accumulator += print_ABS_latex(p);\n      return accumulator;\n    } else if (car(p) === symbol(SQRT) && printMode === PRINTMODE_LATEX) {\n      //debugger\n      accumulator += print_SQRT_latex(p);\n      return accumulator;\n    } else if (car(p) === symbol(TRANSPOSE)) {\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_TRANSPOSE_latex(p);\n        return accumulator;\n      } else if (codeGen) {\n        accumulator += print_TRANSPOSE_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(UNIT)) {\n      if (codeGen) {\n        accumulator += print_UNIT_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(INV)) {\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_INV_latex(p);\n        return accumulator;\n      } else if (codeGen) {\n        accumulator += print_INV_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(BINOMIAL) && printMode === PRINTMODE_LATEX) {\n      accumulator += print_BINOMIAL_latex(p);\n      return accumulator;\n    } else if (car(p) === symbol(DEFINT) && printMode === PRINTMODE_LATEX) {\n      accumulator += print_DEFINT_latex(p);\n      return accumulator;\n    } else if (isinnerordot(p)) {\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_DOT_latex(p);\n        return accumulator;\n      } else if (codeGen) {\n        accumulator += print_DOT_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(SIN)) {\n      if (codeGen) {\n        accumulator += print_SIN_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(COS)) {\n      if (codeGen) {\n        accumulator += print_COS_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(TAN)) {\n      if (codeGen) {\n        accumulator += print_TAN_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(ARCSIN)) {\n      if (codeGen) {\n        accumulator += print_ARCSIN_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(ARCCOS)) {\n      if (codeGen) {\n        accumulator += print_ARCCOS_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(ARCTAN)) {\n      if (codeGen) {\n        accumulator += print_ARCTAN_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(SUM)) {\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_SUM_latex(p);\n        return accumulator;\n      } else if (codeGen) {\n        accumulator += print_SUM_codegen(p);\n        return accumulator;\n      }\n    //else if car(p) == symbol(QUOTE)\n    //  if printMode == PRINTMODE_LATEX\n    //    print_expr(cadr(p))\n    //    return accumulator\n    } else if (car(p) === symbol(PRODUCT)) {\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_PRODUCT_latex(p);\n        return accumulator;\n      } else if (codeGen) {\n        accumulator += print_PRODUCT_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(FOR)) {\n      if (codeGen) {\n        accumulator += print_FOR_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(DO)) {\n      if (codeGen) {\n        accumulator += print_DO_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(TEST)) {\n      if (codeGen) {\n        accumulator += print_TEST_codegen(p);\n        return accumulator;\n      }\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_TEST_latex(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(TESTLT)) {\n      if (codeGen) {\n        accumulator += \"((\" + print_expr(cadr(p)) + \") < (\" + print_expr(caddr(p)) + \"))\";\n        return accumulator;\n      }\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_TESTLT_latex(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(TESTLE)) {\n      if (codeGen) {\n        accumulator += \"((\" + print_expr(cadr(p)) + \") <= (\" + print_expr(caddr(p)) + \"))\";\n        return accumulator;\n      }\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_TESTLE_latex(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(TESTGT)) {\n      if (codeGen) {\n        accumulator += \"((\" + print_expr(cadr(p)) + \") > (\" + print_expr(caddr(p)) + \"))\";\n        return accumulator;\n      }\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_TESTGT_latex(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(TESTGE)) {\n      if (codeGen) {\n        accumulator += \"((\" + print_expr(cadr(p)) + \") >= (\" + print_expr(caddr(p)) + \"))\";\n        return accumulator;\n      }\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_TESTGE_latex(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(TESTEQ)) {\n      if (codeGen) {\n        accumulator += \"((\" + print_expr(cadr(p)) + \") === (\" + print_expr(caddr(p)) + \"))\";\n        return accumulator;\n      }\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_TESTEQ_latex(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(FLOOR)) {\n      if (codeGen) {\n        accumulator += \"Math.floor(\" + print_expr(cadr(p)) + \")\";\n        return accumulator;\n      }\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += \" \\\\lfloor {\" + print_expr(cadr(p)) + \"} \\\\rfloor \";\n        return accumulator;\n      }\n    } else if (car(p) === symbol(CEILING)) {\n      if (codeGen) {\n        accumulator += \"Math.ceiling(\" + print_expr(cadr(p)) + \")\";\n        return accumulator;\n      }\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += \" \\\\lceil {\" + print_expr(cadr(p)) + \"} \\\\rceil \";\n        return accumulator;\n      }\n    } else if (car(p) === symbol(ROUND)) {\n      if (codeGen) {\n        accumulator += \"Math.round(\" + print_expr(cadr(p)) + \")\";\n        return accumulator;\n      }\n    } else if (car(p) === symbol(SETQ)) {\n      if (codeGen) {\n        accumulator += print_SETQ_codegen(p);\n        return accumulator;\n      } else {\n        accumulator += print_expr(cadr(p));\n        accumulator += print_str(\"=\");\n        accumulator += print_expr(caddr(p));\n        return accumulator;\n      }\n    }\n    if (iscons(p)) {\n      //if (car(p) == symbol(FORMAL) && cadr(p)->k == SYM) {\n      //  print_str(((struct symbol *) cadr(p))->name)\n      //  return\n      //}\n      accumulator += print_factor(car(p));\n      p = cdr(p);\n      if (!omitParens) {\n        accumulator += print_str('(');\n      }\n      if (iscons(p)) {\n        accumulator += print_expr(car(p));\n        p = cdr(p);\n        while (iscons(p)) {\n          accumulator += print_str(\",\");\n          accumulator += print_expr(car(p));\n          p = cdr(p);\n        }\n      }\n      if (!omitParens) {\n        accumulator += print_str(')');\n      }\n      return accumulator;\n    }\n    if (p === symbol(DERIVATIVE)) {\n      accumulator += print_char('d');\n    } else if (p === symbol(E)) {\n      if (codeGen) {\n        accumulator += print_str(\"Math.E\");\n      } else {\n        accumulator += print_str(\"e\");\n      }\n    } else if (p === symbol(PI)) {\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_str(\"\\\\pi\");\n      } else {\n        accumulator += print_str(\"pi\");\n      }\n    } else {\n      accumulator += print_str(get_printname(p));\n    }\n    return accumulator;\n  };\n\n  print_list = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    switch (p.k) {\n      case CONS:\n        accumulator += '(';\n        accumulator += print_list(car(p));\n        if (p === cdr(p) && p !== symbol(NIL)) {\n          console.log(\"oh no recursive!\");\n          debugger;\n        }\n        p = cdr(p);\n        while (iscons(p)) {\n          accumulator += \" \";\n          accumulator += print_list(car(p));\n          p = cdr(p);\n          if (p === cdr(p) && p !== symbol(NIL)) {\n            console.log(\"oh no recursive!\");\n            debugger;\n          }\n        }\n        if (p !== symbol(NIL)) {\n          accumulator += \" . \";\n          accumulator += print_list(p);\n        }\n        accumulator += ')';\n        break;\n      case STR:\n        //print_str(\"\\\"\")\n        accumulator += p.str;\n        break;\n      //print_str(\"\\\"\")\n      case NUM:\n      case DOUBLE:\n        accumulator += print_number(p, true);\n        break;\n      case SYM:\n        accumulator += get_printname(p);\n        break;\n      default:\n        accumulator += \"<tensor>\";\n    }\n    return accumulator;\n  };\n\n  print_multiply_sign = function() {\n    var accumulator;\n    accumulator = \"\";\n    if (printMode === PRINTMODE_LATEX) {\n      if (printMode === PRINTMODE_HUMAN && !test_flag) {\n        accumulator += print_str(\" \");\n      } else {\n        return accumulator;\n      }\n    }\n    if (printMode === PRINTMODE_HUMAN && !test_flag && !codeGen) {\n      accumulator += print_str(\" \");\n    } else {\n      accumulator += print_str(\"*\");\n    }\n    return accumulator;\n  };\n\n  is_denominator = function(p) {\n    if (car(p) === symbol(POWER) && cadr(p) !== symbol(E) && isnegativeterm(caddr(p))) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  // don't consider the leading fraction\n  // we want 2/3*a*b*c instead of 2*a*b*c/3\n  any_denominators = function(p) {\n    var q;\n    p = cdr(p);\n    //  if (isfraction(car(p)))\n    //    return 1\n    while (iscons(p)) {\n      q = car(p);\n      if (is_denominator(q)) {\n        return 1;\n      }\n      p = cdr(p);\n    }\n    return 0;\n  };\n\n  /*\n\n  Prints in \"2d\", e.g. instead of 1/(x+1)^2 :\n\n        1\n   ----------\n           2\n    (1 + x)\n\n   Note that although this looks more natural, a) it's not parsable and\n   b) it can be occasionally be ambiguous, such as:\n\n     1\n   ----\n     2\n   x\n\n  is 1/x^2 but it also looks a little like x^(1/2)\n\n  */\n  //-----------------------------------------------------------------------------\n\n  //  Examples:\n\n  //     012345678\n  //  -2 .........\n  //  -1 .........\n  //   0 ..hello..  x=2, y=0, h=1, w=5\n  //   1 .........\n  //   2 .........\n\n  //     012345678\n  //  -2 .........\n  //  -1 ..355....\n  //   0 ..---....  x=2, y=-1, h=3, w=3\n  //   1 ..113....\n  //   2 .........\n\n  //-----------------------------------------------------------------------------\n  YMAX = 10000;\n\n  glyph = (function() {\n    class glyph {};\n\n    glyph.prototype.c = 0;\n\n    glyph.prototype.x = 0;\n\n    glyph.prototype.y = 0;\n\n    return glyph;\n\n  }).call(this);\n\n  // will contain glyphs\n  chartab = [];\n\n  for (charTabIndex = i1 = 0, ref1 = YMAX; (0 <= ref1 ? i1 < ref1 : i1 > ref1); charTabIndex = 0 <= ref1 ? ++i1 : --i1) {\n    chartab[charTabIndex] = new glyph();\n  }\n\n  yindex = 0;\n\n  level = 0;\n\n  emit_x = 0;\n\n  expr_level = 0;\n\n  display_flag = 0;\n\n  // this is not really the translated version,\n  // the original is in window.cpp and is\n  // rather more complex\n  printchar_nowrap = function(character) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += character;\n    return accumulator;\n  };\n\n  printchar = function(character) {\n    return printchar_nowrap(character);\n  };\n\n  print2dascii = function(p) {\n    var beenPrinted, h, w, y;\n    h = 0;\n    w = 0;\n    y = 0;\n    save();\n    yindex = 0;\n    level = 0;\n    emit_x = 0;\n    emit_top_expr(p);\n    // if too wide then print flat\n    [h, w, y] = get_size(0, yindex);\n    if (w > 100) {\n      printline(p);\n      restore();\n      return;\n    }\n    beenPrinted = print_glyphs();\n    restore();\n    return beenPrinted;\n  };\n\n  emit_top_expr = function(p) {\n    if (car(p) === symbol(SETQ)) {\n      emit_expr(cadr(p));\n      __emit_str(\" = \");\n      emit_expr(caddr(p));\n      return;\n    }\n    if (istensor(p)) {\n      return emit_tensor(p);\n    } else {\n      return emit_expr(p);\n    }\n  };\n\n  will_be_displayed_as_fraction = function(p) {\n    if (level > 0) {\n      return 0;\n    }\n    if (isfraction(p)) {\n      return 1;\n    }\n    if (car(p) !== symbol(MULTIPLY)) {\n      return 0;\n    }\n    if (isfraction(cadr(p))) {\n      return 1;\n    }\n    while (iscons(p)) {\n      if (isdenominator(car(p))) {\n        return 1;\n      }\n      p = cdr(p);\n    }\n    return 0;\n  };\n\n  emit_expr = function(p) {\n    //  if (level > 0) {\n    //    printexpr(p)\n    //    return\n    //  }\n    expr_level++;\n    if (car(p) === symbol(ADD)) {\n      p = cdr(p);\n      if (__is_negative(car(p))) {\n        __emit_char('-');\n        if (will_be_displayed_as_fraction(car(p))) {\n          __emit_char(' ');\n        }\n      }\n      emit_term(car(p));\n      p = cdr(p);\n      while (iscons(p)) {\n        if (__is_negative(car(p))) {\n          __emit_char(' ');\n          __emit_char('-');\n          __emit_char(' ');\n        } else {\n          __emit_char(' ');\n          __emit_char('+');\n          __emit_char(' ');\n        }\n        emit_term(car(p));\n        p = cdr(p);\n      }\n    } else {\n      if (__is_negative(p)) {\n        __emit_char('-');\n        if (will_be_displayed_as_fraction(p)) {\n          __emit_char(' ');\n        }\n      }\n      emit_term(p);\n    }\n    return expr_level--;\n  };\n\n  emit_unsigned_expr = function(p) {\n    var results;\n    if (car(p) === symbol(ADD)) {\n      p = cdr(p);\n      //    if (__is_negative(car(p)))\n      //      __emit_char('-')\n      emit_term(car(p));\n      p = cdr(p);\n      results = [];\n      while (iscons(p)) {\n        if (__is_negative(car(p))) {\n          __emit_char(' ');\n          __emit_char('-');\n          __emit_char(' ');\n        } else {\n          __emit_char(' ');\n          __emit_char('+');\n          __emit_char(' ');\n        }\n        emit_term(car(p));\n        results.push(p = cdr(p));\n      }\n      return results;\n    } else {\n      //    if (__is_negative(p))\n      //      __emit_char('-')\n      return emit_term(p);\n    }\n  };\n\n  __is_negative = function(p) {\n    if (isnegativenumber(p)) {\n      return 1;\n    }\n    if (car(p) === symbol(MULTIPLY) && isnegativenumber(cadr(p))) {\n      return 1;\n    }\n    return 0;\n  };\n\n  emit_term = function(p) {\n    var n;\n    if (car(p) === symbol(MULTIPLY)) {\n      n = count_denominators(p);\n      if (n && level === 0) {\n        return emit_fraction(p, n);\n      } else {\n        return emit_multiply(p, n);\n      }\n    } else {\n      return emit_factor(p);\n    }\n  };\n\n  isdenominator = function(p) {\n    if (car(p) === symbol(POWER) && cadr(p) !== symbol(E) && __is_negative(caddr(p))) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  count_denominators = function(p) {\n    var count, q;\n    count = 0;\n    p = cdr(p);\n    //  if (isfraction(car(p))) {\n    //    count++\n    //    p = cdr(p)\n    //  }\n    while (iscons(p)) {\n      q = car(p);\n      if (isdenominator(q)) {\n        count++;\n      }\n      p = cdr(p);\n    }\n    return count;\n  };\n\n  // n is the number of denominators, not counting a fraction like 1/2\n  emit_multiply = function(p, n) {\n    var results;\n    if (n === 0) {\n      p = cdr(p);\n      if (isplusone(car(p)) || isminusone(car(p))) {\n        p = cdr(p);\n      }\n      emit_factor(car(p));\n      p = cdr(p);\n      results = [];\n      while (iscons(p)) {\n        __emit_char(' ');\n        emit_factor(car(p));\n        results.push(p = cdr(p));\n      }\n      return results;\n    } else {\n      emit_numerators(p);\n      __emit_char('/');\n      // need grouping if more than one denominator\n      if (n > 1 || isfraction(cadr(p))) {\n        __emit_char('(');\n        emit_denominators(p);\n        return __emit_char(')');\n      } else {\n        return emit_denominators(p);\n      }\n    }\n  };\n\n  //define A p3\n  //define B p4\n\n  // sign of term has already been emitted\n  emit_fraction = function(p, d) {\n    var count, doNothing, k1, k2, n, x;\n    count = 0;\n    k1 = 0;\n    k2 = 0;\n    n = 0;\n    x = 0;\n    save();\n    p3 = one;\n    p4 = one;\n    if (isrational(cadr(p))) {\n      push(cadr(p));\n      mp_numerator();\n      absval();\n      p3 = pop();\n      push(cadr(p));\n      mp_denominator();\n      p4 = pop(); // p4 is B\n    }\n    if (isdouble(cadr(p))) {\n      push(cadr(p));\n      absval();\n      p3 = pop(); // p3 is A\n    }\n    \n    // count numerators\n    if (isplusone(p3)) { // p3 is A\n      n = 0;\n    } else {\n      n = 1;\n    }\n    p1 = cdr(p);\n    if (isNumericAtom(car(p1))) {\n      p1 = cdr(p1);\n    }\n    while (iscons(p1)) {\n      p2 = car(p1);\n      if (isdenominator(p2)) {\n        doNothing = 1;\n      } else {\n        n++;\n      }\n      p1 = cdr(p1);\n    }\n    // emit numerators\n    x = emit_x;\n    k1 = yindex;\n    count = 0;\n    if (!isplusone(p3)) { // p3 is A\n      emit_number(p3, 0);\n      count++;\n    }\n    // skip over \"multiply\"\n    p1 = cdr(p);\n    // skip over numerical coefficient, already handled\n    if (isNumericAtom(car(p1))) {\n      p1 = cdr(p1);\n    }\n    while (iscons(p1)) {\n      p2 = car(p1);\n      if (isdenominator(p2)) {\n        doNothing = 1;\n      } else {\n        if (count > 0) {\n          __emit_char(' ');\n        }\n        if (n === 1) {\n          emit_expr(p2);\n        } else {\n          emit_factor(p2);\n        }\n        count++;\n      }\n      p1 = cdr(p1);\n    }\n    if (count === 0) {\n      __emit_char('1');\n    }\n    // emit denominators\n    k2 = yindex;\n    count = 0;\n    if (!isplusone(p4)) { // p4 is B\n      emit_number(p4, 0);\n      count++;\n      d++;\n    }\n    p1 = cdr(p);\n    if (isrational(car(p1))) {\n      p1 = cdr(p1);\n    }\n    while (iscons(p1)) {\n      p2 = car(p1);\n      if (isdenominator(p2)) {\n        if (count > 0) {\n          __emit_char(' ');\n        }\n        emit_denominator(p2, d);\n        count++;\n      }\n      p1 = cdr(p1);\n    }\n    fixup_fraction(x, k1, k2);\n    return restore();\n  };\n\n  // p points to a multiply\n  emit_numerators = function(p) {\n    var doNothing, n;\n    save();\n    n = 0;\n    p1 = one;\n    p = cdr(p);\n    if (isrational(car(p))) {\n      push(car(p));\n      mp_numerator();\n      absval();\n      p1 = pop();\n      p = cdr(p);\n    } else if (isdouble(car(p))) {\n      push(car(p));\n      absval();\n      p1 = pop();\n      p = cdr(p);\n    }\n    n = 0;\n    if (!isplusone(p1)) {\n      emit_number(p1, 0);\n      n++;\n    }\n    while (iscons(p)) {\n      if (isdenominator(car(p))) {\n        doNothing = 1;\n      } else {\n        if (n > 0) {\n          __emit_char(' ');\n        }\n        emit_factor(car(p));\n        n++;\n      }\n      p = cdr(p);\n    }\n    if (n === 0) {\n      __emit_char('1');\n    }\n    return restore();\n  };\n\n  // p points to a multiply\n  emit_denominators = function(p) {\n    var n;\n    save();\n    n = 0;\n    p = cdr(p);\n    if (isfraction(car(p))) {\n      push(car(p));\n      mp_denominator();\n      p1 = pop();\n      emit_number(p1, 0);\n      n++;\n      p = cdr(p);\n    }\n    while (iscons(p)) {\n      if (isdenominator(car(p))) {\n        if (n > 0) {\n          __emit_char(' ');\n        }\n        emit_denominator(car(p), 0);\n        n++;\n      }\n      p = cdr(p);\n    }\n    return restore();\n  };\n\n  emit_factor = function(p) {\n    if (istensor(p)) {\n      if (level === 0) {\n        //emit_tensor(p)\n        emit_flat_tensor(p);\n      } else {\n        emit_flat_tensor(p);\n      }\n      return;\n    }\n    if (isdouble(p)) {\n      emit_number(p, 0);\n      return;\n    }\n    if (car(p) === symbol(ADD) || car(p) === symbol(MULTIPLY)) {\n      emit_subexpr(p);\n      return;\n    }\n    if (car(p) === symbol(POWER)) {\n      emit_power(p);\n      return;\n    }\n    if (iscons(p)) {\n      //if (car(p) == symbol(FORMAL) && cadr(p).k == SYM)\n      //  emit_symbol(cadr(p))\n      //else\n      emit_function(p);\n      return;\n    }\n    if (isNumericAtom(p)) {\n      if (level === 0) {\n        emit_numerical_fraction(p);\n      } else {\n        emit_number(p, 0);\n      }\n      return;\n    }\n    if (issymbol(p)) {\n      emit_symbol(p);\n      return;\n    }\n    if (isstr(p)) {\n      emit_string(p);\n    }\n  };\n\n  emit_numerical_fraction = function(p) {\n    var k1, k2, x;\n    k1 = 0;\n    k2 = 0;\n    x = 0;\n    save();\n    push(p);\n    mp_numerator();\n    absval();\n    p3 = pop();\n    push(p);\n    mp_denominator();\n    p4 = pop();\n    if (isplusone(p4)) { // p4 is B\n      emit_number(p3, 0);\n      restore();\n      return;\n    }\n    x = emit_x;\n    k1 = yindex;\n    emit_number(p3, 0);\n    k2 = yindex;\n    emit_number(p4, 0); // p4 is B\n    fixup_fraction(x, k1, k2);\n    return restore();\n  };\n\n  // if it's a factor then it doesn't need parens around it, i.e. 1/sin(theta)^2\n  isfactor = function(p) {\n    if (iscons(p) && car(p) !== symbol(ADD) && car(p) !== symbol(MULTIPLY) && car(p) !== symbol(POWER)) {\n      return 1;\n    }\n    if (issymbol(p)) {\n      return 1;\n    }\n    if (isfraction(p)) {\n      return 0;\n    }\n    if (isnegativenumber(p)) {\n      return 0;\n    }\n    if (isNumericAtom(p)) {\n      return 1;\n    }\n    return 0;\n  };\n\n  emit_power = function(p) {\n    var k1, k2, x;\n    k1 = 0;\n    k2 = 0;\n    x = 0;\n    if (cadr(p) === symbol(E)) {\n      __emit_str(\"exp(\");\n      emit_expr(caddr(p));\n      __emit_char(')');\n      return;\n    }\n    if (level > 0) {\n      if (isminusone(caddr(p))) {\n        __emit_char('1');\n        __emit_char('/');\n        if (isfactor(cadr(p))) {\n          emit_factor(cadr(p));\n        } else {\n          emit_subexpr(cadr(p));\n        }\n      } else {\n        if (isfactor(cadr(p))) {\n          emit_factor(cadr(p));\n        } else {\n          emit_subexpr(cadr(p));\n        }\n        __emit_char('^');\n        if (isfactor(caddr(p))) {\n          emit_factor(caddr(p));\n        } else {\n          emit_subexpr(caddr(p));\n        }\n      }\n      return;\n    }\n    // special case: 1 over something\n    if (__is_negative(caddr(p))) {\n      x = emit_x;\n      k1 = yindex;\n      __emit_char('1');\n      k2 = yindex;\n      //level++\n      emit_denominator(p, 1);\n      //level--\n      fixup_fraction(x, k1, k2);\n      return;\n    }\n    k1 = yindex;\n    if (isfactor(cadr(p))) {\n      emit_factor(cadr(p));\n    } else {\n      emit_subexpr(cadr(p));\n    }\n    k2 = yindex;\n    level++;\n    emit_expr(caddr(p));\n    level--;\n    return fixup_power(k1, k2);\n  };\n\n  // if n == 1 then emit as expr (no parens)\n\n  // p is a power\n  emit_denominator = function(p, n) {\n    var k1, k2;\n    k1 = 0;\n    k2 = 0;\n    // special case: 1 over something\n    if (isminusone(caddr(p))) {\n      if (n === 1) {\n        emit_expr(cadr(p));\n      } else {\n        emit_factor(cadr(p));\n      }\n      return;\n    }\n    k1 = yindex;\n    // emit base\n    if (isfactor(cadr(p))) {\n      emit_factor(cadr(p));\n    } else {\n      emit_subexpr(cadr(p));\n    }\n    k2 = yindex;\n    // emit exponent, don't emit minus sign\n    level++;\n    emit_unsigned_expr(caddr(p));\n    level--;\n    return fixup_power(k1, k2);\n  };\n\n  emit_function = function(p) {\n    if (car(p) === symbol(INDEX) && issymbol(cadr(p))) {\n      emit_index_function(p);\n      return;\n    }\n    if (car(p) === symbol(FACTORIAL)) {\n      emit_factorial_function(p);\n      return;\n    }\n    if (car(p) === symbol(DERIVATIVE)) {\n      __emit_char('d');\n    } else {\n      emit_symbol(car(p));\n    }\n    __emit_char('(');\n    p = cdr(p);\n    if (iscons(p)) {\n      emit_expr(car(p));\n      p = cdr(p);\n      while (iscons(p)) {\n        __emit_char(',');\n        //__emit_char(' ')\n        emit_expr(car(p));\n        p = cdr(p);\n      }\n    }\n    return __emit_char(')');\n  };\n\n  emit_index_function = function(p) {\n    p = cdr(p);\n    if (caar(p) === symbol(ADD) || caar(p) === symbol(MULTIPLY) || caar(p) === symbol(POWER) || caar(p) === symbol(FACTORIAL)) {\n      emit_subexpr(car(p));\n    } else {\n      emit_expr(car(p));\n    }\n    __emit_char('[');\n    p = cdr(p);\n    if (iscons(p)) {\n      emit_expr(car(p));\n      p = cdr(p);\n      while (iscons(p)) {\n        __emit_char(',');\n        emit_expr(car(p));\n        p = cdr(p);\n      }\n    }\n    return __emit_char(']');\n  };\n\n  emit_factorial_function = function(p) {\n    p = cadr(p);\n    if (isfraction(p) || car(p) === symbol(ADD) || car(p) === symbol(MULTIPLY) || car(p) === symbol(POWER) || car(p) === symbol(FACTORIAL)) {\n      emit_subexpr(p);\n    } else {\n      emit_expr(p);\n    }\n    return __emit_char('!');\n  };\n\n  emit_subexpr = function(p) {\n    __emit_char('(');\n    emit_expr(p);\n    return __emit_char(')');\n  };\n\n  emit_symbol = function(p) {\n    var i, j1, pPrintName, ref2, results;\n    i = 0;\n    if (p === symbol(E)) {\n      __emit_str(\"exp(1)\");\n      return;\n    }\n    pPrintName = get_printname(p);\n    results = [];\n    for (i = j1 = 0, ref2 = pPrintName.length; (0 <= ref2 ? j1 < ref2 : j1 > ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n      results.push(__emit_char(pPrintName[i]));\n    }\n    return results;\n  };\n\n  emit_string = function(p) {\n    var i, j1, pString, ref2;\n    i = 0;\n    pString = p.str;\n    __emit_char('\"');\n    for (i = j1 = 0, ref2 = pString.length; (0 <= ref2 ? j1 < ref2 : j1 > ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n      __emit_char(pString[i]);\n    }\n    return __emit_char('\"');\n  };\n\n  fixup_fraction = function(x, k1, k2) {\n    var dx, dy, h1, h2, i, j1, ref2, results, w, w1, w2, y, y1, y2;\n    dx = 0;\n    dy = 0;\n    i = 0;\n    w = 0;\n    y = 0;\n    h1 = 0;\n    w1 = 0;\n    y1 = 0;\n    h2 = 0;\n    w2 = 0;\n    y2 = 0;\n    [h1, w1, y1] = get_size(k1, k2);\n    [h2, w2, y2] = get_size(k2, yindex);\n    if (w2 > w1) {\n      dx = (w2 - w1) / 2; // shift numerator right\n    } else {\n      dx = 0;\n    }\n    dx++;\n    // this is how much is below the baseline\n    y = y1 + h1 - 1;\n    dy = -y - 1;\n    move(k1, k2, dx, dy);\n    if (w2 > w1) {\n      dx = -w1;\n    } else {\n      dx = -w1 + (w1 - w2) / 2;\n    }\n    dx++;\n    dy = -y2 + 1;\n    move(k2, yindex, dx, dy);\n    if (w2 > w1) {\n      w = w2;\n    } else {\n      w = w1;\n    }\n    w += 2;\n    emit_x = x;\n    results = [];\n    for (i = j1 = 0, ref2 = w; (0 <= ref2 ? j1 < ref2 : j1 > ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n      results.push(__emit_char('-'));\n    }\n    return results;\n  };\n\n  fixup_power = function(k1, k2) {\n    var dy, h1, h2, w1, w2, y1, y2;\n    dy = 0;\n    h1 = 0;\n    w1 = 0;\n    y1 = 0;\n    h2 = 0;\n    w2 = 0;\n    y2 = 0;\n    [h1, w1, y1] = get_size(k1, k2);\n    [h2, w2, y2] = get_size(k2, yindex);\n    // move superscript to baseline\n    dy = -y2 - h2 + 1;\n    // now move above base\n    dy += y1 - 1;\n    return move(k2, yindex, 0, dy);\n  };\n\n  move = function(j, k, dx, dy) {\n    var i, j1, ref2, ref3, results;\n    i = 0;\n    results = [];\n    for (i = j1 = ref2 = j, ref3 = k; (ref2 <= ref3 ? j1 < ref3 : j1 > ref3); i = ref2 <= ref3 ? ++j1 : --j1) {\n      chartab[i].x += dx;\n      results.push(chartab[i].y += dy);\n    }\n    return results;\n  };\n\n  // finds the bounding rectangle and vertical position\n  get_size = function(j, k) {\n    var h, i, j1, max_x, max_y, min_x, min_y, ref2, ref3, w, y;\n    i = 0;\n    min_x = chartab[j].x;\n    max_x = chartab[j].x;\n    min_y = chartab[j].y;\n    max_y = chartab[j].y;\n    for (i = j1 = ref2 = j + 1, ref3 = k; (ref2 <= ref3 ? j1 < ref3 : j1 > ref3); i = ref2 <= ref3 ? ++j1 : --j1) {\n      if (chartab[i].x < min_x) {\n        min_x = chartab[i].x;\n      }\n      if (chartab[i].x > max_x) {\n        max_x = chartab[i].x;\n      }\n      if (chartab[i].y < min_y) {\n        min_y = chartab[i].y;\n      }\n      if (chartab[i].y > max_y) {\n        max_y = chartab[i].y;\n      }\n    }\n    h = max_y - min_y + 1;\n    w = max_x - min_x + 1;\n    y = min_y;\n    return [h, w, y];\n  };\n\n  displaychar = function(c) {\n    return __emit_char(c);\n  };\n\n  __emit_char = function(c) {\n    if (yindex === YMAX) {\n      return;\n    }\n    if (chartab[yindex] == null) {\n      debugger;\n    }\n    chartab[yindex].c = c;\n    chartab[yindex].x = emit_x;\n    chartab[yindex].y = 0;\n    yindex++;\n    return emit_x++;\n  };\n\n  __emit_str = function(s) {\n    var i, j1, ref2, results;\n    i = 0;\n    results = [];\n    for (i = j1 = 0, ref2 = s.length; (0 <= ref2 ? j1 < ref2 : j1 > ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n      results.push(__emit_char(s[i]));\n    }\n    return results;\n  };\n\n  emit_number = function(p, emit_sign) {\n    var i, j1, l1, m1, ref2, ref3, ref4, results, results1, tmpString;\n    tmpString = \"\";\n    i = 0;\n    switch (p.k) {\n      case NUM:\n        tmpString = p.q.a.toString();\n        if (tmpString[0] === '-' && emit_sign === 0) {\n          tmpString = tmpString.substring(1);\n        }\n        for (i = j1 = 0, ref2 = tmpString.length; (0 <= ref2 ? j1 < ref2 : j1 > ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n          __emit_char(tmpString[i]);\n        }\n        tmpString = p.q.b.toString();\n        if (tmpString === \"1\") {\n          break;\n        }\n        __emit_char('/');\n        results = [];\n        for (i = l1 = 0, ref3 = tmpString.length; (0 <= ref3 ? l1 < ref3 : l1 > ref3); i = 0 <= ref3 ? ++l1 : --l1) {\n          results.push(__emit_char(tmpString[i]));\n        }\n        return results;\n        break;\n      case DOUBLE:\n        tmpString = doubleToReasonableString(p.d);\n        if (tmpString[0] === '-' && emit_sign === 0) {\n          tmpString = tmpString.substring(1);\n        }\n        results1 = [];\n        for (i = m1 = 0, ref4 = tmpString.length; (0 <= ref4 ? m1 < ref4 : m1 > ref4); i = 0 <= ref4 ? ++m1 : --m1) {\n          results1.push(__emit_char(tmpString[i]));\n        }\n        return results1;\n    }\n  };\n\n  // a and b are glyphs\n  cmpGlyphs = function(a, b) {\n    if (a.y < b.y) {\n      return -1;\n    }\n    if (a.y > b.y) {\n      return 1;\n    }\n    if (a.x < b.x) {\n      return -1;\n    }\n    if (a.x > b.x) {\n      return 1;\n    }\n    return 0;\n  };\n\n  print_glyphs = function() {\n    var accumulator, i, j1, ref2, subsetOfStack, x, y;\n    i = 0;\n    accumulator = \"\";\n    \n    // now sort the glyphs by their vertical positions,\n    // since we are going to build a string where obviously the\n    // \"upper\" line has to printed out first, followed by\n    // a new line, followed by the other lines.\n    //qsort(chartab, yindex, sizeof (struct glyph), __cmp)\n    subsetOfStack = chartab.slice(0, yindex);\n    subsetOfStack.sort(cmpGlyphs);\n    chartab = [].concat(subsetOfStack).concat(chartab.slice(yindex));\n    x = 0;\n    y = chartab[0].y;\n    for (i = j1 = 0, ref2 = yindex; (0 <= ref2 ? j1 < ref2 : j1 > ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n      while (chartab[i].y > y) {\n        accumulator += printchar('\\n');\n        x = 0;\n        y++;\n      }\n      while (chartab[i].x > x) {\n        accumulator += printchar_nowrap(' ');\n        x++;\n      }\n      accumulator += printchar_nowrap(chartab[i].c);\n      x++;\n    }\n    return accumulator;\n  };\n\n  buffer = \"\";\n\n  getdisplaystr = function() {\n    yindex = 0;\n    level = 0;\n    emit_x = 0;\n    emit_expr(pop());\n    fill_buf();\n    return buffer;\n  };\n\n  fill_buf = function() {\n    var i, j1, ref2, sIndex, subsetOfStack, tmpBuffer, x, y;\n    tmpBuffer = buffer;\n    sIndex = 0;\n    i = 0;\n    //qsort(chartab, yindex, sizeof (struct glyph), __cmp)\n    subsetOfStack = chartab.slice(0, yindex);\n    subsetOfStack.sort(cmpGlyphs);\n    chartab = [].concat(subsetOfStack).concat(chartab.slice(yindex));\n    x = 0;\n    y = chartab[0].y;\n    for (i = j1 = 0, ref2 = yindex; (0 <= ref2 ? j1 < ref2 : j1 > ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n      while (chartab[i].y > y) {\n        tmpBuffer[sIndex++] = '\\n';\n        x = 0;\n        y++;\n      }\n      while (chartab[i].x > x) {\n        tmpBuffer[sIndex++] = ' ';\n        x++;\n      }\n      tmpBuffer[sIndex++] = chartab[i].c;\n      x++;\n    }\n    return tmpBuffer[sIndex++] = '\\n';\n  };\n\n  N = 100;\n\n  oneElement = (function() {\n    class oneElement {};\n\n    oneElement.prototype.x = 0;\n\n    oneElement.prototype.y = 0;\n\n    oneElement.prototype.h = 0;\n\n    oneElement.prototype.w = 0;\n\n    oneElement.prototype.index = 0;\n\n    oneElement.prototype.count = 0;\n\n    return oneElement;\n\n  }).call(this);\n\n  elem = [];\n\n  for (elelmIndex = j1 = 0; j1 < 10000; elelmIndex = ++j1) {\n    elem[elelmIndex] = new oneElement();\n  }\n\n  SPACE_BETWEEN_COLUMNS = 3;\n\n  SPACE_BETWEEN_ROWS = 1;\n\n  emit_tensor = function(p) {\n    var col, dx, dy, eh, ew, h, i, l1, m1, n, n1, ncol, nrow, o1, ref2, ref3, ref4, ref5, row, w, x, y;\n    i = 0;\n    n = 0;\n    nrow = 0;\n    ncol = 0;\n    x = 0;\n    y = 0;\n    h = 0;\n    w = 0;\n    dx = 0;\n    dy = 0;\n    eh = 0;\n    ew = 0;\n    row = 0;\n    col = 0;\n    if (p.tensor.ndim > 2) {\n      emit_flat_tensor(p);\n      return;\n    }\n    nrow = p.tensor.dim[0];\n    if (p.tensor.ndim === 2) {\n      ncol = p.tensor.dim[1];\n    } else {\n      ncol = 1;\n    }\n    n = nrow * ncol;\n    if (n > N) {\n      emit_flat_tensor(p);\n      return;\n    }\n    // horizontal coordinate of the matrix\n\n    //if 0\n    //emit_x += 2; # make space for left paren\n    //endif\n    x = emit_x;\n// emit each element\n    for (i = l1 = 0, ref2 = n; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      elem[i].index = yindex;\n      elem[i].x = emit_x;\n      emit_expr(p.tensor.elem[i]);\n      elem[i].count = yindex - elem[i].index;\n      [elem[i].h, elem[i].w, elem[i].y] = get_size(elem[i].index, yindex);\n    }\n    // find element height and width\n    eh = 0;\n    ew = 0;\n    for (i = m1 = 0, ref3 = n; (0 <= ref3 ? m1 < ref3 : m1 > ref3); i = 0 <= ref3 ? ++m1 : --m1) {\n      if (elem[i].h > eh) {\n        eh = elem[i].h;\n      }\n      if (elem[i].w > ew) {\n        ew = elem[i].w;\n      }\n    }\n    // this is the overall height of the matrix\n    h = nrow * eh + (nrow - 1) * SPACE_BETWEEN_ROWS;\n    // this is the overall width of the matrix\n    w = ncol * ew + (ncol - 1) * SPACE_BETWEEN_COLUMNS;\n    // this is the vertical coordinate of the matrix\n    y = -(h / 2);\n// move elements around\n    for (row = n1 = 0, ref4 = nrow; (0 <= ref4 ? n1 < ref4 : n1 > ref4); row = 0 <= ref4 ? ++n1 : --n1) {\n      for (col = o1 = 0, ref5 = ncol; (0 <= ref5 ? o1 < ref5 : o1 > ref5); col = 0 <= ref5 ? ++o1 : --o1) {\n        i = row * ncol + col;\n        // first move to upper left corner of matrix\n        dx = x - elem[i].x;\n        dy = y - elem[i].y;\n        move(elem[i].index, elem[i].index + elem[i].count, dx, dy);\n        // now move to official position\n        dx = 0;\n        if (col > 0) {\n          dx = col * (ew + SPACE_BETWEEN_COLUMNS);\n        }\n        dy = 0;\n        if (row > 0) {\n          dy = row * (eh + SPACE_BETWEEN_ROWS);\n        }\n        // small correction for horizontal centering\n        dx += (ew - elem[i].w) / 2;\n        // small correction for vertical centering\n        dy += (eh - elem[i].h) / 2;\n        move(elem[i].index, elem[i].index + elem[i].count, dx, dy);\n      }\n    }\n    return emit_x = x + w;\n  };\n\n  emit_flat_tensor = function(p) {\n    return emit_tensor_inner(p, 0, 0);\n  };\n\n  emit_tensor_inner = function(p, j, k) {\n    var i, l1, ref2;\n    i = 0;\n    __emit_char('(');\n    for (i = l1 = 0, ref2 = p.tensor.dim[j]; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      if (j + 1 === p.tensor.ndim) {\n        emit_expr(p.tensor.elem[k]);\n        k = k + 1;\n      } else {\n        k = emit_tensor_inner(p, j + 1, k);\n      }\n      if (i + 1 < p.tensor.dim[j]) {\n        __emit_char(',');\n      }\n    }\n    __emit_char(')');\n    return k;\n  };\n\n  // 'product' function\n\n  //define A p3\n  //define B p4\n  //define I p5\n  //define X p6\n\n  // leaves the product at the top of the stack\n  Eval_product = function() {\n    var body, i, indexVariable, j, k, l1, oldIndexVariableValue, ref2, ref3;\n    i = 0;\n    j = 0;\n    k = 0;\n    // 1st arg\n    body = cadr(p1);\n    // 2nd arg (index)\n    indexVariable = caddr(p1);\n    if (!issymbol(indexVariable)) {\n      stop(\"sum: 2nd arg?\");\n    }\n    // 3rd arg (lower limit)\n    push(cadddr(p1));\n    Eval();\n    j = pop_integer();\n    if (isNaN(j)) {\n      push(p1);\n      return;\n    }\n    // 4th arg (upper limit)\n    push(caddddr(p1));\n    Eval();\n    k = pop_integer();\n    if (isNaN(k)) {\n      push(p1);\n      return;\n    }\n    // remember contents of the index\n    // variable so we can put it back after the loop\n    oldIndexVariableValue = get_binding(indexVariable);\n    push_integer(1);\n    for (i = l1 = ref2 = j, ref3 = k; (ref2 <= ref3 ? l1 <= ref3 : l1 >= ref3); i = ref2 <= ref3 ? ++l1 : --l1) {\n      push_integer(i);\n      p5 = pop();\n      set_binding(indexVariable, p5);\n      push(body);\n      Eval();\n      if (DEBUG) {\n        console.log(\"product - factor 1: \" + stack[tos - 1].toString());\n        console.log(\"product - factor 2: \" + stack[tos - 2].toString());\n      }\n      multiply();\n      if (DEBUG) {\n        console.log(\"product - result: \" + stack[tos - 1].toString());\n      }\n    }\n    // put back the index variable to original content\n    return set_binding(indexVariable, oldIndexVariableValue);\n  };\n\n  //  Add rational numbers\n\n  //  Input:    tos-2    addend\n\n  //      tos-1    addend\n\n  //  Output:    sum on stack\n  qadd = function() {\n    var gcdBetweenNumeratorAndDenominator, qadd_ab, qadd_ba, qadd_denominator, qadd_frac1, qadd_frac2, qadd_numerator, resultSum;\n    // a, qadd_ab, b, qadd_ba, c are all bigNum\n    // we are adding the fractions qadd_frac1 + qadd_frac2 i.e.\n    // qadd_frac1.q.a/qadd_frac1.q.b + qadd_frac2.q.a/qadd_frac2.q.b\n    qadd_frac2 = pop();\n    qadd_frac1 = pop();\n    qadd_ab = mmul(qadd_frac1.q.a, qadd_frac2.q.b);\n    qadd_ba = mmul(qadd_frac1.q.b, qadd_frac2.q.a);\n    qadd_numerator = madd(qadd_ab, qadd_ba);\n    //mfree(qadd_ab)\n    //mfree(qadd_ba)\n\n    // zero?\n    if (MZERO(qadd_numerator)) {\n      //console.log \"qadd IS ZERO\"\n      //mfree(qadd_numerator)\n      push(zero);\n      return;\n    }\n    qadd_denominator = mmul(qadd_frac1.q.b, qadd_frac2.q.b);\n    gcdBetweenNumeratorAndDenominator = mgcd(qadd_numerator, qadd_denominator);\n    //console.log \"gcd(\"+qadd_numerator+\",\"+qadd_denominator+\"): \" + gcdBetweenNumeratorAndDenominator\n    gcdBetweenNumeratorAndDenominator = makeSignSameAs(gcdBetweenNumeratorAndDenominator, qadd_denominator);\n    //console.log \"qadd qadd_denominator: \" + qadd_denominator\n    //console.log \"qadd gcdBetweenNumeratorAndDenominator: \" + gcdBetweenNumeratorAndDenominator\n    resultSum = new U();\n    resultSum.k = NUM;\n    resultSum.q.a = mdiv(qadd_numerator, gcdBetweenNumeratorAndDenominator);\n    resultSum.q.b = mdiv(qadd_denominator, gcdBetweenNumeratorAndDenominator);\n    //console.log \"qadd resultSum.q.a: \" + resultSum.q.a\n    //console.log \"qadd resultSum.q.b: \" + resultSum.q.b\n\n    //mfree(qadd_numerator)\n    //mfree(qadd_denominator)\n    //mfree(gcdBetweenNumeratorAndDenominator)\n    return push(resultSum);\n  };\n\n  //console.log \"qadd result: \" + resultSum\n\n  //  Divide rational numbers\n\n  //  Input:    tos-2    dividend\n\n  //      tos-1    divisor\n\n  //  Output:    quotient on stack\n  qdiv = function() {\n    var aa, bb, c;\n    save();\n    p2 = pop();\n    p1 = pop();\n    // zero?\n    if (MZERO(p2.q.a)) {\n      stop(\"divide by zero\");\n    }\n    if (MZERO(p1.q.a)) {\n      push(zero);\n      restore();\n      return;\n    }\n    aa = mmul(p1.q.a, p2.q.b);\n    bb = mmul(p1.q.b, p2.q.a);\n    c = mgcd(aa, bb);\n    c = makeSignSameAs(c, bb);\n    p1 = new U();\n    p1.k = NUM;\n    p1.q.a = mdiv(aa, c);\n    p1.q.b = mdiv(bb, c);\n    push(p1);\n    return restore();\n  };\n\n  //  Multiply rational numbers\n\n  //  Input:    tos-2    multiplicand\n\n  //      tos-1    multiplier\n\n  //  Output:    product on stack\n  qmul = function() {\n    var aa, bb, c;\n    save();\n    p2 = pop();\n    p1 = pop();\n    // zero?\n    if (MZERO(p1.q.a) || MZERO(p2.q.a)) {\n      push(zero);\n      restore();\n      return;\n    }\n    aa = mmul(p1.q.a, p2.q.a);\n    bb = mmul(p1.q.b, p2.q.b);\n    c = mgcd(aa, bb);\n    c = makeSignSameAs(c, bb);\n    p1 = new U();\n    p1.k = NUM;\n    p1.q.a = mdiv(aa, c);\n    p1.q.b = mdiv(bb, c);\n    //mfree(aa)\n    //mfree(bb)\n    push(p1);\n    return restore();\n  };\n\n  // Rational power function\n  qpow = function() {\n    save();\n    qpowf();\n    return restore();\n  };\n\n  //define BASE p1\n  //define EXPO p2\n  qpowf = function() {\n    var a, b, expo, t, x, y;\n    expo = 0;\n    //unsigned int a, b, *t, *x, *y\n    p2 = pop();\n    p1 = pop();\n    if (isplusone(p1) || isZeroAtomOrTensor(p2)) { // p1 is BASE  # p2 is EXPO\n      push_integer(1);\n      return;\n    }\n    // if (-1)^(1/2) -> leave it as is\n    if (isminusone(p1) && isoneovertwo(p2)) { // p1 is BASE  # p2 is EXPO\n      push(imaginaryunit);\n      return;\n    }\n    // if base is zero then return 0\n    if (isZeroAtomOrTensor(p1)) { // p1 is BASE\n      if (isnegativenumber(p2)) { // p2 is EXPO\n        stop(\"divide by zero\");\n      }\n      push(zero);\n      return;\n    }\n    // if exponent is 1 then return base\n    if (isplusone(p2)) { // p2 is EXPO\n      push(p1);\n      return;\n    }\n    // if exponent is integer then power\n    if (isinteger(p2)) { // p2 is EXPO\n      push(p2);\n      expo = pop_integer();\n      if (isNaN(expo)) {\n        // expo greater than 32 bits\n        push_symbol(POWER);\n        push(p1);\n        push(p2);\n        list(3);\n        return;\n      }\n      x = mpow(p1.q.a, Math.abs(expo));\n      y = mpow(p1.q.b, Math.abs(expo));\n      if (expo < 0) {\n        t = x;\n        x = y;\n        y = t;\n        x = makeSignSameAs(x, y);\n        y = makePositive(y);\n      }\n      p3 = new U();\n      p3.k = NUM;\n      p3.q.a = x;\n      p3.q.b = y;\n      push(p3);\n      return;\n    }\n    // from here on out the exponent is NOT an integer\n\n    // if base is -1 then normalize polar angle\n    if (isminusone(p1)) { // p1 is BASE\n      push(p2);\n      normalize_angle();\n      return;\n    }\n    // if base is negative then (-N)^M -> N^M * (-1)^M\n    if (isnegativenumber(p1)) { // p1 is BASE\n      push(p1);\n      negate();\n      push(p2);\n      qpow();\n      push_integer(-1);\n      push(p2);\n      qpow();\n      multiply();\n      return;\n    }\n    if (!isinteger(p1)) { // p1 is BASE\n      push(p1);\n      mp_numerator();\n      push(p2);\n      qpow();\n      push(p1);\n      mp_denominator();\n      push(p2);\n      negate();\n      qpow();\n      multiply();\n      return;\n    }\n    // At this point p1 (BASE) is a positive integer.\n\n    // If p1 (BASE) is small then factor it.\n    if (is_small_integer(p1)) { // p1 is BASE\n      push(p1);\n      push(p2);\n      quickfactor();\n      return;\n    }\n    if (!isSmall(p2.q.a) || !isSmall(p2.q.b)) { // p2 is EXPO\n      push_symbol(POWER);\n      push(p1); // p1 is BASE\n      push(p2);\n      list(3);\n      return;\n    }\n    a = p2.q.a;\n    b = p2.q.b;\n    x = mroot(p1.q.a, b);\n    if (x === 0) {\n      push_symbol(POWER);\n      push(p1);\n      push(p2);\n      list(3);\n      return;\n    }\n    y = mpow(x, a);\n    //mfree(x)\n    p3 = new U();\n    p3.k = NUM;\n    if (p2.q.a.isNegative()) { // p2 is EXPO\n      p3.q.a = bigInt(1);\n      p3.q.b = y;\n    } else {\n      p3.q.a = y;\n      p3.q.b = bigInt(1);\n    }\n    return push(p3);\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Normalize the angle of unit imaginary, i.e. (-1) ^ N\n\n  //  Input:    N on stack (must be rational, not float)\n\n  //  Output:    Result on stack\n\n  //  Note:\n\n  //  n = q * d + r\n\n  //  Example:\n  //            n  d  q  r\n\n  //  (-1)^(8/3)  ->   (-1)^(2/3)  8  3  2  2\n  //  (-1)^(7/3)  ->   (-1)^(1/3)  7  3  2  1\n  //  (-1)^(5/3)  ->  -(-1)^(2/3)  5  3  1  2\n  //  (-1)^(4/3)  ->  -(-1)^(1/3)  4  3  1  1\n  //  (-1)^(2/3)  ->   (-1)^(2/3)  2  3  0  2\n  //  (-1)^(1/3)  ->   (-1)^(1/3)  1  3  0  1\n\n  //  (-1)^(-1/3)  ->  -(-1)^(2/3)  -1  3  -1  2\n  //  (-1)^(-2/3)  ->  -(-1)^(1/3)  -2  3  -1  1\n  //  (-1)^(-4/3)  ->   (-1)^(2/3)  -4  3  -2  2\n  //  (-1)^(-5/3)  ->   (-1)^(1/3)  -5  3  -2  1\n  //  (-1)^(-7/3)  ->  -(-1)^(2/3)  -7  3  -3  2\n  //  (-1)^(-8/3)  ->  -(-1)^(1/3)  -8  3  -3  1\n\n  //-----------------------------------------------------------------------------\n\n  //define A p1\n  //define Q p2\n  //define R p3\n  normalize_angle = function() {\n    save();\n    p1 = pop();\n    if (isinteger(p1)) { // p1 is A\n      if (p1.q.a.isOdd()) { // p1 is A\n        push_integer(-1); // odd exponent\n      } else {\n        push_integer(1); // even exponent\n      }\n      restore();\n      return;\n    }\n    // floor\n    push(p1);\n    bignum_truncate();\n    p2 = pop();\n    if (isnegativenumber(p1)) { // p1 is A\n      push(p2); // p2 is Q\n      push_integer(-1);\n      add();\n      p2 = pop(); // p2 is Q\n    }\n    \n    // remainder (always positive)\n    push(p1);\n    push(p2);\n    subtract();\n    p3 = pop();\n    push_symbol(POWER);\n    push_integer(-1);\n    push(p3); // p3 is R\n    list(3);\n    // negate if quotient is odd\n    if (p2.q.a.isOdd()) { // p2 is Q\n      negate();\n    }\n    return restore();\n  };\n\n  is_small_integer = function(p) {\n    return isSmall(p.q.a);\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Factor small numerical powers\n\n  //  Input:    tos-2    Base (positive integer < 2^31 - 1)\n\n  //      tos-1    Exponent\n\n  //  Output:    Expr on stack\n\n  //-----------------------------------------------------------------------------\n\n  //define BASE p1\n  //define EXPO p2\n  quickfactor = function() {\n    var h, i, l1, n, ref2, stackIndex;\n    i = 0;\n    save();\n    p2 = pop();\n    p1 = pop();\n    h = tos;\n    push(p1);\n    factor_small_number();\n    n = tos - h;\n    stackIndex = h;\n    for (i = l1 = 0, ref2 = n; l1 < ref2; i = l1 += 2) {\n      push(stack[stackIndex + i]);\n      push(stack[stackIndex + i + 1]);\n      push(p2);\n      multiply();\n      quickpower();\n    }\n    // stack has n results from factor_number_raw()\n\n    // on top of that are all the expressions from quickpower()\n\n    // multiply the quickpower() results\n    multiply_all(tos - h - n);\n    p1 = pop();\n    moveTos(h);\n    push(p1);\n    return restore();\n  };\n\n  // p1 (BASE) is a prime number so power is simpler\n  quickpower = function() {\n    var expo;\n    expo = 0;\n    save();\n    p2 = pop();\n    p1 = pop();\n    push(p2);\n    bignum_truncate();\n    p3 = pop();\n    push(p2);\n    push(p3);\n    subtract();\n    p4 = pop();\n    if (!isZeroAtomOrTensor(p4)) {\n      push_symbol(POWER);\n      push(p1);\n      push(p4);\n      list(3);\n    }\n    push(p3);\n    expo = pop_integer();\n    if (isNaN(expo)) {\n      push_symbol(POWER);\n      push(p1);\n      push(p3);\n      list(3);\n      restore();\n      return;\n    }\n    if (expo === 0) {\n      restore();\n      return;\n    }\n    push(p1);\n    bignum_power_number(expo);\n    return restore();\n  };\n\n  //if SELFTEST\n\n  // Divide polynomials\n  Eval_quotient = function() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    push(cadddr(p1));\n    Eval();\n    p1 = pop();\n    if (p1 === symbol(NIL)) {\n      p1 = symbol(SYMBOL_X);\n    }\n    push(p1);\n    return divpoly();\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Divide polynomials\n\n  //  Input:    tos-3    Dividend\n\n  //      tos-2    Divisor\n\n  //      tos-1    x\n\n  //  Output:    tos-1    Quotient\n\n  //-----------------------------------------------------------------------------\n\n  //define DIVIDEND p1\n  //define DIVISOR p2\n  //define X p3\n  //define Q p4\n  //define QUOTIENT p5\n  divpoly = function() {\n    var dividend, divisor, h, i, l1, m, n, ref2, x;\n    h = 0;\n    i = 0;\n    m = 0;\n    n = 0;\n    x = 0;\n    //U **dividend, **divisor\n    save();\n    p3 = pop();\n    p2 = pop();\n    p1 = pop();\n    h = tos;\n    dividend = tos;\n    m = coeff(p3, p1) - 1;\n    divisor = tos;\n    n = coeff(p3, p2) - 1;\n    x = m - n;\n    push_integer(0);\n    p5 = pop();\n    while (x >= 0) {\n      push(stack[dividend + m]);\n      push(stack[divisor + n]);\n      divide();\n      p4 = pop();\n      for (i = l1 = 0, ref2 = n; (0 <= ref2 ? l1 <= ref2 : l1 >= ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n        push(stack[dividend + x + i]);\n        push(stack[divisor + i]);\n        push(p4);\n        multiply();\n        subtract();\n        stack[dividend + x + i] = pop();\n      }\n      push(p5);\n      push(p4);\n      push(p3);\n      push_integer(x);\n      power();\n      multiply();\n      add();\n      p5 = pop();\n      m--;\n      x--;\n    }\n    moveTos(h);\n    push(p5);\n    return restore();\n  };\n\n  DEBUG_RATIONALIZE = false;\n\n  Eval_rationalize = function() {\n    push(cadr(p1));\n    Eval();\n    return rationalize();\n  };\n\n  rationalize = function() {\n    var x;\n    x = expanding;\n    yyrationalize();\n    return expanding = x;\n  };\n\n  yyrationalize = function() {\n    var commonDenominator, eachTerm, theArgument;\n    theArgument = pop();\n    if (istensor(theArgument)) {\n      __rationalize_tensor(theArgument);\n      return;\n    }\n    expanding = 0;\n    if (car(theArgument) !== symbol(ADD)) {\n      push(theArgument);\n      return;\n    }\n    if (DEBUG_RATIONALIZE) {\n      console.log(\"rationalize: this is the input expr: \" + theArgument);\n    }\n    // get new denominator\n    push(one);\n    multiply_denominators(theArgument);\n    commonDenominator = pop();\n    if (DEBUG_RATIONALIZE) {\n      console.log(\"rationalize: this is the new denominator: \" + commonDenominator);\n    }\n    // multiply each term by new denominator\n    push(zero);\n    eachTerm = cdr(theArgument);\n    while (iscons(eachTerm)) {\n      if (DEBUG_RATIONALIZE) {\n        console.log(\"term: \" + car(eachTerm));\n      }\n      push(commonDenominator);\n      push(car(eachTerm));\n      multiply();\n      add();\n      eachTerm = cdr(eachTerm);\n    }\n    if (DEBUG_RATIONALIZE) {\n      console.log(\"rationalize: original terms times new denominator: \" + stack[tos - 1]);\n    }\n    // collect common factors\n    Condense();\n    if (DEBUG_RATIONALIZE) {\n      console.log(\"rationalize: after factoring: \" + stack[tos - 1]);\n    }\n    // divide by common denominator\n    push(commonDenominator);\n    divide();\n    if (DEBUG_RATIONALIZE) {\n      return console.log(\"rationalize: after dividing by new denom. (and we're done): \" + stack[tos - 1]);\n    }\n  };\n\n  multiply_denominators = function(p) {\n    var results;\n    if (car(p) === symbol(ADD)) {\n      p = cdr(p);\n      results = [];\n      while (iscons(p)) {\n        multiply_denominators_term(car(p));\n        results.push(p = cdr(p));\n      }\n      return results;\n    } else {\n      return multiply_denominators_term(p);\n    }\n  };\n\n  multiply_denominators_term = function(p) {\n    var results;\n    if (car(p) === symbol(MULTIPLY)) {\n      p = cdr(p);\n      results = [];\n      while (iscons(p)) {\n        multiply_denominators_factor(car(p));\n        results.push(p = cdr(p));\n      }\n      return results;\n    } else {\n      return multiply_denominators_factor(p);\n    }\n  };\n\n  multiply_denominators_factor = function(p) {\n    if (car(p) !== symbol(POWER)) {\n      return;\n    }\n    push(p);\n    p = caddr(p);\n    // like x^(-2) ?\n    if (isnegativenumber(p)) {\n      inverse();\n      __lcm();\n      return;\n    }\n    // like x^(-a) ?\n    if (car(p) === symbol(MULTIPLY) && isnegativenumber(cadr(p))) {\n      inverse();\n      __lcm();\n      return;\n    }\n    // no match\n    return pop();\n  };\n\n  __rationalize_tensor = function(theTensor) {\n    var i, l1, n, ref2;\n    i = 0;\n    push(theTensor);\n    Eval();\n    theTensor = pop();\n    if (!istensor(theTensor)) { // might be zero\n      push(theTensor);\n      return;\n    }\n    n = theTensor.tensor.nelem;\n    for (i = l1 = 0, ref2 = n; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      push(theTensor.tensor.elem[i]);\n      rationalize();\n      theTensor.tensor.elem[i] = pop();\n    }\n    check_tensor_dimensions(theTensor);\n    return push(theTensor);\n  };\n\n  __lcm = function() {\n    save();\n    p1 = pop();\n    p2 = pop();\n    push(p1);\n    push(p2);\n    multiply();\n    push(p1);\n    push(p2);\n    gcd();\n    divide();\n    return restore();\n  };\n\n  Eval_real = function() {\n    push(cadr(p1));\n    Eval();\n    return real();\n  };\n\n  real = function() {\n    save();\n    rect();\n    p1 = pop();\n    push(p1);\n    push(p1);\n    conjugate();\n    add();\n    push_integer(2);\n    divide();\n    return restore();\n  };\n\n  DEBUG_RECT = false;\n\n  Eval_rect = function() {\n    push(cadr(p1));\n    Eval();\n    return rect();\n  };\n\n  rect = function() {\n    var input;\n    save();\n    p1 = pop();\n    input = p1;\n    if (DEBUG_RECT) {\n      console.log(\"RECT of \" + input);\n    }\n    if (DEBUG_RECT) {\n      console.log(\"any clock forms in : \" + input + \" ? \" + findPossibleClockForm(input));\n    }\n    // if we assume real variables, then the\n    // rect of any symbol is the symbol itself\n    // (note that 'i' is not a symbol, it's made of (-1)^(1/2))\n    // otherwise we have to leave unevalled\n    if (issymbol(p1)) {\n      if (DEBUG_RECT) {\n        console.log(\" rect: simple symbol: \" + input);\n      }\n      if (!isZeroAtomOrTensor(get_binding(symbol(ASSUME_REAL_VARIABLES)))) {\n        push(p1);\n      } else {\n        push_symbol(YYRECT);\n        push(p1);\n        list(2);\n      }\n    } else if (!isZeroAtomOrTensor(get_binding(symbol(ASSUME_REAL_VARIABLES))) && !findPossibleExponentialForm(p1) && !findPossibleClockForm(p1) && !(Find(p1, symbol(SIN)) && Find(p1, symbol(COS)) && Find(p1, imaginaryunit))) { // no polar form?\n      if (DEBUG_RECT) {\n        console.log(\" rect: simple symbol: \" + input);\n      }\n      push(p1);\n    // ib\n    } else if (car(p1) === symbol(MULTIPLY) && isimaginaryunit(cadr(p1)) && !isZeroAtomOrTensor(get_binding(symbol(ASSUME_REAL_VARIABLES)))) {\n      push(p1);\n    // sum\n    } else if (car(p1) === symbol(ADD)) {\n      if (DEBUG_RECT) {\n        console.log(\" rect - \" + input + \" is a sum \");\n      }\n      push_integer(0);\n      p1 = cdr(p1);\n      while (iscons(p1)) {\n        push(car(p1));\n        rect();\n        add();\n        p1 = cdr(p1);\n      }\n    } else {\n      // try to get to the rectangular form by doing\n      // abs(p1) * (cos (theta) + i * sin(theta))\n      // where theta is arg(p1)\n      if (DEBUG_RECT) {\n        console.log(\" rect - \" + input + \" is NOT a sum \");\n      }\n      push(p1);\n      abs();\n      if (DEBUG_RECT) {\n        console.log(\" rect - \" + input + \" abs: \" + stack[tos - 1].toString());\n      }\n      push(p1);\n      arg();\n      if (DEBUG_RECT) {\n        console.log(\" rect - \" + input + \" arg of \" + p1 + \" : \" + stack[tos - 1].toString());\n      }\n      p1 = pop();\n      push(p1);\n      cosine();\n      if (DEBUG_RECT) {\n        console.log(\" rect - \" + input + \" cosine: \" + stack[tos - 1].toString());\n      }\n      push(imaginaryunit);\n      push(p1);\n      sine();\n      if (DEBUG_RECT) {\n        console.log(\" rect - \" + input + \" sine: \" + stack[tos - 1].toString());\n      }\n      multiply();\n      if (DEBUG_RECT) {\n        console.log(\" rect - \" + input + \" i * sine: \" + stack[tos - 1].toString());\n      }\n      add();\n      if (DEBUG_RECT) {\n        console.log(\" rect - \" + input + \" cos + i * sine: \" + stack[tos - 1].toString());\n      }\n      multiply();\n    }\n    restore();\n    if (DEBUG_RECT) {\n      return console.log(\"rect of \" + input + \" : \" + stack[tos - 1]);\n    }\n  };\n\n  //define POLY p1\n  //define X p2\n  //define A p3\n  //define B p4\n  //define C p5\n  //define Y p6\n  show_power_debug = false;\n\n  performing_roots = false;\n\n  Eval_roots = function() {\n    // this transforms simple \"equation\" forms into\n    // something that can be processed. E.g., say, y = 3x - 2\n    // A == B -> A - B\n    // A = B -> A - B\n    p2 = cadr(p1);\n    if (car(p2) === symbol(SETQ) || car(p2) === symbol(TESTEQ)) {\n      push(cadr(p2));\n      Eval();\n      push(caddr(p2));\n      Eval();\n      subtract();\n    } else {\n      push(p2);\n      Eval();\n      p2 = pop();\n      if (car(p2) === symbol(SETQ) || car(p2) === symbol(TESTEQ)) {\n        push(cadr(p2));\n        Eval();\n        push(caddr(p2));\n        Eval();\n        subtract();\n      } else {\n        push(p2);\n      }\n    }\n    // 2nd arg, x\n    push(caddr(p1));\n    Eval();\n    p2 = pop();\n    if (p2 === symbol(NIL)) {\n      guess();\n    } else {\n      push(p2);\n    }\n    p2 = pop();\n    p1 = pop();\n    if (!ispolyexpandedform(p1, p2)) {\n      stop(\"roots: 1st argument is not a polynomial in the variable \" + p2);\n    }\n    push(p1);\n    push(p2);\n    return roots();\n  };\n\n  hasImaginaryCoeff = function(k) {\n    var h, i, imaginaryCoefficients, l1, ref2;\n    //polycoeff = tos\n    imaginaryCoefficients = false;\n    h = tos;\n    for (i = l1 = ref2 = k; l1 > 0; i = l1 += -1) {\n      //console.log \"hasImaginaryCoeff - coeff.:\" + stack[tos-i].toString()\n      if (iscomplexnumber(stack[tos - i])) {\n        imaginaryCoefficients = true;\n        break;\n      }\n    }\n    return imaginaryCoefficients;\n  };\n\n  isSimpleRoot = function(k) {\n    var h, i, isSimpleRootPolynomial, l1, ref2;\n    //polycoeff = tos\n\n    //tos-n    Coefficient of x^0\n    //tos-1    Coefficient of x^(n-1)\n    if (k > 2) {\n      isSimpleRootPolynomial = true;\n      h = tos;\n      if (isZeroAtomOrTensor(stack[tos - k])) {\n        isSimpleRootPolynomial = false;\n      }\n      for (i = l1 = ref2 = k - 1; l1 > 1; i = l1 += -1) {\n        if (!isZeroAtomOrTensor(stack[tos - i])) {\n          isSimpleRootPolynomial = false;\n          break;\n        }\n      }\n    } else {\n      isSimpleRootPolynomial = false;\n    }\n    return isSimpleRootPolynomial;\n  };\n\n  normalisedCoeff = function(variable, polynomial) {\n    var divideBy, i, k, l1, m1, miniStack, ref2, ref3;\n    k = coeff(variable, polynomial);\n    //console.log(\"->\" + tos)\n    divideBy = stack[tos - 1];\n    miniStack = [];\n    for (i = l1 = 1, ref2 = k; (1 <= ref2 ? l1 <= ref2 : l1 >= ref2); i = 1 <= ref2 ? ++l1 : --l1) {\n      miniStack.push(pop());\n    }\n//console.log(tos)\n    for (i = m1 = ref3 = k - 1; (ref3 <= 0 ? m1 <= 0 : m1 >= 0); i = ref3 <= 0 ? ++m1 : --m1) {\n      push(miniStack[i]);\n      push(divideBy);\n      divide();\n    }\n    //console.log(tos)\n    return k;\n  };\n\n  // takes the polynomial and the\n  // variable on the stack\n  roots = function() {\n    var h, i, k, l1, lastCoeff, leadingCoeff, n, ref2;\n    h = 0;\n    i = 0;\n    n = 0;\n    if (DEBUG) {\n      console.log(\"roots: \" + stack[tos - 1].toString() + \" \" + stack[tos - 2].toString());\n    }\n    save();\n    // the simplification of nested radicals uses\n    // \"roots\", which in turn uses simplification\n    // of nested radicals. Usually there is no problem,\n    // one level of recursion does the job. Beyond that,\n    // we probably got stuck in a strange case of infinite\n    // recursion, so bail out and return NIL.\n    if (recursionLevelNestedRadicalsRemoval > 1) {\n      pop();\n      pop();\n      push(symbol(NIL));\n      restore();\n      return;\n    }\n    performing_roots = true;\n    h = tos - 2;\n    if (DEBUG) {\n      console.log(\"roots checking if \" + stack[tos - 1].toString() + \" is a case of simple roots\");\n    }\n    p2 = pop();\n    p1 = pop();\n    push(p1);\n    push(p2);\n    k = normalisedCoeff(p2, p1);\n    if (isSimpleRoot(k)) {\n      if (DEBUG) {\n        console.log(\"yes, \" + stack[tos - 1].toString() + \" is a case of simple roots\");\n      }\n      lastCoeff = stack[tos - k];\n      leadingCoeff = stack[tos - 1];\n      moveTos(tos - k);\n      pop();\n      pop();\n      getSimpleRoots(k, leadingCoeff, lastCoeff);\n    } else {\n      moveTos(tos - k);\n      roots2();\n    }\n    n = tos - h;\n    if (n === 0) {\n      stop(\"roots: the polynomial is not factorable, try nroots\");\n    }\n    if (n === 1) {\n      performing_roots = false;\n      restore();\n      return;\n    }\n    sort_stack(n);\n    p1 = alloc_tensor(n);\n    p1.tensor.ndim = 1;\n    p1.tensor.dim[0] = n;\n    for (i = l1 = 0, ref2 = n; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      p1.tensor.elem[i] = stack[h + i];\n    }\n    moveTos(h);\n    push(p1);\n    restore();\n    return performing_roots = false;\n  };\n\n  // ok to generate these roots take a look at their form\n  // in the case of even and odd exponents here:\n  // http://www.wolframalpha.com/input/?i=roots+x%5E14+%2B+1\n  // http://www.wolframalpha.com/input/?i=roots+ax%5E14+%2B+b\n  // http://www.wolframalpha.com/input/?i=roots+x%5E15+%2B+1\n  // http://www.wolframalpha.com/input/?i=roots+a*x%5E15+%2B+b\n  getSimpleRoots = function(n, leadingCoeff, lastCoeff) {\n    var aSol, commonPart, l1, m1, ref2, ref3, rootsOfOne;\n    if (DEBUG) {\n      console.log(\"getSimpleRoots\");\n    }\n    save();\n    //tos-n    Coefficient of x^0\n    //tos-1    Coefficient of x^(n-1)\n    n = n - 1;\n    push(lastCoeff);\n    push_rational(1, n);\n    power();\n    push(leadingCoeff);\n    push_rational(1, n);\n    power();\n    divide();\n    commonPart = pop();\n    if (n % 2 === 0) {\n      for (rootsOfOne = l1 = 1, ref2 = n; l1 <= ref2; rootsOfOne = l1 += 2) {\n        push(commonPart);\n        push_integer(-1);\n        push_rational(rootsOfOne, n);\n        power();\n        multiply();\n        aSol = pop();\n        push(aSol);\n        push(aSol);\n        negate();\n      }\n    } else {\n      for (rootsOfOne = m1 = 1, ref3 = n; (1 <= ref3 ? m1 <= ref3 : m1 >= ref3); rootsOfOne = 1 <= ref3 ? ++m1 : --m1) {\n        push(commonPart);\n        push_integer(-1);\n        push_rational(rootsOfOne, n);\n        power();\n        multiply();\n        if (rootsOfOne % 2 === 0) {\n          negate();\n        }\n      }\n    }\n    return restore();\n  };\n\n  roots2 = function() {\n    var k;\n    save();\n    if (DEBUG) {\n      console.log(\"roots2: \" + stack[tos - 1].toString() + \" \" + stack[tos - 2].toString());\n    }\n    p2 = pop(); // the polynomial variable\n    p1 = pop(); // the polynomial\n    push(p1);\n    push(p2);\n    k = normalisedCoeff(p2, p1);\n    if (!hasImaginaryCoeff(k)) {\n      moveTos(tos - k);\n      factorpoly();\n      p1 = pop();\n    } else {\n      moveTos(tos - k);\n      pop();\n      pop();\n    }\n    if (car(p1) === symbol(MULTIPLY)) {\n      p1 = cdr(p1);\n      // scan through all the factors\n      // and find the roots of each of them\n      while (iscons(p1)) {\n        push(car(p1));\n        push(p2);\n        roots3();\n        p1 = cdr(p1);\n      }\n    } else {\n      push(p1);\n      push(p2);\n      roots3();\n    }\n    return restore();\n  };\n\n  roots3 = function() {\n    var n;\n    save();\n    p2 = pop();\n    p1 = pop();\n    if (car(p1) === symbol(POWER) && ispolyexpandedform(cadr(p1), p2) && isposint(caddr(p1))) {\n      n = normalisedCoeff(p2, cadr(p1));\n      mini_solve(n);\n    } else if (ispolyexpandedform(p1, p2)) {\n      n = normalisedCoeff(p2, p1);\n      mini_solve(n);\n    }\n    return restore();\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Input:    stack[tos - 2]    polynomial\n\n  //      stack[tos - 1]    dependent symbol\n\n  //  Output:    stack      roots on stack\n\n  //            (input args are popped first)\n\n  //-----------------------------------------------------------------------------\n\n  // note that for many quadratic, cubic and quartic polynomials we don't\n  // actually end up using the quadratic/cubic/quartic formulas in here,\n  // since there is a chance we factored the polynomial and in so\n  // doing we found some solutions and lowered the degree.\n  mini_solve = function(n) {\n    var C_CHECKED_AS_NOT_ZERO, Q_CHECKED_AS_NOT_ZERO, R_18_a_b_c_d, R_27_a2_d, R_2_b3, R_3_a, R_3_a_C, R_3_a_c, R_4_DELTA03, R_6_a, R_6_a_C, R_C, R_C_over_3a, R_C_simplified_toCheckIfZero, R_DELTA0, R_DELTA0_simplified_toCheckIfZero, R_DELTA0_toBeCheckedIfZero, R_DELTA1, R_Q, R_Q_simplified_toCheckIfZero, R_S, R_S_simplified_toCheckIfZero, R_a2, R_a2_d, R_a2_d2, R_a3, R_a_b_c, R_a_b_c_d, R_a_c, R_b2, R_b2_c2, R_b3, R_b3_d, R_c2, R_c3, R_d2, R_determinant, R_determinant_simplified_toCheckIfZero, R_e2, R_e3, R_m, R_m27_a2_d2, R_m4_a_c3, R_m4_b3_d, R_m9_a_b_c, R_m_b_over_3a, R_minus_4S2_minus_2p, R_minus_b_over_4a, R_p, R_principalCubicRoot, R_q, R_q_over_S, R_r, S_CHECKED_AS_NOT_ZERO, ThreePPlus2M, TwoQOversqrtPPlus2M, biquadraticSolutions, choiceOfRadicalInQSoSIsNotZero, coeff2, coeff3, coeff4, depressedSolutions, eachSolution, flipSignOFQSoCIsNotZero, flipSignOFRadicalSoQIsNotZero, i_sqrt3, l1, len, len1, len2, m1, n1, one_minus_i_sqrt3, one_plus_i_sqrt3, ref2, ref3, ref4, resolventCubicSolutions, root_solution, sqrtPPlus2M, toBeCheckedIFZero;\n    //console.log \"mini_solve >>>>>>>>>>>>>>>>>>>>>>>> tos:\" + tos\n    save();\n    // AX + B, X = -B/A\n    if (n === 2) {\n      //console.log \"mini_solve >>>>>>>>> 1st degree\"\n      p3 = pop();\n      p4 = pop();\n      push(p4);\n      push(p3);\n      divide();\n      negate();\n      restore();\n      return;\n    }\n    // AX^2 + BX + C, X = (-B +/- (B^2 - 4AC)^(1/2)) / (2A)\n    if (n === 3) {\n      //console.log \"mini_solve >>>>>>>>> 2nd degree\"\n      p3 = pop(); // A\n      p4 = pop(); // B\n      p5 = pop(); // C\n      \n      // B^2\n      push(p4);\n      push_integer(2);\n      power();\n      // 4AC\n      push_integer(4);\n      push(p3);\n      multiply();\n      push(p5);\n      multiply();\n      // B^2 - 4AC\n      subtract();\n      //(B^2 - 4AC)^(1/2)\n      push_rational(1, 2);\n      power();\n      //p6 is (B^2 - 4AC)^(1/2)\n      p6 = pop();\n      push(p6);\n      push(p4);\n      subtract(); // -B + (B^2 - 4AC)^(1/2)\n      \n      // 1/2A\n      push(p3);\n      push_integer(2);\n      multiply();\n      divide();\n      //simplify()\n      //rationalize()\n      // tos - 1 now is 1st root: (-B + (B^2 - 4AC)^(1/2)) / (2A)\n      push(p6);\n      push(p4);\n      add();\n      // tos - 1 now is  B + (B^2 - 4AC)^(1/2)\n      // tos - 2: 1st root: (-B + (B^2 - 4AC)^(1/2)) / (2A)\n      negate();\n      // tos - 1 now is  -B -(B^2 - 4AC)^(1/2)\n      // tos - 2: 1st root: (-B + (B^2 - 4AC)^(1/2)) / (2A)\n\n      // 1/2A again\n      push(p3);\n      divide();\n      push_rational(1, 2);\n      multiply();\n      //simplify()\n      //rationalize()\n      // tos - 1: 2nd root: (-B - (B^2 - 4AC)^(1/2)) / (2A)\n      // tos - 2: 1st root: (-B + (B^2 - 4AC)^(1/2)) / (2A)\n      restore();\n      return;\n    }\n    //if (n == 4)\n    if (n === 4 || n === 5) {\n      p3 = pop(); // A\n      p4 = pop(); // B\n      p5 = pop(); // C\n      p6 = pop(); // D\n      \n      // C - only related calculations\n      push(p5);\n      push(p5);\n      multiply();\n      R_c2 = pop();\n      push(R_c2);\n      push(p5);\n      multiply();\n      R_c3 = pop();\n      // B - only related calculations\n      push(p4);\n      push(p4);\n      multiply();\n      R_b2 = pop();\n      push(R_b2);\n      push(p4);\n      multiply();\n      R_b3 = pop();\n      push(R_b3);\n      push(p6);\n      multiply();\n      R_b3_d = pop();\n      push(R_b3_d);\n      push_integer(-4);\n      multiply();\n      R_m4_b3_d = pop();\n      push(R_b3);\n      push_integer(2);\n      multiply();\n      R_2_b3 = pop();\n      // A - only related calculations\n      push(p3);\n      push(p3);\n      multiply();\n      R_a2 = pop();\n      push(R_a2);\n      push(p3);\n      multiply();\n      R_a3 = pop();\n      push_integer(3);\n      push(p3);\n      multiply();\n      R_3_a = pop();\n      push(R_a2);\n      push(p6);\n      multiply();\n      R_a2_d = pop();\n      push(R_a2_d);\n      push(p6);\n      multiply();\n      R_a2_d2 = pop();\n      push(R_a2_d);\n      push_integer(27);\n      multiply();\n      R_27_a2_d = pop();\n      push(R_a2_d2);\n      push_integer(-27);\n      multiply();\n      R_m27_a2_d2 = pop();\n      push(R_3_a);\n      push_integer(2);\n      multiply();\n      R_6_a = pop();\n      // mixed calculations\n      push(p3);\n      push(p5);\n      multiply();\n      R_a_c = pop();\n      push(R_a_c);\n      push(p4);\n      multiply();\n      R_a_b_c = pop();\n      push(R_a_b_c);\n      push(p6);\n      multiply();\n      R_a_b_c_d = pop();\n      push(R_a_c);\n      push_integer(3);\n      multiply();\n      R_3_a_c = pop();\n      push_integer(-4);\n      push(p3);\n      push(R_c3);\n      multiply();\n      multiply();\n      R_m4_a_c3 = pop();\n      push(R_a_b_c);\n      push_integer(9);\n      multiply();\n      negate();\n      R_m9_a_b_c = pop();\n      push(R_a_b_c_d);\n      push_integer(18);\n      multiply();\n      R_18_a_b_c_d = pop();\n      push(R_b2);\n      push(R_3_a_c);\n      subtract();\n      R_DELTA0 = pop();\n      push(R_b2);\n      push(R_c2);\n      multiply();\n      R_b2_c2 = pop();\n      push(p4);\n      negate();\n      push(R_3_a);\n      divide();\n      R_m_b_over_3a = pop();\n      if (n === 4) {\n        if (DEBUG) {\n          console.log(\">>>>>>>>>>>>>>>> actually using cubic formula <<<<<<<<<<<<<<< \");\n        }\n        //console.log \">>>> A:\" + p3.toString()\n        //console.log \">>>> B:\" + p4.toString()\n        //console.log \">>>> C:\" + p5.toString()\n        //console.log \">>>> D:\" + p6.toString()\n        if (DEBUG) {\n          console.log(\"cubic: D0: \" + R_DELTA0.toString());\n        }\n        push(R_DELTA0);\n        push_integer(3);\n        power();\n        push_integer(4);\n        multiply();\n        R_4_DELTA03 = pop();\n        push(R_DELTA0);\n        simplify();\n        absValFloat();\n        R_DELTA0_toBeCheckedIfZero = pop();\n        if (DEBUG) {\n          console.log(\"cubic: D0 as float: \" + R_DELTA0_toBeCheckedIfZero.toString());\n        }\n        //if isZeroAtomOrTensor(R_DELTA0_toBeCheckedIfZero)\n        //  console.log \" *********************************** D0 IS ZERO\"\n\n        // DETERMINANT\n        push(R_18_a_b_c_d);\n        push(R_m4_b3_d);\n        push(R_b2_c2);\n        push(R_m4_a_c3);\n        push(R_m27_a2_d2);\n        add();\n        add();\n        add();\n        add();\n        simplify();\n        absValFloat();\n        R_determinant = pop();\n        if (DEBUG) {\n          console.log(\"cubic: DETERMINANT: \" + R_determinant.toString());\n        }\n        // R_DELTA1\n        push(R_2_b3);\n        push(R_m9_a_b_c);\n        push(R_27_a2_d);\n        add();\n        add();\n        R_DELTA1 = pop();\n        if (DEBUG) {\n          console.log(\"cubic: D1: \" + R_DELTA1.toString());\n        }\n        // R_Q\n        push(R_DELTA1);\n        push_integer(2);\n        power();\n        push(R_4_DELTA03);\n        subtract();\n        push_rational(1, 2);\n        power();\n        simplify();\n        R_Q = pop();\n        if (isZeroAtomOrTensor(R_determinant)) {\n          if (isZeroAtomOrTensor(R_DELTA0_toBeCheckedIfZero)) {\n            if (DEBUG) {\n              console.log(\" cubic: DETERMINANT IS ZERO and delta0 is zero\");\n            }\n            push(R_m_b_over_3a); // just same solution three times\n            restore();\n            return;\n          } else {\n            if (DEBUG) {\n              console.log(\" cubic: DETERMINANT IS ZERO and delta0 is not zero\");\n            }\n            push(p3);\n            push(p6);\n            push_integer(9);\n            multiply();\n            multiply();\n            push(p4);\n            push(p5);\n            multiply();\n            subtract();\n            push(R_DELTA0);\n            push_integer(2);\n            multiply();\n            divide(); // first solution\n            root_solution = pop();\n            push(root_solution); // pushing two of them on the stack\n            push(root_solution);\n            // second solution here\n            // 4abc\n            push(R_a_b_c);\n            push_integer(4);\n            multiply();\n            // -9a*a*d\n            push(p3);\n            push(p3);\n            push(p6);\n            push_integer(9);\n            multiply();\n            multiply();\n            multiply();\n            negate();\n            // -9*b^3\n            push(R_b3);\n            negate();\n            // sum the three terms\n            add();\n            add();\n            // denominator is a*delta0\n            push(p3);\n            push(R_DELTA0);\n            multiply();\n            // build the fraction\n            divide();\n            restore();\n            return;\n          }\n        }\n        C_CHECKED_AS_NOT_ZERO = false;\n        flipSignOFQSoCIsNotZero = false;\n        while (!C_CHECKED_AS_NOT_ZERO) {\n          // R_C\n          push(R_Q);\n          if (flipSignOFQSoCIsNotZero) {\n            negate();\n          }\n          push(R_DELTA1);\n          add();\n          push_rational(1, 2);\n          multiply();\n          push_rational(1, 3);\n          power();\n          simplify();\n          R_C = pop();\n          if (DEBUG) {\n            console.log(\"cubic: C: \" + R_C.toString());\n          }\n          push(R_C);\n          simplify();\n          absValFloat();\n          R_C_simplified_toCheckIfZero = pop();\n          if (DEBUG) {\n            console.log(\"cubic: C as absval and float: \" + R_C_simplified_toCheckIfZero.toString());\n          }\n          if (isZeroAtomOrTensor(R_C_simplified_toCheckIfZero)) {\n            if (DEBUG) {\n              console.log(\" cubic: C IS ZERO flipping the sign\");\n            }\n            flipSignOFQSoCIsNotZero = true;\n          } else {\n            C_CHECKED_AS_NOT_ZERO = true;\n          }\n        }\n        push(R_C);\n        push(R_3_a);\n        multiply();\n        R_3_a_C = pop();\n        push(R_3_a_C);\n        push_integer(2);\n        multiply();\n        R_6_a_C = pop();\n        // imaginary parts calculations\n        push(imaginaryunit);\n        push_integer(3);\n        push_rational(1, 2);\n        power();\n        multiply();\n        i_sqrt3 = pop();\n        push_integer(1);\n        push(i_sqrt3);\n        add();\n        one_plus_i_sqrt3 = pop();\n        push_integer(1);\n        push(i_sqrt3);\n        subtract();\n        one_minus_i_sqrt3 = pop();\n        push(R_C);\n        push(R_3_a);\n        divide();\n        R_C_over_3a = pop();\n        // first solution\n        push(R_m_b_over_3a); // first term\n        push(R_C_over_3a);\n        negate(); // second term\n        push(R_DELTA0);\n        push(R_3_a_C);\n        divide();\n        negate(); // third term\n        // now add the three terms together\n        add();\n        add();\n        simplify();\n        // second solution\n        push(R_m_b_over_3a); // first term\n        push(R_C_over_3a);\n        push(one_plus_i_sqrt3);\n        multiply();\n        push_integer(2);\n        divide(); // second term\n        push(one_minus_i_sqrt3);\n        push(R_DELTA0);\n        multiply();\n        push(R_6_a_C);\n        divide(); // third term\n        // now add the three terms together\n        add();\n        add();\n        simplify();\n        // third solution\n        push(R_m_b_over_3a); // first term\n        push(R_C_over_3a);\n        push(one_minus_i_sqrt3);\n        multiply();\n        push_integer(2);\n        divide(); // second term\n        push(one_plus_i_sqrt3);\n        push(R_DELTA0);\n        multiply();\n        push(R_6_a_C);\n        divide(); // third term\n        // now add the three terms together\n        add();\n        add();\n        simplify();\n        restore();\n        return;\n      }\n      // See http://www.sscc.edu/home/jdavidso/Math/Catalog/Polynomials/Fourth/Fourth.html\n      // for a description of general shapes and properties of fourth degree polynomials\n      if (n === 5) {\n        if (DEBUG) {\n          console.log(\">>>>>>>>>>>>>>>> actually using quartic formula <<<<<<<<<<<<<<< \");\n        }\n        p7 = pop(); // E\n        if (isZeroAtomOrTensor(p4) && isZeroAtomOrTensor(p6) && !isZeroAtomOrTensor(p5) && !isZeroAtomOrTensor(p7)) {\n          if (DEBUG) {\n            console.log(\"biquadratic case\");\n          }\n          push(p3);\n          push(symbol(SECRETX));\n          push_integer(2);\n          power();\n          multiply();\n          push(p5);\n          push(symbol(SECRETX));\n          multiply();\n          push(p7);\n          add();\n          add();\n          push(symbol(SECRETX));\n          roots();\n          biquadraticSolutions = pop();\n          ref2 = biquadraticSolutions.tensor.elem;\n          for (l1 = 0, len = ref2.length; l1 < len; l1++) {\n            eachSolution = ref2[l1];\n            push(eachSolution);\n            push_rational(1, 2);\n            power();\n            simplify();\n            push(eachSolution);\n            push_rational(1, 2);\n            power();\n            negate();\n            simplify();\n          }\n          restore();\n          return;\n        }\n        // D - only related calculations\n        push(p6);\n        push(p6);\n        multiply();\n        R_d2 = pop();\n        // E - only related calculations\n        push(p7);\n        push(p7);\n        multiply();\n        R_e2 = pop();\n        push(R_e2);\n        push(p7);\n        multiply();\n        R_e3 = pop();\n        // DETERMINANT\n        push_integer(256);\n        push(R_a3);\n        push(R_e3);\n        multiply();\n        multiply(); // first term 256 a^3 e^3\n        push_integer(-192);\n        push(R_a2_d);\n        push(R_e2);\n        push(p4);\n        multiply();\n        multiply();\n        multiply(); // second term -192 a^3 b d e^2\n        push_integer(-128);\n        push(R_a2);\n        push(R_c2);\n        push(R_e2);\n        multiply();\n        multiply();\n        multiply(); // third term -128 a^2 c^2 e^2\n        push_integer(144);\n        push(R_a2_d2);\n        push(p5);\n        push(p7);\n        multiply();\n        multiply();\n        multiply(); // fourth term 144 a^2 c d^2 e\n        push(R_m27_a2_d2);\n        push(R_d2);\n        multiply(); // fifth term -27 a^2 d^4\n        push_integer(144);\n        push(R_a_b_c);\n        push(p4);\n        push(R_e2);\n        multiply();\n        multiply();\n        multiply(); // sixth term 144 a b^2 c e^2\n        push_integer(-6);\n        push(p3);\n        push(R_b2);\n        push(R_d2);\n        push(p7);\n        multiply();\n        multiply();\n        multiply();\n        multiply(); // seventh term -6 a b^2 d^2 e\n        push_integer(-80);\n        push(R_a_b_c_d);\n        push(p5);\n        push(p7);\n        multiply();\n        multiply();\n        multiply(); // eigth term -80 a b c^2 d e\n        push_integer(18);\n        push(R_a_b_c_d);\n        push(R_d2);\n        multiply();\n        multiply(); // ninth term 18 a b c d^3\n        push_integer(16);\n        push(R_a_c);\n        push(R_c3);\n        push(p7);\n        multiply();\n        multiply();\n        multiply(); // tenth term 16 a c^4 e\n        push_integer(-4);\n        push(R_a_c);\n        push(R_c2);\n        push(R_d2);\n        multiply();\n        multiply();\n        multiply(); // eleventh term -4 a c^3 d^2\n        push_integer(-27);\n        push(R_b3);\n        push(p4);\n        push(R_e2);\n        multiply();\n        multiply();\n        multiply(); // twelveth term -27 b^4 e^2\n        push_integer(18);\n        push(R_b3_d);\n        push(p5);\n        push(p7);\n        multiply();\n        multiply();\n        multiply(); // thirteenth term 18 b^3 c d e\n        push(R_m4_b3_d);\n        push(R_d2);\n        multiply(); // fourteenth term -4 b^3 d^3\n        push_integer(-4);\n        push(R_b2_c2);\n        push(p5);\n        push(p7);\n        multiply();\n        multiply();\n        multiply(); // fifteenth term -4 b^2 c^3 e\n        push(R_b2_c2);\n        push(R_d2);\n        multiply(); // sixteenth term b^2 c^2 d^2\n        \n        // add together the sixteen terms by doing\n        // fifteen adds\n        add();\n        add();\n        add();\n        add();\n        add();\n        add();\n        add();\n        add();\n        add();\n        add();\n        add();\n        add();\n        add();\n        add();\n        add();\n        R_determinant = pop();\n        if (DEBUG) {\n          console.log(\"R_determinant: \" + R_determinant.toString());\n        }\n        // DELTA0\n        push(R_c2); // term one of DELTA0\n        push_integer(-3);\n        push(p4);\n        push(p6);\n        multiply();\n        multiply(); // term two of DELTA0\n        push_integer(12);\n        push(p3);\n        push(p7);\n        multiply();\n        multiply(); // term three of DELTA0\n        \n        // add the three terms together\n        add();\n        add();\n        R_DELTA0 = pop();\n        if (DEBUG) {\n          console.log(\"R_DELTA0: \" + R_DELTA0.toString());\n        }\n        // DELTA1\n        push_integer(2);\n        push(R_c3);\n        multiply();\n        push_integer(-9);\n        push(p4);\n        push(p5);\n        push(p6);\n        multiply();\n        multiply();\n        multiply();\n        push_integer(27);\n        push(R_b2);\n        push(p7);\n        multiply();\n        multiply();\n        push_integer(27);\n        push(p3);\n        push(R_d2);\n        multiply();\n        multiply();\n        push_integer(-72);\n        push(R_a_c);\n        push(p7);\n        multiply();\n        multiply();\n        // add the five terms together\n        add();\n        add();\n        add();\n        add();\n        R_DELTA1 = pop();\n        if (DEBUG) {\n          console.log(\"R_DELTA1: \" + R_DELTA1.toString());\n        }\n        // p\n        push_integer(8);\n        push(R_a_c);\n        multiply();\n        push_integer(-3);\n        push(R_b2);\n        multiply();\n        add();\n        push_integer(8);\n        push(R_a2);\n        multiply();\n        divide();\n        R_p = pop();\n        if (DEBUG) {\n          console.log(\"p: \" + R_p.toString());\n        }\n        // q\n        push(R_b3);\n        push_integer(-4);\n        push(R_a_b_c);\n        multiply();\n        push_integer(8);\n        push(R_a2_d);\n        multiply();\n        add();\n        add();\n        push_integer(8);\n        push(R_a3);\n        multiply();\n        divide();\n        R_q = pop();\n        if (DEBUG) {\n          console.log(\"q: \" + R_q.toString());\n        }\n        if (DEBUG) {\n          console.log(\"tos 1 \" + tos);\n        }\n        if (!isZeroAtomOrTensor(p4)) {\n          if (DEBUG) {\n            console.log(\"tos 2 \" + tos);\n          }\n          push_integer(8);\n          push(p5);\n          push(p3);\n          multiply();\n          multiply();\n          push_integer(-3);\n          push(p4);\n          push_integer(2);\n          power();\n          multiply();\n          add();\n          push_integer(8);\n          push(p3);\n          push_integer(2);\n          power();\n          multiply();\n          divide();\n          R_p = pop();\n          if (DEBUG) {\n            console.log(\"p for depressed quartic: \" + R_p.toString());\n          }\n          push(p4);\n          push_integer(3);\n          power();\n          push_integer(-4);\n          push(p3);\n          push(p4);\n          push(p5);\n          multiply();\n          multiply();\n          multiply();\n          push_integer(8);\n          push(p6);\n          push(p3);\n          push_integer(2);\n          power();\n          multiply();\n          multiply();\n          add();\n          add();\n          push_integer(8);\n          push(p3);\n          push_integer(3);\n          power();\n          multiply();\n          divide();\n          R_q = pop();\n          if (DEBUG) {\n            console.log(\"q for depressed quartic: \" + R_q.toString());\n          }\n          // convert to depressed quartic\n          push(p4);\n          push_integer(4);\n          power();\n          push_integer(-3);\n          multiply();\n          push_integer(256);\n          push(R_a3);\n          push(p7);\n          multiply();\n          multiply();\n          push_integer(-64);\n          push(R_a2_d);\n          push(p4);\n          multiply();\n          multiply();\n          push_integer(16);\n          push(R_b2);\n          push(p3);\n          push(p5);\n          multiply();\n          multiply();\n          multiply();\n          add();\n          add();\n          add();\n          push_integer(256);\n          push(p3);\n          push_integer(4);\n          power();\n          multiply();\n          divide();\n          R_r = pop();\n          if (DEBUG) {\n            console.log(\"r for depressed quartic: \" + R_r.toString());\n          }\n          if (DEBUG) {\n            console.log(\"tos 4 \" + tos);\n          }\n          push(symbol(SECRETX));\n          push_integer(4);\n          power();\n          if (DEBUG) {\n            console.log(\"4 * x^4: \" + stack[tos - 1].toString());\n          }\n          push(R_p);\n          push(symbol(SECRETX));\n          push_integer(2);\n          power();\n          multiply();\n          if (DEBUG) {\n            console.log(\"R_p * x^2: \" + stack[tos - 1].toString());\n          }\n          push(R_q);\n          push(symbol(SECRETX));\n          multiply();\n          if (DEBUG) {\n            console.log(\"R_q * x: \" + stack[tos - 1].toString());\n          }\n          push(R_r);\n          if (DEBUG) {\n            console.log(\"R_r: \" + stack[tos - 1].toString());\n          }\n          add();\n          add();\n          add();\n          simplify();\n          if (DEBUG) {\n            console.log(\"solving depressed quartic: \" + stack[tos - 1].toString());\n          }\n          push(symbol(SECRETX));\n          roots();\n          depressedSolutions = pop();\n          if (DEBUG) {\n            console.log(\"depressedSolutions: \" + depressedSolutions);\n          }\n          ref3 = depressedSolutions.tensor.elem;\n          for (m1 = 0, len1 = ref3.length; m1 < len1; m1++) {\n            eachSolution = ref3[m1];\n            push(eachSolution);\n            push(p4);\n            push_integer(4);\n            push(p3);\n            multiply();\n            divide();\n            subtract();\n            simplify();\n            if (DEBUG) {\n              console.log(\"solution from depressed: \" + stack[tos - 1].toString());\n            }\n          }\n          restore();\n          return;\n        } else {\n          R_p = p5;\n          R_q = p6;\n          R_r = p7;\n          /*\n           * Descartes' solution\n           * https://en.wikipedia.org/wiki/Quartic_function#Descartes.27_solution\n           * finding the \"u\" in the depressed equation\n\n          push_integer(2)\n          push(R_p)\n          multiply()\n          coeff2 = pop()\n\n          push_integer(-4)\n          push(R_p)\n          push_integer(2)\n          power()\n          multiply()\n          push(R_r)\n          multiply()\n          coeff3 = pop()\n\n          push(R_q)\n          push_integer(2)\n          power()\n          negate()\n          coeff4 = pop()\n\n           * now build the polynomial\n          push(symbol(SECRETX))\n          push_integer(3)\n          power()\n\n          push(coeff2)\n          push(symbol(SECRETX))\n          push_integer(2)\n          power()\n          multiply()\n\n          push(coeff3)\n          push(symbol(SECRETX))\n          multiply()\n\n          push(coeff4)\n\n          add()\n          add()\n          add()\n\n          console.log(\"Descarte's resolventCubic: \" +  stack[tos-1].toString())\n          push(symbol(SECRETX))\n\n          roots()\n\n          resolventCubicSolutions = pop()\n          console.log(\"Descarte's resolventCubic solutions: \" +  resolventCubicSolutions)\n          console.log(\"tos: \" +  tos)\n\n          R_u = null\n          #R_u = resolventCubicSolutions.tensor.elem[1]\n          for eachSolution in resolventCubicSolutions.tensor.elem\n            console.log(\"examining solution: \" +  eachSolution)\n            push(eachSolution)\n            push_integer(2)\n            multiply()\n            push(R_p)\n            add()\n\n            absValFloat()\n            toBeCheckedIFZero = pop()\n            console.log(\"abs value is: \" +  eachSolution)\n            if !isZeroAtomOrTensor(toBeCheckedIFZero)\n              R_u = eachSolution\n              break\n\n          console.log(\"chosen solution: \" +  R_u)\n\n          push(R_u)\n          negate()\n          R_s = pop()\n\n          push(R_p)\n          push(R_u)\n          push_integer(2)\n          power()\n          push(R_q)\n          push(R_u)\n          divide()\n          add()\n          add()\n          push_integer(2)\n          divide()\n          R_t = pop()\n\n          push(R_p)\n          push(R_u)\n          push_integer(2)\n          power()\n          push(R_q)\n          push(R_u)\n          divide()\n          subtract()\n          add()\n          push_integer(2)\n          divide()\n          R_v = pop()\n\n           * factoring the quartic into two quadratics:\n\n           * now build the polynomial\n          push(symbol(SECRETX))\n          push_integer(2)\n          power()\n\n          push(R_s)\n          push(symbol(SECRETX))\n          multiply()\n\n          push(R_t)\n\n          add()\n          add()\n\n          console.log(\"factored quartic 1: \" + stack[tos-1].toString())\n\n          push(symbol(SECRETX))\n          push_integer(2)\n          power()\n\n          push(R_u)\n          push(symbol(SECRETX))\n          multiply()\n\n          push(R_v)\n\n          add()\n          add()\n\n          console.log(\"factored quartic 2: \" + stack[tos-1].toString())\n          pop()\n\n          restore()\n          return\n           */\n          // Ferrari's solution\n          // https://en.wikipedia.org/wiki/Quartic_function#Ferrari.27s_solution\n          // finding the \"m\" in the depressed equation\n          push_rational(5, 2);\n          push(R_p);\n          multiply();\n          coeff2 = pop();\n          push_integer(2);\n          push(R_p);\n          push_integer(2);\n          power();\n          multiply();\n          push(R_r);\n          subtract();\n          coeff3 = pop();\n          push(R_p);\n          push_integer(3);\n          power();\n          push_integer(2);\n          divide();\n          push_rational(-1, 2);\n          push(R_p);\n          push(R_r);\n          multiply();\n          multiply();\n          push_rational(-1, 8);\n          push(R_q);\n          push_integer(2);\n          power();\n          multiply();\n          add();\n          add();\n          coeff4 = pop();\n          push(symbol(SECRETX));\n          push_integer(3);\n          power();\n          push(coeff2);\n          push(symbol(SECRETX));\n          push_integer(2);\n          power();\n          multiply();\n          push(coeff3);\n          push(symbol(SECRETX));\n          multiply();\n          push(coeff4);\n          add();\n          add();\n          add();\n          if (DEBUG) {\n            console.log(\"resolventCubic: \" + stack[tos - 1].toString());\n          }\n          push(symbol(SECRETX));\n          roots();\n          resolventCubicSolutions = pop();\n          if (DEBUG) {\n            console.log(\"resolventCubicSolutions: \" + resolventCubicSolutions);\n          }\n          R_m = null;\n          ref4 = resolventCubicSolutions.tensor.elem;\n          //R_m = resolventCubicSolutions.tensor.elem[1]\n          for (n1 = 0, len2 = ref4.length; n1 < len2; n1++) {\n            eachSolution = ref4[n1];\n            if (DEBUG) {\n              console.log(\"examining solution: \" + eachSolution);\n            }\n            push(eachSolution);\n            push_integer(2);\n            multiply();\n            push(R_p);\n            add();\n            absValFloat();\n            toBeCheckedIFZero = pop();\n            if (DEBUG) {\n              console.log(\"abs value is: \" + eachSolution);\n            }\n            if (!isZeroAtomOrTensor(toBeCheckedIFZero)) {\n              R_m = eachSolution;\n              break;\n            }\n          }\n          if (DEBUG) {\n            console.log(\"chosen solution: \" + R_m);\n          }\n          push(R_m);\n          push_integer(2);\n          multiply();\n          push(R_p);\n          add();\n          push_rational(1, 2);\n          power();\n          simplify();\n          sqrtPPlus2M = pop();\n          push(R_q);\n          push_integer(2);\n          multiply();\n          push(sqrtPPlus2M);\n          divide();\n          simplify();\n          TwoQOversqrtPPlus2M = pop();\n          push(R_p);\n          push_integer(3);\n          multiply();\n          push(R_m);\n          push_integer(2);\n          multiply();\n          add();\n          ThreePPlus2M = pop();\n          // solution1\n          push(sqrtPPlus2M);\n          push(ThreePPlus2M);\n          push(TwoQOversqrtPPlus2M);\n          add();\n          negate();\n          push_rational(1, 2);\n          power();\n          simplify();\n          add();\n          push_integer(2);\n          divide();\n          // solution2\n          push(sqrtPPlus2M);\n          push(ThreePPlus2M);\n          push(TwoQOversqrtPPlus2M);\n          add();\n          negate();\n          push_rational(1, 2);\n          power();\n          simplify();\n          subtract();\n          push_integer(2);\n          divide();\n          // solution3\n          push(sqrtPPlus2M);\n          negate();\n          push(ThreePPlus2M);\n          push(TwoQOversqrtPPlus2M);\n          subtract();\n          negate();\n          push_rational(1, 2);\n          power();\n          simplify();\n          add();\n          push_integer(2);\n          divide();\n          // solution4\n          push(sqrtPPlus2M);\n          negate();\n          push(ThreePPlus2M);\n          push(TwoQOversqrtPPlus2M);\n          subtract();\n          negate();\n          push_rational(1, 2);\n          power();\n          simplify();\n          subtract();\n          push_integer(2);\n          divide();\n          restore();\n          return;\n        }\n        // Q ---------------------------\n        push(R_determinant);\n        simplify();\n        absValFloat();\n        R_determinant_simplified_toCheckIfZero = pop();\n        push(R_DELTA0);\n        simplify();\n        absValFloat();\n        R_DELTA0_simplified_toCheckIfZero = pop();\n        S_CHECKED_AS_NOT_ZERO = false;\n        choiceOfRadicalInQSoSIsNotZero = 0;\n        while (!S_CHECKED_AS_NOT_ZERO) {\n          Q_CHECKED_AS_NOT_ZERO = false;\n          flipSignOFRadicalSoQIsNotZero = false;\n          while (!Q_CHECKED_AS_NOT_ZERO) {\n            // D1 under the outer radical\n            push(R_DELTA1);\n            // D1^2 under the inner radical\n            push(R_DELTA1);\n            push_integer(2);\n            power();\n            // 4*D0^3 under the inner radical\n            push_integer(-4);\n            push(R_DELTA0);\n            push_integer(3);\n            power();\n            multiply();\n            // addition under the inner radical\n            add();\n            // the second radical\n            push_rational(1, 2);\n            power();\n            if (flipSignOFRadicalSoQIsNotZero) {\n              negate();\n            }\n            // the addition under the outer radical\n            add();\n            // content of outer radical divided by two\n            push_integer(2);\n            divide();\n            if (DEBUG) {\n              console.log(\"content of cubic root: \" + stack[tos - 1].toString());\n            }\n            // outer radical calculation: cubic root\n            // now we actually have to find all the roots\n            // because we have to pick the one that makes S != 0\n            push_rational(1, 3);\n            power();\n            simplify();\n            R_principalCubicRoot = pop();\n            if (DEBUG) {\n              console.log(\"principal cubic root: \" + R_principalCubicRoot.toString());\n            }\n            if (DEBUG) {\n              console.log(\"tos : \" + tos);\n            }\n            if (choiceOfRadicalInQSoSIsNotZero === 0) {\n              if (DEBUG) {\n                console.log(\"chosing principal cubic root\");\n              }\n              push(R_principalCubicRoot);\n            } else if (choiceOfRadicalInQSoSIsNotZero === 1) {\n              if (DEBUG) {\n                console.log(\"chosing cubic root beyond principal\");\n              }\n              push(R_principalCubicRoot);\n              push_rational(-1, 2);\n              multiply();\n              push_integer(3);\n              push_rational(1, 2);\n              power();\n              push(imaginaryunit);\n              multiply();\n              push_rational(-1, 2);\n              multiply();\n              push(R_principalCubicRoot);\n              multiply();\n              add();\n            } else if (choiceOfRadicalInQSoSIsNotZero === 1) {\n              if (DEBUG) {\n                console.log(\"chosing cubic root beyond beyond principal\");\n              }\n              push(R_principalCubicRoot);\n              push_rational(-1, 2);\n              multiply();\n              push_integer(3);\n              push_rational(1, 2);\n              power();\n              push(imaginaryunit);\n              multiply();\n              push_rational(1, 2);\n              multiply();\n              push(R_principalCubicRoot);\n              multiply();\n              add();\n            }\n            simplify();\n            R_Q = pop();\n            if (DEBUG) {\n              console.log(\"Q \" + R_Q.toString());\n            }\n            if (DEBUG) {\n              console.log(\"tos: \" + tos);\n            }\n            push(R_Q);\n            simplify();\n            absValFloat();\n            R_Q_simplified_toCheckIfZero = pop();\n            if (DEBUG) {\n              console.log(\"Q simplified and abs\" + R_Q_simplified_toCheckIfZero.toString());\n            }\n            if (isZeroAtomOrTensor(R_Q_simplified_toCheckIfZero) && (!isZeroAtomOrTensor(R_determinant_simplified_toCheckIfZero) && isZeroAtomOrTensor(R_DELTA0_simplified_toCheckIfZero))) {\n              if (DEBUG) {\n                console.log(\" *********************************** Q IS ZERO and it matters, flipping the sign\");\n              }\n              flipSignOFRadicalSoQIsNotZero = true;\n            } else {\n              Q_CHECKED_AS_NOT_ZERO = true;\n            }\n            if (DEBUG) {\n              console.log(\"tos: \" + tos);\n            }\n          }\n          // S\n          push_rational(-2, 3);\n          push(R_p);\n          multiply();\n          push(R_Q);\n          push(R_DELTA0);\n          push(R_Q);\n          divide();\n          add();\n          //rationalize()\n          //console.log(\"rationalised: \" + stack[tos-1].toString())\n          //simplify()\n          push(R_3_a);\n          divide();\n          add();\n          push_rational(1, 2);\n          power();\n          push_integer(2);\n          divide();\n          show_power_debug = true;\n          simplify();\n          R_S = pop();\n          if (DEBUG) {\n            console.log(\"S \" + R_S.toString());\n          }\n          // now check if S is zero\n          push(R_S);\n          simplify();\n          absValFloat();\n          R_S_simplified_toCheckIfZero = pop();\n          if (DEBUG) {\n            console.log(\"S \" + R_S_simplified_toCheckIfZero.toString());\n          }\n          if (isZeroAtomOrTensor(R_S_simplified_toCheckIfZero)) {\n            if (DEBUG) {\n              console.log(\" *********************************** S IS ZERO chosing another cubic root\");\n            }\n            choiceOfRadicalInQSoSIsNotZero++;\n          } else {\n            S_CHECKED_AS_NOT_ZERO = true;\n          }\n          if (DEBUG) {\n            console.log(\"tos: \" + tos);\n          }\n        }\n        // ----------------------------\n        if (DEBUG) {\n          console.log(\"tos: \" + tos);\n        }\n        push(p4);\n        negate();\n        push(p3);\n        push_integer(4);\n        multiply();\n        divide();\n        R_minus_b_over_4a = pop();\n        push_integer(-4);\n        push(R_S);\n        push_integer(2);\n        power();\n        multiply();\n        push_integer(2);\n        push(R_p);\n        multiply();\n        subtract();\n        R_minus_4S2_minus_2p = pop();\n        push(R_q);\n        push(R_S);\n        divide();\n        R_q_over_S = pop();\n        if (DEBUG) {\n          console.log(\"tos before putting together the 4 solutions: \" + tos);\n        }\n        // first solution\n        push(R_minus_b_over_4a); // first term\n        push(R_S);\n        subtract();\n        push(R_minus_4S2_minus_2p);\n        push(R_q_over_S);\n        add();\n        push_rational(1, 2);\n        power();\n        push_integer(2);\n        divide();\n        add();\n        simplify();\n        // second solution\n        push(R_minus_b_over_4a); // first term\n        push(R_S);\n        subtract();\n        push(R_minus_4S2_minus_2p);\n        push(R_q_over_S);\n        add();\n        push_rational(1, 2);\n        power();\n        push_integer(2);\n        divide();\n        subtract();\n        simplify();\n        // third solution\n        push(R_minus_b_over_4a); // first term\n        push(R_S);\n        add();\n        push(R_minus_4S2_minus_2p);\n        push(R_q_over_S);\n        subtract();\n        push_rational(1, 2);\n        power();\n        push_integer(2);\n        divide();\n        add();\n        simplify();\n        // fourth solution\n        push(R_minus_b_over_4a); // first term\n        push(R_S);\n        add();\n        push(R_minus_4S2_minus_2p);\n        push(R_q_over_S);\n        subtract();\n        push_rational(1, 2);\n        power();\n        push_integer(2);\n        divide();\n        subtract();\n        simplify();\n        restore();\n        return;\n      }\n    }\n    moveTos(tos - n);\n    return restore();\n  };\n\n  Eval_round = function() {\n    push(cadr(p1));\n    Eval();\n    return yround();\n  };\n\n  yround = function() {\n    save();\n    yyround();\n    return restore();\n  };\n\n  yyround = function() {\n    var d;\n    d = 0.0;\n    p1 = pop();\n    if (!isNumericAtom(p1)) {\n      push_symbol(ROUND);\n      push(p1);\n      list(2);\n      return;\n    }\n    if (isdouble(p1)) {\n      d = Math.round(p1.d);\n      push_double(d);\n      return;\n    }\n    if (isinteger(p1)) {\n      push(p1);\n      return;\n    }\n    push(p1);\n    yyfloat();\n    p1 = pop();\n    return push_integer(Math.round(p1.d));\n  };\n\n  // This scanner uses the recursive descent method.\n\n  // The char pointers token_str and scan_str are pointers to the input string as\n  // in the following example.\n\n  //  | g | a | m | m | a |   | a | l | p | h | a |\n  //    ^                   ^\n  //    token_str           scan_str\n\n  // The char pointer token_buf points to a malloc buffer.\n\n  //  | g | a | m | m | a | \\0 |\n  //    ^\n  //    token_buf\n\n  // In the sequence of method invocations for scanning,\n  // first we do the calls for scanning the operands\n  // of the operators of least precedence.\n  // So, since precedence in maths goes something like\n  // (form high to low) exponents, mult/div, plus/minus\n  // so we scan first for terms, then factors, then powers.\n  // That's the general idea, but of course we also have to deal\n  // with things like parens, non-commutative\n  // dot (or inner) product, assignments and tests,\n  // function calls etc.\n  // Note that a^1/2 is, correctly, a/2, not, incorrectly, sqrt(a),\n  // see comment in related test in power.coffee for more about this.\n\n  //  Notes:\n\n  //  Formerly add() and multiply() were used to construct expressions but\n  //  this preevaluation caused problems.\n\n  //  For example, suppose A has the floating point value inf.\n\n  //  Before, the expression A/A resulted in 1 because the scanner would\n  //  divide the symbols.\n\n  //  After removing add() and multiply(), A/A results in nan which is the\n  //  correct result.\n\n  //  The functions negate() and inverse() are used but they do not cause\n  //  problems with preevaluation of symbols.\n  T_INTEGER = 1001;\n\n  T_DOUBLE = 1002;\n\n  T_SYMBOL = 1003;\n\n  T_FUNCTION = 1004;\n\n  T_NEWLINE = 1006;\n\n  T_STRING = 1007;\n\n  T_GTEQ = 1008;\n\n  T_LTEQ = 1009;\n\n  T_EQ = 1010;\n\n  T_NEQ = 1011;\n\n  T_QUOTASSIGN = 1012;\n\n  token = \"\";\n\n  newline_flag = 0;\n\n  meta_mode = 0;\n\n  input_str = 0;\n\n  scan_str = 0;\n\n  token_str = 0;\n\n  token_buf = 0;\n\n  lastFoundSymbol = null;\n\n  symbolsRightOfAssignment = null;\n\n  symbolsLeftOfAssignment = null;\n\n  isSymbolLeftOfAssignment = null;\n\n  scanningParameters = null;\n\n  functionInvokationsScanningStack = null;\n\n  skipRootVariableToBeSolved = false;\n\n  assignmentFound = null;\n\n  // Returns number of chars scanned and expr on stack.\n\n  // Returns zero when nothing left to scan.\n\n  // takes a string\n  scanned = \"\";\n\n  scan = function(s) {\n    if (DEBUG) {\n      console.log(\"#### scanning \" + s);\n    }\n    //if s==\"y=x\"\n    //  debugger\n    //if s==\"y\"\n    //  debugger\n    //if s==\"i=sqrt(-1)\"\n    //  debugger\n    lastFoundSymbol = null;\n    symbolsRightOfAssignment = [];\n    symbolsLeftOfAssignment = [];\n    isSymbolLeftOfAssignment = true;\n    scanningParameters = [];\n    functionInvokationsScanningStack = [\"\"];\n    assignmentFound = false;\n    scanned = s;\n    meta_mode = 0;\n    expanding++;\n    input_str = 0;\n    scan_str = 0;\n    get_next_token();\n    if (token === \"\") {\n      push(symbol(NIL));\n      expanding--;\n      return 0;\n    }\n    scan_stmt();\n    expanding--;\n    if (!assignmentFound) {\n      symbolsInExpressionsWithoutAssignments = symbolsInExpressionsWithoutAssignments.concat(symbolsLeftOfAssignment);\n    }\n    return token_str - input_str;\n  };\n\n  // takes a string\n  scan_meta = function(s) {\n    scanned = s;\n    meta_mode = 1;\n    expanding++;\n    input_str = 0;\n    scan_str = 0;\n    get_next_token();\n    if (token === \"\") {\n      push(symbol(NIL));\n      expanding--;\n      return 0;\n    }\n    scan_stmt();\n    expanding--;\n    return token_str - input_str;\n  };\n\n  scan_stmt = function() {\n    var assignmentIsOfQuotedType, existingDependencies, i, indexOfSymbolLeftOfAssignment, l1, len, len1, m1, symbolLeftOfAssignment;\n    scan_relation();\n    assignmentIsOfQuotedType = false;\n    if (token === T_QUOTASSIGN) {\n      assignmentIsOfQuotedType = true;\n    }\n    if (token === T_QUOTASSIGN || token === '=') {\n      symbolLeftOfAssignment = lastFoundSymbol;\n      if (DEBUG) {\n        console.log(\"assignment!\");\n      }\n      assignmentFound = true;\n      isSymbolLeftOfAssignment = false;\n      get_next_token();\n      push_symbol(SETQ);\n      swap();\n      // if it's a := then add a quote\n      if (assignmentIsOfQuotedType) {\n        push_symbol(QUOTE);\n      }\n      scan_relation();\n      // if it's a := then you have to list\n      // together the quote and its argument\n      if (assignmentIsOfQuotedType) {\n        list(2);\n      }\n      list(3);\n      isSymbolLeftOfAssignment = true;\n      if (codeGen) {\n        // in case of re-assignment, the symbol on the\n        // left will also be in the set of the symbols\n        // on the right. In that case just remove it from\n        // the symbols on the right.\n        indexOfSymbolLeftOfAssignment = symbolsRightOfAssignment.indexOf(symbolLeftOfAssignment);\n        if (indexOfSymbolLeftOfAssignment !== -1) {\n          symbolsRightOfAssignment.splice(indexOfSymbolLeftOfAssignment, 1);\n          symbolsHavingReassignments.push(symbolLeftOfAssignment);\n        }\n        \n        // print out the immediate dependencies\n        if (DEBUG) {\n          console.log(\"locally, \" + symbolLeftOfAssignment + \" depends on: \");\n          for (l1 = 0, len = symbolsRightOfAssignment.length; l1 < len; l1++) {\n            i = symbolsRightOfAssignment[l1];\n            console.log(\"  \" + i);\n          }\n        }\n        // ok add the local dependencies to the existing\n        // dependencies of this left-value symbol\n\n        // create the exiting dependencies list if it doesn't exist\n        if (symbolsDependencies[symbolLeftOfAssignment] == null) {\n          symbolsDependencies[symbolLeftOfAssignment] = [];\n        }\n        existingDependencies = symbolsDependencies[symbolLeftOfAssignment];\n// copy over the new dependencies to the existing\n// dependencies avoiding repetitions\n        for (m1 = 0, len1 = symbolsRightOfAssignment.length; m1 < len1; m1++) {\n          i = symbolsRightOfAssignment[m1];\n          if (existingDependencies.indexOf(i) === -1) {\n            existingDependencies.push(i);\n          }\n        }\n        return symbolsRightOfAssignment = [];\n      }\n    }\n  };\n\n  scan_relation = function() {\n    scan_expression();\n    switch (token) {\n      case T_EQ:\n        push_symbol(TESTEQ);\n        swap();\n        get_next_token();\n        scan_expression();\n        return list(3);\n      case T_NEQ:\n        push_symbol(NOT);\n        swap();\n        push_symbol(TESTEQ);\n        swap();\n        get_next_token();\n        scan_expression();\n        list(3);\n        return list(2);\n      case T_LTEQ:\n        push_symbol(TESTLE);\n        swap();\n        get_next_token();\n        scan_expression();\n        return list(3);\n      case T_GTEQ:\n        push_symbol(TESTGE);\n        swap();\n        get_next_token();\n        scan_expression();\n        return list(3);\n      case '<':\n        push_symbol(TESTLT);\n        swap();\n        get_next_token();\n        scan_expression();\n        return list(3);\n      case '>':\n        push_symbol(TESTGT);\n        swap();\n        get_next_token();\n        scan_expression();\n        return list(3);\n    }\n  };\n\n  scan_expression = function() {\n    var h;\n    h = tos;\n    switch (token) {\n      case '+':\n        get_next_token();\n        scan_term();\n        break;\n      case '-':\n        get_next_token();\n        scan_term();\n        negate();\n        break;\n      default:\n        scan_term();\n    }\n    while (newline_flag === 0 && (token === '+' || token === '-')) {\n      if (token === '+') {\n        get_next_token();\n        scan_term();\n      } else {\n        get_next_token();\n        scan_term();\n        negate();\n      }\n    }\n    if (tos - h > 1) {\n      list(tos - h);\n      push_symbol(ADD);\n      swap();\n      return cons();\n    }\n  };\n\n  is_factor = function() {\n    if ((typeof token.charCodeAt === \"function\" ? token.charCodeAt(0) : void 0) === dotprod_unicode) {\n      return 1;\n    }\n    switch (token) {\n      case '*':\n      case '/':\n        return 1;\n      case '(':\n      case T_SYMBOL:\n      case T_FUNCTION:\n      case T_INTEGER:\n      case T_DOUBLE:\n      case T_STRING:\n        if (newline_flag) { // implicit mul can't cross line\n          scan_str = token_str; // better error display\n          return 0;\n        } else {\n          return 1;\n        }\n    }\n    return 0;\n  };\n\n  simplify_1_in_products = function(tos, h) {\n    if (tos > h && isrational(stack[tos - 1]) && equaln(stack[tos - 1], 1)) {\n      return pop();\n    }\n  };\n\n  // calculate away consecutive constants\n  multiply_consecutive_constants = function(tos, h) {\n    if (tos > h + 1 && isNumericAtom(stack[tos - 2]) && isNumericAtom(stack[tos - 1])) {\n      return multiply();\n    }\n  };\n\n  scan_term = function() {\n    var h;\n    h = tos;\n    scan_factor();\n    if (parse_time_simplifications) {\n      simplify_1_in_products(tos, h);\n    }\n    while (is_factor()) {\n      if (token === '*') {\n        get_next_token();\n        scan_factor();\n      } else if (token === '/') {\n        // in case of 1/... then\n        // we scanned the 1, we get rid\n        // of it because otherwise it becomes\n        // an extra factor that wasn't there and\n        // things like\n        // 1/(2*a) become 1*(1/(2*a))\n        simplify_1_in_products(tos, h);\n        get_next_token();\n        scan_factor();\n        inverse();\n      } else if ((typeof token.charCodeAt === \"function\" ? token.charCodeAt(0) : void 0) === dotprod_unicode) {\n        get_next_token();\n        push_symbol(INNER);\n        swap();\n        scan_factor();\n        list(3);\n      } else {\n        scan_factor();\n      }\n      if (parse_time_simplifications) {\n        multiply_consecutive_constants(tos, h);\n        simplify_1_in_products(tos, h);\n      }\n    }\n    if (h === tos) {\n      return push_integer(1);\n    } else if (tos - h > 1) {\n      list(tos - h);\n      push_symbol(MULTIPLY);\n      swap();\n      return cons();\n    }\n  };\n\n  scan_power = function() {\n    if (token === '^') {\n      get_next_token();\n      push_symbol(POWER);\n      swap();\n      scan_factor();\n      return list(3);\n    }\n  };\n\n  scan_index = function(h) {\n    //console.log \"[ as index\"\n    get_next_token();\n    push_symbol(INDEX);\n    swap();\n    scan_expression();\n    while (token === ',') {\n      get_next_token();\n      scan_expression();\n    }\n    if (token !== ']') {\n      scan_error(\"] expected\");\n    }\n    get_next_token();\n    return list(tos - h);\n  };\n\n  scan_factor = function() {\n    var firstFactorIsNumber, h;\n    h = tos;\n    //console.log \"scan_factor token: \" + token\n    firstFactorIsNumber = false;\n    if (token === '(') {\n      scan_subexpr();\n    } else if (token === T_SYMBOL) {\n      scan_symbol();\n    } else if (token === T_FUNCTION) {\n      scan_function_call_with_function_name();\n    } else if (token === '[') {\n      //console.log \"[ as tensor\"\n      //debugger\n      scan_tensor();\n    } else if (token === T_INTEGER) {\n      firstFactorIsNumber = true;\n      bignum_scan_integer(token_buf);\n      get_next_token();\n    } else if (token === T_DOUBLE) {\n      firstFactorIsNumber = true;\n      bignum_scan_float(token_buf);\n      get_next_token();\n    } else if (token === T_STRING) {\n      scan_string();\n    } else {\n      scan_error(\"syntax error\");\n    }\n    // after the main initial part of the factor that\n    // we just scanned above,\n    // we can get an arbitrary about of appendages\n    // of the form ...[...](...)...\n    // If the main part is not a number, then these are all, respectively,\n    //  - index references (as opposed to tensor definition) and\n    //  - function calls without an explicit function name\n    //    (instead of subexpressions or parameters of function\n    //    definitions or function calls with an explicit function\n    //    name), respectively\n    while (token === '[' || token === '(' && newline_flag === 0 && !firstFactorIsNumber) {\n      if (token === '[') {\n        scan_index(h);\n      } else if (token === '(') {\n        //console.log \"( as function call without function name \"\n        scan_function_call_without_function_name();\n      }\n    }\n    while (token === '!') {\n      get_next_token();\n      push_symbol(FACTORIAL);\n      swap();\n      list(2);\n    }\n    while ((typeof token.charCodeAt === \"function\" ? token.charCodeAt(0) : void 0) === transpose_unicode) {\n      get_next_token();\n      push_symbol(TRANSPOSE);\n      swap();\n      list(2);\n    }\n    return scan_power();\n  };\n\n  addSymbolRightOfAssignment = function(theSymbol) {\n    var i, l1, prefixVar, ref2;\n    if (predefinedSymbolsInGlobalScope_doNotTrackInDependencies.indexOf(theSymbol) === -1 && symbolsRightOfAssignment.indexOf(theSymbol) === -1 && symbolsRightOfAssignment.indexOf(\"'\" + theSymbol) === -1 && !skipRootVariableToBeSolved) {\n      if (DEBUG) {\n        console.log(\"... adding symbol: \" + theSymbol + \" to the set of the symbols right of assignment\");\n      }\n      prefixVar = \"\";\n      for (i = l1 = 1, ref2 = functionInvokationsScanningStack.length; (1 <= ref2 ? l1 < ref2 : l1 > ref2); i = 1 <= ref2 ? ++l1 : --l1) {\n        if (functionInvokationsScanningStack[i] !== \"\") {\n          prefixVar += functionInvokationsScanningStack[i] + \"_\" + i + \"_\";\n        }\n      }\n      theSymbol = prefixVar + theSymbol;\n      return symbolsRightOfAssignment.push(theSymbol);\n    }\n  };\n\n  addSymbolLeftOfAssignment = function(theSymbol) {\n    var i, l1, prefixVar, ref2;\n    if (predefinedSymbolsInGlobalScope_doNotTrackInDependencies.indexOf(theSymbol) === -1 && symbolsLeftOfAssignment.indexOf(theSymbol) === -1 && symbolsLeftOfAssignment.indexOf(\"'\" + theSymbol) === -1 && !skipRootVariableToBeSolved) {\n      if (DEBUG) {\n        console.log(\"... adding symbol: \" + theSymbol + \" to the set of the symbols left of assignment\");\n      }\n      prefixVar = \"\";\n      for (i = l1 = 1, ref2 = functionInvokationsScanningStack.length; (1 <= ref2 ? l1 < ref2 : l1 > ref2); i = 1 <= ref2 ? ++l1 : --l1) {\n        if (functionInvokationsScanningStack[i] !== \"\") {\n          prefixVar += functionInvokationsScanningStack[i] + \"_\" + i + \"_\";\n        }\n      }\n      theSymbol = prefixVar + theSymbol;\n      return symbolsLeftOfAssignment.push(theSymbol);\n    }\n  };\n\n  scan_symbol = function() {\n    if (token !== T_SYMBOL) {\n      scan_error(\"symbol expected\");\n    }\n    if (meta_mode && token_buf.length === 1) {\n      switch (token_buf[0]) {\n        case 'a':\n          push(symbol(METAA));\n          break;\n        case 'b':\n          push(symbol(METAB));\n          break;\n        case 'x':\n          push(symbol(METAX));\n          break;\n        default:\n          push(usr_symbol(token_buf));\n      }\n    } else {\n      push(usr_symbol(token_buf));\n    }\n    //console.log \"found symbol: \" + token_buf\n    if (scanningParameters.length === 0) {\n      if (DEBUG) {\n        console.log(\"out of scanning parameters, processing \" + token_buf);\n      }\n      lastFoundSymbol = token_buf;\n      if (isSymbolLeftOfAssignment) {\n        addSymbolLeftOfAssignment(token_buf);\n      }\n    } else {\n      if (DEBUG) {\n        console.log(\"still scanning parameters, skipping \" + token_buf);\n      }\n      if (isSymbolLeftOfAssignment) {\n        addSymbolRightOfAssignment(\"'\" + token_buf);\n      }\n    }\n    if (DEBUG) {\n      console.log(\"found symbol: \" + token_buf + \" left of assignment: \" + isSymbolLeftOfAssignment);\n    }\n    if (!isSymbolLeftOfAssignment) {\n      addSymbolRightOfAssignment(token_buf);\n    }\n    return get_next_token();\n  };\n\n  scan_string = function() {\n    push(new_string(token_buf));\n    return get_next_token();\n  };\n\n  scan_function_call_with_function_name = function() {\n    var functionName, i, l1, n, p, ref2;\n    if (DEBUG) {\n      console.log(\"-- scan_function_call_with_function_name start\");\n    }\n    n = 1; // the parameter number as we scan parameters\n    p = new U();\n    p = usr_symbol(token_buf);\n    push(p);\n    functionName = token_buf;\n    if (functionName === \"roots\" || functionName === \"defint\" || functionName === \"sum\" || functionName === \"product\" || functionName === \"for\") {\n      functionInvokationsScanningStack.push(token_buf);\n    }\n    lastFoundSymbol = token_buf;\n    if (!isSymbolLeftOfAssignment) {\n      addSymbolRightOfAssignment(token_buf);\n    }\n    get_next_token(); // open parens\n    get_next_token(); // 1st parameter\n    scanningParameters.push(true);\n    if (token !== ')') {\n      scan_stmt();\n      n++;\n      while (token === ',') {\n        get_next_token();\n        // roots' disappearing variable, if there, is the second one\n        if (n === 2 && functionInvokationsScanningStack[functionInvokationsScanningStack.length - 1].indexOf(\"roots\") !== -1) {\n          symbolsRightOfAssignment = symbolsRightOfAssignment.filter(function(x) {\n            return !(new RegExp(\"roots_\" + (functionInvokationsScanningStack.length - 1) + \"_\" + token_buf)).test(x);\n          });\n          skipRootVariableToBeSolved = true;\n        }\n        // sums' disappearing variable, is alsways the second one\n        if (n === 2 && functionInvokationsScanningStack[functionInvokationsScanningStack.length - 1].indexOf(\"sum\") !== -1) {\n          symbolsRightOfAssignment = symbolsRightOfAssignment.filter(function(x) {\n            return !(new RegExp(\"sum_\" + (functionInvokationsScanningStack.length - 1) + \"_\" + token_buf)).test(x);\n          });\n          skipRootVariableToBeSolved = true;\n        }\n        // product's disappearing variable, is alsways the second one\n        if (n === 2 && functionInvokationsScanningStack[functionInvokationsScanningStack.length - 1].indexOf(\"product\") !== -1) {\n          symbolsRightOfAssignment = symbolsRightOfAssignment.filter(function(x) {\n            return !(new RegExp(\"product_\" + (functionInvokationsScanningStack.length - 1) + \"_\" + token_buf)).test(x);\n          });\n          skipRootVariableToBeSolved = true;\n        }\n        // for's disappearing variable, is alsways the second one\n        if (n === 2 && functionInvokationsScanningStack[functionInvokationsScanningStack.length - 1].indexOf(\"for\") !== -1) {\n          symbolsRightOfAssignment = symbolsRightOfAssignment.filter(function(x) {\n            return !(new RegExp(\"for_\" + (functionInvokationsScanningStack.length - 1) + \"_\" + token_buf)).test(x);\n          });\n          skipRootVariableToBeSolved = true;\n        }\n        // defint's disappearing variables can be in positions 2,5,8...\n        if (functionInvokationsScanningStack[functionInvokationsScanningStack.length - 1].indexOf(\"defint\") !== -1 && (n === 2 || (n > 2 && ((n - 2) % 3 === 0)))) {\n          symbolsRightOfAssignment = symbolsRightOfAssignment.filter(function(x) {\n            return !(new RegExp(\"defint_\" + (functionInvokationsScanningStack.length - 1) + \"_\" + token_buf)).test(x);\n          });\n          skipRootVariableToBeSolved = true;\n        }\n        scan_stmt();\n        skipRootVariableToBeSolved = false;\n        n++;\n      }\n      // todo refactor this, there are two copies\n      // this catches the case where the \"roots\" variable is not specified\n      if (n === 2 && functionInvokationsScanningStack[functionInvokationsScanningStack.length - 1].indexOf(\"roots\") !== -1) {\n        symbolsRightOfAssignment = symbolsRightOfAssignment.filter(function(x) {\n          return !(new RegExp(\"roots_\" + (functionInvokationsScanningStack.length - 1) + \"_\" + \"x\")).test(x);\n        });\n      }\n    }\n    scanningParameters.pop();\n    for (i = l1 = 0, ref2 = symbolsRightOfAssignment.length; (0 <= ref2 ? l1 <= ref2 : l1 >= ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      if (symbolsRightOfAssignment[i] != null) {\n        if (functionName === \"roots\") {\n          symbolsRightOfAssignment[i] = symbolsRightOfAssignment[i].replace(new RegExp(\"roots_\" + (functionInvokationsScanningStack.length - 1) + \"_\"), \"\");\n        }\n        if (functionName === \"defint\") {\n          symbolsRightOfAssignment[i] = symbolsRightOfAssignment[i].replace(new RegExp(\"defint_\" + (functionInvokationsScanningStack.length - 1) + \"_\"), \"\");\n        }\n        if (functionName === \"sum\") {\n          symbolsRightOfAssignment[i] = symbolsRightOfAssignment[i].replace(new RegExp(\"sum_\" + (functionInvokationsScanningStack.length - 1) + \"_\"), \"\");\n        }\n        if (functionName === \"product\") {\n          symbolsRightOfAssignment[i] = symbolsRightOfAssignment[i].replace(new RegExp(\"product_\" + (functionInvokationsScanningStack.length - 1) + \"_\"), \"\");\n        }\n        if (functionName === \"for\") {\n          symbolsRightOfAssignment[i] = symbolsRightOfAssignment[i].replace(new RegExp(\"for_\" + (functionInvokationsScanningStack.length - 1) + \"_\"), \"\");\n        }\n      }\n    }\n    if (token !== ')') {\n      scan_error(\") expected\");\n    }\n    get_next_token();\n    list(n);\n    if (functionName === \"roots\" || functionName === \"defint\" || functionName === \"sum\" || functionName === \"product\" || functionName === \"for\") {\n      functionInvokationsScanningStack.pop();\n    }\n    if (functionName === symbol(PATTERN).printname) {\n      patternHasBeenFound = true;\n    }\n    if (DEBUG) {\n      return console.log(\"-- scan_function_call_with_function_name end\");\n    }\n  };\n\n  scan_function_call_without_function_name = function() {\n    var n;\n    if (DEBUG) {\n      console.log(\"-- scan_function_call_without_function_name start\");\n    }\n    // the function will have to be looked up\n    // at runtime (i.e. we need to evaulate something to find it\n    // e.g. it might be inside a tensor, so we'd need to evaluate\n    // a tensor element access in that case)\n    push_symbol(EVAL);\n    swap();\n    list(2);\n    n = 1; // the parameter number as we scan parameters\n    get_next_token(); // left paren\n    scanningParameters.push(true);\n    if (token !== ')') {\n      scan_stmt();\n      n++;\n      while (token === ',') {\n        get_next_token();\n        scan_stmt();\n        n++;\n      }\n    }\n    scanningParameters.pop();\n    if (token !== ')') {\n      scan_error(\") expected\");\n    }\n    get_next_token();\n    list(n);\n    if (DEBUG) {\n      return console.log(\"-- scan_function_call_without_function_name end: \" + stack[tos - 1]);\n    }\n  };\n\n  // scan subexpression\n  scan_subexpr = function() {\n    var n;\n    n = 0;\n    if (token !== '(') {\n      scan_error(\"( expected\");\n    }\n    get_next_token();\n    scan_stmt();\n    if (token !== ')') {\n      scan_error(\") expected\");\n    }\n    return get_next_token();\n  };\n\n  scan_tensor = function() {\n    var n;\n    n = 0;\n    if (token !== '[') {\n      scan_error(\"[ expected\");\n    }\n    get_next_token();\n    //console.log \"scanning the next statement\"\n    scan_stmt();\n    n = 1;\n    while (token === ',') {\n      get_next_token();\n      scan_stmt();\n      n++;\n    }\n    //console.log \"building tensor with elements number: \" + n\n    build_tensor(n);\n    if (token !== ']') {\n      scan_error(\"] expected\");\n    }\n    return get_next_token();\n  };\n\n  scan_error = function(errmsg) {\n    errorMessage = \"\";\n    // try not to put question mark on orphan line\n    while (input_str !== scan_str) {\n      if ((scanned[input_str] === '\\n' || scanned[input_str] === '\\r') && input_str + 1 === scan_str) {\n        break;\n      }\n      errorMessage += scanned[input_str++];\n    }\n    errorMessage += \" ? \";\n    while (scanned[input_str] && (scanned[input_str] !== '\\n' && scanned[input_str] !== '\\r')) {\n      errorMessage += scanned[input_str++];\n    }\n    errorMessage += '\\n';\n    return stop(errmsg);\n  };\n\n  // There are n expressions on the stack, possibly tensors.\n\n  // This function assembles the stack expressions into a single tensor.\n\n  // For example, at the top level of the expression ((a,b),(c,d)), the vectors\n  // (a,b) and (c,d) would be on the stack.\n\n  // takes an integer\n  build_tensor = function(n) {\n    var i, l1, ref2;\n    // int i, j, k, ndim, nelem\n    i = 0;\n    save();\n    p2 = alloc_tensor(n);\n    p2.tensor.ndim = 1;\n    p2.tensor.dim[0] = n;\n    for (i = l1 = 0, ref2 = n; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      p2.tensor.elem[i] = stack[tos - n + i];\n    }\n    check_tensor_dimensions(p2);\n    moveTos(tos - n);\n    push(p2);\n    return restore();\n  };\n\n  get_next_token = function() {\n    newline_flag = 0;\n    while (1) {\n      get_token();\n      if (token !== T_NEWLINE) {\n        break;\n      }\n      newline_flag = 1;\n    }\n    if (DEBUG) {\n      return console.log(\"get_next_token token: \" + token);\n    }\n  };\n\n  //if token == ')'\n  //  debugger\n  get_token = function() {\n    // skip spaces\n    while (isspace(scanned[scan_str])) {\n      if (scanned[scan_str] === '\\n' || scanned[scan_str] === '\\r') {\n        token = T_NEWLINE;\n        scan_str++;\n        return;\n      }\n      scan_str++;\n    }\n    token_str = scan_str;\n    // end of string?\n    if (scan_str === scanned.length) {\n      token = \"\";\n      return;\n    }\n    // number?\n    if (isdigit(scanned[scan_str]) || scanned[scan_str] === '.') {\n      while (isdigit(scanned[scan_str])) {\n        scan_str++;\n      }\n      if (scanned[scan_str] === '.') {\n        scan_str++;\n        while (isdigit(scanned[scan_str])) {\n          scan_str++;\n        }\n        if (scanned[scan_str] === 'e' && (scanned[scan_str + 1] === '+' || scanned[scan_str + 1] === '-' || isdigit(scanned[scan_str + 1]))) {\n          scan_str += 2;\n          while (isdigit(scanned[scan_str])) {\n            scan_str++;\n          }\n        }\n        token = T_DOUBLE;\n      } else {\n        token = T_INTEGER;\n      }\n      update_token_buf(token_str, scan_str);\n      return;\n    }\n    // symbol?\n    if (isalpha(scanned[scan_str])) {\n      while (isalnumorunderscore(scanned[scan_str])) {\n        scan_str++;\n      }\n      if (scanned[scan_str] === '(') {\n        token = T_FUNCTION;\n      } else {\n        token = T_SYMBOL;\n      }\n      update_token_buf(token_str, scan_str);\n      return;\n    }\n    // string ?\n    if (scanned[scan_str] === '\"') {\n      scan_str++;\n      while (scanned[scan_str] !== '\"') {\n        //if (scan_str == scanned.length || scanned[scan_str] == '\\n' || scanned[scan_str] == '\\r')\n        if (scan_str === scanned.length - 1) {\n          scan_str++;\n          scan_error(\"runaway string\");\n          scan_str--;\n        }\n        scan_str++;\n      }\n      scan_str++;\n      token = T_STRING;\n      update_token_buf(token_str + 1, scan_str - 1);\n      return;\n    }\n    // comment?\n    if (scanned[scan_str] === '#' || scanned[scan_str] === '-' && scanned[scan_str + 1] === '-') {\n      while (scanned[scan_str] && scanned[scan_str] !== '\\n' && scanned[scan_str] !== '\\r') {\n        scan_str++;\n      }\n      if (scanned[scan_str]) {\n        scan_str++;\n      }\n      token = T_NEWLINE;\n      return;\n    }\n    // quote-assignment\n    if (scanned[scan_str] === ':' && scanned[scan_str + 1] === '=') {\n      scan_str += 2;\n      token = T_QUOTASSIGN;\n      return;\n    }\n    // relational operator?\n    if (scanned[scan_str] === '=' && scanned[scan_str + 1] === '=') {\n      scan_str += 2;\n      token = T_EQ;\n      return;\n    }\n    // != operator. It's a little odd because\n    // \"!\" is not a \"not\", which would make things consistent.\n    // (it's used for factorial).\n    // An alternative would be to use \"<>\" but it's not used\n    // a lot in other languages...\n    if (scanned[scan_str] === '!' && scanned[scan_str + 1] === '=') {\n      scan_str += 2;\n      token = T_NEQ;\n      return;\n    }\n    if (scanned[scan_str] === '<' && scanned[scan_str + 1] === '=') {\n      scan_str += 2;\n      token = T_LTEQ;\n      return;\n    }\n    if (scanned[scan_str] === '>' && scanned[scan_str + 1] === '=') {\n      scan_str += 2;\n      token = T_GTEQ;\n      return;\n    }\n    // single char token\n    return token = scanned[scan_str++];\n  };\n\n  // both strings\n  update_token_buf = function(a, b) {\n    return token_buf = scanned.substring(a, b);\n  };\n\n  $.scan = scan;\n\n  //-----------------------------------------------------------------------------\n\n  //  Author : philippe.billet@noos.fr\n\n  //  sgn sign function\n\n  //-----------------------------------------------------------------------------\n  Eval_sgn = function() {\n    push(cadr(p1));\n    Eval();\n    return sgn();\n  };\n\n  sgn = function() {\n    save();\n    yysgn();\n    return restore();\n  };\n\n  //define X p1\n  yysgn = function() {\n    p1 = pop();\n    if (isdouble(p1)) {\n      if (p1.d > 0) {\n        push_integer(1);\n        return;\n      } else {\n        if (p1.d === 0) {\n          push_integer(1);\n          return;\n        } else {\n          push_integer(-1);\n          return;\n        }\n      }\n    }\n    if (isrational(p1)) {\n      if (MSIGN(mmul(p1.q.a, p1.q.b)) === -1) {\n        push_integer(-1);\n        return;\n      } else {\n        if (MZERO(mmul(p1.q.a, p1.q.b))) {\n          push_integer(0);\n          return;\n        } else {\n          push_integer(1);\n          return;\n        }\n      }\n    }\n    if (iscomplexnumber(p1)) {\n      push_integer(-1);\n      push(p1);\n      absval();\n      power();\n      push(p1);\n      multiply();\n      return;\n    }\n    if (isnegativeterm(p1)) {\n      push_symbol(SGN);\n      push(p1);\n      negate();\n      list(2);\n      push_integer(-1);\n      multiply();\n      return;\n    }\n    /*\n    push_integer(2)\n    push(p1)\n    heaviside()\n    multiply()\n    push_integer(-1)\n    add()\n    */\n    push_symbol(SGN);\n    push(p1);\n    return list(2);\n  };\n\n  // shape of tensor\n  Eval_shape = function() {\n    push(cadr(p1));\n    Eval();\n    return shape();\n  };\n\n  shape = function() {\n    var ai, an, i, l1, m1, ndim, ref2, ref3, t;\n    i = 0;\n    ndim = 0;\n    t = 0;\n    ai = [];\n    an = [];\n    for (i = l1 = 0, ref2 = MAXDIM; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      ai[i] = 0;\n      an[i] = 0;\n    }\n    //U **a, **b\n    save();\n    p1 = pop();\n    if (!istensor(p1)) {\n      if (!isZeroAtomOrTensor(p1)) {\n        stop(\"transpose: tensor expected, 1st arg is not a tensor\");\n      }\n      push(zero);\n      restore();\n      return;\n    }\n    ndim = p1.tensor.ndim;\n    p2 = alloc_tensor(ndim);\n    p2.tensor.ndim = 1;\n    p2.tensor.dim[0] = ndim;\n    for (i = m1 = 0, ref3 = ndim; (0 <= ref3 ? m1 < ref3 : m1 > ref3); i = 0 <= ref3 ? ++m1 : --m1) {\n      push_integer(p1.tensor.dim[i]);\n      p2.tensor.elem[i] = pop();\n    }\n    push(p2);\n    return restore();\n  };\n\n  /*\n   Simplify factorials\n\n  The following script\n\n    F(n,k) = k binomial(n,k)\n    (F(n,k) + F(n,k-1)) / F(n+1,k)\n\n  generates\n\n         k! n!             n! (1 - k + n)!              k! n!\n   -------------------- + -------------------- - ----------------------\n   (-1 + k)! (1 + n)!     (1 + n)! (-k + n)!     k (-1 + k)! (1 + n)!\n\n  Simplify each term to get\n\n      k       1 - k + n       1\n   ------- + ----------- - -------\n    1 + n       1 + n       1 + n\n\n  Then simplify the sum to get\n\n      n\n   -------\n    1 + n\n\n  */\n  // simplify factorials term-by-term\n  Eval_simfac = function() {\n    push(cadr(p1));\n    Eval();\n    return simfac();\n  };\n\n  //if 1\n  simfac = function() {\n    var h;\n    h = 0;\n    save();\n    p1 = pop();\n    if (car(p1) === symbol(ADD)) {\n      h = tos;\n      p1 = cdr(p1);\n      while (p1 !== symbol(NIL)) {\n        push(car(p1));\n        simfac_term();\n        p1 = cdr(p1);\n      }\n      add_all(tos - h);\n    } else {\n      push(p1);\n      simfac_term();\n    }\n    return restore();\n  };\n\n  //else\n  /*\n  void\n  simfac(void)\n  {\n    int h\n    save()\n    p1 = pop()\n    if (car(p1) == symbol(ADD)) {\n      h = tos\n      p1 = cdr(p1)\n      while (p1 != symbol(NIL)) {\n        push(car(p1))\n        simfac_term()\n        p1 = cdr(p1)\n      }\n      addk(tos - h)\n      p1 = pop()\n      if (find(p1, symbol(FACTORIAL))) {\n        push(p1)\n        if (car(p1) == symbol(ADD)) {\n          Condense()\n          simfac_term()\n        }\n      }\n    } else {\n      push(p1)\n      simfac_term()\n    }\n    restore()\n  }\n\n  #endif\n   */\n  simfac_term = function() {\n    var doNothing, h;\n    h = 0;\n    save();\n    p1 = pop();\n    // if not a product of factors then done\n    if (car(p1) !== symbol(MULTIPLY)) {\n      push(p1);\n      restore();\n      return;\n    }\n    // push all factors\n    h = tos;\n    p1 = cdr(p1);\n    while (p1 !== symbol(NIL)) {\n      push(car(p1));\n      p1 = cdr(p1);\n    }\n    // keep trying until no more to do\n    while (yysimfac(h)) {\n      doNothing = 1;\n    }\n    multiply_all_noexpand(tos - h);\n    return restore();\n  };\n\n  // try all pairs of factors\n  yysimfac = function(h) {\n    var i, j, l1, m1, ref2, ref3, ref4, ref5;\n    i = 0;\n    j = 0;\n    for (i = l1 = ref2 = h, ref3 = tos; (ref2 <= ref3 ? l1 < ref3 : l1 > ref3); i = ref2 <= ref3 ? ++l1 : --l1) {\n      p1 = stack[i];\n      for (j = m1 = ref4 = h, ref5 = tos; (ref4 <= ref5 ? m1 < ref5 : m1 > ref5); j = ref4 <= ref5 ? ++m1 : --m1) {\n        if (i === j) {\n          continue;\n        }\n        p2 = stack[j];\n        //  n! / n    ->  (n - 1)!\n        if (car(p1) === symbol(FACTORIAL) && car(p2) === symbol(POWER) && isminusone(caddr(p2)) && equal(cadr(p1), cadr(p2))) {\n          push(cadr(p1));\n          push(one);\n          subtract();\n          factorial();\n          stack[i] = pop();\n          stack[j] = one;\n          return 1;\n        }\n        //  n / n!    ->  1 / (n - 1)!\n        if (car(p2) === symbol(POWER) && isminusone(caddr(p2)) && caadr(p2) === symbol(FACTORIAL) && equal(p1, cadadr(p2))) {\n          push(p1);\n          push_integer(-1);\n          add();\n          factorial();\n          reciprocate();\n          stack[i] = pop();\n          stack[j] = one;\n          return 1;\n        }\n        //  (n + 1) n!  ->  (n + 1)!\n        if (car(p2) === symbol(FACTORIAL)) {\n          push(p1);\n          push(cadr(p2));\n          subtract();\n          p3 = pop();\n          if (isplusone(p3)) {\n            push(p1);\n            factorial();\n            stack[i] = pop();\n            stack[j] = one;\n            return 1;\n          }\n        }\n        //  1 / ((n + 1) n!)  ->  1 / (n + 1)!\n        if (car(p1) === symbol(POWER) && isminusone(caddr(p1)) && car(p2) === symbol(POWER) && isminusone(caddr(p2)) && caadr(p2) === symbol(FACTORIAL)) {\n          push(cadr(p1));\n          push(cadr(cadr(p2)));\n          subtract();\n          p3 = pop();\n          if (isplusone(p3)) {\n            push(cadr(p1));\n            factorial();\n            reciprocate();\n            stack[i] = pop();\n            stack[j] = one;\n            return 1;\n          }\n        }\n        //  (n + 1)! / n!  ->  n + 1\n\n        //  n! / (n + 1)!  ->  1 / (n + 1)\n        if (car(p1) === symbol(FACTORIAL) && car(p2) === symbol(POWER) && isminusone(caddr(p2)) && caadr(p2) === symbol(FACTORIAL)) {\n          push(cadr(p1));\n          push(cadr(cadr(p2)));\n          subtract();\n          p3 = pop();\n          if (isplusone(p3)) {\n            stack[i] = cadr(p1);\n            stack[j] = one;\n            return 1;\n          }\n          if (isminusone(p3)) {\n            push(cadr(cadr(p2)));\n            reciprocate();\n            stack[i] = pop();\n            stack[j] = one;\n            return 1;\n          }\n          if (equaln(p3, 2)) {\n            stack[i] = cadr(p1);\n            push(cadr(p1));\n            push_integer(-1);\n            add();\n            stack[j] = pop();\n            return 1;\n          }\n          if (equaln(p3, -2)) {\n            push(cadr(cadr(p2)));\n            reciprocate();\n            stack[i] = pop();\n            push(cadr(cadr(p2)));\n            push_integer(-1);\n            add();\n            reciprocate();\n            stack[j] = pop();\n            return 1;\n          }\n        }\n      }\n    }\n    return 0;\n  };\n\n  DEBUG_SIMPLIFY = false;\n\n  Eval_simplify = function() {\n    push(cadr(p1));\n    runUserDefinedSimplifications();\n    Eval();\n    return simplify();\n  };\n\n  runUserDefinedSimplifications = function() {\n    var atLeastOneSuccessInRouldOfRulesApplications, eachConsecutiveRuleApplication, eachSimplification, l1, len, len1, m1, numberOfRulesApplications, originalexpanding, success;\n    // -----------------------\n    // unfortunately for the time being user\n    // specified simplifications are only\n    // run in things which don't contain\n    // integrals.\n    // Doesn't work yet, could be because of\n    // some clobbering as \"transform\" is called\n    // recursively?\n    if (userSimplificationsInListForm.length !== 0 && !Find(cadr(p1), symbol(INTEGRAL))) {\n      originalexpanding = expanding;\n      expanding = false;\n      if (DEBUG_SIMPLIFY) {\n        console.log(\"runUserDefinedSimplifications passed: \" + stack[tos - 1].toString());\n      }\n      Eval();\n      if (DEBUG_SIMPLIFY) {\n        console.log(\"runUserDefinedSimplifications after eval no expanding: \" + stack[tos - 1].toString());\n      }\n      expanding = originalexpanding;\n      p1 = stack[tos - 1];\n      if (DEBUG_SIMPLIFY) {\n        console.log(\"patterns to be checked: \");\n      }\n      for (l1 = 0, len = userSimplificationsInListForm.length; l1 < len; l1++) {\n        eachSimplification = userSimplificationsInListForm[l1];\n        if (DEBUG_SIMPLIFY) {\n          console.log(\"...\" + eachSimplification);\n        }\n      }\n      atLeastOneSuccessInRouldOfRulesApplications = true;\n      numberOfRulesApplications = 0;\n      while (atLeastOneSuccessInRouldOfRulesApplications && numberOfRulesApplications < MAX_CONSECUTIVE_APPLICATIONS_OF_ALL_RULES) {\n        atLeastOneSuccessInRouldOfRulesApplications = false;\n        numberOfRulesApplications++;\n        for (m1 = 0, len1 = userSimplificationsInListForm.length; m1 < len1; m1++) {\n          eachSimplification = userSimplificationsInListForm[m1];\n          success = true;\n          eachConsecutiveRuleApplication = 0;\n          while (success && eachConsecutiveRuleApplication < MAX_CONSECUTIVE_APPLICATIONS_OF_SINGLE_RULE) {\n            eachConsecutiveRuleApplication++;\n            if (DEBUG_SIMPLIFY) {\n              console.log(\"simplify - tos: \" + tos + \" checking pattern: \" + eachSimplification + \" on: \" + p1);\n            }\n            push_symbol(NIL);\n            success = transform(eachSimplification, true);\n            if (success) {\n              atLeastOneSuccessInRouldOfRulesApplications = true;\n            }\n            p1 = stack[tos - 1];\n            if (DEBUG_SIMPLIFY) {\n              console.log(\"p1 at this stage of simplification: \" + p1);\n            }\n          }\n          if (eachConsecutiveRuleApplication === MAX_CONSECUTIVE_APPLICATIONS_OF_SINGLE_RULE) {\n            stop(\"maximum application of single transformation rule exceeded: \" + eachSimplification);\n          }\n        }\n      }\n      if (numberOfRulesApplications === MAX_CONSECUTIVE_APPLICATIONS_OF_ALL_RULES) {\n        stop(\"maximum application of all transformation rules exceeded \");\n      }\n      if (DEBUG_SIMPLIFY) {\n        console.log(\"METAX = \" + get_binding(symbol(METAX)));\n      }\n      if (DEBUG_SIMPLIFY) {\n        console.log(\"METAA = \" + get_binding(symbol(METAA)));\n      }\n      if (DEBUG_SIMPLIFY) {\n        return console.log(\"METAB = \" + get_binding(symbol(METAB)));\n      }\n    }\n  };\n\n  // ------------------------\n  simplifyForCodeGeneration = function() {\n    save();\n    runUserDefinedSimplifications();\n    codeGen = true;\n    // in \"codeGen\" mode we completely\n    // eval and simplify the function bodies\n    // because we really want to resolve all\n    // the variables indirections and apply\n    // all the simplifications we can.\n    simplify_main();\n    codeGen = false;\n    return restore();\n  };\n\n  simplify = function() {\n    save();\n    simplify_main();\n    return restore();\n  };\n\n  simplify_main = function() {\n    var args, fbody;\n    p1 = pop();\n    // when we do code generation, we proceed to\n    // fully evaluate and simplify the body of\n    // a function, so we resolve all variables\n    // indirections and we simplify everything\n    // we can given the current assignments.\n    if (codeGen && car(p1) === symbol(FUNCTION)) {\n      fbody = cadr(p1);\n      push(fbody);\n      // let's simplify the body so we give it a\n      // compact form\n      eval();\n      simplify();\n      p3 = pop();\n      // replace the evaled body\n      args = caddr(p1);\n      push_symbol(FUNCTION);\n      push(p3);\n      push(args);\n      list(3);\n      p1 = pop();\n    }\n    if (istensor(p1)) {\n      simplify_tensor();\n      return;\n    }\n    if (Find(p1, symbol(FACTORIAL))) {\n      push(p1);\n      simfac();\n      p2 = pop();\n      push(p1);\n      rationalize();\n      simfac();\n      p3 = pop();\n      if (count(p2) < count(p3)) {\n        p1 = p2;\n      } else {\n        p1 = p3;\n      }\n    }\n    f10();\n    if (DEBUG_SIMPLIFY) {\n      console.log(\"f10: \" + p1.toString());\n    }\n    f1();\n    if (DEBUG_SIMPLIFY) {\n      console.log(\"f1: \" + p1.toString());\n    }\n    f2();\n    if (DEBUG_SIMPLIFY) {\n      console.log(\"f2: \" + p1.toString());\n    }\n    f3();\n    if (DEBUG_SIMPLIFY) {\n      console.log(\"f3: \" + p1.toString());\n    }\n    f4();\n    if (DEBUG_SIMPLIFY) {\n      console.log(\"f4: \" + p1.toString());\n    }\n    f5();\n    if (DEBUG_SIMPLIFY) {\n      console.log(\"f5: \" + p1.toString());\n    }\n    f9();\n    if (DEBUG_SIMPLIFY) {\n      console.log(\"f9: \" + p1.toString());\n    }\n    simplify_polarRect();\n    if (do_simplify_nested_radicals) {\n      // if there is some de-nesting then\n      // re-run a simplification because\n      // the shape of the expression might\n      // have changed significantly.\n      // e.g. simplify(14^(1/2) - (16 - 4*7^(1/2))^(1/2))\n      // needs some more semplification after the de-nesting.\n      if (simplify_nested_radicals()) {\n        if (DEBUG_SIMPLIFY) {\n          console.log(\"de-nesting successful into: \" + p1.toString());\n        }\n        push(p1);\n        simplify();\n        return;\n      }\n    }\n    simplify_rectToClock();\n    simplify_rational_expressions();\n    return push(p1);\n  };\n\n  simplify_tensor = function() {\n    var i, l1, m1, ref2, ref3;\n    i = 0;\n    p2 = alloc_tensor(p1.tensor.nelem);\n    p2.tensor.ndim = p1.tensor.ndim;\n    for (i = l1 = 0, ref2 = p1.tensor.ndim; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      p2.tensor.dim[i] = p1.tensor.dim[i];\n    }\n    for (i = m1 = 0, ref3 = p1.tensor.nelem; (0 <= ref3 ? m1 < ref3 : m1 > ref3); i = 0 <= ref3 ? ++m1 : --m1) {\n      push(p1.tensor.elem[i]);\n      simplify();\n      p2.tensor.elem[i] = pop();\n    }\n    check_tensor_dimensions(p2);\n    if (isZeroAtomOrTensor(p2)) {\n      p2 = zero; // null tensor becomes scalar zero\n    }\n    return push(p2);\n  };\n\n  // try rationalizing\n  f1 = function() {\n    if (car(p1) !== symbol(ADD)) {\n      return;\n    }\n    push(p1);\n    rationalize();\n    p2 = pop();\n    if (count(p2) < count(p1)) {\n      return p1 = p2;\n    }\n  };\n\n  // try condensing\n  f2 = function() {\n    if (car(p1) !== symbol(ADD)) {\n      return;\n    }\n    push(p1);\n    Condense();\n    p2 = pop();\n    if (count(p2) <= count(p1)) {\n      return p1 = p2;\n    }\n  };\n\n  // this simplifies forms like (A-B) / (B-A)\n  f3 = function() {\n    push(p1);\n    rationalize();\n    negate();\n    rationalize();\n    negate();\n    rationalize();\n    p2 = pop();\n    if (count(p2) < count(p1)) {\n      return p1 = p2;\n    }\n  };\n\n  f10 = function() {\n    var a, b, carp1, miao, originalexpanding;\n    carp1 = car(p1);\n    miao = cdr(p1);\n    if (carp1 === symbol(MULTIPLY) || isinnerordot(p1)) {\n      // both operands a transpose?\n      if ((car(car(cdr(p1))) === symbol(TRANSPOSE)) && (car(car(cdr(cdr(p1)))) === symbol(TRANSPOSE))) {\n        if (DEBUG_SIMPLIFY) {\n          console.log(\"maybe collecting a transpose \" + p1);\n        }\n        a = cadr(car(cdr(p1)));\n        b = cadr(car(cdr(cdr(p1))));\n        if (carp1 === symbol(MULTIPLY)) {\n          push(a);\n          push(b);\n          multiply();\n        } else if (isinnerordot(p1)) {\n          push(b);\n          push(a);\n          inner();\n        }\n        push_integer(1);\n        push_integer(2);\n        originalexpanding = expanding;\n        expanding = false;\n        transpose();\n        expanding = originalexpanding;\n        p2 = pop();\n        if (count(p2) < count(p1)) {\n          p1 = p2;\n        }\n        if (DEBUG_SIMPLIFY) {\n          return console.log(\"collecting a transpose \" + p2);\n        }\n      }\n    }\n  };\n\n  // try expanding denominators\n  f4 = function() {\n    if (isZeroAtomOrTensor(p1)) {\n      return;\n    }\n    push(p1);\n    rationalize();\n    inverse();\n    rationalize();\n    inverse();\n    rationalize();\n    p2 = pop();\n    if (count(p2) < count(p1)) {\n      return p1 = p2;\n    }\n  };\n\n  // simplifies trig forms\n  simplify_trig = function() {\n    save();\n    p1 = pop();\n    f5();\n    push(p1);\n    return restore();\n  };\n\n  f5 = function() {\n    if (Find(p1, symbol(SIN)) === 0 && Find(p1, symbol(COS)) === 0) {\n      return;\n    }\n    p2 = p1;\n    trigmode = 1;\n    push(p2);\n    Eval();\n    p3 = pop();\n    trigmode = 2;\n    push(p2);\n    Eval();\n    p4 = pop();\n    trigmode = 0;\n    if (count(p4) < count(p3) || nterms(p4) < nterms(p3)) {\n      p3 = p4;\n    }\n    if (count(p3) < count(p1) || nterms(p3) < nterms(p1)) {\n      return p1 = p3;\n    }\n  };\n\n  // if it's a sum then try to simplify each term\n  f9 = function() {\n    var oldp1, oldp2;\n    if (car(p1) !== symbol(ADD)) {\n      return;\n    }\n    push_integer(0);\n    p2 = cdr(p1);\n    while (iscons(p2)) {\n      push(car(p2));\n      simplify();\n      add();\n      oldp1 = p1;\n      oldp2 = p2;\n      p1 = pop();\n      simplify_rational_expressions();\n      push(p1);\n      p1 = oldp1;\n      p2 = oldp2;\n      p2 = cdr(p2);\n    }\n    p2 = pop();\n    if (count(p2) < count(p1)) {\n      return p1 = p2;\n    }\n  };\n\n  simplify_rational_expressions = function() {\n    var denom, num, polyVar, sasa, theGCD;\n    push(p1);\n    denominator();\n    denom = pop();\n    if (isone(denom)) {\n      return;\n    }\n    push(p1);\n    numerator();\n    num = pop();\n    if (isone(num)) {\n      return;\n    }\n    if (!(polyVar = areunivarpolysfactoredorexpandedform(num, denom))) {\n      return;\n    }\n    push(num);\n    push(denom);\n    gcd();\n    push(polyVar);\n    factor();\n    theGCD = pop();\n    // if there are no common factors then\n    // bail\n    if (isone(theGCD)) {\n      return;\n    }\n    push(num);\n    push(polyVar);\n    factor();\n    push(theGCD);\n    //divide()\n    inverse();\n    multiply_noexpand();\n    simplify();\n    sasa = stack[tos - 1].toString();\n    push(denom);\n    push(polyVar);\n    factor();\n    push(theGCD);\n    //divide()\n    inverse();\n    multiply_noexpand();\n    simplify();\n    sasa = stack[tos - 1].toString();\n    divide();\n    //simplify()\n    Condense();\n    sasa = stack[tos - 1].toString();\n    p2 = pop();\n    if (count(p2) < count(p1)) {\n      return p1 = p2;\n    }\n  };\n\n  // things like 6*(cos(2/9*pi)+i*sin(2/9*pi))\n  // where we have sin and cos, those might start to\n  // look better in clock form i.e.  6*(-1)^(2/9) \n  simplify_rectToClock = function() {\n    //debugger\n    if (Find(p1, symbol(SIN)) === 0 && Find(p1, symbol(COS)) === 0) {\n      return;\n    }\n    push(p1);\n    Eval();\n    clockform();\n    p2 = pop();\n    if (DEBUG_SIMPLIFY) {\n      console.log(\"before simplification clockform: \" + p1 + \" after: \" + p2);\n    }\n    if (count(p2) < count(p1)) {\n      return p1 = p2;\n    }\n  };\n\n  simplify_polarRect = function() {\n    push(p1);\n    polarRectAMinusOneBase();\n    Eval();\n    p2 = pop();\n    if (count(p2) < count(p1)) {\n      return p1 = p2;\n    }\n  };\n\n  polarRectAMinusOneBase = function() {\n    var h;\n    save();\n    p1 = pop();\n    if (isimaginaryunit(p1)) {\n      push(p1);\n      restore();\n      return;\n    }\n    if (equal(car(p1), symbol(POWER)) && isminusone(cadr(p1))) {\n      // base we just said is minus 1\n      push(one);\n      negate();\n      // exponent\n      push(caddr(p1));\n      polarRectAMinusOneBase();\n      power();\n      // try to simplify it using polar and rect\n      polar();\n      rect();\n    } else if (iscons(p1)) {\n      h = tos;\n      while (iscons(p1)) {\n        //console.log(\"recursing on: \" + car(p1).toString())\n        push(car(p1));\n        polarRectAMinusOneBase();\n        //console.log(\"...transformed into: \" + stack[tos-1].toString())\n        p1 = cdr(p1);\n      }\n      list(tos - h);\n    } else {\n      push(p1);\n    }\n    restore();\n  };\n\n  nterms = function(p) {\n    if (car(p) !== symbol(ADD)) {\n      return 1;\n    } else {\n      return length(p) - 1;\n    }\n  };\n\n  simplify_nested_radicals = function() {\n    var prev_expanding, simplificationWithCondense, simplificationWithoutCondense, somethingSimplified;\n    if (recursionLevelNestedRadicalsRemoval > 0) {\n      if (DEBUG_SIMPLIFY) {\n        console.log(\"denesting bailing out because of too much recursion\");\n      }\n      return false;\n    }\n    push(p1);\n    somethingSimplified = take_care_of_nested_radicals();\n    // in this paragraph we check whether we can collect\n    // common factors without complicating the expression\n    // in particular we want to avoid \n    // collecting radicals like in this case where\n    // we collect sqrt(2):\n    //   2-2^(1/2) into 2^(1/2)*(-1+2^(1/2))\n    // but we do like to collect other non-radicals e.g.\n    //   17/2+3/2*5^(1/2) into 1/2*(17+3*5^(1/2))\n    // so what we do is we count the powers and we check\n    // which version has the least number of them.\n    simplificationWithoutCondense = stack[tos - 1];\n    prev_expanding = expanding;\n    expanding = 0;\n    yycondense();\n    expanding = prev_expanding;\n    simplificationWithCondense = pop();\n    //console.log(\"occurrences of powers in \" + simplificationWithoutCondense + \" :\" + countOccurrencesOfSymbol(symbol(POWER),simplificationWithoutCondense))\n    //console.log(\"occurrences of powers in \" + simplificationWithCondense + \" :\" + countOccurrencesOfSymbol(symbol(POWER),simplificationWithCondense))\n    if (countOccurrencesOfSymbol(symbol(POWER), simplificationWithoutCondense) < countOccurrencesOfSymbol(symbol(POWER), simplificationWithCondense)) {\n      push(simplificationWithoutCondense);\n    } else {\n      push(simplificationWithCondense);\n    }\n    // we got out result, wrap up\n    p1 = pop();\n    return somethingSimplified;\n  };\n\n  take_care_of_nested_radicals = function() {\n    var A, B, C, SOLUTION, anyRadicalSimplificationWorked, base, checkSize, commonBases, commonInnerExponent, countingTerms, eachSolution, exponent, firstTerm, h, i, innerbase, innerexponent, l1, len, len1, len2, len3, lowercase_a, lowercase_b, m1, n1, numberOfTerms, o1, possibleNewExpression, possibleNewExpressionValue, possibleRationalSolutions, possibleSolutions, potentialPower, realOfpossibleRationalSolutions, ref2, secondTerm, secondTermFactor, termsThatAreNotPowers, whichRationalSolution;\n    if (recursionLevelNestedRadicalsRemoval > 0) {\n      if (DEBUG_SIMPLIFY) {\n        console.log(\"denesting bailing out because of too much recursion\");\n      }\n      return false;\n    }\n    save();\n    p1 = pop();\n    //console.log(\"take_care_of_nested_radicals p1: \" + p1.toString())\n    if (equal(car(p1), symbol(POWER))) {\n      //console.log(\"ok it's a power \")\n      base = cadr(p1);\n      exponent = caddr(p1);\n      if (!isminusone(exponent) && equal(car(base), symbol(ADD)) && isfraction(exponent) && (equalq(exponent, 1, 3) || equalq(exponent, 1, 2))) {\n        //console.log(\"ok there is a radix with a term inside\")\n        firstTerm = cadr(base);\n        push(firstTerm);\n        take_care_of_nested_radicals();\n        pop();\n        secondTerm = caddr(base);\n        push(secondTerm);\n        take_care_of_nested_radicals();\n        pop();\n        //console.log(\"possible double radical term1: \" + firstTerm)\n        //console.log(\"possible double radical term2: \" + secondTerm)\n        numberOfTerms = 0;\n        countingTerms = base;\n        while (cdr(countingTerms) !== symbol(NIL)) {\n          numberOfTerms++;\n          countingTerms = cdr(countingTerms);\n        }\n        //console.log(\"number of terms: \" + numberOfTerms)\n        if (numberOfTerms > 2) {\n          //console.log(\"too many terms under outer radix \")\n          push(p1);\n          restore();\n          return false;\n        }\n        // list here all the factors\n        commonInnerExponent = null;\n        commonBases = [];\n        termsThatAreNotPowers = [];\n        if (car(secondTerm) === symbol(MULTIPLY)) {\n          // product of factors\n          secondTermFactor = cdr(secondTerm);\n          if (iscons(secondTermFactor)) {\n            while (iscons(secondTermFactor)) {\n              //console.log(\"second term factor BIS: \" + car(secondTermFactor).toString())\n              potentialPower = car(secondTermFactor);\n              if (car(potentialPower) === symbol(POWER)) {\n                innerbase = cadr(potentialPower);\n                innerexponent = caddr(potentialPower);\n                if (equalq(innerexponent, 1, 2)) {\n                  if (commonInnerExponent == null) {\n                    commonInnerExponent = innerexponent;\n                    commonBases.push(innerbase);\n                  } else {\n                    if (equal(innerexponent, commonInnerExponent)) {\n                      //console.log(\"common base: \" + innerbase.toString())\n                      commonBases.push(innerbase);\n                    } else {\n\n                    }\n                  }\n                }\n              } else {\n                //console.log(\"no common bases here \")\n                //console.log(\"this one is a power base: \" + innerbase + \" , exponent: \" + innerexponent)\n                termsThatAreNotPowers.push(potentialPower);\n              }\n              secondTermFactor = cdr(secondTermFactor);\n            }\n          }\n        } else if (car(secondTerm) === symbol(POWER)) {\n          innerbase = cadr(secondTerm);\n          innerexponent = caddr(secondTerm);\n          if ((commonInnerExponent == null) && equalq(innerexponent, 1, 2)) {\n            //console.log(\"tackling double radical 2: \" + p1.toString())\n            commonInnerExponent = innerexponent;\n            commonBases.push(innerbase);\n          }\n        }\n        if (commonBases.length === 0) {\n          push(p1);\n          restore();\n          return false;\n        }\n        A = firstTerm;\n        //console.log(\"A: \" + A.toString())\n        push_integer(1);\n        for (l1 = 0, len = commonBases.length; l1 < len; l1++) {\n          i = commonBases[l1];\n          push(i);\n          multiply();\n        }\n        //console.log(\"basis with common exponent: \" + i.toString())\n        C = pop();\n        //console.log(\"C: \" + C.toString())\n        push_integer(1);\n        for (m1 = 0, len1 = termsThatAreNotPowers.length; m1 < len1; m1++) {\n          i = termsThatAreNotPowers[m1];\n          push(i);\n          multiply();\n        }\n        //console.log(\"terms that are not powers: \" + i.toString())\n        B = pop();\n        //console.log(\"B: \" + B.toString())\n        if (equalq(exponent, 1, 3)) {\n          push(A);\n          negate();\n          push(C);\n          multiply();\n          push(B);\n          divide(); // 4th coeff\n          //console.log(\"constant coeff \" + stack[tos-1].toString())\n          checkSize = pop();\n          push(checkSize);\n          real();\n          yyfloat();\n          if (Math.abs(pop().d) > Math.pow(2, 32)) {\n            push(p1);\n            restore();\n            return false;\n          }\n          push(checkSize);\n          push_integer(3);\n          push(C);\n          multiply(); // 3rd coeff\n          //console.log(\"next coeff \" + stack[tos-1].toString())\n          checkSize = pop();\n          push(checkSize);\n          real();\n          yyfloat();\n          if (Math.abs(pop().d) > Math.pow(2, 32)) {\n            pop();\n            push(p1);\n            restore();\n            return false;\n          }\n          push(checkSize);\n          push(symbol(SECRETX));\n          multiply();\n          push_integer(-3);\n          push(A);\n          multiply();\n          push(B);\n          divide(); // 2nd coeff\n          checkSize = pop();\n          push(checkSize);\n          real();\n          yyfloat();\n          if (Math.abs(pop().d) > Math.pow(2, 32)) {\n            pop();\n            pop();\n            push(p1);\n            restore();\n            return false;\n          }\n          push(checkSize);\n          //console.log(\"next coeff \" + stack[tos-1].toString())\n          push(symbol(SECRETX));\n          push_integer(2);\n          power();\n          multiply();\n          push_integer(1); // 1st coeff\n          //console.log(\"next coeff \" + stack[tos-1].toString())\n          push(symbol(SECRETX));\n          push_integer(3);\n          power();\n          multiply();\n          add();\n          add();\n          add();\n        } else if (equalq(exponent, 1, 2)) {\n          push(C); // 3th coeff\n          checkSize = pop();\n          push(checkSize);\n          real();\n          yyfloat();\n          if (Math.abs(pop().d) > Math.pow(2, 32)) {\n            push(p1);\n            restore();\n            return false;\n          }\n          push(checkSize);\n          //console.log(\"constant coeff \" + stack[tos-1].toString())\n          push_integer(-2);\n          push(A);\n          multiply();\n          push(B);\n          divide(); // 2nd coeff\n          checkSize = pop();\n          push(checkSize);\n          real();\n          yyfloat();\n          if (Math.abs(pop().d) > Math.pow(2, 32)) {\n            pop();\n            push(p1);\n            restore();\n            return false;\n          }\n          push(checkSize);\n          //console.log(\"next coeff \" + stack[tos-1].toString())\n          push(symbol(SECRETX));\n          multiply();\n          push_integer(1); // 1st coeff\n          //console.log(\"next coeff \" + stack[tos-1].toString())\n          push(symbol(SECRETX));\n          push_integer(2);\n          power();\n          multiply();\n          add();\n          add();\n        }\n        //console.log(\"whole polynomial: \" + stack[tos-1].toString())\n        push(symbol(SECRETX));\n        recursionLevelNestedRadicalsRemoval++;\n        //console.log(\"invoking roots at recursion level: \" + recursionLevelNestedRadicalsRemoval)\n        roots();\n        recursionLevelNestedRadicalsRemoval--;\n        if (equal(stack[tos - 1], symbol(NIL))) {\n          if (DEBUG_SIMPLIFY) {\n            console.log(\"roots bailed out because of too much recursion\");\n          }\n          pop();\n          push(p1);\n          restore();\n          return false;\n        }\n        //console.log(\"all solutions: \" + stack[tos-1].toString())\n\n        // exclude the solutions with radicals\n        possibleSolutions = [];\n        ref2 = stack[tos - 1].tensor.elem;\n        for (n1 = 0, len2 = ref2.length; n1 < len2; n1++) {\n          eachSolution = ref2[n1];\n          if (!Find(eachSolution, symbol(POWER))) {\n            possibleSolutions.push(eachSolution);\n          }\n        }\n        pop(); // popping the tensor with the solutions\n        \n        //console.log(\"possible solutions: \" + possibleSolutions.toString())\n        if (possibleSolutions.length === 0) {\n          push(p1);\n          restore();\n          return false;\n        }\n        possibleRationalSolutions = [];\n        realOfpossibleRationalSolutions = [];\n//console.log(\"checking the one with maximum real part \")\n        for (o1 = 0, len3 = possibleSolutions.length; o1 < len3; o1++) {\n          i = possibleSolutions[o1];\n          push(i);\n          real();\n          yyfloat();\n          possibleRationalSolutions.push(i);\n          realOfpossibleRationalSolutions.push(pop().d);\n        }\n        whichRationalSolution = realOfpossibleRationalSolutions.indexOf(Math.max.apply(Math, realOfpossibleRationalSolutions));\n        SOLUTION = possibleRationalSolutions[whichRationalSolution];\n        //console.log(\"picked solution: \" + SOLUTION)\n        /*\n        #possibleNewExpressions = []\n        #realOfPossibleNewExpressions = []\n         * pick the solution which cubic root has no radicals\n        lowercase_b = null\n        for SOLUTION in possibleSolutions\n          console.log(\"testing solution: \" + SOLUTION.toString())\n\n          debugger\n          if equalq(exponent,1,3)\n            push(A)\n            push(SOLUTION)\n            push_integer(3)\n            power()\n            push_integer(3)\n            push(C)\n            multiply()\n            push(SOLUTION)\n            multiply()\n            add()\n            divide()\n            console.log(\"argument of cubic root: \" + stack[tos-1].toString())\n            push_rational(1,3)\n            power()\n          else if equalq(exponent,1,2)\n            push(A)\n            push(SOLUTION)\n            push_integer(2)\n            power()\n            push(C)\n            add()\n            divide()\n            console.log(\"argument of cubic root: \" + stack[tos-1].toString())\n            push_rational(1,2)\n            power()\n          console.log(\"b is: \" + stack[tos-1].toString())\n\n          lowercase_b = pop()\n\n          if !Find(lowercase_b, symbol(POWER))\n            break\n         */\n        if (equalq(exponent, 1, 3)) {\n          push(A);\n          push(SOLUTION);\n          push_integer(3);\n          power();\n          push_integer(3);\n          push(C);\n          multiply();\n          push(SOLUTION);\n          multiply();\n          add();\n          divide();\n          //console.log(\"argument of cubic root: \" + stack[tos-1].toString())\n          push_rational(1, 3);\n          power();\n        } else if (equalq(exponent, 1, 2)) {\n          push(A);\n          push(SOLUTION);\n          push_integer(2);\n          power();\n          push(C);\n          add();\n          divide();\n          //console.log(\"argument of cubic root: \" + stack[tos-1].toString())\n          push_rational(1, 2);\n          power();\n        }\n        //console.log(\"b is: \" + stack[tos-1].toString())\n        lowercase_b = pop();\n        if (lowercase_b == null) {\n          push(p1);\n          restore();\n          return false;\n        }\n        push(lowercase_b);\n        push(SOLUTION);\n        multiply();\n        if (equalq(exponent, 1, 3)) {\n          //console.log(\"a is: \" + stack[tos-1].toString())\n          lowercase_a = pop();\n          push(lowercase_b);\n          push(C);\n          push_rational(1, 2);\n          power();\n          multiply();\n          push(lowercase_a);\n          add();\n          simplify();\n        } else if (equalq(exponent, 1, 2)) {\n          //console.log(\"a could be: \" + stack[tos-1].toString())\n          lowercase_a = pop();\n          push(lowercase_b);\n          push(C);\n          push_rational(1, 2);\n          power();\n          multiply();\n          push(lowercase_a);\n          add();\n          simplify();\n          possibleNewExpression = pop();\n          //console.log(\"verifying if  \" + possibleNewExpression + \" is positive\")\n          push(possibleNewExpression);\n          real();\n          yyfloat();\n          possibleNewExpressionValue = pop();\n          if (!isnegativenumber(possibleNewExpressionValue)) {\n            //console.log(\"... it is positive\")\n            push(possibleNewExpression);\n          } else {\n            //console.log(\"... it is NOT positive\")\n            push(lowercase_b);\n            negate();\n            lowercase_b = pop();\n            push(lowercase_a);\n            negate();\n            lowercase_a = pop();\n            push(lowercase_b);\n            push(C);\n            push_rational(1, 2);\n            power();\n            multiply();\n            push(lowercase_a);\n            add();\n            simplify();\n          }\n        }\n        // possibleNewExpression is now at top of stack\n\n        //console.log(\"potential new expression: \" + stack[tos-1].toString())\n        p1 = pop();\n        //newExpression = pop()\n        //debugger\n        //push(newExpression)\n        //real()\n        //yyfloat()\n        //possibleNewExpressions.push(newExpression)\n        //realOfPossibleNewExpressions.push(pop().d)\n\n        //whichExpression = realOfPossibleNewExpressions.indexOf(Math.max.apply(Math, realOfPossibleNewExpressions))\n        //p1 = possibleNewExpressions[whichExpression]\n        //console.log(\"final new expression: \" + p1.toString())\n        push(p1);\n        restore();\n        return true;\n      } else {\n        push(p1);\n        restore();\n        return false;\n      }\n    } else if (iscons(p1)) {\n      h = tos;\n      anyRadicalSimplificationWorked = false;\n      while (iscons(p1)) {\n        //console.log(\"recursing on: \" + car(p1).toString())\n        push(car(p1));\n        anyRadicalSimplificationWorked = anyRadicalSimplificationWorked || take_care_of_nested_radicals();\n        //console.log(\"...transformed into: \" + stack[tos-1].toString())\n        p1 = cdr(p1);\n      }\n      list(tos - h);\n      restore();\n      return anyRadicalSimplificationWorked;\n    } else {\n      push(p1);\n      restore();\n      return false;\n    }\n    throw new Error(\"control flow should never reach here\");\n  };\n\n  // Sine function of numerical and symbolic arguments\n  Eval_sin = function() {\n    //console.log \"sin ---- \"\n    push(cadr(p1));\n    Eval();\n    return sine();\n  };\n\n  //console.log \"sin end ---- \"\n  sine = function() {\n    //console.log \"sine ---- \"\n    save();\n    p1 = pop();\n    if (car(p1) === symbol(ADD)) {\n      // sin of a sum can be further decomposed into\n      //sin(alpha+beta) = sin(alpha)*cos(beta)+sin(beta)*cos(alpha)\n      sine_of_angle_sum();\n    } else {\n      sine_of_angle();\n    }\n    return restore();\n  };\n\n  //console.log \"sine end ---- \"\n\n  // Use angle sum formula for special angles.\n\n  //define A p3\n  //define B p4\n\n  // decompose sum sin(alpha+beta) into\n  // sin(alpha)*cos(beta)+sin(beta)*cos(alpha)\n  sine_of_angle_sum = function() {\n    //console.log \"sin of angle sum ---- \"\n    p2 = cdr(p1);\n    while (iscons(p2)) {\n      p4 = car(p2);\n      if (isnpi(p4)) { // p4 is B\n        push(p1);\n        push(p4);\n        subtract();\n        p3 = pop();\n        push(p3);\n        sine();\n        push(p4);\n        cosine();\n        multiply();\n        push(p3);\n        cosine();\n        push(p4);\n        sine();\n        multiply();\n        add();\n        return;\n      }\n      //console.log \"sin of angle sum end ---- \"\n      p2 = cdr(p2);\n    }\n    return sine_of_angle();\n  };\n\n  //console.log \"sin of angle sum end ---- \"\n  sine_of_angle = function() {\n    var d, n;\n    if (car(p1) === symbol(ARCSIN)) {\n      push(cadr(p1));\n      return;\n    }\n    if (isdouble(p1)) {\n      d = Math.sin(p1.d);\n      if (Math.abs(d) < 1e-10) {\n        d = 0.0;\n      }\n      push_double(d);\n      return;\n    }\n    // sine function is antisymmetric, sin(-x) = -sin(x)\n    if (isnegative(p1)) {\n      push(p1);\n      negate();\n      sine();\n      negate();\n      return;\n    }\n    // sin(arctan(x)) = x / sqrt(1 + x^2)\n\n    // see p. 173 of the CRC Handbook of Mathematical Sciences\n    if (car(p1) === symbol(ARCTAN)) {\n      push(cadr(p1));\n      push_integer(1);\n      push(cadr(p1));\n      push_integer(2);\n      power();\n      add();\n      push_rational(-1, 2);\n      power();\n      multiply();\n      return;\n    }\n    // multiply by 180/pi to go from radians to degrees.\n    // we go from radians to degrees because it's much\n    // easier to calculate symbolic results of most (not all) \"classic\"\n    // angles (e.g. 30,45,60...) if we calculate the degrees\n    // and the we do a switch on that.\n    // Alternatively, we could look at the fraction of pi\n    // (e.g. 60 degrees is 1/3 pi) but that's more\n    // convoluted as we'd need to look at both numerator and\n    // denominator.\n    push(p1);\n    push_integer(180);\n    multiply();\n    if (evaluatingAsFloats) {\n      push_double(Math.PI);\n    } else {\n      push_symbol(PI);\n    }\n    divide();\n    n = pop_integer();\n    // most \"good\" (i.e. compact) trigonometric results\n    // happen for a round number of degrees. There are some exceptions\n    // though, e.g. 22.5 degrees, which we don't capture here.\n    if (n < 0 || isNaN(n)) {\n      push(symbol(SIN));\n      push(p1);\n      list(2);\n      return;\n    }\n    // values of some famous angles. Many more here:\n    // https://en.wikipedia.org/wiki/Trigonometric_constants_expressed_in_real_radicals\n    switch (n % 360) {\n      case 0:\n      case 180:\n        return push_integer(0);\n      case 30:\n      case 150:\n        return push_rational(1, 2);\n      case 210:\n      case 330:\n        return push_rational(-1, 2);\n      case 45:\n      case 135:\n        push_rational(1, 2);\n        push_integer(2);\n        push_rational(1, 2);\n        power();\n        return multiply();\n      case 225:\n      case 315:\n        push_rational(-1, 2);\n        push_integer(2);\n        push_rational(1, 2);\n        power();\n        return multiply();\n      case 60:\n      case 120:\n        push_rational(1, 2);\n        push_integer(3);\n        push_rational(1, 2);\n        power();\n        return multiply();\n      case 240:\n      case 300:\n        push_rational(-1, 2);\n        push_integer(3);\n        push_rational(1, 2);\n        power();\n        return multiply();\n      case 90:\n        return push_integer(1);\n      case 270:\n        return push_integer(-1);\n      default:\n        push(symbol(SIN));\n        push(p1);\n        return list(2);\n    }\n  };\n\n  //            exp(x) - exp(-x)\n  //  sinh(x) = ----------------\n  //                   2\n  Eval_sinh = function() {\n    push(cadr(p1));\n    Eval();\n    return ysinh();\n  };\n\n  ysinh = function() {\n    save();\n    yysinh();\n    return restore();\n  };\n\n  yysinh = function() {\n    var d;\n    d = 0.0;\n    p1 = pop();\n    if (car(p1) === symbol(ARCSINH)) {\n      push(cadr(p1));\n      return;\n    }\n    if (isdouble(p1)) {\n      d = Math.sinh(p1.d);\n      if (Math.abs(d) < 1e-10) {\n        d = 0.0;\n      }\n      push_double(d);\n      return;\n    }\n    if (isZeroAtomOrTensor(p1)) {\n      push(zero);\n      return;\n    }\n    push_symbol(SINH);\n    push(p1);\n    return list(2);\n  };\n\n  subst = function() {\n    var expr, i, l1, m1, newExpr, newTensor, oldExpr, ref2, ref3;\n    save();\n    newExpr = pop();\n    oldExpr = pop();\n    if (oldExpr === symbol(NIL) || newExpr === symbol(NIL)) {\n      restore();\n      return;\n    }\n    expr = pop();\n    if (istensor(expr)) {\n      newTensor = alloc_tensor(expr.tensor.nelem);\n      newTensor.tensor.ndim = expr.tensor.ndim;\n      for (i = l1 = 0, ref2 = expr.tensor.ndim; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n        newTensor.tensor.dim[i] = expr.tensor.dim[i];\n      }\n      for (i = m1 = 0, ref3 = expr.tensor.nelem; (0 <= ref3 ? m1 < ref3 : m1 > ref3); i = 0 <= ref3 ? ++m1 : --m1) {\n        push(expr.tensor.elem[i]);\n        push(oldExpr);\n        push(newExpr);\n        subst();\n        newTensor.tensor.elem[i] = pop();\n        check_tensor_dimensions(newTensor);\n      }\n      push(newTensor);\n    } else if (equal(expr, oldExpr)) {\n      push(newExpr);\n    } else if (iscons(expr)) {\n      push(car(expr));\n      push(oldExpr);\n      push(newExpr);\n      subst();\n      push(cdr(expr));\n      push(oldExpr);\n      push(newExpr);\n      subst();\n      cons();\n    } else {\n      push(expr);\n    }\n    return restore();\n  };\n\n  // 'sum' function\n\n  //define A p3\n  //define B p4\n  //define I p5\n  //define X p6\n\n  // leaves the sum at the top of the stack\n  Eval_sum = function() {\n    var body, i, indexVariable, j, k, l1, ref2, ref3;\n    i = 0;\n    j = 0;\n    k = 0;\n    // 1st arg\n    body = cadr(p1);\n    // 2nd arg (index)\n    indexVariable = caddr(p1);\n    if (!issymbol(indexVariable)) {\n      stop(\"sum: 2nd arg?\");\n    }\n    // 3rd arg (lower limit)\n    push(cadddr(p1));\n    Eval();\n    j = pop_integer();\n    if (isNaN(j)) {\n      push(p1);\n      return;\n    }\n    // 4th arg (upper limit)\n    push(caddddr(p1));\n    Eval();\n    k = pop_integer();\n    if (isNaN(k)) {\n      push(p1);\n      return;\n    }\n    // remember contents of the index\n    // variable so we can put it back after the loop\n    p4 = get_binding(indexVariable);\n    push_integer(0);\n    for (i = l1 = ref2 = j, ref3 = k; (ref2 <= ref3 ? l1 <= ref3 : l1 >= ref3); i = ref2 <= ref3 ? ++l1 : --l1) {\n      push_integer(i);\n      p5 = pop();\n      set_binding(indexVariable, p5);\n      push(body);\n      Eval();\n      add();\n    }\n    // put back the index variable to original content\n    return set_binding(indexVariable, p4);\n  };\n\n  // Tangent function of numerical and symbolic arguments\n  Eval_tan = function() {\n    push(cadr(p1));\n    Eval();\n    return tangent();\n  };\n\n  tangent = function() {\n    save();\n    yytangent();\n    return restore();\n  };\n\n  yytangent = function() {\n    var d, n;\n    n = 0;\n    d = 0.0;\n    p1 = pop();\n    if (car(p1) === symbol(ARCTAN)) {\n      push(cadr(p1));\n      return;\n    }\n    if (isdouble(p1)) {\n      d = Math.tan(p1.d);\n      if (Math.abs(d) < 1e-10) {\n        d = 0.0;\n      }\n      push_double(d);\n      return;\n    }\n    // tan function is antisymmetric, tan(-x) = -tan(x)\n    if (isnegative(p1)) {\n      push(p1);\n      negate();\n      tangent();\n      negate();\n      return;\n    }\n    // multiply by 180/pi to go from radians to degrees.\n    // we go from radians to degrees because it's much\n    // easier to calculate symbolic results of most (not all) \"classic\"\n    // angles (e.g. 30,45,60...) if we calculate the degrees\n    // and the we do a switch on that.\n    // Alternatively, we could look at the fraction of pi\n    // (e.g. 60 degrees is 1/3 pi) but that's more\n    // convoluted as we'd need to look at both numerator and\n    // denominator.\n    push(p1);\n    push_integer(180);\n    multiply();\n    if (evaluatingAsFloats) {\n      push_double(Math.PI);\n    } else {\n      push_symbol(PI);\n    }\n    divide();\n    n = pop_integer();\n    // most \"good\" (i.e. compact) trigonometric results\n    // happen for a round number of degrees. There are some exceptions\n    // though, e.g. 22.5 degrees, which we don't capture here.\n    if (n < 0 || isNaN(n)) {\n      push(symbol(TAN));\n      push(p1);\n      list(2);\n      return;\n    }\n    switch (n % 360) {\n      case 0:\n      case 180:\n        return push_integer(0);\n      case 30:\n      case 210:\n        push_rational(1, 3);\n        push_integer(3);\n        push_rational(1, 2);\n        power();\n        return multiply();\n      case 150:\n      case 330:\n        push_rational(-1, 3);\n        push_integer(3);\n        push_rational(1, 2);\n        power();\n        return multiply();\n      case 45:\n      case 225:\n        return push_integer(1);\n      case 135:\n      case 315:\n        return push_integer(-1);\n      case 60:\n      case 240:\n        push_integer(3);\n        push_rational(1, 2);\n        return power();\n      case 120:\n      case 300:\n        push_integer(3);\n        push_rational(1, 2);\n        power();\n        return negate();\n      default:\n        push(symbol(TAN));\n        push(p1);\n        return list(2);\n    }\n  };\n\n  //             exp(2 x) - 1\n  //  tanh(x) = --------------\n  //             exp(2 x) + 1\n  Eval_tanh = function() {\n    var d;\n    d = 0.0;\n    push(cadr(p1));\n    Eval();\n    p1 = pop();\n    if (car(p1) === symbol(ARCTANH)) {\n      push(cadr(p1));\n      return;\n    }\n    if (isdouble(p1)) {\n      d = Math.tanh(p1.d);\n      if (Math.abs(d) < 1e-10) {\n        d = 0.0;\n      }\n      push_double(d);\n      return;\n    }\n    if (isZeroAtomOrTensor(p1)) {\n      push(zero);\n      return;\n    }\n    push_symbol(TANH);\n    push(p1);\n    return list(2);\n  };\n\n  Eval_taylor = function() {\n    // 1st arg\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    // 2nd arg\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p2 = pop();\n    if (p2 === symbol(NIL)) {\n      guess();\n    } else {\n      push(p2);\n    }\n    // 3rd arg\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p2 = pop();\n    if (p2 === symbol(NIL)) {\n      push_integer(24); // default number of terms\n    } else {\n      push(p2);\n    }\n    // 4th arg\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p2 = pop();\n    if (p2 === symbol(NIL)) {\n      push_integer(0); // default expansion point\n    } else {\n      push(p2);\n    }\n    return taylor();\n  };\n\n  //define F p1\n  //define X p2\n  //define N p3\n  //define A p4\n  //define C p5\n  taylor = function() {\n    var i, k, l1, ref2;\n    i = 0;\n    k = 0;\n    save();\n    p4 = pop();\n    p3 = pop();\n    p2 = pop();\n    p1 = pop();\n    push(p3);\n    k = pop_integer();\n    if (isNaN(k)) {\n      push_symbol(TAYLOR);\n      push(p1);\n      push(p2);\n      push(p3);\n      push(p4);\n      list(5);\n      restore();\n      return;\n    }\n    push(p1);\n    push(p2);\n    push(p4);\n    subst();\n    Eval();\n    push_integer(1);\n    p5 = pop();\n    for (i = l1 = 1, ref2 = k; (1 <= ref2 ? l1 <= ref2 : l1 >= ref2); i = 1 <= ref2 ? ++l1 : --l1) {\n      push(p1);\n      push(p2);\n      derivative();\n      p1 = pop();\n      if (isZeroAtomOrTensor(p1)) {\n        break;\n      }\n      push(p5);\n      push(p2);\n      push(p4);\n      subtract();\n      multiply();\n      p5 = pop();\n      push(p1);\n      push(p2);\n      push(p4);\n      subst();\n      Eval();\n      push(p5);\n      multiply();\n      push_integer(i);\n      factorial();\n      divide();\n      add();\n    }\n    return restore();\n  };\n\n  //(docs are generated from top-level comments, keep an eye on the formatting!)\n  /* tensor =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  General description\n  -------------------\n  Tensors are a strange in-between of matrices and \"computer\"\n  rectangular data structures.\n\n  Tensors, unlike matrices, and like rectangular data structures,\n  can have an arbitrary number of dimensions (rank), although a tensor with\n  rank zero is just a scalar.\n\n  Tensors, like matrices and unlike many computer rectangular data structures,\n  must be \"contiguous\" i.e. have no empty spaces within its size, and \"uniform\",\n  i.e. each element must have the same shape and hence the same rank.\n\n  Also tensors have necessarily to make a distinction between row vectors,\n  column vectors (which have a rank of 2) and uni-dimensional vectors (rank 1).\n  They look very similar but they are fundamentally different.\n\n  Tensors are 1-indexed, as per general math notation, and like Fortran,\n  Lua, Mathematica, SASL, MATLAB, Julia, Erlang and APL.\n\n  Tensors with elements that are also tensors get promoted to a higher rank\n  , this is so we can represent and get the rank of a matrix correctly.\n  Example:\n  Start with a tensor of rank 1 with 2 elements (i.e. shape: 2)\n  if you put in both its elements another 2 tensors\n  of rank 1 with 2 elements (i.e. shape: 2)\n  then the result is a tensor of rank 2 with shape 2,2\n  i.e. the dimension of a tensor at all times must be\n  the number of nested tensors in it.\n  Also, all tensors must be \"uniform\" i.e. they must be accessed\n  uniformly, which means that all existing elements of a tensor\n  must be contiguous and have the same shape.\n  Implication of it all is that you can't put arbitrary\n  tensors inside tensors (like you would do to represent block matrices)\n  Rather, all tensors inside tensors must have same shape (and hence, rank)\n\n  Limitations\n  -----------\n  n.a.\n\n  Implementation info\n  -------------------\n  Tensors are implemented...\n\n  */\n  // Called from the \"eval\" module to evaluate tensor elements.\n  // p1 points to the tensor operand.\n  Eval_tensor = function() {\n    var a, b, i, l1, m1, ndim, nelem, ref2, ref3;\n    i = 0;\n    ndim = 0;\n    nelem = 0;\n    //U **a, **b\n\n    //---------------------------------------------------------------------\n\n    //  create a new tensor for the result\n\n    //---------------------------------------------------------------------\n    check_tensor_dimensions(p1);\n    nelem = p1.tensor.nelem;\n    ndim = p1.tensor.ndim;\n    p2 = alloc_tensor(nelem);\n    p2.tensor.ndim = ndim;\n    for (i = l1 = 0, ref2 = ndim; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      p2.tensor.dim[i] = p1.tensor.dim[i];\n    }\n    //---------------------------------------------------------------------\n\n    //  b = Eval(a)\n\n    //---------------------------------------------------------------------\n    a = p1.tensor.elem;\n    b = p2.tensor.elem;\n    check_tensor_dimensions(p2);\n    for (i = m1 = 0, ref3 = nelem; (0 <= ref3 ? m1 < ref3 : m1 > ref3); i = 0 <= ref3 ? ++m1 : --m1) {\n      //console.log \"push/pop: pushing element a of \" + i\n      push(a[i]);\n      Eval();\n      //console.log \"push/pop: popping into element b of \" + i\n      b[i] = pop();\n    }\n    check_tensor_dimensions(p1);\n    check_tensor_dimensions(p2);\n    //---------------------------------------------------------------------\n\n    //  push the result\n\n    //---------------------------------------------------------------------\n    push(p2);\n    return promote_tensor();\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Add tensors\n\n  //  Input:    Operands on stack\n\n  //  Output:    Result on stack\n\n  //-----------------------------------------------------------------------------\n  tensor_plus_tensor = function() {\n    var a, b, c, i, l1, m1, n1, ndim, nelem, ref2, ref3, ref4;\n    i = 0;\n    ndim = 0;\n    nelem = 0;\n    //U **a, **b, **c\n    save();\n    p2 = pop();\n    p1 = pop();\n    // are the dimension lists equal?\n    ndim = p1.tensor.ndim;\n    if (ndim !== p2.tensor.ndim) {\n      push(symbol(NIL));\n      restore();\n      return;\n    }\n    for (i = l1 = 0, ref2 = ndim; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      if (p1.tensor.dim[i] !== p2.tensor.dim[i]) {\n        push(symbol(NIL));\n        restore();\n        return;\n      }\n    }\n    // create a new tensor for the result\n    nelem = p1.tensor.nelem;\n    p3 = alloc_tensor(nelem);\n    p3.tensor.ndim = ndim;\n    for (i = m1 = 0, ref3 = ndim; (0 <= ref3 ? m1 < ref3 : m1 > ref3); i = 0 <= ref3 ? ++m1 : --m1) {\n      p3.tensor.dim[i] = p1.tensor.dim[i];\n    }\n    // c = a + b\n    a = p1.tensor.elem;\n    b = p2.tensor.elem;\n    c = p3.tensor.elem;\n    for (i = n1 = 0, ref4 = nelem; (0 <= ref4 ? n1 < ref4 : n1 > ref4); i = 0 <= ref4 ? ++n1 : --n1) {\n      push(a[i]);\n      push(b[i]);\n      add();\n      c[i] = pop();\n    }\n    // push the result\n    push(p3);\n    return restore();\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  careful not to reorder factors\n\n  //-----------------------------------------------------------------------------\n  tensor_times_scalar = function() {\n    var a, b, i, l1, m1, ndim, nelem, ref2, ref3;\n    i = 0;\n    ndim = 0;\n    nelem = 0;\n    //U **a, **b\n    save();\n    p2 = pop();\n    p1 = pop();\n    ndim = p1.tensor.ndim;\n    nelem = p1.tensor.nelem;\n    p3 = alloc_tensor(nelem);\n    p3.tensor.ndim = ndim;\n    for (i = l1 = 0, ref2 = ndim; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      p3.tensor.dim[i] = p1.tensor.dim[i];\n    }\n    a = p1.tensor.elem;\n    b = p3.tensor.elem;\n    for (i = m1 = 0, ref3 = nelem; (0 <= ref3 ? m1 < ref3 : m1 > ref3); i = 0 <= ref3 ? ++m1 : --m1) {\n      push(a[i]);\n      push(p2);\n      multiply();\n      b[i] = pop();\n    }\n    push(p3);\n    return restore();\n  };\n\n  scalar_times_tensor = function() {\n    var a, b, i, l1, m1, ndim, nelem, ref2, ref3;\n    i = 0;\n    ndim = 0;\n    nelem = 0;\n    //U **a, **b\n    save();\n    p2 = pop();\n    p1 = pop();\n    ndim = p2.tensor.ndim;\n    nelem = p2.tensor.nelem;\n    p3 = alloc_tensor(nelem);\n    p3.tensor.ndim = ndim;\n    for (i = l1 = 0, ref2 = ndim; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      p3.tensor.dim[i] = p2.tensor.dim[i];\n    }\n    a = p2.tensor.elem;\n    b = p3.tensor.elem;\n    for (i = m1 = 0, ref3 = nelem; (0 <= ref3 ? m1 < ref3 : m1 > ref3); i = 0 <= ref3 ? ++m1 : --m1) {\n      push(p1);\n      push(a[i]);\n      multiply();\n      b[i] = pop();\n    }\n    push(p3);\n    return restore();\n  };\n\n  check_tensor_dimensions = function(p) {\n    if (p.tensor.nelem !== p.tensor.elem.length) {\n      console.log(\"something wrong in tensor dimensions\");\n      debugger;\n    }\n  };\n\n  is_square_matrix = function(p) {\n    if (istensor(p) && p.tensor.ndim === 2 && p.tensor.dim[0] === p.tensor.dim[1]) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  gradient of tensor\n\n  //-----------------------------------------------------------------------------\n  d_tensor_tensor = function() {\n    var a, b, c, i, j, l1, m1, n1, ndim, nelem, ref2, ref3, ref4;\n    i = 0;\n    j = 0;\n    ndim = 0;\n    nelem = 0;\n    //U **a, **b, **c\n    ndim = p1.tensor.ndim;\n    nelem = p1.tensor.nelem;\n    if (ndim + 1 >= MAXDIM) {\n      push_symbol(DERIVATIVE);\n      push(p1);\n      push(p2);\n      list(3);\n      return;\n    }\n    p3 = alloc_tensor(nelem * p2.tensor.nelem);\n    p3.tensor.ndim = ndim + 1;\n    for (i = l1 = 0, ref2 = ndim; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      p3.tensor.dim[i] = p1.tensor.dim[i];\n    }\n    p3.tensor.dim[ndim] = p2.tensor.dim[0];\n    a = p1.tensor.elem;\n    b = p2.tensor.elem;\n    c = p3.tensor.elem;\n    for (i = m1 = 0, ref3 = nelem; (0 <= ref3 ? m1 < ref3 : m1 > ref3); i = 0 <= ref3 ? ++m1 : --m1) {\n      for (j = n1 = 0, ref4 = p2.tensor.nelem; (0 <= ref4 ? n1 < ref4 : n1 > ref4); j = 0 <= ref4 ? ++n1 : --n1) {\n        push(a[i]);\n        push(b[j]);\n        derivative();\n        c[i * p2.tensor.nelem + j] = pop();\n      }\n    }\n    return push(p3);\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  gradient of scalar\n\n  //-----------------------------------------------------------------------------\n  d_scalar_tensor = function() {\n    var a, b, i, l1, ref2;\n    //U **a, **b\n    p3 = alloc_tensor(p2.tensor.nelem);\n    p3.tensor.ndim = 1;\n    p3.tensor.dim[0] = p2.tensor.dim[0];\n    a = p2.tensor.elem;\n    b = p3.tensor.elem;\n    for (i = l1 = 0, ref2 = p2.tensor.nelem; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      push(p1);\n      push(a[i]);\n      derivative();\n      b[i] = pop();\n    }\n    return push(p3);\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Derivative of tensor\n\n  //-----------------------------------------------------------------------------\n  d_tensor_scalar = function() {\n    var a, b, i, l1, m1, ref2, ref3;\n    i = 0;\n    //U **a, **b\n    p3 = alloc_tensor(p1.tensor.nelem);\n    p3.tensor.ndim = p1.tensor.ndim;\n    for (i = l1 = 0, ref2 = p1.tensor.ndim; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      p3.tensor.dim[i] = p1.tensor.dim[i];\n    }\n    a = p1.tensor.elem;\n    b = p3.tensor.elem;\n    for (i = m1 = 0, ref3 = p1.tensor.nelem; (0 <= ref3 ? m1 < ref3 : m1 > ref3); i = 0 <= ref3 ? ++m1 : --m1) {\n      push(a[i]);\n      push(p2);\n      derivative();\n      b[i] = pop();\n    }\n    return push(p3);\n  };\n\n  compare_tensors = function(p1, p2) {\n    var i, l1, m1, ref2, ref3;\n    i = 0;\n    if (p1.tensor.ndim < p2.tensor.ndim) {\n      return -1;\n    }\n    if (p1.tensor.ndim > p2.tensor.ndim) {\n      return 1;\n    }\n    for (i = l1 = 0, ref2 = p1.tensor.ndim; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      if (p1.tensor.dim[i] < p2.tensor.dim[i]) {\n        return -1;\n      }\n      if (p1.tensor.dim[i] > p2.tensor.dim[i]) {\n        return 1;\n      }\n    }\n    for (i = m1 = 0, ref3 = p1.tensor.nelem; (0 <= ref3 ? m1 < ref3 : m1 > ref3); i = 0 <= ref3 ? ++m1 : --m1) {\n      if (equal(p1.tensor.elem[i], p2.tensor.elem[i])) {\n        continue;\n      }\n      if (lessp(p1.tensor.elem[i], p2.tensor.elem[i])) {\n        return -1;\n      } else {\n        return 1;\n      }\n    }\n    return 0;\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Raise a tensor to a power\n\n  //  Input:    p1  tensor\n\n  //      p2  exponent\n\n  //  Output:    Result on stack\n\n  //-----------------------------------------------------------------------------\n  power_tensor = function() {\n    var i, k, l1, m1, n, ref2, ref3, results;\n    i = 0;\n    k = 0;\n    n = 0;\n    // first and last dims must be equal\n    k = p1.tensor.ndim - 1;\n    if (p1.tensor.dim[0] !== p1.tensor.dim[k]) {\n      push_symbol(POWER);\n      push(p1);\n      push(p2);\n      list(3);\n      return;\n    }\n    push(p2);\n    n = pop_integer();\n    if (isNaN(n)) {\n      push_symbol(POWER);\n      push(p1);\n      push(p2);\n      list(3);\n      return;\n    }\n    if (n === 0) {\n      if (p1.tensor.ndim !== 2) {\n        stop(\"power(tensor,0) with tensor rank not equal to 2\");\n      }\n      n = p1.tensor.dim[0];\n      p1 = alloc_tensor(n * n);\n      p1.tensor.ndim = 2;\n      p1.tensor.dim[0] = n;\n      p1.tensor.dim[1] = n;\n      for (i = l1 = 0, ref2 = n; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n        p1.tensor.elem[n * i + i] = one;\n      }\n      check_tensor_dimensions(p1);\n      push(p1);\n      return;\n    }\n    if (n < 0) {\n      n = -n;\n      push(p1);\n      inv();\n      p1 = pop();\n    }\n    push(p1);\n    results = [];\n    for (i = m1 = 1, ref3 = n; (1 <= ref3 ? m1 < ref3 : m1 > ref3); i = 1 <= ref3 ? ++m1 : --m1) {\n      push(p1);\n      inner();\n      if (isZeroAtomOrTensor(stack[tos - 1])) {\n        break;\n      } else {\n        results.push(void 0);\n      }\n    }\n    return results;\n  };\n\n  copy_tensor = function() {\n    var i, l1, m1, ref2, ref3;\n    i = 0;\n    save();\n    p1 = pop();\n    p2 = alloc_tensor(p1.tensor.nelem);\n    p2.tensor.ndim = p1.tensor.ndim;\n    for (i = l1 = 0, ref2 = p1.tensor.ndim; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      p2.tensor.dim[i] = p1.tensor.dim[i];\n    }\n    for (i = m1 = 0, ref3 = p1.tensor.nelem; (0 <= ref3 ? m1 < ref3 : m1 > ref3); i = 0 <= ref3 ? ++m1 : --m1) {\n      p2.tensor.elem[i] = p1.tensor.elem[i];\n    }\n    check_tensor_dimensions(p1);\n    check_tensor_dimensions(p2);\n    push(p2);\n    return restore();\n  };\n\n  // Tensors with elements that are also tensors get promoted to a higher rank.\n  promote_tensor = function() {\n    var i, j, k, l1, m1, n1, ndim, nelem, o1, q1, ref2, ref3, ref4, ref5, ref6;\n    i = 0;\n    j = 0;\n    k = 0;\n    nelem = 0;\n    ndim = 0;\n    save();\n    p1 = pop();\n    if (!istensor(p1)) {\n      push(p1);\n      restore();\n      return;\n    }\n    p2 = p1.tensor.elem[0];\n    for (i = l1 = 1, ref2 = p1.tensor.nelem; (1 <= ref2 ? l1 < ref2 : l1 > ref2); i = 1 <= ref2 ? ++l1 : --l1) {\n      if (!compatible(p2, p1.tensor.elem[i])) {\n        stop(\"Cannot promote tensor due to inconsistent tensor components.\");\n      }\n    }\n    if (!istensor(p2)) {\n      push(p1);\n      restore();\n      return;\n    }\n    ndim = p1.tensor.ndim + p2.tensor.ndim;\n    if (ndim > MAXDIM) {\n      stop(\"tensor rank > \" + MAXDIM);\n    }\n    nelem = p1.tensor.nelem * p2.tensor.nelem;\n    p3 = alloc_tensor(nelem);\n    p3.tensor.ndim = ndim;\n    for (i = m1 = 0, ref3 = p1.tensor.ndim; (0 <= ref3 ? m1 < ref3 : m1 > ref3); i = 0 <= ref3 ? ++m1 : --m1) {\n      p3.tensor.dim[i] = p1.tensor.dim[i];\n    }\n    for (j = n1 = 0, ref4 = p2.tensor.ndim; (0 <= ref4 ? n1 < ref4 : n1 > ref4); j = 0 <= ref4 ? ++n1 : --n1) {\n      p3.tensor.dim[i + j] = p2.tensor.dim[j];\n    }\n    k = 0;\n    for (i = o1 = 0, ref5 = p1.tensor.nelem; (0 <= ref5 ? o1 < ref5 : o1 > ref5); i = 0 <= ref5 ? ++o1 : --o1) {\n      p2 = p1.tensor.elem[i];\n      for (j = q1 = 0, ref6 = p2.tensor.nelem; (0 <= ref6 ? q1 < ref6 : q1 > ref6); j = 0 <= ref6 ? ++q1 : --q1) {\n        p3.tensor.elem[k++] = p2.tensor.elem[j];\n      }\n    }\n    check_tensor_dimensions(p2);\n    check_tensor_dimensions(p3);\n    push(p3);\n    return restore();\n  };\n\n  compatible = function(p, q) {\n    var i, l1, ref2;\n    if (!istensor(p) && !istensor(q)) {\n      return 1;\n    }\n    if (!istensor(p) || !istensor(q)) {\n      return 0;\n    }\n    if (p.tensor.ndim !== q.tensor.ndim) {\n      return 0;\n    }\n    for (i = l1 = 0, ref2 = p.tensor.ndim; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      if (p.tensor.dim[i] !== q.tensor.dim[i]) {\n        return 0;\n      }\n    }\n    return 1;\n  };\n\n  // If the number of args is odd then the last arg is the default result.\n  // Works like a switch statement. Could also be used for piecewise\n  // functions? TODO should probably be called \"switch\"?\n  Eval_test = function() {\n    var checkResult, orig;\n    orig = p1;\n    p1 = cdr(p1);\n    while (iscons(p1)) {\n      // odd number of parameters means that the\n      // last argument becomes the default case\n      // i.e. the one without a test.\n      if (cdr(p1) === symbol(NIL)) {\n        push(car(p1));\n        Eval();\n        return;\n      }\n      checkResult = isZeroLikeOrNonZeroLikeOrUndetermined(car(p1));\n      if (checkResult == null) {\n        // we couldn't determine the result\n        // of a test. This means we can't conclude\n        // anything about the result of the\n        // overall test, so we must bail\n        // with the unevalled test\n        push(orig);\n        return;\n      } else if (checkResult) {\n        // test succesful, we found out output\n        push(cadr(p1));\n        Eval();\n        return;\n      } else {\n        // test unsuccessful, continue to the\n        // next pair of test,value\n        p1 = cddr(p1);\n      }\n    }\n    // no test matched and there was no\n    // catch-all case, so we return zero.\n    return push_integer(0);\n  };\n\n  // we test A==B by first subtracting and checking if we symbolically\n  // get zero. If not, we evaluate to float and check if we get a zero.\n  // If we get another NUMBER then we know they are different.\n  // If we get something else, then we don't know and we return the\n  // unaveluated test, which is the same as saying \"maybe\".\n  Eval_testeq = function() {\n    var checkResult, orig, subtractionResult;\n    // first try without simplifyng both sides\n    orig = p1;\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    subtract();\n    subtractionResult = pop();\n    // OK so we are doing something tricky here\n    // we are using isZeroLikeOrNonZeroLikeOrUndetermined to check if the result\n    // is zero or not zero or unknown.\n    // isZeroLikeOrNonZeroLikeOrUndetermined has some routines\n    // to determine the zero-ness/non-zero-ness or\n    // undeterminate-ness of things so we use\n    // that here and down below.\n    checkResult = isZeroLikeOrNonZeroLikeOrUndetermined(subtractionResult);\n    if (checkResult) {\n      push_integer(0);\n      return;\n    } else if ((checkResult != null) && !checkResult) {\n      push_integer(1);\n      return;\n    }\n    // we didn't get a simple numeric result but\n    // let's try again after doing\n    // a simplification on both sides\n    push(cadr(p1));\n    Eval();\n    simplify();\n    push(caddr(p1));\n    Eval();\n    simplify();\n    subtract();\n    subtractionResult = pop();\n    checkResult = isZeroLikeOrNonZeroLikeOrUndetermined(subtractionResult);\n    if (checkResult) {\n      push_integer(0);\n      return;\n    } else if ((checkResult != null) && !checkResult) {\n      push_integer(1);\n      return;\n    }\n    // if we didn't get to a number then we\n    // don't know whether the quantities are\n    // different so do nothing\n    return push(orig);\n  };\n\n  // Relational operators expect a numeric result for operand difference.\n  Eval_testge = function() {\n    var comparison, orig;\n    orig = p1;\n    comparison = cmp_args();\n    if (comparison == null) {\n      push(orig);\n      return;\n    }\n    if (comparison >= 0) {\n      return push_integer(1);\n    } else {\n      return push_integer(0);\n    }\n  };\n\n  Eval_testgt = function() {\n    var comparison, orig;\n    orig = p1;\n    comparison = cmp_args();\n    if (comparison == null) {\n      push(orig);\n      return;\n    }\n    if (comparison > 0) {\n      return push_integer(1);\n    } else {\n      return push_integer(0);\n    }\n  };\n\n  Eval_testle = function() {\n    var comparison, orig;\n    orig = p1;\n    comparison = cmp_args();\n    if (comparison == null) {\n      push(orig);\n      return;\n    }\n    if (comparison <= 0) {\n      return push_integer(1);\n    } else {\n      return push_integer(0);\n    }\n  };\n\n  Eval_testlt = function() {\n    var comparison, orig;\n    orig = p1;\n    comparison = cmp_args();\n    if (comparison == null) {\n      push(orig);\n      return;\n    }\n    if (comparison < 0) {\n      return push_integer(1);\n    } else {\n      return push_integer(0);\n    }\n  };\n\n  // not definition\n  Eval_not = function() {\n    var checkResult, wholeAndExpression;\n    wholeAndExpression = p1;\n    checkResult = isZeroLikeOrNonZeroLikeOrUndetermined(cadr(p1));\n    if (checkResult == null) {\n      // inconclusive test on predicate\n      return push(wholeAndExpression);\n    } else if (checkResult) {\n      // true -> false\n      return push_integer(0);\n    } else {\n      // false -> true\n      return push_integer(1);\n    }\n  };\n\n  /* and =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  a,b,...\n\n  General description\n  -------------------\n  Logical-and of predicate expressions.\n\n  */\n  // and definition\n  Eval_and = function() {\n    var andPredicates, checkResult, somePredicateUnknown, wholeAndExpression;\n    wholeAndExpression = p1;\n    andPredicates = cdr(wholeAndExpression);\n    somePredicateUnknown = false;\n    while (iscons(andPredicates)) {\n      // eval each predicate\n      checkResult = isZeroLikeOrNonZeroLikeOrUndetermined(car(andPredicates));\n      if (checkResult == null) {\n        // here we have stuff that is not reconducible to any\n        // numeric value (or tensor with numeric values) e.g.\n        // 'a+b', so it just means that we just don't know the\n        // truth value of this particular predicate.\n        // We'll track the fact that we found an unknown\n        // predicate and we continue with the other predicates.\n        // (note that in case some subsequent predicate will be false,\n        // it won't matter that we found some unknowns and\n        // the whole test will be immediately zero).\n        somePredicateUnknown = true;\n        andPredicates = cdr(andPredicates);\n      } else if (checkResult) {\n        // found a true, move on to the next predicate\n        andPredicates = cdr(andPredicates);\n      } else if (!checkResult) {\n        // found a false, enough to falsify everything and return\n        push_integer(0);\n        return;\n      }\n    }\n    // We checked all the predicates and none of them\n    // was false. So they were all either true or unknown.\n    // Now, if even just one was unknown, we'll have to call this\n    // test as inconclusive and return the whole test expression.\n    // If all the predicates were known, then we can conclude\n    // that the test returns true.\n    if (somePredicateUnknown) {\n      return push(wholeAndExpression);\n    } else {\n      return push_integer(1);\n    }\n  };\n\n  // or definition\n  Eval_or = function() {\n    var checkResult, orPredicates, somePredicateUnknown, wholeOrExpression;\n    wholeOrExpression = p1;\n    orPredicates = cdr(wholeOrExpression);\n    somePredicateUnknown = false;\n    while (iscons(orPredicates)) {\n      // eval each predicate\n      checkResult = isZeroLikeOrNonZeroLikeOrUndetermined(car(orPredicates));\n      if (checkResult == null) {\n        // here we have stuff that is not reconducible to any\n        // numeric value (or tensor with numeric values) e.g.\n        // 'a+b', so it just means that we just don't know the\n        // truth value of this particular predicate.\n        // We'll track the fact that we found an unknown\n        // predicate and we continue with the other predicates.\n        // (note that in case some subsequent predicate will be false,\n        // it won't matter that we found some unknowns and\n        // the whole test will be immediately zero).\n        somePredicateUnknown = true;\n        orPredicates = cdr(orPredicates);\n      } else if (checkResult) {\n        // found a true, enough to return true\n        push_integer(1);\n        return;\n      } else if (!checkResult) {\n        // found a false, move on to the next predicate\n        orPredicates = cdr(orPredicates);\n      }\n    }\n    // We checked all the predicates and none of them\n    // was true. So they were all either false or unknown.\n    // Now, if even just one was unknown, we'll have to call this\n    // test as inconclusive and return the whole test expression.\n    // If all the predicates were known, then we can conclude\n    // that the test returns false.\n    if (somePredicateUnknown) {\n      return push(wholeOrExpression);\n    } else {\n      return push_integer(0);\n    }\n  };\n\n  // use subtract for cases like A < A + 1\n\n  // TODO you could be smarter here and\n  // simplify both sides only in the case\n  // of \"relational operator: cannot determine...\"\n  // a bit like we do in Eval_testeq\n  cmp_args = function() {\n    var t;\n    t = 0;\n    push(cadr(p1));\n    Eval();\n    simplify();\n    push(caddr(p1));\n    Eval();\n    simplify();\n    subtract();\n    p1 = pop();\n    // try floating point if necessary\n    if (p1.k !== NUM && p1.k !== DOUBLE) {\n      push(p1);\n      yyfloat();\n      Eval();\n      p1 = pop();\n    }\n    //console.log \"comparison: \" + p1.toString()\n    if (isZeroAtomOrTensor(p1)) {\n      //console.log \"comparison isZero \"\n      return 0;\n    }\n    switch (p1.k) {\n      case NUM:\n        if (MSIGN(p1.q.a) === -1) {\n          t = -1;\n        } else {\n          t = 1;\n        }\n        break;\n      case DOUBLE:\n        //console.log \"comparison p1.d: \" + p1.d\n        if (p1.d < 0.0) {\n          t = -1;\n        } else {\n          t = 1;\n        }\n        break;\n      default:\n        //console.log \"comparison is null\"\n        t = null;\n    }\n    return t;\n  };\n\n  /*\n  Transform an expression using a pattern. The\n  pattern can come from the integrals table or\n  the user-defined patterns.\n\n  The expression and free variable are on the stack.\n\n  The argument s is a null terminated list of transform rules.\n\n  For example, see the itab (integrals table)\n\n  Internally, the following symbols are used:\n\n    F  input expression\n\n    X  free variable, i.e. F of X\n\n    A  template expression\n\n    B  result expression\n\n    C  list of conditional expressions\n\n  Puts the final expression on top of stack\n  (whether it's transformed or not) and returns\n  true is successful, false if not.\n\n  */\n  // p1 and p2 are tmps\n\n  //define F p3\n  //define X p4\n  //define A p5\n  //define B p6\n  //define C p7\n  transform = function(s, generalTransform) {\n    var bookmarkTosToPrintDecomps, eachTransformEntry, i, l1, len, len1, m1, n1, numberOfDecomps, ref2, restTerm, secondTerm, success, theTransform, transform_h, transformationSuccessful, transformedTerms;\n    transform_h = 0;\n    save();\n    p1 = null;\n    p4 = pop(); // X i.e. free variable\n    p3 = pop(); // F i.e. input expression\n    if (DEBUG) {\n      console.log(\"         !!!!!!!!!   transform on: \" + p3);\n    }\n    saveMetaBindings();\n    set_binding(symbol(METAX), p4);\n    // put constants in F(X) on the stack\n    transform_h = tos;\n    push_integer(1);\n    push(p3);\n    push(p4);\n    polyform();\n    push(p4);\n    bookmarkTosToPrintDecomps = tos - 2;\n    decomp(generalTransform);\n    numberOfDecomps = tos - bookmarkTosToPrintDecomps;\n    if (DEBUG) {\n      console.log(\"  \" + numberOfDecomps + \" decomposed elements ====== \");\n      for (i = l1 = 0, ref2 = numberOfDecomps; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n        console.log(\"  decomposition element \" + i + \": \" + stack[tos - 1 - i]);\n      }\n    }\n    transformationSuccessful = false;\n    if (generalTransform) {\n      if (!isNumericAtom(p3)) {\n        theTransform = s;\n        if (DEBUG) {\n          console.log(\"applying transform: \" + theTransform);\n        }\n        if (DEBUG) {\n          console.log(\"scanning table entry \" + theTransform);\n        }\n        push(theTransform);\n        // replacements of meta variables. Note that we don't\n        // use scan_meta because the pattern is not a string\n        // that we have to parse, it's a tree already.\n        // replace a_ with METAA in the passed transformation\n        push(symbol(SYMBOL_A_UNDERSCORE));\n        push(symbol(METAA));\n        subst();\n        // replace b_ with METAB in the passed transformation\n        push(symbol(SYMBOL_B_UNDERSCORE));\n        push(symbol(METAB));\n        subst();\n        // replace x_ with METAX in the passed transformation\n        push(symbol(SYMBOL_X_UNDERSCORE));\n        push(symbol(METAX));\n        subst();\n        p1 = pop();\n        p5 = car(p1);\n        if (DEBUG) {\n          console.log(\"template expression: \" + p5);\n        }\n        p6 = cadr(p1);\n        p7 = cddr(p1);\n        /*\n        p5 = p1.tensor.elem[0]\n        p6 = p1.tensor.elem[1]\n        for i in [2..(p1.tensor.elem.length-1)]\n          push p1.tensor.elem[i]\n        list(p1.tensor.elem.length - 2)\n        p7 = pop()\n        */\n        if (f_equals_a(transform_h, generalTransform)) {\n          // successful transformation,\n          // transformed result is in p6\n          transformationSuccessful = true;\n        } else {\n          // the match failed but perhaps we can match\n          // something lower down in the tree, so\n          // let's recurse the tree\n          if (DEBUG) {\n            console.log(\"p3 at this point: \" + p3);\n          }\n          transformedTerms = [];\n          if (DEBUG) {\n            console.log(\"car(p3): \" + car(p3));\n          }\n          restTerm = p3;\n          if (iscons(restTerm)) {\n            transformedTerms.push(car(p3));\n            restTerm = cdr(p3);\n          }\n          while (iscons(restTerm)) {\n            secondTerm = car(restTerm);\n            restTerm = cdr(restTerm);\n            if (DEBUG) {\n              console.log(\"tos before recursive transform: \" + tos);\n            }\n            push(secondTerm);\n            push_symbol(NIL);\n            if (DEBUG) {\n              console.log(\"testing: \" + secondTerm);\n            }\n            //if (secondTerm+\"\") == \"eig(A x,transpose(A x))()\"\n            //  debugger\n            if (DEBUG) {\n              console.log(\"about to try to simplify other term: \" + secondTerm);\n            }\n            success = transform(s, generalTransform);\n            transformationSuccessful = transformationSuccessful || success;\n            transformedTerms.push(pop());\n            if (DEBUG) {\n              console.log(\"tried to simplify other term: \" + secondTerm + \" ...successful?: \" + success + \" ...transformed: \" + transformedTerms[transformedTerms.length - 1]);\n            }\n          }\n          // recreate the tree we were passed,\n          // but with all the terms being transformed\n          if (transformedTerms.length !== 0) {\n            for (m1 = 0, len = transformedTerms.length; m1 < len; m1++) {\n              i = transformedTerms[m1];\n              push(i);\n            }\n            list(transformedTerms.length);\n            p6 = pop(); // \"integrals\" mode\n          }\n        }\n      }\n    } else {\n      for (n1 = 0, len1 = s.length; n1 < len1; n1++) {\n        eachTransformEntry = s[n1];\n        if (DEBUG) {\n          console.log(\"scanning table entry \" + eachTransformEntry);\n          if ((eachTransformEntry + \"\").indexOf(\"f(sqrt(a+b*x),2/3*1/b*sqrt((a+b*x)^3))\") !== -1) {\n            debugger;\n          }\n        }\n        if (eachTransformEntry) {\n          scan_meta(eachTransformEntry);\n          p1 = pop();\n          p5 = cadr(p1);\n          p6 = caddr(p1);\n          p7 = cdddr(p1);\n          /*\n          p5 = p1.tensor.elem[0]\n          p6 = p1.tensor.elem[1]\n          for i in [2..(p1.tensor.elem.length-1)]\n            push p1.tensor.elem[i]\n          list(p1.tensor.elem.length - 2)\n          p7 = pop()\n          */\n          if (f_equals_a(transform_h, generalTransform)) {\n            // there is a successful transformation,\n            // transformed result is in p6\n            transformationSuccessful = true;\n            break;\n          }\n        }\n      }\n    }\n    moveTos(transform_h);\n    if (transformationSuccessful) {\n      //console.log \"transformation successful\"\n      // a transformation was successful\n      push(p6);\n      Eval();\n      p1 = pop();\n      //console.log \"...into: \" + p1\n      transformationSuccessful = true;\n    } else {\n      // transformations failed\n      if (generalTransform) {\n        // result = original expression\n        p1 = p3;\n      } else {\n        p1 = symbol(NIL);\n      }\n    }\n    restoreMetaBindings();\n    push(p1);\n    restore();\n    return transformationSuccessful;\n  };\n\n  saveMetaBindings = function() {\n    push(get_binding(symbol(METAA)));\n    push(get_binding(symbol(METAB)));\n    return push(get_binding(symbol(METAX)));\n  };\n\n  restoreMetaBindings = function() {\n    set_binding(symbol(METAX), pop());\n    set_binding(symbol(METAB), pop());\n    return set_binding(symbol(METAA), pop());\n  };\n\n  // search for a METAA and METAB such that F = A\n  f_equals_a = function(h, generalTransform) {\n    var fea_i, fea_j, l1, m1, originalexpanding, ref2, ref3, ref4, ref5;\n    fea_i = 0;\n    fea_j = 0;\n    for (fea_i = l1 = ref2 = h, ref3 = tos; (ref2 <= ref3 ? l1 < ref3 : l1 > ref3); fea_i = ref2 <= ref3 ? ++l1 : --l1) {\n      set_binding(symbol(METAA), stack[fea_i]);\n      if (DEBUG) {\n        console.log(\"  binding METAA to \" + get_binding(symbol(METAA)));\n      }\n      for (fea_j = m1 = ref4 = h, ref5 = tos; (ref4 <= ref5 ? m1 < ref5 : m1 > ref5); fea_j = ref4 <= ref5 ? ++m1 : --m1) {\n        set_binding(symbol(METAB), stack[fea_j]);\n        if (DEBUG) {\n          console.log(\"  binding METAB to \" + get_binding(symbol(METAB)));\n        }\n        // now test all the conditions (it's an and between them)\n        p1 = p7;\n        while (iscons(p1)) {\n          push(car(p1));\n          Eval();\n          p2 = pop();\n          if (isZeroAtomOrTensor(p2)) {\n            break;\n          }\n          p1 = cdr(p1);\n        }\n        if (iscons(p1)) {\n          // conditions are not met,\n          // skip to the next binding of metas\n          continue;\n        }\n        push(p3);\n        if (DEBUG) {\n          console.log(\"about to evaluate template expression: \" + p5 + \" binding METAA to \" + get_binding(symbol(METAA)) + \" and binding METAB to \" + get_binding(symbol(METAB)) + \" and binding METAX to \" + get_binding(symbol(METAX)));\n        }\n        push(p5);\n        if (generalTransform) {\n          originalexpanding = expanding;\n          expanding = false;\n        }\n        Eval();\n        if (generalTransform) {\n          expanding = originalexpanding;\n        }\n        if (DEBUG) {\n          console.log(\"  comparing \" + stack[tos - 1] + \" to: \" + stack[tos - 2]);\n        }\n        subtract();\n        p1 = pop();\n        if (isZeroAtomOrTensor(p1)) {\n          if (DEBUG) {\n            console.log(\"binding METAA to \" + get_binding(symbol(METAA)));\n            console.log(\"binding METAB to \" + get_binding(symbol(METAB)));\n            console.log(\"binding METAX to \" + get_binding(symbol(METAX)));\n            console.log(\"comparing \" + p3 + \" to: \" + p5);\n          }\n          return 1; // yes\n        }\n      }\n    }\n    return 0; // no\n  };\n\n  // Transpose tensor indices\n  Eval_transpose = function() {\n    push(cadr(p1));\n    Eval();\n    // add default params if they\n    // have not been passed\n    if (cddr(p1) === symbol(NIL)) {\n      push_integer(1);\n      push_integer(2);\n    } else {\n      push(caddr(p1));\n      Eval();\n      push(cadddr(p1));\n      Eval();\n    }\n    return transpose();\n  };\n\n  transpose = function() {\n    var a, accumulator, ai, an, b, eachEntry, i, innerTranspSwitch1, innerTranspSwitch2, j, k, l, l1, m, m1, n1, ndim, nelem, o1, q1, r1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, s1, t;\n    i = 0;\n    j = 0;\n    k = 0;\n    l = 0;\n    m = 0;\n    ndim = 0;\n    nelem = 0;\n    t = 0;\n    ai = [];\n    an = [];\n    for (i = l1 = 0, ref2 = MAXDIM; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      ai[i] = 0;\n      an[i] = 0;\n    }\n    //U **a, **b\n    save();\n    // by default p3 is 2 and p2 is 1\n    p3 = pop(); // index to be transposed\n    p2 = pop(); // other index to be transposed\n    p1 = pop(); // what needs to be transposed\n    \n    // a transposition just goes away when\n    // applied to a scalar\n    if (isNumericAtom(p1)) {\n      push(p1);\n      restore();\n      return;\n    }\n    // transposition goes away for identity matrix\n    if ((isplusone(p2) && isplustwo(p3)) || (isplusone(p3) && isplustwo(p2))) {\n      if (isidentitymatrix(p1)) {\n        push(p1);\n        restore();\n        return;\n      }\n    }\n    // a transposition just goes away when\n    // applied to another transposition with\n    // the same columns to be switched\n    if (istranspose(p1)) {\n      innerTranspSwitch1 = car(cdr(cdr(p1)));\n      innerTranspSwitch2 = car(cdr(cdr(cdr(p1))));\n      if ((equal(innerTranspSwitch1, p3) && equal(innerTranspSwitch2, p2)) || (equal(innerTranspSwitch2, p3) && equal(innerTranspSwitch1, p2)) || ((equal(innerTranspSwitch1, symbol(NIL)) && equal(innerTranspSwitch2, symbol(NIL))) && ((isplusone(p3) && isplustwo(p2)) || (isplusone(p2) && isplustwo(p3))))) {\n        push(car(cdr(p1)));\n        restore();\n        return;\n      }\n    }\n    // if operand is a sum then distribute\n    // (if we are in expanding mode)\n    if (expanding && isadd(p1)) {\n      p1 = cdr(p1);\n      push(zero);\n      while (iscons(p1)) {\n        push(car(p1));\n        // add the dimensions to switch but only if\n        // they are not the default ones.\n        push(p2);\n        push(p3);\n        transpose();\n        add();\n        p1 = cdr(p1);\n      }\n      restore();\n      return;\n    }\n    // if operand is a multiplication then distribute\n    // (if we are in expanding mode)\n    if (expanding && ismultiply(p1)) {\n      p1 = cdr(p1);\n      push(one);\n      while (iscons(p1)) {\n        push(car(p1));\n        // add the dimensions to switch but only if\n        // they are not the default ones.\n        push(p2);\n        push(p3);\n        transpose();\n        multiply();\n        p1 = cdr(p1);\n      }\n      restore();\n      return;\n    }\n    // distribute the transpose of a dot\n    // if in expanding mode\n    // note that the distribution happens\n    // in reverse as per tranpose rules.\n    // The dot operator is not\n    // commutative, so, it matters.\n    if (expanding && isinnerordot(p1)) {\n      p1 = cdr(p1);\n      accumulator = [];\n      while (iscons(p1)) {\n        accumulator.push([car(p1), p2, p3]);\n        p1 = cdr(p1);\n      }\n      for (eachEntry = m1 = ref3 = accumulator.length - 1; (ref3 <= 0 ? m1 <= 0 : m1 >= 0); eachEntry = ref3 <= 0 ? ++m1 : --m1) {\n        push(accumulator[eachEntry][0]);\n        push(accumulator[eachEntry][1]);\n        push(accumulator[eachEntry][2]);\n        transpose();\n        if (eachEntry !== accumulator.length - 1) {\n          inner();\n        }\n      }\n      restore();\n      return;\n    }\n    if (!istensor(p1)) {\n      if (!isZeroAtomOrTensor(p1)) {\n        //stop(\"transpose: tensor expected, 1st arg is not a tensor\")\n        push_symbol(TRANSPOSE);\n        push(p1);\n        if ((!isplusone(p2) || !isplustwo(p3)) && (!isplusone(p3) || !isplustwo(p2))) {\n          push(p2);\n          push(p3);\n          list(4);\n        } else {\n          list(2);\n        }\n        restore();\n        return;\n      }\n      push(zero);\n      restore();\n      return;\n    }\n    ndim = p1.tensor.ndim;\n    nelem = p1.tensor.nelem;\n    // is it a vector?\n    // so here it's something curious - note how vectors are\n    // not really special two-dimensional matrices, but rather\n    // 1-dimension objects (like tensors can be). So since\n    // they have one dimension, transposition has no effect.\n    // (as opposed as if they were special two-dimensional\n    // matrices)\n    // see also Ran Pan, Tensor Transpose and Its Properties. CoRR abs/1411.1503 (2014)\n    if (ndim === 1) {\n      push(p1);\n      restore();\n      return;\n    }\n    push(p2);\n    l = pop_integer();\n    push(p3);\n    m = pop_integer();\n    if (l < 1 || l > ndim || m < 1 || m > ndim) {\n      stop(\"transpose: index out of range\");\n    }\n    l--;\n    m--;\n    p2 = alloc_tensor(nelem);\n    p2.tensor.ndim = ndim;\n    for (i = n1 = 0, ref4 = ndim; (0 <= ref4 ? n1 < ref4 : n1 > ref4); i = 0 <= ref4 ? ++n1 : --n1) {\n      p2.tensor.dim[i] = p1.tensor.dim[i];\n    }\n    p2.tensor.dim[l] = p1.tensor.dim[m];\n    p2.tensor.dim[m] = p1.tensor.dim[l];\n    a = p1.tensor.elem;\n    b = p2.tensor.elem;\n// init tensor index\n    for (i = o1 = 0, ref5 = ndim; (0 <= ref5 ? o1 < ref5 : o1 > ref5); i = 0 <= ref5 ? ++o1 : --o1) {\n      ai[i] = 0;\n      an[i] = p1.tensor.dim[i];\n    }\n// copy components from a to b\n    for (i = q1 = 0, ref6 = nelem; (0 <= ref6 ? q1 < ref6 : q1 > ref6); i = 0 <= ref6 ? ++q1 : --q1) {\n      // swap indices l and m\n      t = ai[l];\n      ai[l] = ai[m];\n      ai[m] = t;\n      t = an[l];\n      an[l] = an[m];\n      an[m] = t;\n      k = 0;\n      for (j = r1 = 0, ref7 = ndim; (0 <= ref7 ? r1 < ref7 : r1 > ref7); j = 0 <= ref7 ? ++r1 : --r1) {\n        k = (k * an[j]) + ai[j];\n      }\n      // swap indices back\n      t = ai[l];\n      ai[l] = ai[m];\n      ai[m] = t;\n      t = an[l];\n      an[l] = an[m];\n      an[m] = t;\n      b[k] = a[i];\n// increment tensor index\n\n      // Suppose the tensor dimensions are 2 and 3.\n// Then the tensor index ai increments as follows:\n// 00 -> 01\n// 01 -> 02\n// 02 -> 10\n// 10 -> 11\n// 11 -> 12\n// 12 -> 00\n      for (j = s1 = ref8 = ndim - 1; (ref8 <= 0 ? s1 <= 0 : s1 >= 0); j = ref8 <= 0 ? ++s1 : --s1) {\n        if (++ai[j] < an[j]) {\n          break;\n        }\n        ai[j] = 0;\n      }\n    }\n    push(p2);\n    return restore();\n  };\n\n  // Evaluate a user defined function\n\n  //define F p3 # F is the function body\n  //define A p4 # A is the formal argument list\n  //define B p5 # B is the calling argument list\n  //define S p6 # S is the argument substitution list\n\n  // we got here because there was a function invocation and\n  // it's not been parsed (and consequently tagged) as any\n  // system function.\n  // So we are dealing with another function.\n  // The function could be actually defined, or not yet,\n  // so we'll deal with both cases.\n  /* d =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  f,x\n\n  General description\n  -------------------\n  Returns the partial derivative of f with respect to x. x can be a vector e.g. [x,y].\n\n  */\n  Eval_user_function = function() {\n    var bodyAndFormalArguments, h;\n    // Use \"derivative\" instead of \"d\" if there is no user function \"d\"\n    if (DEBUG) {\n      console.log(\"Eval_user_function evaluating: \" + car(p1));\n    }\n    if (car(p1) === symbol(SYMBOL_D) && get_binding(symbol(SYMBOL_D)) === symbol(SYMBOL_D)) {\n      Eval_derivative();\n      return;\n    }\n    // normally car(p1) is a symbol with the function name\n    // but it could be something that has to be\n    // evaluated to get to the function definition instead\n    // (e.g. the function is an element of an array)\n    // so we do an eval to sort it all out. \n    push(car(p1));\n    Eval();\n    // we expect to find either the body and\n    // formula arguments, OR, if the function\n    // has not been defined yet, then the\n    // function will just contain its own name, as\n    // all undefined variables do.\n    bodyAndFormalArguments = pop();\n    if (isNumericAtom(bodyAndFormalArguments)) {\n      stop(\"expected function invocation, found multiplication instead. Use '*' symbol explicitly for multiplication.\");\n    } else if (istensor(bodyAndFormalArguments)) {\n      stop(\"expected function invocation, found tensor product instead. Use 'dot/inner' explicitly.\");\n    } else if (isstr(bodyAndFormalArguments)) {\n      stop(\"expected function, found string instead.\");\n    }\n    p3 = car(cdr(bodyAndFormalArguments)); // p3 is function body F\n    // p4 is the formal argument list\n    // that is also contained here in the FUNCTION node \n    p4 = car(cdr(cdr(bodyAndFormalArguments)));\n    p5 = cdr(p1);\n    // next check is whether evaluation did nothing, so the function is undefined\n    if ((car(bodyAndFormalArguments) !== symbol(FUNCTION)) || (bodyAndFormalArguments === car(p1))) { // p3 is F\n      // leave everything as it was and return\n      h = tos;\n      push(bodyAndFormalArguments);\n      p1 = p5;\n      while (iscons(p1)) {\n        push(car(p1));\n        Eval();\n        p1 = cdr(p1);\n      }\n      list(tos - h);\n      return;\n    }\n    // Create the argument substitution list p6(S)\n    p1 = p4;\n    p2 = p5;\n    h = tos;\n    while (iscons(p1) && iscons(p2)) {\n      push(car(p1));\n      push(car(p2));\n      // why explicitly Eval the parameters when\n      // the body of the function is\n      // evalled anyways? Commenting it out. All tests pass...\n      //Eval()\n      p1 = cdr(p1);\n      p2 = cdr(p2);\n    }\n    list(tos - h);\n    p6 = pop();\n    push(p3);\n    if (iscons(p6)) { // p6 is S\n      push(p6);\n      rewrite_args();\n    }\n    //console.log \"rewritten body: \" + stack[tos-1]\n    return Eval();\n  };\n\n  // Rewrite by expanding symbols that contain args\n  rewrite_args = function() {\n    var h, n;\n    n = 0;\n    save();\n    // subst. list which is a list\n    // where each consecutive pair\n    // is what needs to be substituted and with what\n    p2 = pop();\n    p1 = pop();\n    if (istensor(p1)) {\n      n = rewrite_args_tensor();\n      restore();\n      return n;\n    }\n    if (iscons(p1)) {\n      h = tos;\n      if (car(p1) === car(p2)) {\n        // rewrite a function in\n        // the body with the one\n        // passed from the paramaters\n        push_symbol(EVAL);\n        push(car(cdr(p2)));\n        list(2);\n      } else {\n        // if there is no match\n        // then no substitution necessary\n        push(car(p1));\n      }\n      // continue recursively to\n      // rewrite the rest of the body\n      p1 = cdr(p1);\n      while (iscons(p1)) {\n        push(car(p1));\n        push(p2);\n        n += rewrite_args();\n        p1 = cdr(p1);\n      }\n      list(tos - h);\n      restore();\n      return n;\n    }\n    if (!issymbol(p1)) {\n      push(p1);\n      restore();\n      return 0;\n    }\n    // Here we are in a symbol case\n    // so we need to substitute\n\n    // Check if there is a direct match\n    // of symbols right away\n    p3 = p2;\n    while (iscons(p3)) {\n      if (p1 === car(p3)) {\n        push(cadr(p3));\n        restore();\n        return 1;\n      }\n      p3 = cddr(p3);\n    }\n    // Get the symbol's content, if _that_\n    // matches then do the substitution\n    p3 = get_binding(p1);\n    push(p3);\n    if (p1 !== p3) {\n      push(p2);\n      n = rewrite_args();\n      if (n === 0) {\n        pop();\n        push(p1); // restore if not rewritten with arg\n      }\n    }\n    restore();\n    return n;\n  };\n\n  rewrite_args_tensor = function() {\n    var i, l1, n, ref2;\n    n = 0;\n    i = 0;\n    push(p1);\n    copy_tensor();\n    p1 = pop();\n    for (i = l1 = 0, ref2 = p1.tensor.nelem; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      push(p1.tensor.elem[i]);\n      push(p2);\n      n += rewrite_args();\n      p1.tensor.elem[i] = pop();\n    }\n    check_tensor_dimensions(p1);\n    push(p1);\n    return n;\n  };\n\n  Eval_zero = function() {\n    var i, k, l1, m, m1, n, ref2, ref3;\n    i = 0;\n    k = [];\n    m = 0;\n    n = 0;\n    for (i = l1 = 0, ref2 = MAXDIM; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      k[i] = 0;\n    }\n    m = 1;\n    n = 0;\n    p2 = cdr(p1);\n    while (iscons(p2)) {\n      push(car(p2));\n      Eval();\n      i = pop_integer();\n      if (i < 1 || isNaN(i)) {\n        // if the input is nonsensical\n        // just return 0\n        push(zero);\n        return;\n      }\n      m *= i;\n      k[n++] = i;\n      p2 = cdr(p2);\n    }\n    if (n === 0) {\n      push(zero);\n      return;\n    }\n    p1 = alloc_tensor(m);\n    p1.tensor.ndim = n;\n    for (i = m1 = 0, ref3 = n; (0 <= ref3 ? m1 < ref3 : m1 > ref3); i = 0 <= ref3 ? ++m1 : --m1) {\n      p1.tensor.dim[i] = k[i];\n    }\n    return push(p1);\n  };\n\n  allocatedId = 0;\n\n  alloc_tensor = function(nelem) {\n    var i, l1, p, ref2;\n    i = 0;\n    p = new U();\n    p.k = TENSOR;\n    p.tensor = new tensor();\n    p.tensor.nelem = nelem;\n    for (i = l1 = 0, ref2 = nelem; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      p.tensor.elem[i] = zero;\n    }\n    p.tensor.allocatedId = allocatedId;\n    //if allocatedId == 9\n    //  debugger\n    allocatedId++;\n    check_tensor_dimensions(p);\n    return p;\n  };\n\n  /*\n  // garbage collector\n\n  void\n  gc(void)\n  {\n    int i, j\n    U *p\n\n    // tag everything\n\n    for (i = 0; i < mcount; i++) {\n      p = mem[i]\n      for (j = 0; j < N; j++)\n        p[j].tag = 1\n    }\n\n    // untag what's used\n\n    untag(p0)\n    untag(p1)\n    untag(p2)\n    untag(p3)\n    untag(p4)\n    untag(p5)\n    untag(p6)\n    untag(p7)\n    untag(p8)\n    untag(p9)\n\n    untag(one)\n    untag(zero)\n    untag(imaginaryunit)\n\n    for (i = 0; i < NSYM; i++) {\n      untag(binding[i])\n      untag(arglist[i])\n    }\n\n    for (i = 0; i < tos; i++)\n      untag(stack[i])\n\n    for (i = (int) (frame - stack); i < TOS; i++)\n      untag(stack[i])\n\n    // collect everything that's still tagged\n\n    free_count = 0\n\n    for (i = 0; i < mcount; i++) {\n      p = mem[i]\n      for (j = 0; j < N; j++) {\n        if (p[j].tag == 0)\n          continue\n        // still tagged so it's unused, put on free list\n        switch (p[j].k) {\n        case TENSOR:\n          free(p[j].u.tensor)\n          break\n        case STR:\n          free(p[j].u.str)\n          break\n        case NUM:\n          mfree(p[j].u.q.a)\n          mfree(p[j].u.q.b)\n          break\n        }\n        p[j].k = CONS; // so no double free occurs above\n        p[j].u.cons.cdr = free_list\n        free_list = p + j\n        free_count++\n      }\n    }\n  }\n\n  void\n  untag(U *p)\n  {\n    int i\n\n    if (iscons(p)) {\n      do {\n        if (p->tag == 0)\n          return\n        p->tag = 0\n        untag(p->u.cons.car)\n        p = p->u.cons.cdr\n      } while (iscons(p))\n      untag(p)\n      return\n    }\n\n    if (p->tag) {\n      p->tag = 0\n       if (istensor(p)) {\n        for (i = 0; i < p->u.tensor->nelem; i++)\n          untag(p->u.tensor->elem[i])\n      }\n    }\n  }\n\n  // get memory for 100,000 atoms\n\n  void\n  alloc_mem(void)\n  {\n    int i\n    U *p\n    if (mcount == M)\n      return\n    p = (U *) malloc(N * sizeof (struct U))\n    if (p == NULL)\n      return\n    mem[mcount++] = p\n    for (i = 0; i < N; i++) {\n      p[i].k = CONS; // so no free in gc\n      p[i].u.cons.cdr = p + i + 1\n    }\n    p[N - 1].u.cons.cdr = free_list\n    free_list = p\n    free_count += N\n  }\n\n  void\n  print_mem_info(void)\n  {\n    char buf[100]\n\n    sprintf(buf, \"%d blocks (%d bytes/block)\\n\", N * mcount, (int) sizeof (U))\n    printstr(buf)\n\n    sprintf(buf, \"%d free\\n\", free_count)\n    printstr(buf)\n\n    sprintf(buf, \"%d used\\n\", N * mcount - free_count)\n    printstr(buf)\n  }\n  */\n  // returns 1 if expr p contains expr q, otherweise returns 0\n  Find = function(p, q) {\n    var i, l1, ref2;\n    i = 0;\n    if (equal(p, q)) {\n      return 1;\n    }\n    if (istensor(p)) {\n      for (i = l1 = 0, ref2 = p.tensor.nelem; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n        if (Find(p.tensor.elem[i], q)) {\n          return 1;\n        }\n      }\n      return 0;\n    }\n    while (iscons(p)) {\n      if (Find(car(p), q)) {\n        return 1;\n      }\n      p = cdr(p);\n    }\n    return 0;\n  };\n\n  // find stuff like (-1)^(something (but disregard\n  // imaginary units which are in the form (-1)^(1/2))\n  findPossibleClockForm = function(p) {\n    var i, l1, ref2;\n    i = 0;\n    if (isimaginaryunit(p)) {\n      return 0;\n    }\n    if (car(p) === symbol(POWER) && !isinteger(caddr(p1))) {\n      if (Find(cadr(p), imaginaryunit)) {\n        //console.log \"found i^fraction \" + p\n        return 1;\n      }\n    }\n    if (car(p) === symbol(POWER) && equaln(cadr(p), -1) && !isinteger(caddr(p1))) {\n      //console.log \"found -1^fraction in \" + p\n      return 1;\n    }\n    if (istensor(p)) {\n      for (i = l1 = 0, ref2 = p.tensor.nelem; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n        if (findPossibleClockForm(p.tensor.elem[i])) {\n          return 1;\n        }\n      }\n      return 0;\n    }\n    while (iscons(p)) {\n      if (findPossibleClockForm(car(p))) {\n        return 1;\n      }\n      p = cdr(p);\n    }\n    return 0;\n  };\n\n  // find stuff like (e)^(i something)\n  findPossibleExponentialForm = function(p) {\n    var i, l1, ref2;\n    i = 0;\n    if (car(p) === symbol(POWER) && cadr(p) === symbol(E)) {\n      return Find(caddr(p), imaginaryunit);\n    }\n    if (istensor(p)) {\n      for (i = l1 = 0, ref2 = p.tensor.nelem; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n        if (findPossibleExponentialForm(p.tensor.elem[i])) {\n          return 1;\n        }\n      }\n      return 0;\n    }\n    while (iscons(p)) {\n      if (findPossibleExponentialForm(car(p))) {\n        return 1;\n      }\n      p = cdr(p);\n    }\n    return 0;\n  };\n\n  $.Find = Find;\n\n  init = function() {\n    var i, l1, ref2;\n    //debugger\n    //console.log \"DOING AN INIT ========================================================================\"\n    i = 0;\n    flag = 0;\n    reset_after_error();\n    chainOfUserSymbolsNotFunctionsBeingEvaluated = [];\n    if (flag) { // already initted\n      return;\n    }\n    flag = 1;\n// total clearout of symbol table\n    for (i = l1 = 0, ref2 = NSYM; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      symtab[i] = new U();\n      symtab[i].k = SYM;\n      binding[i] = symtab[i];\n      isSymbolReclaimable[i] = false;\n    }\n    return defn();\n  };\n\n  defn_str = [\n    \"version=\\\"\" + version + \"\\\"\",\n    \"e=exp(1)\",\n    \"i=sqrt(-1)\",\n    \"autoexpand=1\",\n    \"assumeRealVariables=1\",\n    \"trange=[-pi,pi]\",\n    \"xrange=[-10,10]\",\n    \"yrange=[-10,10]\",\n    \"last=0\",\n    \"trace=0\",\n    \"forceFixedPrintout=1\",\n    \"maxFixedPrintoutDigits=6\",\n    \"printLeaveEAlone=1\",\n    \"printLeaveXAlone=0\",\n    // cross definition\n    \"cross(u,v)=[u[2]*v[3]-u[3]*v[2],u[3]*v[1]-u[1]*v[3],u[1]*v[2]-u[2]*v[1]]\",\n    // curl definition\n    \"curl(v)=[d(v[3],y)-d(v[2],z),d(v[1],z)-d(v[3],x),d(v[2],x)-d(v[1],y)]\",\n    // div definition\n    \"div(v)=d(v[1],x)+d(v[2],y)+d(v[3],z)\",\n    // Note that we use the mathematics / Javascript / Mathematica\n    // convention that \"log\" is indeed the natural logarithm.\n\n    // In engineering, biology, astronomy, \"log\" can stand instead\n    // for the \"common\" logarithm i.e. base 10. Also note that Google\n    // calculations use log for the common logarithm.\n    \"ln(x)=log(x)\"\n  ];\n\n  defn = function() {\n    var definitionOfInterest, defn_i, l1, originalCodeGen, ref2;\n    p0 = symbol(NIL);\n    p1 = symbol(NIL);\n    p2 = symbol(NIL);\n    p3 = symbol(NIL);\n    p4 = symbol(NIL);\n    p5 = symbol(NIL);\n    p6 = symbol(NIL);\n    p7 = symbol(NIL);\n    p8 = symbol(NIL);\n    p9 = symbol(NIL);\n    std_symbol(\"abs\", ABS);\n    std_symbol(\"add\", ADD);\n    std_symbol(\"adj\", ADJ);\n    std_symbol(\"and\", AND);\n    std_symbol(\"approxratio\", APPROXRATIO);\n    std_symbol(\"arccos\", ARCCOS);\n    std_symbol(\"arccosh\", ARCCOSH);\n    std_symbol(\"arcsin\", ARCSIN);\n    std_symbol(\"arcsinh\", ARCSINH);\n    std_symbol(\"arctan\", ARCTAN);\n    std_symbol(\"arctanh\", ARCTANH);\n    std_symbol(\"arg\", ARG);\n    std_symbol(\"atomize\", ATOMIZE);\n    std_symbol(\"besselj\", BESSELJ);\n    std_symbol(\"bessely\", BESSELY);\n    std_symbol(\"binding\", BINDING);\n    std_symbol(\"binomial\", BINOMIAL);\n    std_symbol(\"ceiling\", CEILING);\n    std_symbol(\"check\", CHECK);\n    std_symbol(\"choose\", CHOOSE);\n    std_symbol(\"circexp\", CIRCEXP);\n    std_symbol(\"clear\", CLEAR);\n    std_symbol(\"clearall\", CLEARALL);\n    std_symbol(\"clearpatterns\", CLEARPATTERNS);\n    std_symbol(\"clock\", CLOCK);\n    std_symbol(\"coeff\", COEFF);\n    std_symbol(\"cofactor\", COFACTOR);\n    std_symbol(\"condense\", CONDENSE);\n    std_symbol(\"conj\", CONJ);\n    std_symbol(\"contract\", CONTRACT);\n    std_symbol(\"cos\", COS);\n    std_symbol(\"cosh\", COSH);\n    std_symbol(\"decomp\", DECOMP);\n    std_symbol(\"defint\", DEFINT);\n    std_symbol(\"deg\", DEGREE);\n    std_symbol(\"denominator\", DENOMINATOR);\n    std_symbol(\"det\", DET);\n    std_symbol(\"derivative\", DERIVATIVE);\n    std_symbol(\"dim\", DIM);\n    std_symbol(\"dirac\", DIRAC);\n    std_symbol(\"divisors\", DIVISORS);\n    std_symbol(\"do\", DO);\n    std_symbol(\"dot\", DOT);\n    std_symbol(\"draw\", DRAW);\n    std_symbol(\"dsolve\", DSOLVE);\n    std_symbol(\"erf\", ERF);\n    std_symbol(\"erfc\", ERFC);\n    std_symbol(\"eigen\", EIGEN);\n    std_symbol(\"eigenval\", EIGENVAL);\n    std_symbol(\"eigenvec\", EIGENVEC);\n    std_symbol(\"eval\", EVAL);\n    std_symbol(\"exp\", EXP);\n    std_symbol(\"expand\", EXPAND);\n    std_symbol(\"expcos\", EXPCOS);\n    std_symbol(\"expsin\", EXPSIN);\n    std_symbol(\"factor\", FACTOR);\n    std_symbol(\"factorial\", FACTORIAL);\n    std_symbol(\"factorpoly\", FACTORPOLY);\n    std_symbol(\"filter\", FILTER);\n    std_symbol(\"float\", FLOATF);\n    std_symbol(\"floor\", FLOOR);\n    std_symbol(\"for\", FOR);\n    std_symbol(\"function\", FUNCTION);\n    std_symbol(\"Gamma\", GAMMA);\n    std_symbol(\"gcd\", GCD);\n    std_symbol(\"hermite\", HERMITE);\n    std_symbol(\"hilbert\", HILBERT);\n    std_symbol(\"imag\", IMAG);\n    std_symbol(\"component\", INDEX);\n    std_symbol(\"inner\", INNER);\n    std_symbol(\"integral\", INTEGRAL);\n    std_symbol(\"inv\", INV);\n    std_symbol(\"invg\", INVG);\n    std_symbol(\"isinteger\", ISINTEGER);\n    std_symbol(\"isprime\", ISPRIME);\n    std_symbol(\"laguerre\", LAGUERRE);\n    //  std_symbol(\"laplace\", LAPLACE)\n    std_symbol(\"lcm\", LCM);\n    std_symbol(\"leading\", LEADING);\n    std_symbol(\"legendre\", LEGENDRE);\n    std_symbol(\"log\", LOG);\n    std_symbol(\"lookup\", LOOKUP);\n    std_symbol(\"mod\", MOD);\n    std_symbol(\"multiply\", MULTIPLY);\n    std_symbol(\"not\", NOT);\n    std_symbol(\"nroots\", NROOTS);\n    std_symbol(\"number\", NUMBER);\n    std_symbol(\"numerator\", NUMERATOR);\n    std_symbol(\"operator\", OPERATOR);\n    std_symbol(\"or\", OR);\n    std_symbol(\"outer\", OUTER);\n    std_symbol(\"pattern\", PATTERN);\n    std_symbol(\"patternsinfo\", PATTERNSINFO);\n    std_symbol(\"polar\", POLAR);\n    std_symbol(\"power\", POWER);\n    std_symbol(\"prime\", PRIME);\n    std_symbol(\"print\", PRINT);\n    std_symbol(\"print2dascii\", PRINT2DASCII);\n    std_symbol(\"printcomputer\", PRINTFULL);\n    std_symbol(\"printlatex\", PRINTLATEX);\n    std_symbol(\"printlist\", PRINTLIST);\n    std_symbol(\"printhuman\", PRINTPLAIN);\n    std_symbol(\"printLeaveEAlone\", PRINT_LEAVE_E_ALONE);\n    std_symbol(\"printLeaveXAlone\", PRINT_LEAVE_X_ALONE);\n    std_symbol(\"product\", PRODUCT);\n    std_symbol(\"quote\", QUOTE);\n    std_symbol(\"quotient\", QUOTIENT);\n    std_symbol(\"rank\", RANK);\n    std_symbol(\"rationalize\", RATIONALIZE);\n    std_symbol(\"real\", REAL);\n    std_symbol(\"rect\", YYRECT);\n    std_symbol(\"roots\", ROOTS);\n    std_symbol(\"round\", ROUND);\n    std_symbol(\"equals\", SETQ);\n    std_symbol(\"sgn\", SGN);\n    std_symbol(\"silentpattern\", SILENTPATTERN);\n    std_symbol(\"simplify\", SIMPLIFY);\n    std_symbol(\"sin\", SIN);\n    std_symbol(\"sinh\", SINH);\n    std_symbol(\"shape\", SHAPE);\n    std_symbol(\"sqrt\", SQRT);\n    std_symbol(\"stop\", STOP);\n    std_symbol(\"subst\", SUBST);\n    std_symbol(\"sum\", SUM);\n    std_symbol(\"symbolsinfo\", SYMBOLSINFO);\n    std_symbol(\"tan\", TAN);\n    std_symbol(\"tanh\", TANH);\n    std_symbol(\"taylor\", TAYLOR);\n    std_symbol(\"test\", TEST);\n    std_symbol(\"testeq\", TESTEQ);\n    std_symbol(\"testge\", TESTGE);\n    std_symbol(\"testgt\", TESTGT);\n    std_symbol(\"testle\", TESTLE);\n    std_symbol(\"testlt\", TESTLT);\n    std_symbol(\"transpose\", TRANSPOSE);\n    std_symbol(\"unit\", UNIT);\n    std_symbol(\"zero\", ZERO);\n    std_symbol(\"nil\", NIL);\n    std_symbol(\"autoexpand\", AUTOEXPAND);\n    std_symbol(\"bake\", BAKE);\n    std_symbol(\"assumeRealVariables\", ASSUME_REAL_VARIABLES);\n    std_symbol(\"last\", LAST);\n    std_symbol(\"lastprint\", LAST_PRINT);\n    std_symbol(\"last2dasciiprint\", LAST_2DASCII_PRINT);\n    std_symbol(\"lastfullprint\", LAST_FULL_PRINT);\n    std_symbol(\"lastlatexprint\", LAST_LATEX_PRINT);\n    std_symbol(\"lastlistprint\", LAST_LIST_PRINT);\n    std_symbol(\"lastplainprint\", LAST_PLAIN_PRINT);\n    std_symbol(\"trace\", TRACE);\n    std_symbol(\"forceFixedPrintout\", FORCE_FIXED_PRINTOUT);\n    std_symbol(\"maxFixedPrintoutDigits\", MAX_FIXED_PRINTOUT_DIGITS);\n    std_symbol(\"~\", YYE); // tilde so sort puts it after other symbols\n    std_symbol(\"$DRAWX\", DRAWX); // special purpose internal symbols\n    std_symbol(\"$METAA\", METAA);\n    std_symbol(\"$METAB\", METAB);\n    std_symbol(\"$METAX\", METAX);\n    std_symbol(\"$SECRETX\", SECRETX);\n    std_symbol(\"version\", VERSION);\n    std_symbol(\"pi\", PI);\n    std_symbol(\"a\", SYMBOL_A);\n    std_symbol(\"b\", SYMBOL_B);\n    std_symbol(\"c\", SYMBOL_C);\n    std_symbol(\"d\", SYMBOL_D);\n    std_symbol(\"i\", SYMBOL_I);\n    std_symbol(\"j\", SYMBOL_J);\n    std_symbol(\"n\", SYMBOL_N);\n    std_symbol(\"r\", SYMBOL_R);\n    std_symbol(\"s\", SYMBOL_S);\n    std_symbol(\"t\", SYMBOL_T);\n    std_symbol(\"x\", SYMBOL_X);\n    std_symbol(\"y\", SYMBOL_Y);\n    std_symbol(\"z\", SYMBOL_Z);\n    std_symbol(\"I\", SYMBOL_IDENTITY_MATRIX);\n    std_symbol(\"a_\", SYMBOL_A_UNDERSCORE);\n    std_symbol(\"b_\", SYMBOL_B_UNDERSCORE);\n    std_symbol(\"x_\", SYMBOL_X_UNDERSCORE);\n    std_symbol(\"$C1\", C1);\n    std_symbol(\"$C2\", C2);\n    std_symbol(\"$C3\", C3);\n    std_symbol(\"$C4\", C4);\n    std_symbol(\"$C5\", C5);\n    std_symbol(\"$C6\", C6);\n    defineSomeHandyConstants();\n    // don't add all these functions to the\n    // symbolsDependencies, clone the original\n    originalCodeGen = codeGen;\n    codeGen = false;\n    for (defn_i = l1 = 0, ref2 = defn_str.length; (0 <= ref2 ? l1 < ref2 : l1 > ref2); defn_i = 0 <= ref2 ? ++l1 : --l1) {\n      definitionOfInterest = defn_str[defn_i];\n      scan(definitionOfInterest);\n      if (DEBUG) {\n        console.log(\"... evaling \" + definitionOfInterest);\n        console.log(\"top of stack:\");\n        console.log(print_list(stack[tos - 1]));\n      }\n      Eval();\n      pop();\n    }\n    // restore the symbol dependencies as they were before.\n    return codeGen = originalCodeGen;\n  };\n\n  defineSomeHandyConstants = function() {\n    zero = new_integer(0);\n    one = new_integer(1);\n    push_double(1.0);\n    one_as_double = pop();\n    // i is the square root of -1 i.e. -1 ^ 1/2\n    push_symbol(POWER);\n    if (DEBUG) {\n      console.log(print_list(stack[tos - 1]));\n    }\n    push_integer(-1);\n    if (DEBUG) {\n      console.log(print_list(stack[tos - 1]));\n    }\n    push_rational(1, 2);\n    if (DEBUG) {\n      console.log(print_list(stack[tos - 1]));\n    }\n    list(3);\n    if (DEBUG) {\n      console.log(print_list(stack[tos - 1]));\n    }\n    return imaginaryunit = pop(); // must be untagged in gc\n  };\n\n  // Bignum compare\n\n  //  returns\n\n  //  -1    a < b\n\n  //  0    a = b\n\n  //  1    a > b\n  mcmp = function(a, b) {\n    return a.compare(b);\n  };\n\n  // a is a bigint, n is a normal int\n  mcmpint = function(a, n) {\n    var b, t;\n    b = bigInt(n);\n    t = mcmp(a, b);\n    return t;\n  };\n\n  strcmp = function(str1, str2) {\n    if (str1 === str2) {\n      return 0;\n    } else if (str1 > str2) {\n      return 1;\n    } else {\n      return -1;\n    }\n  };\n\n  doubleToReasonableString = function(d) {\n    var maxFixedPrintoutDigits, stringRepresentation;\n    // when generating code, print out\n    // the standard JS Number printout\n    if (codeGen) {\n      return \"\" + d;\n    }\n    if (isZeroAtomOrTensor(get_binding(symbol(FORCE_FIXED_PRINTOUT)))) {\n      stringRepresentation = \"\" + d;\n      // manipulate the string so that it can be parsed by\n      // Algebrite (something like 1.23e-123 wouldn't cut it because\n      // that would be parsed as 1.23*e - 123)\n      if (printMode === PRINTMODE_LATEX) {\n        // 1.0\\mathrm{e}{-10} looks much better than the plain 1.0e-10\n        if (/\\d*\\.\\d*e.*/gm.test(stringRepresentation)) {\n          stringRepresentation = stringRepresentation.replace(/e(.*)/gm, \"\\\\mathrm{e}{$1}\");\n        } else {\n          // if there is no dot in the mantissa, add it so we see it's\n          // a double and not a perfect number\n          // e.g. 1e-10 becomes 1.0\\mathrm{e}{-10}\n          stringRepresentation = stringRepresentation.replace(/(\\d+)e(.*)/gm, \"$1.0\\\\mathrm{e}{$2}\");\n        }\n      } else {\n        if (/\\d*\\.\\d*e.*/gm.test(stringRepresentation)) {\n          stringRepresentation = stringRepresentation.replace(/e(.*)/gm, \"*10^($1)\");\n        } else {\n          // if there is no dot in the mantissa, add it so we see it's\n          // a double and not a perfect number\n          // e.g. 1e-10 becomes 1.0e-10\n          stringRepresentation = stringRepresentation.replace(/(\\d+)e(.*)/gm, \"$1.0*10^($2)\");\n        }\n      }\n    } else {\n      push(get_binding(symbol(MAX_FIXED_PRINTOUT_DIGITS)));\n      maxFixedPrintoutDigits = pop_integer();\n      //console.log \"maxFixedPrintoutDigits: \" + maxFixedPrintoutDigits\n      //console.log \"type: \" + typeof(maxFixedPrintoutDigits)\n      //console.log \"toFixed: \" + d.toFixed(maxFixedPrintoutDigits)\n      stringRepresentation = \"\" + d.toFixed(maxFixedPrintoutDigits);\n      // remove any trailing zeroes after the dot\n      // see https://stackoverflow.com/questions/26299160/using-regex-how-do-i-remove-the-trailing-zeros-from-a-decimal-number\n      stringRepresentation = stringRepresentation.replace(/(\\.\\d*?[1-9])0+$/gm, \"$1\");\n      // in case there are only zeroes after the dot, removes the dot too\n      stringRepresentation = stringRepresentation.replace(/\\.0+$/gm, \"\");\n      // we actually want to give a hint to user that\n      // it's a double, so add a trailing \".0\" if there\n      // is no decimal point\n      if (stringRepresentation.indexOf(\".\") === -1) {\n        stringRepresentation += \".0\";\n      }\n      if (parseFloat(stringRepresentation) !== d) {\n        stringRepresentation = d.toFixed(maxFixedPrintoutDigits) + \"...\";\n      }\n    }\n    return stringRepresentation;\n  };\n\n  // does nothing\n  clear_term = function() {};\n\n  // s is a string here anyways\n  isspace = function(s) {\n    if (s == null) {\n      return false;\n    }\n    return s === ' ' || s === '\\t' || s === '\\n' || s === '\\v' || s === '\\f' || s === '\\r';\n  };\n\n  isdigit = function(str) {\n    if (str == null) {\n      return false;\n    }\n    return /^\\d+$/.test(str);\n  };\n\n  isalpha = function(str) {\n    if (str == null) {\n      return false;\n    }\n    //Check for non-alphabetic characters and space\n    return str.search(/[^A-Za-z]/) === -1;\n  };\n\n  isalphaOrUnderscore = function(str) {\n    if (str == null) {\n      return false;\n    }\n    //Check for non-alphabetic characters and space\n    return str.search(/[^A-Za-z_]/) === -1;\n  };\n\n  isunderscore = function(str) {\n    if (str == null) {\n      return false;\n    }\n    return str.search(/_/) === -1;\n  };\n\n  isalnumorunderscore = function(str) {\n    if (str == null) {\n      return false;\n    }\n    return isalphaOrUnderscore(str) || isdigit(str);\n  };\n\n  count = function(p) {\n    var n;\n    if (iscons(p)) {\n      n = 0;\n      while (iscons(p)) {\n        n += count(car(p)) + 1;\n        p = cdr(p);\n      }\n    } else {\n      n = 1;\n    }\n    return n;\n  };\n\n  // this probably works out to be\n  // more general than just counting symbols, it can\n  // probably count instances of anything you pass as\n  // first argument but didn't try it.\n  countOccurrencesOfSymbol = function(needle, p) {\n    var n;\n    n = 0;\n    if (iscons(p)) {\n      while (iscons(p)) {\n        n += countOccurrencesOfSymbol(needle, car(p));\n        p = cdr(p);\n      }\n    } else {\n      if (equal(needle, p)) {\n        n = 1;\n      }\n    }\n    return n;\n  };\n\n  // returns the total number of elements\n  // in an expression\n  countsize = function(p) {\n    var i, l1, n, ref2;\n    n = 0;\n    if (istensor(p)) {\n      for (i = l1 = 0, ref2 = p.tensor.nelem; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n        n += p.tensor.elem[i];\n      }\n    } else if (iscons(p)) {\n      while (iscons(p)) {\n        n += count(car(p)) + 1;\n        p = cdr(p);\n      }\n    } else {\n      n = 1;\n    }\n    return n;\n  };\n\n  //jmp_buf stop_return, draw_stop_return\n\n  // s is a string here\n  stop = function(s) {\n    var message;\n    //if (draw_flag == 2)\n    //  longjmp(draw_stop_return, 1)\n    //else\n    errorMessage += \"Stop: \";\n    errorMessage += s;\n    //debugger\n    message = errorMessage;\n    errorMessage = '';\n    moveTos(0);\n    throw new Error(message);\n  };\n\n  \n  //longjmp(stop_return, 1)\n\n  // Figuring out dependencies is key to automatically\n  // generating a method signature when generating JS code\n  // from algebrite scripts.\n  // This is important because the user can keep using normal Algebrite\n  // scripting without special notations.\n  // Basically the process consists of figuring out\n  // the \"ground variables\" that are needed to compute each variable.\n  // Now there are two ways of doing this:\n  //   * at parse time\n  //   * after running the scripts\n  // Doing it at parse time means that we can't track simplifications\n  // canceling-out some variables for example. But on the other side\n  // it's very quick and the user can somehow see what the signature is\n  // going to look like (assuming tha code is rather simple), or anyways\n  // is going to easily make sense of the generated signature.\n  // Doing it after execution on the other hand would allow us to see\n  // if some variable cancel-out. But if variables cancel out then\n  // they might do so according to some run-time behaviour that the user\n  // might struggle to keep track of.\n  // So the effort for the user to make sense of the signature in the first case\n  // is similar to the effort of keeping tab of types in a typed language.\n  // While in the second case the effort is similar to running the\n  // code and simplifications in her head.\n\n  // If we just want to compute the dependencies, we don't need to do\n  // anything costly, we don't \"run\" the code and we don't simplify\n  // the code. Just finding the plain dependencies\n  // TODO change the name of this function, as it doesn't just find the\n  // dependencies. It also runs it and generates the JS code.\n  findDependenciesInScript = function(stringToBeParsed, dontGenerateCode) {\n    var allReturnedLatexStrings, allReturnedPlainStrings, bodyForReadableSummaryOfGeneratedCode, cyclesDescriptions, deQuotedDep, dependencyInfo, eachDependency, error, generatedBody, generatedCode, i, indexOfEachReplacement, indexOfPartRemainingToBeParsed, inited, key, l1, len, len1, len2, len3, len4, len5, len6, len7, m1, n, n1, newUserSymbol, o1, origPrintMode, originalUserSymbol, parameters, q1, r1, readableSummaryOfGeneratedCode, recursedDependencies, ref2, replacementsFrom, replacementsTo, s1, scriptEvaluation, stringToBeRun, t1, testableString, timeStartFromAlgebra, toBePrinted, u1, userVariablesMentioned, value, variablesWithCycles;\n    if (DEBUG) {\n      console.log(\"stringToBeParsed: \" + stringToBeParsed);\n    }\n    timeStartFromAlgebra = new Date().getTime();\n    inited = true;\n    codeGen = true;\n    symbolsDependencies = {};\n    symbolsHavingReassignments = [];\n    symbolsInExpressionsWithoutAssignments = [];\n    patternHasBeenFound = false;\n    indexOfPartRemainingToBeParsed = 0;\n    allReturnedPlainStrings = \"\";\n    allReturnedLatexStrings = \"\";\n    n = 0;\n    // we are going to store the dependencies _of the block as a whole_\n    // so all affected variables in the whole block are lumped\n    // together, and same for the variable that affect those, we\n    // lump them all together.\n    dependencyInfo = {\n      affectsVariables: [],\n      affectedBy: []\n    };\n    stringToBeRun = stringToBeParsed;\n    // parse the input. This collects the\n    // dependency information\n    while (1) {\n      try {\n        errorMessage = \"\";\n        check_stack();\n        if (DEBUG) {\n          console.log(\"findDependenciesInScript: scanning\");\n        }\n        n = scan(stringToBeParsed.substring(indexOfPartRemainingToBeParsed));\n        if (DEBUG) {\n          console.log(\"scanned\");\n        }\n        pop();\n        check_stack();\n      } catch (error1) {\n        error = error1;\n        if (PRINTOUTRESULT) {\n          console.log(error);\n        }\n        errorMessage = error + \"\";\n        //debugger\n        reset_after_error();\n        break;\n      }\n      if (n === 0) {\n        break;\n      }\n      indexOfPartRemainingToBeParsed += n;\n    }\n    testableString = \"\";\n    // print out all local dependencies as collected by this\n    // parsing pass\n    if (DEBUG) {\n      console.log(\"all local dependencies ----------------\");\n    }\n    testableString += \"All local dependencies: \";\n    for (key in symbolsDependencies) {\n      value = symbolsDependencies[key];\n      if (DEBUG) {\n        console.log(\"variable \" + key + \" depends on: \");\n      }\n      dependencyInfo.affectsVariables.push(key);\n      testableString += \" variable \" + key + \" depends on: \";\n      for (l1 = 0, len = value.length; l1 < len; l1++) {\n        i = value[l1];\n        if (DEBUG) {\n          console.log(\"    \" + i);\n        }\n        if (i[0] !== \"'\") {\n          dependencyInfo.affectedBy.push(i);\n        }\n        testableString += i + \", \";\n      }\n      testableString += \"; \";\n    }\n    testableString += \". \";\n    // print out the symbols with re-assignments:\n    if (DEBUG) {\n      console.log(\"Symbols with reassignments ----------------\");\n    }\n    testableString += \"Symbols with reassignments: \";\n    for (m1 = 0, len1 = symbolsHavingReassignments.length; m1 < len1; m1++) {\n      key = symbolsHavingReassignments[m1];\n      if (dependencyInfo.affectedBy.indexOf(key) === -1) {\n        dependencyInfo.affectedBy.push(key);\n        testableString += key + \", \";\n      }\n    }\n    testableString += \". \";\n    // print out the symbols that appear in expressions without assignments\n    if (DEBUG) {\n      console.log(\"Symbols in expressions without assignments ----------------\");\n    }\n    testableString += \"Symbols in expressions without assignments: \";\n    for (n1 = 0, len2 = symbolsInExpressionsWithoutAssignments.length; n1 < len2; n1++) {\n      key = symbolsInExpressionsWithoutAssignments[n1];\n      if (dependencyInfo.affectedBy.indexOf(key) === -1) {\n        dependencyInfo.affectedBy.push(key);\n        testableString += key + \", \";\n      }\n    }\n    testableString += \". \";\n    // ALL Algebrite code is affected by any pattern changing\n    dependencyInfo.affectedBy.push(\"PATTERN_DEPENDENCY\");\n    if (patternHasBeenFound) {\n      dependencyInfo.affectsVariables.push(\"PATTERN_DEPENDENCY\");\n      testableString += \" - PATTERN_DEPENDENCY inserted - \";\n    }\n    // print out all global dependencies as collected by this\n    // parsing pass\n    if (DEBUG) {\n      console.log(\"All dependencies recursively ----------------\");\n    }\n    testableString += \"All dependencies recursively: \";\n    scriptEvaluation = [\"\", \"\"];\n    generatedCode = \"\";\n    readableSummaryOfGeneratedCode = \"\";\n    if (errorMessage === \"\" && !dontGenerateCode) {\n      try {\n        allReturnedPlainStrings = \"\";\n        allReturnedLatexStrings = \"\";\n        scriptEvaluation = run(stringToBeParsed, true);\n        allReturnedPlainStrings = \"\";\n        allReturnedLatexStrings = \"\";\n      } catch (error1) {\n        error = error1;\n        if (PRINTOUTRESULT) {\n          console.log(error);\n        }\n        errorMessage = error + \"\";\n        //debugger\n        init();\n      }\n      if (errorMessage === \"\") {\n        for (key in symbolsDependencies) {\n          codeGen = true;\n          if (DEBUG) {\n            console.log(\"  variable \" + key + \" is: \" + get_binding(usr_symbol(key)).toString());\n          }\n          codeGen = false;\n          if (DEBUG) {\n            console.log(\"  variable \" + key + \" depends on: \");\n          }\n          testableString += \" variable \" + key + \" depends on: \";\n          recursedDependencies = [];\n          variablesWithCycles = [];\n          cyclesDescriptions = [];\n          recursiveDependencies(key, recursedDependencies, [], variablesWithCycles, [], cyclesDescriptions);\n          for (o1 = 0, len3 = variablesWithCycles.length; o1 < len3; o1++) {\n            i = variablesWithCycles[o1];\n            if (DEBUG) {\n              console.log(\"    --> cycle through \" + i);\n            }\n          }\n          for (q1 = 0, len4 = recursedDependencies.length; q1 < len4; q1++) {\n            i = recursedDependencies[q1];\n            if (DEBUG) {\n              console.log(\"    \" + i);\n            }\n            testableString += i + \", \";\n          }\n          testableString += \"; \";\n          for (r1 = 0, len5 = cyclesDescriptions.length; r1 < len5; r1++) {\n            i = cyclesDescriptions[r1];\n            testableString += \" \" + i + \", \";\n          }\n          if (DEBUG) {\n            console.log(\"  code generation:\" + key + \" is: \" + get_binding(usr_symbol(key)).toString());\n          }\n          // we really want to make an extra effort\n          // to generate simplified code, so\n          // run a \"simplify\" on the content of each\n          // variable that we are generating code for.\n          // Note that the variable\n          // will still point to un-simplified structures,\n          // we only simplify the generated code.\n          push(get_binding(usr_symbol(key)));\n          // Since we go and simplify all variables we meet,\n          // we have to replace each variable passed as a parameter\n          // with something entirely new, so that there is no chance\n          // that it might evoke previous values in the external scope\n          // as in this case:\n          //  a = 2\n          //  f(a) = a+1+b\n          // we don't want 'a' in the body of f to be simplified to 2\n          // There are two cases: 1) the variable actually was already in\n          // the symbol table, in which case there is going to be this new\n          // one prepended with AVOID_BINDING_TO_EXTERNAL_SCOPE_VALUE, and\n          // we'll have to remove up this variable later.\n          // OR 2) the variable wasn't already in the symbol table, in which\n          // case we directly create this one, which means that we'll have\n          // to rename it later to the correct name without the prepended\n          // part.\n          replacementsFrom = [];\n          replacementsTo = [];\n          for (s1 = 0, len6 = recursedDependencies.length; s1 < len6; s1++) {\n            eachDependency = recursedDependencies[s1];\n            if (eachDependency[0] === \"'\") {\n              deQuotedDep = eachDependency.substring(1);\n              originalUserSymbol = usr_symbol(deQuotedDep);\n              newUserSymbol = usr_symbol(\"AVOID_BINDING_TO_EXTERNAL_SCOPE_VALUE\" + deQuotedDep);\n              replacementsFrom.push(originalUserSymbol);\n              replacementsTo.push(newUserSymbol);\n              push(originalUserSymbol);\n              push(newUserSymbol);\n              subst();\n              if (DEBUG) {\n                console.log(\"after substitution: \" + stack[tos - 1]);\n              }\n            }\n          }\n          try {\n            simplifyForCodeGeneration();\n          } catch (error1) {\n            error = error1;\n            if (PRINTOUTRESULT) {\n              console.log(error);\n            }\n            errorMessage = error + \"\";\n            //debugger\n            init();\n          }\n          for (indexOfEachReplacement = t1 = 0, ref2 = replacementsFrom.length; (0 <= ref2 ? t1 < ref2 : t1 > ref2); indexOfEachReplacement = 0 <= ref2 ? ++t1 : --t1) {\n            //console.log \"replacing back \" + replacementsTo[indexOfEachReplacement] + \" into: \" + replacementsFrom[indexOfEachReplacement]\n            push(replacementsTo[indexOfEachReplacement]);\n            push(replacementsFrom[indexOfEachReplacement]);\n            subst();\n          }\n          clearRenamedVariablesToAvoidBindingToExternalScope();\n          if (errorMessage === \"\") {\n            toBePrinted = pop();\n            // we have to get all the variables used on the right side\n            // here. I.e. to print the arguments it's better to look at the\n            // actual method body after simplification.\n            userVariablesMentioned = [];\n            collectUserSymbols(toBePrinted, userVariablesMentioned);\n            allReturnedPlainStrings = \"\";\n            allReturnedLatexStrings = \"\";\n            codeGen = true;\n            generatedBody = toBePrinted.toString();\n            codeGen = false;\n            origPrintMode = printMode;\n            printMode = PRINTMODE_LATEX;\n            bodyForReadableSummaryOfGeneratedCode = toBePrinted.toString();\n            printMode = origPrintMode;\n            if (variablesWithCycles.indexOf(key) !== -1) {\n              generatedCode += \"// \" + key + \" is part of a cyclic dependency, no code generated.\";\n              readableSummaryOfGeneratedCode += \"#\" + key + \" is part of a cyclic dependency, no code generated.\";\n            } else {\n              /*\n               * using this paragraph instead of the following one\n               * creates methods signatures that\n               * are slightly less efficient\n               * i.e. variables compare even if they are\n               * simplified away.\n               * In theory these signatures are more stable, but\n               * in practice signatures vary quite a bit anyways\n               * depending on previous assignments for example,\n               * so it's unclear whether going for stability\n               * is sensible at all..\n              if recursedDependencies.length != 0\n                parameters = \"(\"\n                for i in recursedDependencies\n                  if i.indexOf(\"'\") != 0\n                    parameters += i + \", \"\n                  else\n                    if recursedDependencies.indexOf(i.substring(1)) == -1\n                      parameters += i.substring(1) + \", \"\n               */\n              // remove all native functions from the\n              // parameters as well.\n              userVariablesMentioned = userVariablesMentioned.filter(function(x) {\n                return predefinedSymbolsInGlobalScope_doNotTrackInDependencies.indexOf(x + \"\") === -1;\n              });\n              // remove the variable that are not in the dependency list\n              // i.e. only allow the variables that are in the dependency list\n              userVariablesMentioned = userVariablesMentioned.filter(function(x) {\n                return recursedDependencies.indexOf(x + \"\") !== -1 || recursedDependencies.indexOf(\"\\'\" + x + \"\") !== -1;\n              });\n              if (userVariablesMentioned.length !== 0) {\n                parameters = \"(\";\n                for (u1 = 0, len7 = userVariablesMentioned.length; u1 < len7; u1++) {\n                  i = userVariablesMentioned[u1];\n                  if (i.printname !== key) {\n                    parameters += i.printname + \", \";\n                  }\n                }\n                // eliminate the last \", \" for printout clarity\n                parameters = parameters.replace(/, $/gm, \"\");\n                parameters += \")\";\n                generatedCode += key + \" = function \" + parameters + \" { return ( \" + generatedBody + \" ); }\";\n                readableSummaryOfGeneratedCode += key + parameters + \" = \" + bodyForReadableSummaryOfGeneratedCode;\n              } else {\n                generatedCode += key + \" = \" + generatedBody + \";\";\n                readableSummaryOfGeneratedCode += key + \" = \" + bodyForReadableSummaryOfGeneratedCode;\n              }\n            }\n            generatedCode += \"\\n\";\n            readableSummaryOfGeneratedCode += \"\\n\";\n            if (DEBUG) {\n              console.log(\"    \" + generatedCode);\n            }\n          }\n        }\n      }\n    }\n    // eliminate the last new line\n    generatedCode = generatedCode.replace(/\\n$/gm, \"\");\n    readableSummaryOfGeneratedCode = readableSummaryOfGeneratedCode.replace(/\\n$/gm, \"\");\n    // cleanup\n    symbolsDependencies = {};\n    symbolsHavingReassignments = [];\n    patternHasBeenFound = false;\n    symbolsInExpressionsWithoutAssignments = [];\n    if (DEBUG) {\n      console.log(\"testable string: \" + testableString);\n    }\n    if (TIMING_DEBUGS) {\n      console.log(\"findDependenciesInScript time for: \" + stringToBeRun + \" : \" + ((new Date().getTime()) - timeStartFromAlgebra) + \"ms\");\n    }\n    return [testableString, scriptEvaluation[0], generatedCode, readableSummaryOfGeneratedCode, scriptEvaluation[1], errorMessage, dependencyInfo];\n  };\n\n  recursiveDependencies = function(variableToBeChecked, arrayWhereDependenciesWillBeAdded, variablesAlreadyFleshedOut, variablesWithCycles, chainBeingChecked, cyclesDescriptions) {\n    var cyclesDescription, i, k, l1, len, len1, m1, ref2;\n    variablesAlreadyFleshedOut.push(variableToBeChecked);\n    // recursive dependencies can only be descended if the variable is not bound to a parameter\n    if (symbolsDependencies[chainBeingChecked[chainBeingChecked.length - 1]] != null) {\n      if (symbolsDependencies[chainBeingChecked[chainBeingChecked.length - 1]].indexOf(\"'\" + variableToBeChecked) !== -1) {\n        if (DEBUG) {\n          console.log(\"can't keep following the chain of \" + variableToBeChecked + \" because it's actually a variable bound to a parameter\");\n        }\n        if (arrayWhereDependenciesWillBeAdded.indexOf(\"'\" + variableToBeChecked) === -1 && arrayWhereDependenciesWillBeAdded.indexOf(variableToBeChecked) === -1) {\n          arrayWhereDependenciesWillBeAdded.push(variableToBeChecked);\n        }\n        return arrayWhereDependenciesWillBeAdded;\n      }\n    }\n    chainBeingChecked.push(variableToBeChecked);\n    if (symbolsDependencies[variableToBeChecked] == null) {\n      // end case: the passed variable has no dependencies\n      // so there is nothing else to do\n      if (arrayWhereDependenciesWillBeAdded.indexOf(variableToBeChecked) === -1) {\n        arrayWhereDependenciesWillBeAdded.push(variableToBeChecked);\n      }\n      return arrayWhereDependenciesWillBeAdded;\n    } else {\n      ref2 = symbolsDependencies[variableToBeChecked];\n      // recursion case: we have to dig deeper\n      for (l1 = 0, len = ref2.length; l1 < len; l1++) {\n        i = ref2[l1];\n        // check that there is no recursion in dependencies\n        // we do that by keeping a list of variables that\n        // have already been \"fleshed-out\". If we encounter\n        // any of those \"fleshed-out\" variables while\n        // fleshing out, then there is a cycle \n        if (chainBeingChecked.indexOf(i) !== -1) {\n          if (DEBUG) {\n            console.log(\"  found cycle:\");\n          }\n          cyclesDescription = \"\";\n          for (m1 = 0, len1 = chainBeingChecked.length; m1 < len1; m1++) {\n            k = chainBeingChecked[m1];\n            if (variablesWithCycles.indexOf(k) === -1) {\n              variablesWithCycles.push(k);\n            }\n            if (DEBUG) {\n              console.log(k + \" --> \");\n            }\n            cyclesDescription += k + \" --> \";\n          }\n          if (DEBUG) {\n            console.log(\" ... then \" + i + \" again\");\n          }\n          cyclesDescription += \" ... then \" + i + \" again\";\n          cyclesDescriptions.push(cyclesDescription);\n          //if DEBUG then console.log \"    --> cycle through \" + i\n          // we want to flesh-out i but it's already been\n          // fleshed-out, just add it to the variables\n          // with cycles and move on\n          // todo refactor this, there are two copies of these two lines\n          if (variablesWithCycles.indexOf(i) === -1) {\n            variablesWithCycles.push(i);\n          }\n        } else {\n          // flesh-out i recursively\n          recursiveDependencies(i, arrayWhereDependenciesWillBeAdded, variablesAlreadyFleshedOut, variablesWithCycles, chainBeingChecked, cyclesDescriptions);\n          chainBeingChecked.pop();\n        }\n      }\n      //variablesAlreadyFleshedOut.pop()\n      return arrayWhereDependenciesWillBeAdded;\n    }\n  };\n\n  // parses and runs one statement/expression at a time\n  inited = false;\n\n  latexErrorSign = \"\\\\rlap{\\\\large\\\\color{red}\\\\bigtriangleup}{\\\\ \\\\ \\\\tiny\\\\color{red}!}\";\n\n  turnErrorMessageToLatex = function(theErrorMessage) {\n    theErrorMessage = theErrorMessage.replace(/\\n/g, \"\");\n    theErrorMessage = theErrorMessage.replace(/_/g, \"} \\\\_ \\\\text{\");\n    theErrorMessage = theErrorMessage.replace(new RegExp(String.fromCharCode(transpose_unicode), 'g'), \"}{}^{T}\\\\text{\");\n    theErrorMessage = theErrorMessage.replace(new RegExp(String.fromCharCode(dotprod_unicode), 'g'), \"}\\\\cdot \\\\text{\");\n    theErrorMessage = theErrorMessage.replace(\"Stop:\", \"}  \\\\quad \\\\text{Stop:\");\n    theErrorMessage = theErrorMessage.replace(\"->\", \"}  \\\\rightarrow \\\\text{\");\n    theErrorMessage = theErrorMessage.replace(\"?\", \"}\\\\enspace \" + latexErrorSign + \" \\\\enspace  \\\\text{\");\n    theErrorMessage = \"$$\\\\text{\" + theErrorMessage.replace(/\\n/g, \"\") + \"}$$\";\n    //console.log \"theErrorMessage: \" + theErrorMessage\n    return theErrorMessage;\n  };\n\n  // there are around a dozen different unicodes that\n  // represent some sort of middle dot, let's catch the most\n  // common and turn them into what we can process\n  normaliseDots = function(stringToNormalise) {\n    stringToNormalise = stringToNormalise.replace(new RegExp(String.fromCharCode(8901), 'g'), String.fromCharCode(dotprod_unicode));\n    stringToNormalise = stringToNormalise.replace(new RegExp(String.fromCharCode(8226), 'g'), String.fromCharCode(dotprod_unicode));\n    stringToNormalise = stringToNormalise.replace(new RegExp(String.fromCharCode(12539), 'g'), String.fromCharCode(dotprod_unicode));\n    stringToNormalise = stringToNormalise.replace(new RegExp(String.fromCharCode(55296), 'g'), String.fromCharCode(dotprod_unicode));\n    stringToNormalise = stringToNormalise.replace(new RegExp(String.fromCharCode(65381), 'g'), String.fromCharCode(dotprod_unicode));\n    return stringToNormalise;\n  };\n\n  TIMING_DEBUGS = false;\n\n  run = function(stringToBeRun, generateLatex = false) {\n    var allReturnedLatexStrings, allReturnedPlainStrings, collectedLatexResult, collectedPlainResult, error, errorWhileExecution, i, indexOfPartRemainingToBeParsed, n, stringToBeReturned, theErrorMessage, timeStart, timingDebugWrite;\n    timeStart = new Date().getTime();\n    //stringToBeRun = stringToBeRun + \"\\n\"\n    stringToBeRun = normaliseDots(stringToBeRun);\n    //console.log \"run running: \" + stringToBeRun\n    if (stringToBeRun === \"selftest\") {\n      selftest();\n      return;\n    }\n    if (!inited) {\n      inited = true;\n      init();\n    }\n    i = 0;\n    n = 0;\n    indexOfPartRemainingToBeParsed = 0;\n    allReturnedPlainStrings = \"\";\n    allReturnedLatexStrings = \"\";\n    while (1) {\n      try {\n        // while we can keep scanning commands out of the\n        // passed input AND we can execute them...\n        errorMessage = \"\";\n        check_stack();\n        n = scan(stringToBeRun.substring(indexOfPartRemainingToBeParsed));\n        p1 = pop();\n        check_stack();\n      } catch (error1) {\n        error = error1;\n        if (PRINTOUTRESULT) {\n          console.log(error);\n        }\n        //debugger\n        allReturnedPlainStrings += error.message;\n        if (generateLatex) {\n          //debugger\n          theErrorMessage = turnErrorMessageToLatex(error.message);\n          allReturnedLatexStrings += theErrorMessage;\n        }\n        reset_after_error();\n        break;\n      }\n      if (n === 0) {\n        break;\n      }\n      // if debug mode then print the source text\n\n      //if (equaln(get_binding(symbol(TRACE)), 1)) {\n      //  for (i = 0 i < n i++)\n      //    if (s[i] != '\\r')\n      //      printchar(s[i])\n      //  if (s[n - 1] != '\\n') # n is not zero, see above\n      //    printchar('\\n')\n      //}\n      indexOfPartRemainingToBeParsed += n;\n      push(p1);\n      //debugger\n      errorWhileExecution = false;\n      try {\n        stringsEmittedByUserPrintouts = \"\";\n        top_level_eval();\n        //console.log \"emitted string after top_level_eval(): >\" + stringsEmittedByUserPrintouts + \"<\"\n        //console.log \"allReturnedPlainStrings string after top_level_eval(): >\" + allReturnedPlainStrings + \"<\"\n        p2 = pop();\n        check_stack();\n        if (isstr(p2)) {\n          if (DEBUG) {\n            console.log(p2.str);\n          }\n          if (DEBUG) {\n            console.log(\"\\n\");\n          }\n        }\n        // if the return value is nil there isn't much point\n        // in adding \"nil\" to the printout\n        if (p2 === symbol(NIL)) {\n          //collectedPlainResult = stringsEmittedByUserPrintouts\n          collectedPlainResult = stringsEmittedByUserPrintouts;\n          if (generateLatex) {\n            collectedLatexResult = \"$$\" + stringsEmittedByUserPrintouts + \"$$\";\n          }\n        } else {\n          //console.log \"emitted string before collectPlainStringFromReturnValue: >\" + stringsEmittedByUserPrintouts + \"<\"\n          //console.log \"allReturnedPlainStrings string before collectPlainStringFromReturnValue: >\" + allReturnedPlainStrings + \"<\"\n          collectedPlainResult = print_expr(p2);\n          collectedPlainResult += \"\\n\";\n          //console.log \"collectedPlainResult: >\" + collectedPlainResult + \"<\"\n          if (generateLatex) {\n            collectedLatexResult = \"$$\" + collectLatexStringFromReturnValue(p2) + \"$$\";\n            if (DEBUG) {\n              console.log(\"collectedLatexResult: \" + collectedLatexResult);\n            }\n          }\n        }\n        allReturnedPlainStrings += collectedPlainResult;\n        if (generateLatex) {\n          allReturnedLatexStrings += collectedLatexResult;\n        }\n        if (PRINTOUTRESULT) {\n          if (DEBUG) {\n            console.log(\"printline\");\n          }\n          if (DEBUG) {\n            console.log(collectedPlainResult);\n          }\n        }\n        //alert collectedPlainResult\n        if (PRINTOUTRESULT) {\n          if (DEBUG) {\n            console.log(\"display:\");\n          }\n          print2dascii(p2);\n        }\n        if (generateLatex) {\n          allReturnedLatexStrings += \"\\n\";\n        }\n      } catch (error1) {\n        error = error1;\n        errorWhileExecution = true;\n        collectedPlainResult = error.message;\n        if (generateLatex) {\n          collectedLatexResult = turnErrorMessageToLatex(error.message);\n        }\n        if (PRINTOUTRESULT) {\n          console.log(collectedPlainResult);\n        }\n        allReturnedPlainStrings += collectedPlainResult;\n        if (collectedPlainResult !== \"\") {\n          allReturnedPlainStrings += \"\\n\";\n        }\n        if (generateLatex) {\n          allReturnedLatexStrings += collectedLatexResult;\n          allReturnedLatexStrings += \"\\n\";\n        }\n        init();\n      }\n    }\n    if (allReturnedPlainStrings[allReturnedPlainStrings.length - 1] === \"\\n\") {\n      allReturnedPlainStrings = allReturnedPlainStrings.substring(0, allReturnedPlainStrings.length - 1);\n    }\n    if (generateLatex) {\n      if (allReturnedLatexStrings[allReturnedLatexStrings.length - 1] === \"\\n\") {\n        allReturnedLatexStrings = allReturnedLatexStrings.substring(0, allReturnedLatexStrings.length - 1);\n      }\n    }\n    if (generateLatex) {\n      if (DEBUG) {\n        console.log(\"allReturnedLatexStrings: \" + allReturnedLatexStrings);\n      }\n      stringToBeReturned = [allReturnedPlainStrings, allReturnedLatexStrings];\n    } else {\n      stringToBeReturned = allReturnedPlainStrings;\n    }\n    if (TIMING_DEBUGS) {\n      timingDebugWrite = \"run time on: \" + stringToBeRun + \" : \" + (new Date().getTime() - timeStart) + \"ms\";\n      console.log(timingDebugWrite);\n    }\n    allReturnedPlainStrings = \"\";\n    allReturnedLatexStrings = \"\";\n    return stringToBeReturned;\n  };\n\n  check_stack = function() {\n    if (tos !== 0) {\n      debugger;\n      stop(\"stack error\");\n    }\n    if (frame !== TOS) {\n      debugger;\n      stop(\"frame error\");\n    }\n    if (chainOfUserSymbolsNotFunctionsBeingEvaluated.length !== 0) {\n      debugger;\n      stop(\"symbols evaluation still ongoing?\");\n    }\n    if (evaluatingAsFloats !== 0) {\n      debugger;\n      stop(\"numeric evaluation still ongoing?\");\n    }\n    if (evaluatingPolar !== 0) {\n      debugger;\n      return stop(\"evaluation of polar still ongoing?\");\n    }\n  };\n\n  // cannot reference symbols yet\n\n  // returns nil on stack if no result to print\n  top_level_eval = function() {\n    var evalledArgument, originalArgument, shouldAutoexpand;\n    if (DEBUG) {\n      console.log(\"#### top level eval\");\n    }\n    trigmode = 0;\n    shouldAutoexpand = symbol(AUTOEXPAND);\n    if (isZeroAtomOrTensor(get_binding(shouldAutoexpand))) {\n      expanding = 0;\n    } else {\n      expanding = 1;\n    }\n    originalArgument = top();\n    Eval();\n    evalledArgument = top();\n    // \"draw\", \"for\" and \"setq\" return \"nil\", there is no result to print\n    if (evalledArgument === symbol(NIL)) {\n      return;\n    }\n    // update \"last\" to contain the last result\n    set_binding(symbol(LAST), evalledArgument);\n    if (!isZeroAtomOrTensor(get_binding(symbol(BAKE)))) {\n      bake();\n      evalledArgument = top();\n    }\n    // If user asked explicitly asked to evaluate \"i\" or \"j\" and\n    // they represent the imaginary unit (-1)^(1/2), then \n    // show (-1)^(1/2).\n    if ((originalArgument === symbol(SYMBOL_I) || originalArgument === symbol(SYMBOL_J)) && isimaginaryunit(evalledArgument)) {\n\n    // In all other cases, replace all instances of (-1)^(1/2) in the result\n    // with the symbol \"i\" or \"j\" depending on which one\n    // represents the imaginary unit\n    } else if (isimaginaryunit(get_binding(symbol(SYMBOL_J)))) {\n      push(imaginaryunit);\n      push_symbol(SYMBOL_J);\n      return subst();\n    } else if (isimaginaryunit(get_binding(symbol(SYMBOL_I)))) {\n      push(imaginaryunit);\n      push_symbol(SYMBOL_I);\n      return subst();\n    }\n  };\n\n  check_esc_flag = function() {\n    if (esc_flag) {\n      return stop(\"esc key\");\n    }\n  };\n\n  // this is called when the whole notebook is re-run\n  // so we get the chance of clearing the whole state from\n  // scratch.\n  // In practice, the state we need to clear that persists\n  // across blocks are only the patterns, so\n  // just eject those.\n  clearAlgebraEnvironment = function() {\n    //console.log \"CLEARING clearAlgebraEnvironment =============================================================\"\n    return do_clearall();\n  };\n\n  computeDependenciesFromAlgebra = function(codeFromAlgebraBlock) {\n    var i, keepState, l1, len, len1, m1, originalcodeFromAlgebraBlock, userSimplificationsInProgramForm;\n    if (DEBUG) {\n      console.log(\"computeDependenciesFromAlgebra!!!\");\n    }\n    // return findDependenciesInScript(codeFromAlgebraBlock, true)[6]\n\n    // TODO this part below is duplicated from computeResultsAndJavaScriptFromAlgebra\n    //      ...should refactor.\n    originalcodeFromAlgebraBlock = codeFromAlgebraBlock;\n    keepState = true;\n    called_from_Algebra_block = true;\n    //console.log \"codeFromAlgebraBlock: \" + codeFromAlgebraBlock\n    codeFromAlgebraBlock = normaliseDots(codeFromAlgebraBlock);\n    if (!keepState) {\n      userSimplificationsInListForm = [];\n      userSimplificationsInProgramForm = \"\";\n      for (l1 = 0, len = userSimplificationsInListForm.length; l1 < len; l1++) {\n        i = userSimplificationsInListForm[l1];\n        //console.log \"silentpattern(\" + car(i) + \",\"+cdr(i)+\")\"\n        userSimplificationsInProgramForm += \"silentpattern(\" + car(i) + \",\" + car(cdr(i)) + \",\" + car(cdr(cdr(i))) + \")\\n\";\n      }\n      do_clearall();\n      codeFromAlgebraBlock = userSimplificationsInProgramForm + codeFromAlgebraBlock;\n      if (DEBUG) {\n        console.log(\"codeFromAlgebraBlock including patterns: \" + codeFromAlgebraBlock);\n      }\n    }\n    if (DEBUG) {\n      console.log(\"computeDependenciesFromAlgebra: patterns in the list --------------- \");\n      for (m1 = 0, len1 = userSimplificationsInListForm.length; m1 < len1; m1++) {\n        i = userSimplificationsInListForm[m1];\n        console.log(car(i) + \",\" + cdr(i) + \")\");\n      }\n      console.log(\"...end of list --------------- \");\n    }\n    called_from_Algebra_block = false;\n    return findDependenciesInScript(codeFromAlgebraBlock, true)[6];\n  };\n\n  computeResultsAndJavaScriptFromAlgebra = function(codeFromAlgebraBlock) {\n    var code, dependencyInfo, i, keepState, l1, latexResult, len, len1, m1, originalcodeFromAlgebraBlock, readableSummaryOfCode, result, stringToBeRun, testableStringIsIgnoredHere, timeStartFromAlgebra, userSimplificationsInProgramForm;\n    originalcodeFromAlgebraBlock = codeFromAlgebraBlock;\n    keepState = true;\n    called_from_Algebra_block = true;\n    timeStartFromAlgebra = new Date().getTime();\n    if (TIMING_DEBUGS) {\n      console.log(\" --------- computeResultsAndJavaScriptFromAlgebra input: \" + codeFromAlgebraBlock + \" at: \" + (new Date()));\n    }\n    // we start \"clean\" each time:\n    // clear all the symbols and then re-define\n    // the \"starting\" symbols.\n\n    //console.log \"codeFromAlgebraBlock: \" + codeFromAlgebraBlock\n    codeFromAlgebraBlock = normaliseDots(codeFromAlgebraBlock);\n    stringToBeRun = codeFromAlgebraBlock;\n    if (DEBUG) {\n      console.log(\"computeResultsAndJavaScriptFromAlgebra: patterns in the list --------------- \");\n      for (l1 = 0, len = userSimplificationsInListForm.length; l1 < len; l1++) {\n        i = userSimplificationsInListForm[l1];\n        console.log(car(i) + \",\" + cdr(i) + \")\");\n      }\n      console.log(\"...end of list --------------- \");\n    }\n    if (!keepState) {\n      userSimplificationsInListForm = [];\n      userSimplificationsInProgramForm = \"\";\n      for (m1 = 0, len1 = userSimplificationsInListForm.length; m1 < len1; m1++) {\n        i = userSimplificationsInListForm[m1];\n        //console.log \"silentpattern(\" + car(i) + \",\"+cdr(i)+\")\"\n        userSimplificationsInProgramForm += \"silentpattern(\" + car(i) + \",\" + car(cdr(i)) + \",\" + car(cdr(cdr(i))) + \")\\n\";\n      }\n      do_clearall();\n      codeFromAlgebraBlock = userSimplificationsInProgramForm + codeFromAlgebraBlock;\n      if (DEBUG) {\n        console.log(\"codeFromAlgebraBlock including patterns: \" + codeFromAlgebraBlock);\n      }\n    }\n    //debugger\n    [testableStringIsIgnoredHere, result, code, readableSummaryOfCode, latexResult, errorMessage, dependencyInfo] = findDependenciesInScript(codeFromAlgebraBlock);\n    called_from_Algebra_block = false;\n    if (readableSummaryOfCode !== \"\" || errorMessage !== \"\") {\n      result += \"\\n\" + readableSummaryOfCode;\n      if (errorMessage !== \"\") {\n        result += \"\\n\" + errorMessage;\n      }\n      result = result.replace(/\\n/g, \"\\n\\n\");\n      latexResult += \"\\n\" + \"$$\" + readableSummaryOfCode + \"$$\";\n      if (errorMessage !== \"\") {\n        latexResult += turnErrorMessageToLatex(errorMessage);\n      }\n      latexResult = latexResult.replace(/\\n/g, \"\\n\\n\");\n    }\n    // remove empty results altogether from latex output, which happens\n    // for example for assignments to variables or\n    // functions definitions\n    latexResult = latexResult.replace(/\\n*/, \"\");\n    latexResult = latexResult.replace(/\\$\\$\\$\\$\\n*/g, \"\");\n    code = code.replace(/Math\\./g, \"\");\n    code = code.replace(/\\n/g, \"\\n\\n\");\n    //console.log \"code: \" + code\n    //console.log \"result: \" + result\n    //console.log \"latexResult: \" + latexResult\n    if (TIMING_DEBUGS) {\n      console.log(\"computeResultsAndJavaScriptFromAlgebra time (total time from notebook and back) for: \" + stringToBeRun + \" : \" + ((new Date().getTime()) - timeStartFromAlgebra) + \"ms\");\n    }\n    return {\n      //code: \"// no code generated yet\\n//try again later\"\n      //code: \"console.log('some passed code is run'); window.something = 1;\"\n      code: code,\n      // TODO temporarily pass latex in place of standard result too\n      result: latexResult,\n      latexResult: latexResult,\n      dependencyInfo: dependencyInfo\n    };\n  };\n\n  (typeof exports !== \"undefined\" && exports !== null ? exports : this).run = run;\n\n  (typeof exports !== \"undefined\" && exports !== null ? exports : this).findDependenciesInScript = findDependenciesInScript;\n\n  (typeof exports !== \"undefined\" && exports !== null ? exports : this).computeDependenciesFromAlgebra = computeDependenciesFromAlgebra;\n\n  (typeof exports !== \"undefined\" && exports !== null ? exports : this).computeResultsAndJavaScriptFromAlgebra = computeResultsAndJavaScriptFromAlgebra;\n\n  (typeof exports !== \"undefined\" && exports !== null ? exports : this).clearAlgebraEnvironment = clearAlgebraEnvironment;\n\n  //   _______\n  //  |  | <- stack\n  //  |  |\n  //  |_______|\n  //  |  | <- stack + tos\n  //  |  |\n  //  |  |\n  //  |_______|\n  //  |  | <- frame\n  //  |_______|\n  //      <- stack + TOS\n\n  //  The stack grows from low memory towards high memory. This is so that\n  //  multiple expressions can be pushed on the stack and then accessed as an\n  //  array.\n\n  //  The frame area holds local variables and grows from high memory towards\n  //  low memory. The frame area makes local variables visible to the garbage\n  //  collector.\n  tos = 0;\n\n  // p is a U\n  nil_symbols = 0;\n\n  push = function(p) {\n    if (p == null) {\n      debugger;\n    }\n    if (p.isZero != null) {\n      debugger;\n    }\n    //console.log \"pushing \"\n    //console.log print_list(p)\n    if (p === symbol(NIL)) {\n      nil_symbols++;\n      if (DEBUG) {\n        console.log(\"pushing symbol(NIL) #\" + nil_symbols);\n      }\n    }\n    //if nil_symbols == 111\n    //  debugger\n    if (tos >= frame) {\n      stop(\"stack overflow\");\n    }\n    return stack[tos++] = p;\n  };\n\n  // returns a U\n  moveTos = function(stackPos) {\n    if (tos <= stackPos) {\n      // we are moving the stack pointer\n      // \"up\" the stack (as if we were doing a push)\n      tos = stackPos;\n      return;\n    }\n    // we are moving the stack pointer\n    // \"down\" the stack i.e. as if we were\n    // doing a pop, we can zero-\n    // out all the elements that we pass\n    // so we can reclaim the memory\n    while (tos > stackPos) {\n      stack[tos] = null;\n      tos--;\n    }\n  };\n\n  top = function() {\n    return stack[tos - 1];\n  };\n\n  pop = function() {\n    var elementToBeReturned;\n    //popsNum++\n    //console.log \"pop #\" + popsNum\n    if (tos === 0) {\n      debugger;\n      stop(\"stack underflow\");\n    }\n    if (stack[tos - 1] == null) {\n      debugger;\n    }\n    elementToBeReturned = stack[--tos];\n    \n    // give a chance to the garbage\n    // collection to reclaim space\n    // This is JS-specific, it would\n    // actually make the C garbage\n    // collector useless.\n    stack[tos] = null;\n    return elementToBeReturned;\n  };\n\n  // n is an integer\n  push_frame = function(n) {\n    var i, l1, ref2, results;\n    i = 0;\n    frame -= n;\n    if (frame < tos) {\n      debugger;\n      stop(\"frame overflow, circular reference?\");\n    }\n    results = [];\n    for (i = l1 = 0, ref2 = n; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      results.push(stack[frame + i] = symbol(NIL));\n    }\n    return results;\n  };\n\n  // n is an integer\n  pop_frame = function(n) {\n    frame += n;\n    if (frame > TOS) {\n      return stop(\"frame underflow\");\n    }\n  };\n\n  save = function() {\n    frame -= 10;\n    if (frame < tos) {\n      debugger;\n      stop(\"frame overflow, circular reference?\");\n    }\n    stack[frame + 0] = p0;\n    stack[frame + 1] = p1;\n    stack[frame + 2] = p2;\n    stack[frame + 3] = p3;\n    stack[frame + 4] = p4;\n    stack[frame + 5] = p5;\n    stack[frame + 6] = p6;\n    stack[frame + 7] = p7;\n    stack[frame + 8] = p8;\n    return stack[frame + 9] = p9;\n  };\n\n  restore = function() {\n    if (frame > TOS - 10) {\n      stop(\"frame underflow\");\n    }\n    p0 = stack[frame + 0];\n    p1 = stack[frame + 1];\n    p2 = stack[frame + 2];\n    p3 = stack[frame + 3];\n    p4 = stack[frame + 4];\n    p5 = stack[frame + 5];\n    p6 = stack[frame + 6];\n    p7 = stack[frame + 7];\n    p8 = stack[frame + 8];\n    p9 = stack[frame + 9];\n    return frame += 10;\n  };\n\n  // Local U * is OK here because there is no functional path to the garbage collector.\n  swap = function() {\n    var p, q;\n    //U *p, *q\n    // p and q are both Us\n    p = pop();\n    q = pop();\n    push(p);\n    return push(q);\n  };\n\n  // Local U * is OK here because there is no functional path to the garbage collector.\n  dupl = function() {\n    var p;\n    //U *p\n    p = pop();\n    push(p);\n    return push(p);\n  };\n\n  $.dupl = dupl;\n\n  $.swap = swap;\n\n  $.restore = restore;\n\n  $.save = save;\n\n  $.push = push;\n\n  $.pop = pop;\n\n  // The symbol table is a simple array of struct U.\n\n  // put symbol at index n\n  Eval_symbolsinfo = function() {\n    var symbolsinfoToBePrinted;\n    symbolsinfoToBePrinted = symbolsinfo();\n    if (symbolsinfoToBePrinted !== \"\") {\n      return push(new_string(symbolsinfoToBePrinted));\n    } else {\n      return push_symbol(NIL);\n    }\n  };\n\n  symbolsinfo = function() {\n    var bindingi, i, l1, ref2, ref3, symbolsinfoToBePrinted, symtabi;\n    symbolsinfoToBePrinted = \"\";\n    for (i = l1 = ref2 = NIL + 1, ref3 = symtab.length; (ref2 <= ref3 ? l1 < ref3 : l1 > ref3); i = ref2 <= ref3 ? ++l1 : --l1) {\n      if (symtab[i].printname === \"\") {\n        if (isSymbolReclaimable[i] === false) {\n          break;\n        } else {\n          continue;\n        }\n      }\n      symtabi = symtab[i] + \"\";\n      bindingi = (binding[i] + \"\").substring(0, 4);\n      symbolsinfoToBePrinted += \"symbol: \" + symtabi + \" size: \" + countsize(binding[i]) + \" value: \" + bindingi + \"...\\n\";\n    }\n    return symbolsinfoToBePrinted;\n  };\n\n  // s is a string, n is an int\n  // TODO: elsewhere when we create a symbol we\n  // rather prefer to create a new entry. Here we just\n  // reuse the existing one. If that can never be a problem\n  // then explain why, otherwise do create a new entry.\n  std_symbol = function(s, n, latexPrint) {\n    var p;\n    p = symtab[n];\n    if (p == null) {\n      debugger;\n    }\n    p.printname = s;\n    if (latexPrint != null) {\n      return p.latexPrint = latexPrint;\n    } else {\n      return p.latexPrint = s;\n    }\n  };\n\n  // symbol lookup, or symbol creation if symbol doesn't exist yet\n  // this happens often from the scanner. When the scanner sees something\n  // like myVar = 2, it create a tree (SETQ (\"myVar\" symbol as created/looked up here (2)))\n  // user-defined functions also have a usr symbol.\n\n  // Note that some symbols like, say, \"abs\",\n  // are picked up by the scanner directly as keywords,\n  // so they are not looked up via this.\n  // So in fact you could redefine abs to be abs(x) = x\n  // but still abs would be picked up by the scanner as a particular\n  // node type and calls to abs() will be always to the \"native\" abs\n\n  // Also note that some symbols such as \"zero\" are (strangely) not picked up by\n  // the scanner as special nodes, rather they are identified as keywords\n  // (e.g. not redefinable) at time of symbol lookup (in Eval_sym) and\n  // evalled, where eval has a case for ZERO.\n\n  // Also note that there are a number of symbols, such as a,b,c,x,y,z,...\n  // that are actually created by std_symbols.\n  // They are not special node types (like abs), they are normal symbols\n  // that are looked up, but the advantage is that since they are often\n  // used internally by algebrite, we create the symbol in advance and\n  // we can reference the symbol entry in a clean way\n  // (e.g. symbol(SYMBOL_X)) rather than\n  // by looking up a string.\n\n  // s is a string\n  usr_symbol = function(s) {\n    var i, l1, ref2;\n    //console.log \"usr_symbol of \" + s\n    //if s == \"aaa\"\n    //  debugger\n\n    // find either the existing symbol, or if we\n    // reach an empty symbol (printname == \"\") then\n    // re-use that location.\n    i = 0;\n    for (i = l1 = 0, ref2 = NSYM; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      if (s === symtab[i].printname) {\n        // found the symbol\n        return symtab[i];\n      }\n      if (symtab[i].printname === \"\") {\n        // found an entry in the symbol table\n        // with no printname, exit the loop\n        // and re-use this location\n        break;\n      }\n    }\n    if (i === NSYM) {\n      stop(\"symbol table overflow\");\n    }\n    symtab[i] = new U();\n    symtab[i].k = SYM;\n    symtab[i].printname = s;\n    // say that we just created the symbol\n    // then, binding[the new symbol entry]\n    // by default points to the symbol.\n    // So the value of an unassigned symbol will\n    // be just its name.\n    binding[i] = symtab[i];\n    isSymbolReclaimable[i] = false;\n    return symtab[i];\n  };\n\n  // get the symbol's printname\n\n  // p is a U\n  get_printname = function(p) {\n    if (p.k !== SYM) {\n      stop(\"symbol error\");\n    }\n    return p.printname;\n  };\n\n  // p and q are both U\n  // there are two Us at play here. One belongs to the\n  // symtab array and is the variable name.\n  // The other one is the U with the content, and that\n  // one will go in the corresponding \"binding\" array entry.\n  set_binding = function(p, q) {\n    var indexFound;\n    if (p.k !== SYM) {\n      stop(\"symbol error\");\n    }\n    //console.log \"setting binding of \" + p.toString() + \" to: \" + q.toString()\n    //if p.toString() == \"aaa\"\n    //  debugger\n    indexFound = symtab.indexOf(p);\n    /*\n    if indexFound == -1\n      debugger\n      for i in [0...symtab.length]\n        if p.printname == symtab[i].printname\n          indexFound = i\n          console.log \"remedied an index not found!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\"\n          break\n    */\n    if (symtab.indexOf(p, indexFound + 1) !== -1) {\n      console.log(\"ops, more than one element!\");\n      debugger;\n    }\n    if (DEBUG) {\n      console.log(\"lookup >> set_binding lookup \" + indexFound);\n    }\n    isSymbolReclaimable[indexFound] = false;\n    return binding[indexFound] = q;\n  };\n\n  // p is a U\n  get_binding = function(p) {\n    var indexFound;\n    if (p.k !== SYM) {\n      stop(\"symbol error\");\n    }\n    //console.log \"getting binding of \" + p.toString()\n    //if p.toString() == \"aaa\"\n    //  debugger\n    indexFound = symtab.indexOf(p);\n    /*\n    if indexFound == -1\n      debugger\n      for i in [0...symtab.length]\n        if p.printname == symtab[i].printname\n          indexFound = i\n          console.log \"remedied an index not found!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\"\n          break\n    */\n    if (symtab.indexOf(p, indexFound + 1) !== -1) {\n      console.log(\"ops, more than one element!\");\n      debugger;\n    }\n    if (DEBUG) {\n      console.log(\"lookup >> get_binding lookup \" + indexFound);\n    }\n    //if indexFound == 139\n    //  debugger\n    //if indexFound == 137\n    //  debugger\n    return binding[indexFound];\n  };\n\n  // the concept of user symbol is a little fuzzy\n  // beucase mathematics is full of symbols that actually\n  // have a special meaning, e.g. e,i,I in some cases j...\n  is_usr_symbol = function(p) {\n    var theSymnum;\n    if (p.k !== SYM) {\n      return false;\n    }\n    theSymnum = symnum(p);\n    // see \"defs\" file for the naming of the symbols\n    if (theSymnum > PI && theSymnum !== SYMBOL_I && theSymnum !== SYMBOL_IDENTITY_MATRIX) {\n      return true;\n    }\n    return false;\n  };\n\n  // get symbol's number from ptr\n  // p is U\n  lookupsTotal = 0;\n\n  symnum = function(p) {\n    var indexFound;\n    lookupsTotal++;\n    if (p.k !== SYM) {\n      stop(\"symbol error\");\n    }\n    indexFound = symtab.indexOf(p);\n    if (symtab.indexOf(p, indexFound + 1) !== -1) {\n      console.log(\"ops, more than one element!\");\n      debugger;\n    }\n    if (DEBUG) {\n      console.log(\"lookup >> symnum lookup \" + indexFound + \" lookup # \" + lookupsTotal);\n    }\n    //if lookupsTotal == 21\n    //  debugger\n    //if indexFound == 79\n    //  debugger\n    return indexFound;\n  };\n\n  // push indexed symbol\n\n  // k is an int\n  push_symbol = function(k) {\n    return push(symtab[k]);\n  };\n\n  clear_symbols = function() {\n    var i, l1, ref2, ref3, results;\n// we can clear just what's assignable.\n// everything before NIL is not assignable,\n// so there is no need to clear it.\n    results = [];\n    for (i = l1 = ref2 = NIL + 1, ref3 = NSYM; (ref2 <= ref3 ? l1 < ref3 : l1 > ref3); i = ref2 <= ref3 ? ++l1 : --l1) {\n      // stop at the first empty\n      // entry that is not reclaimable\n      if (symtab[i].printname === \"\") {\n        if (isSymbolReclaimable[i] === false) {\n          break;\n        } else {\n          continue;\n        }\n      }\n      symtab[i] = new U();\n      symtab[i].k = SYM;\n      binding[i] = symtab[i];\n      results.push(isSymbolReclaimable[i] = false);\n    }\n    return results;\n  };\n\n  //symtab[i].printname = \"\"\n  //binding[i] = symtab[i]\n\n  // collect all the variables in a tree\n  collectUserSymbols = function(p, accumulator = []) {\n    var i, l1, ref2;\n    if (is_usr_symbol(p)) {\n      if (accumulator.indexOf(p) === -1) {\n        accumulator.push(p);\n        return;\n      }\n    }\n    if (istensor(p)) {\n      for (i = l1 = 0, ref2 = p.tensor.nelem; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n        collectUserSymbols(p.tensor.elem[i], accumulator);\n      }\n      return;\n    }\n    while (iscons(p)) {\n      collectUserSymbols(car(p), accumulator);\n      p = cdr(p);\n    }\n  };\n\n  $.get_binding = get_binding;\n\n  $.set_binding = set_binding;\n\n  $.usr_symbol = usr_symbol;\n\n  $.symbolsinfo = symbolsinfo;\n\n  $.collectUserSymbols = collectUserSymbols;\n\n  if (!inited) {\n    inited = true;\n    init();\n  }\n\n  $.init = init;\n\n  parse_internal = function(argu) {\n    if (typeof argu === 'string') {\n      return scan(argu);\n    // now its in the stack\n    } else if (typeof argu === 'number') {\n      if (argu % 1 === 0) {\n        return push_integer(argu);\n      } else {\n        return push_double(argu);\n      }\n    } else if (argu instanceof U) {\n      // hey look its a U\n      return push(argu);\n    } else {\n      console.warn('unknown argument type', argu);\n      return push(symbol(NIL));\n    }\n  };\n\n  parse = function(argu) {\n    var data, error;\n    try {\n      parse_internal(argu);\n      data = pop();\n      check_stack();\n    } catch (error1) {\n      error = error1;\n      reset_after_error();\n      throw error;\n    }\n    return data;\n  };\n\n  // exec handles the running ia JS of all the algebrite\n  // functions. The function name is passed in \"name\" and\n  // the corresponding function is pushed at the top of the stack\n  exec = function(name, ...argus) {\n    var argu, error, fn, l1, len, result;\n    fn = get_binding(usr_symbol(name));\n    check_stack();\n    push(fn);\n    for (l1 = 0, len = argus.length; l1 < len; l1++) {\n      argu = argus[l1];\n      parse_internal(argu);\n    }\n    list(1 + argus.length);\n    p1 = pop();\n    push(p1);\n    try {\n      top_level_eval();\n      result = pop();\n      check_stack();\n    } catch (error1) {\n      error = error1;\n      reset_after_error();\n      throw error;\n    }\n    return result;\n  };\n\n  $.exec = exec;\n\n  $.parse = parse;\n\n  (function() {\n    var builtin_fns, fn, l1, len, results;\n    builtin_fns = [\"abs\", \"add\", \"adj\", \"and\", \"approxratio\", \"arccos\", \"arccosh\", \"arcsin\", \"arcsinh\", \"arctan\", \"arctanh\", \"arg\", \"atomize\", \"besselj\", \"bessely\", \"binding\", \"binomial\", \"ceiling\", \"check\", \"choose\", \"circexp\", \"clear\", \"clearall\", \"clearpatterns\", \"clock\", \"coeff\", \"cofactor\", \"condense\", \"conj\", \"contract\", \"cos\", \"cosh\", \"decomp\", \"defint\", \"deg\", \"denominator\", \"det\", \"derivative\", \"dim\", \"dirac\", \"divisors\", \"do\", \"dot\", \"draw\", \"dsolve\", \"eigen\", \"eigenval\", \"eigenvec\", \"erf\", \"erfc\", \"eval\", \"exp\", \"expand\", \"expcos\", \"expsin\", \"factor\", \"factorial\", \"factorpoly\", \"filter\", \"float\", \"floor\", \"for\", \"Gamma\", \"gcd\", \"hermite\", \"hilbert\", \"imag\", \"component\", \"inner\", \"integral\", \"inv\", \"invg\", \"isinteger\", \"isprime\", \"laguerre\", \"lcm\", \"leading\", \"legendre\", \"log\", \"mod\", \"multiply\", \"not\", \"nroots\", \"number\", \"numerator\", \"operator\", \"or\", \"outer\", \"pattern\", \"patternsinfo\", \"polar\", \"power\", \"prime\", \"print\", \"print2dascii\", \"printcomputer\", \"printlatex\", \"printlist\", \"printhuman\", \"product\", \"quote\", \"quotient\", \"rank\", \"rationalize\", \"real\", \"rect\", \"roots\", \"round\", \"equals\", \"shape\", \"sgn\", \"silentpattern\", \"simplify\", \"sin\", \"sinh\", \"sqrt\", \"stop\", \"subst\", \"sum\", \"symbolsinfo\", \"tan\", \"tanh\", \"taylor\", \"test\", \"testeq\", \"testge\", \"testgt\", \"testle\", \"testlt\", \"transpose\", \"unit\", \"zero\"];\n    results = [];\n    for (l1 = 0, len = builtin_fns.length; l1 < len; l1++) {\n      fn = builtin_fns[l1];\n      results.push($[fn] = exec.bind(this, fn));\n    }\n    return results;\n  })();\n\n  freeze = function() {\n    var frozenContents, frozenHash, frozenPatterns, frozenSymbols, i, l1, ref2;\n    frozenSymbols = [];\n    frozenContents = [];\n    frozenPatterns = [];\n    frozenHash = \"\";\n    for (i = l1 = 0, ref2 = symtab.length; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      //if symtab[i].printname == \"\"\n      //  if isSymbolReclaimable[i] == false\n      //    break\n      //  else\n      //    continue\n      if (isSymbolReclaimable[i] === false) {\n        frozenSymbols.push(symtab[i]);\n        frozenContents.push(binding[i]);\n      }\n    }\n    // just clone them\n    frozenPatterns = userSimplificationsInListForm.slice(0);\n    return [frozenSymbols, frozenContents, frozenPatterns, zero, one, imaginaryunit, getStateHash()];\n  };\n\n  unfreeze = function(frozen) {\n    var frozenContents, frozenPatterns, frozenSymbols, i, l1, ref2;\n    [frozenSymbols, frozenContents, frozenPatterns, zero, one, imaginaryunit] = frozen;\n//clear_symbols()\n    for (i = l1 = 0, ref2 = frozenSymbols.length; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      symtab[i] = frozenSymbols[i];\n      binding[i] = frozenContents[i];\n    }\n    return userSimplificationsInListForm = frozenPatterns.slice(0);\n  };\n\n  compareState = function(previousHash) {\n    var frozenHash;\n    frozenHash = getStateHash();\n    if (frozenHash === previousHash) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  getStateHash = function() {\n    var bindingi, frozenHash, i, l1, len, m1, ref2, ref3, symtabi;\n    frozenHash = \"\";\n    for (i = l1 = ref2 = NIL + 1, ref3 = symtab.length; (ref2 <= ref3 ? l1 < ref3 : l1 > ref3); i = ref2 <= ref3 ? ++l1 : --l1) {\n      if (symtab[i].printname === \"\") {\n        if (isSymbolReclaimable[i] === false) {\n          break;\n        } else {\n          continue;\n        }\n      }\n      symtabi = print_list(symtab[i]);\n      bindingi = print_list(binding[i]);\n      frozenHash += \" //\" + symtabi + \" : \" + bindingi;\n    }\n    for (m1 = 0, len = userSimplificationsInListForm.length; m1 < len; m1++) {\n      i = userSimplificationsInListForm[m1];\n      frozenHash += \" pattern: \" + i;\n    }\n    if (DEBUG) {\n      console.log(\"frozenHash: \" + frozenHash);\n    }\n    return frozenHash;\n  };\n\n}).call(this);\n","var bigInt = (function (undefined) {\r\n    \"use strict\";\r\n\r\n    var BASE = 1e7,\r\n        LOG_BASE = 7,\r\n        MAX_INT = 9007199254740992,\r\n        MAX_INT_ARR = smallToArray(MAX_INT),\r\n        DEFAULT_ALPHABET = \"0123456789abcdefghijklmnopqrstuvwxyz\";\r\n\r\n    var supportsNativeBigInt = typeof BigInt === \"function\";\r\n\r\n    function Integer(v, radix, alphabet, caseSensitive) {\r\n        if (typeof v === \"undefined\") return Integer[0];\r\n        if (typeof radix !== \"undefined\") return +radix === 10 && !alphabet ? parseValue(v) : parseBase(v, radix, alphabet, caseSensitive);\r\n        return parseValue(v);\r\n    }\r\n\r\n    function BigInteger(value, sign) {\r\n        this.value = value;\r\n        this.sign = sign;\r\n        this.isSmall = false;\r\n    }\r\n    BigInteger.prototype = Object.create(Integer.prototype);\r\n\r\n    function SmallInteger(value) {\r\n        this.value = value;\r\n        this.sign = value < 0;\r\n        this.isSmall = true;\r\n    }\r\n    SmallInteger.prototype = Object.create(Integer.prototype);\r\n\r\n    function NativeBigInt(value) {\r\n        this.value = value;\r\n    }\r\n    NativeBigInt.prototype = Object.create(Integer.prototype);\r\n\r\n    function isPrecise(n) {\r\n        return -MAX_INT < n && n < MAX_INT;\r\n    }\r\n\r\n    function smallToArray(n) { // For performance reasons doesn't reference BASE, need to change this function if BASE changes\r\n        if (n < 1e7)\r\n            return [n];\r\n        if (n < 1e14)\r\n            return [n % 1e7, Math.floor(n / 1e7)];\r\n        return [n % 1e7, Math.floor(n / 1e7) % 1e7, Math.floor(n / 1e14)];\r\n    }\r\n\r\n    function arrayToSmall(arr) { // If BASE changes this function may need to change\r\n        trim(arr);\r\n        var length = arr.length;\r\n        if (length < 4 && compareAbs(arr, MAX_INT_ARR) < 0) {\r\n            switch (length) {\r\n                case 0: return 0;\r\n                case 1: return arr[0];\r\n                case 2: return arr[0] + arr[1] * BASE;\r\n                default: return arr[0] + (arr[1] + arr[2] * BASE) * BASE;\r\n            }\r\n        }\r\n        return arr;\r\n    }\r\n\r\n    function trim(v) {\r\n        var i = v.length;\r\n        while (v[--i] === 0);\r\n        v.length = i + 1;\r\n    }\r\n\r\n    function createArray(length) { // function shamelessly stolen from Yaffle's library https://github.com/Yaffle/BigInteger\r\n        var x = new Array(length);\r\n        var i = -1;\r\n        while (++i < length) {\r\n            x[i] = 0;\r\n        }\r\n        return x;\r\n    }\r\n\r\n    function truncate(n) {\r\n        if (n > 0) return Math.floor(n);\r\n        return Math.ceil(n);\r\n    }\r\n\r\n    function add(a, b) { // assumes a and b are arrays with a.length >= b.length\r\n        var l_a = a.length,\r\n            l_b = b.length,\r\n            r = new Array(l_a),\r\n            carry = 0,\r\n            base = BASE,\r\n            sum, i;\r\n        for (i = 0; i < l_b; i++) {\r\n            sum = a[i] + b[i] + carry;\r\n            carry = sum >= base ? 1 : 0;\r\n            r[i] = sum - carry * base;\r\n        }\r\n        while (i < l_a) {\r\n            sum = a[i] + carry;\r\n            carry = sum === base ? 1 : 0;\r\n            r[i++] = sum - carry * base;\r\n        }\r\n        if (carry > 0) r.push(carry);\r\n        return r;\r\n    }\r\n\r\n    function addAny(a, b) {\r\n        if (a.length >= b.length) return add(a, b);\r\n        return add(b, a);\r\n    }\r\n\r\n    function addSmall(a, carry) { // assumes a is array, carry is number with 0 <= carry < MAX_INT\r\n        var l = a.length,\r\n            r = new Array(l),\r\n            base = BASE,\r\n            sum, i;\r\n        for (i = 0; i < l; i++) {\r\n            sum = a[i] - base + carry;\r\n            carry = Math.floor(sum / base);\r\n            r[i] = sum - carry * base;\r\n            carry += 1;\r\n        }\r\n        while (carry > 0) {\r\n            r[i++] = carry % base;\r\n            carry = Math.floor(carry / base);\r\n        }\r\n        return r;\r\n    }\r\n\r\n    BigInteger.prototype.add = function (v) {\r\n        var n = parseValue(v);\r\n        if (this.sign !== n.sign) {\r\n            return this.subtract(n.negate());\r\n        }\r\n        var a = this.value, b = n.value;\r\n        if (n.isSmall) {\r\n            return new BigInteger(addSmall(a, Math.abs(b)), this.sign);\r\n        }\r\n        return new BigInteger(addAny(a, b), this.sign);\r\n    };\r\n    BigInteger.prototype.plus = BigInteger.prototype.add;\r\n\r\n    SmallInteger.prototype.add = function (v) {\r\n        var n = parseValue(v);\r\n        var a = this.value;\r\n        if (a < 0 !== n.sign) {\r\n            return this.subtract(n.negate());\r\n        }\r\n        var b = n.value;\r\n        if (n.isSmall) {\r\n            if (isPrecise(a + b)) return new SmallInteger(a + b);\r\n            b = smallToArray(Math.abs(b));\r\n        }\r\n        return new BigInteger(addSmall(b, Math.abs(a)), a < 0);\r\n    };\r\n    SmallInteger.prototype.plus = SmallInteger.prototype.add;\r\n\r\n    NativeBigInt.prototype.add = function (v) {\r\n        return new NativeBigInt(this.value + parseValue(v).value);\r\n    }\r\n    NativeBigInt.prototype.plus = NativeBigInt.prototype.add;\r\n\r\n    function subtract(a, b) { // assumes a and b are arrays with a >= b\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            r = new Array(a_l),\r\n            borrow = 0,\r\n            base = BASE,\r\n            i, difference;\r\n        for (i = 0; i < b_l; i++) {\r\n            difference = a[i] - borrow - b[i];\r\n            if (difference < 0) {\r\n                difference += base;\r\n                borrow = 1;\r\n            } else borrow = 0;\r\n            r[i] = difference;\r\n        }\r\n        for (i = b_l; i < a_l; i++) {\r\n            difference = a[i] - borrow;\r\n            if (difference < 0) difference += base;\r\n            else {\r\n                r[i++] = difference;\r\n                break;\r\n            }\r\n            r[i] = difference;\r\n        }\r\n        for (; i < a_l; i++) {\r\n            r[i] = a[i];\r\n        }\r\n        trim(r);\r\n        return r;\r\n    }\r\n\r\n    function subtractAny(a, b, sign) {\r\n        var value;\r\n        if (compareAbs(a, b) >= 0) {\r\n            value = subtract(a, b);\r\n        } else {\r\n            value = subtract(b, a);\r\n            sign = !sign;\r\n        }\r\n        value = arrayToSmall(value);\r\n        if (typeof value === \"number\") {\r\n            if (sign) value = -value;\r\n            return new SmallInteger(value);\r\n        }\r\n        return new BigInteger(value, sign);\r\n    }\r\n\r\n    function subtractSmall(a, b, sign) { // assumes a is array, b is number with 0 <= b < MAX_INT\r\n        var l = a.length,\r\n            r = new Array(l),\r\n            carry = -b,\r\n            base = BASE,\r\n            i, difference;\r\n        for (i = 0; i < l; i++) {\r\n            difference = a[i] + carry;\r\n            carry = Math.floor(difference / base);\r\n            difference %= base;\r\n            r[i] = difference < 0 ? difference + base : difference;\r\n        }\r\n        r = arrayToSmall(r);\r\n        if (typeof r === \"number\") {\r\n            if (sign) r = -r;\r\n            return new SmallInteger(r);\r\n        } return new BigInteger(r, sign);\r\n    }\r\n\r\n    BigInteger.prototype.subtract = function (v) {\r\n        var n = parseValue(v);\r\n        if (this.sign !== n.sign) {\r\n            return this.add(n.negate());\r\n        }\r\n        var a = this.value, b = n.value;\r\n        if (n.isSmall)\r\n            return subtractSmall(a, Math.abs(b), this.sign);\r\n        return subtractAny(a, b, this.sign);\r\n    };\r\n    BigInteger.prototype.minus = BigInteger.prototype.subtract;\r\n\r\n    SmallInteger.prototype.subtract = function (v) {\r\n        var n = parseValue(v);\r\n        var a = this.value;\r\n        if (a < 0 !== n.sign) {\r\n            return this.add(n.negate());\r\n        }\r\n        var b = n.value;\r\n        if (n.isSmall) {\r\n            return new SmallInteger(a - b);\r\n        }\r\n        return subtractSmall(b, Math.abs(a), a >= 0);\r\n    };\r\n    SmallInteger.prototype.minus = SmallInteger.prototype.subtract;\r\n\r\n    NativeBigInt.prototype.subtract = function (v) {\r\n        return new NativeBigInt(this.value - parseValue(v).value);\r\n    }\r\n    NativeBigInt.prototype.minus = NativeBigInt.prototype.subtract;\r\n\r\n    BigInteger.prototype.negate = function () {\r\n        return new BigInteger(this.value, !this.sign);\r\n    };\r\n    SmallInteger.prototype.negate = function () {\r\n        var sign = this.sign;\r\n        var small = new SmallInteger(-this.value);\r\n        small.sign = !sign;\r\n        return small;\r\n    };\r\n    NativeBigInt.prototype.negate = function () {\r\n        return new NativeBigInt(-this.value);\r\n    }\r\n\r\n    BigInteger.prototype.abs = function () {\r\n        return new BigInteger(this.value, false);\r\n    };\r\n    SmallInteger.prototype.abs = function () {\r\n        return new SmallInteger(Math.abs(this.value));\r\n    };\r\n    NativeBigInt.prototype.abs = function () {\r\n        return new NativeBigInt(this.value >= 0 ? this.value : -this.value);\r\n    }\r\n\r\n\r\n    function multiplyLong(a, b) {\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            l = a_l + b_l,\r\n            r = createArray(l),\r\n            base = BASE,\r\n            product, carry, i, a_i, b_j;\r\n        for (i = 0; i < a_l; ++i) {\r\n            a_i = a[i];\r\n            for (var j = 0; j < b_l; ++j) {\r\n                b_j = b[j];\r\n                product = a_i * b_j + r[i + j];\r\n                carry = Math.floor(product / base);\r\n                r[i + j] = product - carry * base;\r\n                r[i + j + 1] += carry;\r\n            }\r\n        }\r\n        trim(r);\r\n        return r;\r\n    }\r\n\r\n    function multiplySmall(a, b) { // assumes a is array, b is number with |b| < BASE\r\n        var l = a.length,\r\n            r = new Array(l),\r\n            base = BASE,\r\n            carry = 0,\r\n            product, i;\r\n        for (i = 0; i < l; i++) {\r\n            product = a[i] * b + carry;\r\n            carry = Math.floor(product / base);\r\n            r[i] = product - carry * base;\r\n        }\r\n        while (carry > 0) {\r\n            r[i++] = carry % base;\r\n            carry = Math.floor(carry / base);\r\n        }\r\n        return r;\r\n    }\r\n\r\n    function shiftLeft(x, n) {\r\n        var r = [];\r\n        while (n-- > 0) r.push(0);\r\n        return r.concat(x);\r\n    }\r\n\r\n    function multiplyKaratsuba(x, y) {\r\n        var n = Math.max(x.length, y.length);\r\n\r\n        if (n <= 30) return multiplyLong(x, y);\r\n        n = Math.ceil(n / 2);\r\n\r\n        var b = x.slice(n),\r\n            a = x.slice(0, n),\r\n            d = y.slice(n),\r\n            c = y.slice(0, n);\r\n\r\n        var ac = multiplyKaratsuba(a, c),\r\n            bd = multiplyKaratsuba(b, d),\r\n            abcd = multiplyKaratsuba(addAny(a, b), addAny(c, d));\r\n\r\n        var product = addAny(addAny(ac, shiftLeft(subtract(subtract(abcd, ac), bd), n)), shiftLeft(bd, 2 * n));\r\n        trim(product);\r\n        return product;\r\n    }\r\n\r\n    // The following function is derived from a surface fit of a graph plotting the performance difference\r\n    // between long multiplication and karatsuba multiplication versus the lengths of the two arrays.\r\n    function useKaratsuba(l1, l2) {\r\n        return -0.012 * l1 - 0.012 * l2 + 0.000015 * l1 * l2 > 0;\r\n    }\r\n\r\n    BigInteger.prototype.multiply = function (v) {\r\n        var n = parseValue(v),\r\n            a = this.value, b = n.value,\r\n            sign = this.sign !== n.sign,\r\n            abs;\r\n        if (n.isSmall) {\r\n            if (b === 0) return Integer[0];\r\n            if (b === 1) return this;\r\n            if (b === -1) return this.negate();\r\n            abs = Math.abs(b);\r\n            if (abs < BASE) {\r\n                return new BigInteger(multiplySmall(a, abs), sign);\r\n            }\r\n            b = smallToArray(abs);\r\n        }\r\n        if (useKaratsuba(a.length, b.length)) // Karatsuba is only faster for certain array sizes\r\n            return new BigInteger(multiplyKaratsuba(a, b), sign);\r\n        return new BigInteger(multiplyLong(a, b), sign);\r\n    };\r\n\r\n    BigInteger.prototype.times = BigInteger.prototype.multiply;\r\n\r\n    function multiplySmallAndArray(a, b, sign) { // a >= 0\r\n        if (a < BASE) {\r\n            return new BigInteger(multiplySmall(b, a), sign);\r\n        }\r\n        return new BigInteger(multiplyLong(b, smallToArray(a)), sign);\r\n    }\r\n    SmallInteger.prototype._multiplyBySmall = function (a) {\r\n        if (isPrecise(a.value * this.value)) {\r\n            return new SmallInteger(a.value * this.value);\r\n        }\r\n        return multiplySmallAndArray(Math.abs(a.value), smallToArray(Math.abs(this.value)), this.sign !== a.sign);\r\n    };\r\n    BigInteger.prototype._multiplyBySmall = function (a) {\r\n        if (a.value === 0) return Integer[0];\r\n        if (a.value === 1) return this;\r\n        if (a.value === -1) return this.negate();\r\n        return multiplySmallAndArray(Math.abs(a.value), this.value, this.sign !== a.sign);\r\n    };\r\n    SmallInteger.prototype.multiply = function (v) {\r\n        return parseValue(v)._multiplyBySmall(this);\r\n    };\r\n    SmallInteger.prototype.times = SmallInteger.prototype.multiply;\r\n\r\n    NativeBigInt.prototype.multiply = function (v) {\r\n        return new NativeBigInt(this.value * parseValue(v).value);\r\n    }\r\n    NativeBigInt.prototype.times = NativeBigInt.prototype.multiply;\r\n\r\n    function square(a) {\r\n        //console.assert(2 * BASE * BASE < MAX_INT);\r\n        var l = a.length,\r\n            r = createArray(l + l),\r\n            base = BASE,\r\n            product, carry, i, a_i, a_j;\r\n        for (i = 0; i < l; i++) {\r\n            a_i = a[i];\r\n            carry = 0 - a_i * a_i;\r\n            for (var j = i; j < l; j++) {\r\n                a_j = a[j];\r\n                product = 2 * (a_i * a_j) + r[i + j] + carry;\r\n                carry = Math.floor(product / base);\r\n                r[i + j] = product - carry * base;\r\n            }\r\n            r[i + l] = carry;\r\n        }\r\n        trim(r);\r\n        return r;\r\n    }\r\n\r\n    BigInteger.prototype.square = function () {\r\n        return new BigInteger(square(this.value), false);\r\n    };\r\n\r\n    SmallInteger.prototype.square = function () {\r\n        var value = this.value * this.value;\r\n        if (isPrecise(value)) return new SmallInteger(value);\r\n        return new BigInteger(square(smallToArray(Math.abs(this.value))), false);\r\n    };\r\n\r\n    NativeBigInt.prototype.square = function (v) {\r\n        return new NativeBigInt(this.value * this.value);\r\n    }\r\n\r\n    function divMod1(a, b) { // Left over from previous version. Performs faster than divMod2 on smaller input sizes.\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            base = BASE,\r\n            result = createArray(b.length),\r\n            divisorMostSignificantDigit = b[b_l - 1],\r\n            // normalization\r\n            lambda = Math.ceil(base / (2 * divisorMostSignificantDigit)),\r\n            remainder = multiplySmall(a, lambda),\r\n            divisor = multiplySmall(b, lambda),\r\n            quotientDigit, shift, carry, borrow, i, l, q;\r\n        if (remainder.length <= a_l) remainder.push(0);\r\n        divisor.push(0);\r\n        divisorMostSignificantDigit = divisor[b_l - 1];\r\n        for (shift = a_l - b_l; shift >= 0; shift--) {\r\n            quotientDigit = base - 1;\r\n            if (remainder[shift + b_l] !== divisorMostSignificantDigit) {\r\n                quotientDigit = Math.floor((remainder[shift + b_l] * base + remainder[shift + b_l - 1]) / divisorMostSignificantDigit);\r\n            }\r\n            // quotientDigit <= base - 1\r\n            carry = 0;\r\n            borrow = 0;\r\n            l = divisor.length;\r\n            for (i = 0; i < l; i++) {\r\n                carry += quotientDigit * divisor[i];\r\n                q = Math.floor(carry / base);\r\n                borrow += remainder[shift + i] - (carry - q * base);\r\n                carry = q;\r\n                if (borrow < 0) {\r\n                    remainder[shift + i] = borrow + base;\r\n                    borrow = -1;\r\n                } else {\r\n                    remainder[shift + i] = borrow;\r\n                    borrow = 0;\r\n                }\r\n            }\r\n            while (borrow !== 0) {\r\n                quotientDigit -= 1;\r\n                carry = 0;\r\n                for (i = 0; i < l; i++) {\r\n                    carry += remainder[shift + i] - base + divisor[i];\r\n                    if (carry < 0) {\r\n                        remainder[shift + i] = carry + base;\r\n                        carry = 0;\r\n                    } else {\r\n                        remainder[shift + i] = carry;\r\n                        carry = 1;\r\n                    }\r\n                }\r\n                borrow += carry;\r\n            }\r\n            result[shift] = quotientDigit;\r\n        }\r\n        // denormalization\r\n        remainder = divModSmall(remainder, lambda)[0];\r\n        return [arrayToSmall(result), arrayToSmall(remainder)];\r\n    }\r\n\r\n    function divMod2(a, b) { // Implementation idea shamelessly stolen from Silent Matt's library http://silentmatt.com/biginteger/\r\n        // Performs faster than divMod1 on larger input sizes.\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            result = [],\r\n            part = [],\r\n            base = BASE,\r\n            guess, xlen, highx, highy, check;\r\n        while (a_l) {\r\n            part.unshift(a[--a_l]);\r\n            trim(part);\r\n            if (compareAbs(part, b) < 0) {\r\n                result.push(0);\r\n                continue;\r\n            }\r\n            xlen = part.length;\r\n            highx = part[xlen - 1] * base + part[xlen - 2];\r\n            highy = b[b_l - 1] * base + b[b_l - 2];\r\n            if (xlen > b_l) {\r\n                highx = (highx + 1) * base;\r\n            }\r\n            guess = Math.ceil(highx / highy);\r\n            do {\r\n                check = multiplySmall(b, guess);\r\n                if (compareAbs(check, part) <= 0) break;\r\n                guess--;\r\n            } while (guess);\r\n            result.push(guess);\r\n            part = subtract(part, check);\r\n        }\r\n        result.reverse();\r\n        return [arrayToSmall(result), arrayToSmall(part)];\r\n    }\r\n\r\n    function divModSmall(value, lambda) {\r\n        var length = value.length,\r\n            quotient = createArray(length),\r\n            base = BASE,\r\n            i, q, remainder, divisor;\r\n        remainder = 0;\r\n        for (i = length - 1; i >= 0; --i) {\r\n            divisor = remainder * base + value[i];\r\n            q = truncate(divisor / lambda);\r\n            remainder = divisor - q * lambda;\r\n            quotient[i] = q | 0;\r\n        }\r\n        return [quotient, remainder | 0];\r\n    }\r\n\r\n    function divModAny(self, v) {\r\n        var value, n = parseValue(v);\r\n        if (supportsNativeBigInt) {\r\n            return [new NativeBigInt(self.value / n.value), new NativeBigInt(self.value % n.value)];\r\n        }\r\n        var a = self.value, b = n.value;\r\n        var quotient;\r\n        if (b === 0) throw new Error(\"Cannot divide by zero\");\r\n        if (self.isSmall) {\r\n            if (n.isSmall) {\r\n                return [new SmallInteger(truncate(a / b)), new SmallInteger(a % b)];\r\n            }\r\n            return [Integer[0], self];\r\n        }\r\n        if (n.isSmall) {\r\n            if (b === 1) return [self, Integer[0]];\r\n            if (b == -1) return [self.negate(), Integer[0]];\r\n            var abs = Math.abs(b);\r\n            if (abs < BASE) {\r\n                value = divModSmall(a, abs);\r\n                quotient = arrayToSmall(value[0]);\r\n                var remainder = value[1];\r\n                if (self.sign) remainder = -remainder;\r\n                if (typeof quotient === \"number\") {\r\n                    if (self.sign !== n.sign) quotient = -quotient;\r\n                    return [new SmallInteger(quotient), new SmallInteger(remainder)];\r\n                }\r\n                return [new BigInteger(quotient, self.sign !== n.sign), new SmallInteger(remainder)];\r\n            }\r\n            b = smallToArray(abs);\r\n        }\r\n        var comparison = compareAbs(a, b);\r\n        if (comparison === -1) return [Integer[0], self];\r\n        if (comparison === 0) return [Integer[self.sign === n.sign ? 1 : -1], Integer[0]];\r\n\r\n        // divMod1 is faster on smaller input sizes\r\n        if (a.length + b.length <= 200)\r\n            value = divMod1(a, b);\r\n        else value = divMod2(a, b);\r\n\r\n        quotient = value[0];\r\n        var qSign = self.sign !== n.sign,\r\n            mod = value[1],\r\n            mSign = self.sign;\r\n        if (typeof quotient === \"number\") {\r\n            if (qSign) quotient = -quotient;\r\n            quotient = new SmallInteger(quotient);\r\n        } else quotient = new BigInteger(quotient, qSign);\r\n        if (typeof mod === \"number\") {\r\n            if (mSign) mod = -mod;\r\n            mod = new SmallInteger(mod);\r\n        } else mod = new BigInteger(mod, mSign);\r\n        return [quotient, mod];\r\n    }\r\n\r\n    BigInteger.prototype.divmod = function (v) {\r\n        var result = divModAny(this, v);\r\n        return {\r\n            quotient: result[0],\r\n            remainder: result[1]\r\n        };\r\n    };\r\n    NativeBigInt.prototype.divmod = SmallInteger.prototype.divmod = BigInteger.prototype.divmod;\r\n\r\n\r\n    BigInteger.prototype.divide = function (v) {\r\n        return divModAny(this, v)[0];\r\n    };\r\n    NativeBigInt.prototype.over = NativeBigInt.prototype.divide = function (v) {\r\n        return new NativeBigInt(this.value / parseValue(v).value);\r\n    };\r\n    SmallInteger.prototype.over = SmallInteger.prototype.divide = BigInteger.prototype.over = BigInteger.prototype.divide;\r\n\r\n    BigInteger.prototype.mod = function (v) {\r\n        return divModAny(this, v)[1];\r\n    };\r\n    NativeBigInt.prototype.mod = NativeBigInt.prototype.remainder = function (v) {\r\n        return new NativeBigInt(this.value % parseValue(v).value);\r\n    };\r\n    SmallInteger.prototype.remainder = SmallInteger.prototype.mod = BigInteger.prototype.remainder = BigInteger.prototype.mod;\r\n\r\n    BigInteger.prototype.pow = function (v) {\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value,\r\n            value, x, y;\r\n        if (b === 0) return Integer[1];\r\n        if (a === 0) return Integer[0];\r\n        if (a === 1) return Integer[1];\r\n        if (a === -1) return n.isEven() ? Integer[1] : Integer[-1];\r\n        if (n.sign) {\r\n            return Integer[0];\r\n        }\r\n        if (!n.isSmall) throw new Error(\"The exponent \" + n.toString() + \" is too large.\");\r\n        if (this.isSmall) {\r\n            if (isPrecise(value = Math.pow(a, b)))\r\n                return new SmallInteger(truncate(value));\r\n        }\r\n        x = this;\r\n        y = Integer[1];\r\n        while (true) {\r\n            if (b & 1 === 1) {\r\n                y = y.times(x);\r\n                --b;\r\n            }\r\n            if (b === 0) break;\r\n            b /= 2;\r\n            x = x.square();\r\n        }\r\n        return y;\r\n    };\r\n    SmallInteger.prototype.pow = BigInteger.prototype.pow;\r\n\r\n    NativeBigInt.prototype.pow = function (v) {\r\n        var n = parseValue(v);\r\n        var a = this.value, b = n.value;\r\n        var _0 = BigInt(0), _1 = BigInt(1), _2 = BigInt(2);\r\n        if (b === _0) return Integer[1];\r\n        if (a === _0) return Integer[0];\r\n        if (a === _1) return Integer[1];\r\n        if (a === BigInt(-1)) return n.isEven() ? Integer[1] : Integer[-1];\r\n        if (n.isNegative()) return new NativeBigInt(_0);\r\n        var x = this;\r\n        var y = Integer[1];\r\n        while (true) {\r\n            if ((b & _1) === _1) {\r\n                y = y.times(x);\r\n                --b;\r\n            }\r\n            if (b === _0) break;\r\n            b /= _2;\r\n            x = x.square();\r\n        }\r\n        return y;\r\n    }\r\n\r\n    BigInteger.prototype.modPow = function (exp, mod) {\r\n        exp = parseValue(exp);\r\n        mod = parseValue(mod);\r\n        if (mod.isZero()) throw new Error(\"Cannot take modPow with modulus 0\");\r\n        var r = Integer[1],\r\n            base = this.mod(mod);\r\n        if (exp.isNegative()) {\r\n            exp = exp.multiply(Integer[-1]);\r\n            base = base.modInv(mod);\r\n        }\r\n        while (exp.isPositive()) {\r\n            if (base.isZero()) return Integer[0];\r\n            if (exp.isOdd()) r = r.multiply(base).mod(mod);\r\n            exp = exp.divide(2);\r\n            base = base.square().mod(mod);\r\n        }\r\n        return r;\r\n    };\r\n    NativeBigInt.prototype.modPow = SmallInteger.prototype.modPow = BigInteger.prototype.modPow;\r\n\r\n    function compareAbs(a, b) {\r\n        if (a.length !== b.length) {\r\n            return a.length > b.length ? 1 : -1;\r\n        }\r\n        for (var i = a.length - 1; i >= 0; i--) {\r\n            if (a[i] !== b[i]) return a[i] > b[i] ? 1 : -1;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    BigInteger.prototype.compareAbs = function (v) {\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value;\r\n        if (n.isSmall) return 1;\r\n        return compareAbs(a, b);\r\n    };\r\n    SmallInteger.prototype.compareAbs = function (v) {\r\n        var n = parseValue(v),\r\n            a = Math.abs(this.value),\r\n            b = n.value;\r\n        if (n.isSmall) {\r\n            b = Math.abs(b);\r\n            return a === b ? 0 : a > b ? 1 : -1;\r\n        }\r\n        return -1;\r\n    };\r\n    NativeBigInt.prototype.compareAbs = function (v) {\r\n        var a = this.value;\r\n        var b = parseValue(v).value;\r\n        a = a >= 0 ? a : -a;\r\n        b = b >= 0 ? b : -b;\r\n        return a === b ? 0 : a > b ? 1 : -1;\r\n    }\r\n\r\n    BigInteger.prototype.compare = function (v) {\r\n        // See discussion about comparison with Infinity:\r\n        // https://github.com/peterolson/BigInteger.js/issues/61\r\n        if (v === Infinity) {\r\n            return -1;\r\n        }\r\n        if (v === -Infinity) {\r\n            return 1;\r\n        }\r\n\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value;\r\n        if (this.sign !== n.sign) {\r\n            return n.sign ? 1 : -1;\r\n        }\r\n        if (n.isSmall) {\r\n            return this.sign ? -1 : 1;\r\n        }\r\n        return compareAbs(a, b) * (this.sign ? -1 : 1);\r\n    };\r\n    BigInteger.prototype.compareTo = BigInteger.prototype.compare;\r\n\r\n    SmallInteger.prototype.compare = function (v) {\r\n        if (v === Infinity) {\r\n            return -1;\r\n        }\r\n        if (v === -Infinity) {\r\n            return 1;\r\n        }\r\n\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value;\r\n        if (n.isSmall) {\r\n            return a == b ? 0 : a > b ? 1 : -1;\r\n        }\r\n        if (a < 0 !== n.sign) {\r\n            return a < 0 ? -1 : 1;\r\n        }\r\n        return a < 0 ? 1 : -1;\r\n    };\r\n    SmallInteger.prototype.compareTo = SmallInteger.prototype.compare;\r\n\r\n    NativeBigInt.prototype.compare = function (v) {\r\n        if (v === Infinity) {\r\n            return -1;\r\n        }\r\n        if (v === -Infinity) {\r\n            return 1;\r\n        }\r\n        var a = this.value;\r\n        var b = parseValue(v).value;\r\n        return a === b ? 0 : a > b ? 1 : -1;\r\n    }\r\n    NativeBigInt.prototype.compareTo = NativeBigInt.prototype.compare;\r\n\r\n    BigInteger.prototype.equals = function (v) {\r\n        return this.compare(v) === 0;\r\n    };\r\n    NativeBigInt.prototype.eq = NativeBigInt.prototype.equals = SmallInteger.prototype.eq = SmallInteger.prototype.equals = BigInteger.prototype.eq = BigInteger.prototype.equals;\r\n\r\n    BigInteger.prototype.notEquals = function (v) {\r\n        return this.compare(v) !== 0;\r\n    };\r\n    NativeBigInt.prototype.neq = NativeBigInt.prototype.notEquals = SmallInteger.prototype.neq = SmallInteger.prototype.notEquals = BigInteger.prototype.neq = BigInteger.prototype.notEquals;\r\n\r\n    BigInteger.prototype.greater = function (v) {\r\n        return this.compare(v) > 0;\r\n    };\r\n    NativeBigInt.prototype.gt = NativeBigInt.prototype.greater = SmallInteger.prototype.gt = SmallInteger.prototype.greater = BigInteger.prototype.gt = BigInteger.prototype.greater;\r\n\r\n    BigInteger.prototype.lesser = function (v) {\r\n        return this.compare(v) < 0;\r\n    };\r\n    NativeBigInt.prototype.lt = NativeBigInt.prototype.lesser = SmallInteger.prototype.lt = SmallInteger.prototype.lesser = BigInteger.prototype.lt = BigInteger.prototype.lesser;\r\n\r\n    BigInteger.prototype.greaterOrEquals = function (v) {\r\n        return this.compare(v) >= 0;\r\n    };\r\n    NativeBigInt.prototype.geq = NativeBigInt.prototype.greaterOrEquals = SmallInteger.prototype.geq = SmallInteger.prototype.greaterOrEquals = BigInteger.prototype.geq = BigInteger.prototype.greaterOrEquals;\r\n\r\n    BigInteger.prototype.lesserOrEquals = function (v) {\r\n        return this.compare(v) <= 0;\r\n    };\r\n    NativeBigInt.prototype.leq = NativeBigInt.prototype.lesserOrEquals = SmallInteger.prototype.leq = SmallInteger.prototype.lesserOrEquals = BigInteger.prototype.leq = BigInteger.prototype.lesserOrEquals;\r\n\r\n    BigInteger.prototype.isEven = function () {\r\n        return (this.value[0] & 1) === 0;\r\n    };\r\n    SmallInteger.prototype.isEven = function () {\r\n        return (this.value & 1) === 0;\r\n    };\r\n    NativeBigInt.prototype.isEven = function () {\r\n        return (this.value & BigInt(1)) === BigInt(0);\r\n    }\r\n\r\n    BigInteger.prototype.isOdd = function () {\r\n        return (this.value[0] & 1) === 1;\r\n    };\r\n    SmallInteger.prototype.isOdd = function () {\r\n        return (this.value & 1) === 1;\r\n    };\r\n    NativeBigInt.prototype.isOdd = function () {\r\n        return (this.value & BigInt(1)) === BigInt(1);\r\n    }\r\n\r\n    BigInteger.prototype.isPositive = function () {\r\n        return !this.sign;\r\n    };\r\n    SmallInteger.prototype.isPositive = function () {\r\n        return this.value > 0;\r\n    };\r\n    NativeBigInt.prototype.isPositive = SmallInteger.prototype.isPositive;\r\n\r\n    BigInteger.prototype.isNegative = function () {\r\n        return this.sign;\r\n    };\r\n    SmallInteger.prototype.isNegative = function () {\r\n        return this.value < 0;\r\n    };\r\n    NativeBigInt.prototype.isNegative = SmallInteger.prototype.isNegative;\r\n\r\n    BigInteger.prototype.isUnit = function () {\r\n        return false;\r\n    };\r\n    SmallInteger.prototype.isUnit = function () {\r\n        return Math.abs(this.value) === 1;\r\n    };\r\n    NativeBigInt.prototype.isUnit = function () {\r\n        return this.abs().value === BigInt(1);\r\n    }\r\n\r\n    BigInteger.prototype.isZero = function () {\r\n        return false;\r\n    };\r\n    SmallInteger.prototype.isZero = function () {\r\n        return this.value === 0;\r\n    };\r\n    NativeBigInt.prototype.isZero = function () {\r\n        return this.value === BigInt(0);\r\n    }\r\n\r\n    BigInteger.prototype.isDivisibleBy = function (v) {\r\n        var n = parseValue(v);\r\n        if (n.isZero()) return false;\r\n        if (n.isUnit()) return true;\r\n        if (n.compareAbs(2) === 0) return this.isEven();\r\n        return this.mod(n).isZero();\r\n    };\r\n    NativeBigInt.prototype.isDivisibleBy = SmallInteger.prototype.isDivisibleBy = BigInteger.prototype.isDivisibleBy;\r\n\r\n    function isBasicPrime(v) {\r\n        var n = v.abs();\r\n        if (n.isUnit()) return false;\r\n        if (n.equals(2) || n.equals(3) || n.equals(5)) return true;\r\n        if (n.isEven() || n.isDivisibleBy(3) || n.isDivisibleBy(5)) return false;\r\n        if (n.lesser(49)) return true;\r\n        // we don't know if it's prime: let the other functions figure it out\r\n    }\r\n\r\n    function millerRabinTest(n, a) {\r\n        var nPrev = n.prev(),\r\n            b = nPrev,\r\n            r = 0,\r\n            d, t, i, x;\r\n        while (b.isEven()) b = b.divide(2), r++;\r\n        next: for (i = 0; i < a.length; i++) {\r\n            if (n.lesser(a[i])) continue;\r\n            x = bigInt(a[i]).modPow(b, n);\r\n            if (x.isUnit() || x.equals(nPrev)) continue;\r\n            for (d = r - 1; d != 0; d--) {\r\n                x = x.square().mod(n);\r\n                if (x.isUnit()) return false;\r\n                if (x.equals(nPrev)) continue next;\r\n            }\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    // Set \"strict\" to true to force GRH-supported lower bound of 2*log(N)^2\r\n    BigInteger.prototype.isPrime = function (strict) {\r\n        var isPrime = isBasicPrime(this);\r\n        if (isPrime !== undefined) return isPrime;\r\n        var n = this.abs();\r\n        var bits = n.bitLength();\r\n        if (bits <= 64)\r\n            return millerRabinTest(n, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]);\r\n        var logN = Math.log(2) * bits.toJSNumber();\r\n        var t = Math.ceil((strict === true) ? (2 * Math.pow(logN, 2)) : logN);\r\n        for (var a = [], i = 0; i < t; i++) {\r\n            a.push(bigInt(i + 2));\r\n        }\r\n        return millerRabinTest(n, a);\r\n    };\r\n    NativeBigInt.prototype.isPrime = SmallInteger.prototype.isPrime = BigInteger.prototype.isPrime;\r\n\r\n    BigInteger.prototype.isProbablePrime = function (iterations, rng) {\r\n        var isPrime = isBasicPrime(this);\r\n        if (isPrime !== undefined) return isPrime;\r\n        var n = this.abs();\r\n        var t = iterations === undefined ? 5 : iterations;\r\n        for (var a = [], i = 0; i < t; i++) {\r\n            a.push(bigInt.randBetween(2, n.minus(2), rng));\r\n        }\r\n        return millerRabinTest(n, a);\r\n    };\r\n    NativeBigInt.prototype.isProbablePrime = SmallInteger.prototype.isProbablePrime = BigInteger.prototype.isProbablePrime;\r\n\r\n    BigInteger.prototype.modInv = function (n) {\r\n        var t = bigInt.zero, newT = bigInt.one, r = parseValue(n), newR = this.abs(), q, lastT, lastR;\r\n        while (!newR.isZero()) {\r\n            q = r.divide(newR);\r\n            lastT = t;\r\n            lastR = r;\r\n            t = newT;\r\n            r = newR;\r\n            newT = lastT.subtract(q.multiply(newT));\r\n            newR = lastR.subtract(q.multiply(newR));\r\n        }\r\n        if (!r.isUnit()) throw new Error(this.toString() + \" and \" + n.toString() + \" are not co-prime\");\r\n        if (t.compare(0) === -1) {\r\n            t = t.add(n);\r\n        }\r\n        if (this.isNegative()) {\r\n            return t.negate();\r\n        }\r\n        return t;\r\n    };\r\n\r\n    NativeBigInt.prototype.modInv = SmallInteger.prototype.modInv = BigInteger.prototype.modInv;\r\n\r\n    BigInteger.prototype.next = function () {\r\n        var value = this.value;\r\n        if (this.sign) {\r\n            return subtractSmall(value, 1, this.sign);\r\n        }\r\n        return new BigInteger(addSmall(value, 1), this.sign);\r\n    };\r\n    SmallInteger.prototype.next = function () {\r\n        var value = this.value;\r\n        if (value + 1 < MAX_INT) return new SmallInteger(value + 1);\r\n        return new BigInteger(MAX_INT_ARR, false);\r\n    };\r\n    NativeBigInt.prototype.next = function () {\r\n        return new NativeBigInt(this.value + BigInt(1));\r\n    }\r\n\r\n    BigInteger.prototype.prev = function () {\r\n        var value = this.value;\r\n        if (this.sign) {\r\n            return new BigInteger(addSmall(value, 1), true);\r\n        }\r\n        return subtractSmall(value, 1, this.sign);\r\n    };\r\n    SmallInteger.prototype.prev = function () {\r\n        var value = this.value;\r\n        if (value - 1 > -MAX_INT) return new SmallInteger(value - 1);\r\n        return new BigInteger(MAX_INT_ARR, true);\r\n    };\r\n    NativeBigInt.prototype.prev = function () {\r\n        return new NativeBigInt(this.value - BigInt(1));\r\n    }\r\n\r\n    var powersOfTwo = [1];\r\n    while (2 * powersOfTwo[powersOfTwo.length - 1] <= BASE) powersOfTwo.push(2 * powersOfTwo[powersOfTwo.length - 1]);\r\n    var powers2Length = powersOfTwo.length, highestPower2 = powersOfTwo[powers2Length - 1];\r\n\r\n    function shift_isSmall(n) {\r\n        return Math.abs(n) <= BASE;\r\n    }\r\n\r\n    BigInteger.prototype.shiftLeft = function (v) {\r\n        var n = parseValue(v).toJSNumber();\r\n        if (!shift_isSmall(n)) {\r\n            throw new Error(String(n) + \" is too large for shifting.\");\r\n        }\r\n        if (n < 0) return this.shiftRight(-n);\r\n        var result = this;\r\n        if (result.isZero()) return result;\r\n        while (n >= powers2Length) {\r\n            result = result.multiply(highestPower2);\r\n            n -= powers2Length - 1;\r\n        }\r\n        return result.multiply(powersOfTwo[n]);\r\n    };\r\n    NativeBigInt.prototype.shiftLeft = SmallInteger.prototype.shiftLeft = BigInteger.prototype.shiftLeft;\r\n\r\n    BigInteger.prototype.shiftRight = function (v) {\r\n        var remQuo;\r\n        var n = parseValue(v).toJSNumber();\r\n        if (!shift_isSmall(n)) {\r\n            throw new Error(String(n) + \" is too large for shifting.\");\r\n        }\r\n        if (n < 0) return this.shiftLeft(-n);\r\n        var result = this;\r\n        while (n >= powers2Length) {\r\n            if (result.isZero() || (result.isNegative() && result.isUnit())) return result;\r\n            remQuo = divModAny(result, highestPower2);\r\n            result = remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];\r\n            n -= powers2Length - 1;\r\n        }\r\n        remQuo = divModAny(result, powersOfTwo[n]);\r\n        return remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];\r\n    };\r\n    NativeBigInt.prototype.shiftRight = SmallInteger.prototype.shiftRight = BigInteger.prototype.shiftRight;\r\n\r\n    function bitwise(x, y, fn) {\r\n        y = parseValue(y);\r\n        var xSign = x.isNegative(), ySign = y.isNegative();\r\n        var xRem = xSign ? x.not() : x,\r\n            yRem = ySign ? y.not() : y;\r\n        var xDigit = 0, yDigit = 0;\r\n        var xDivMod = null, yDivMod = null;\r\n        var result = [];\r\n        while (!xRem.isZero() || !yRem.isZero()) {\r\n            xDivMod = divModAny(xRem, highestPower2);\r\n            xDigit = xDivMod[1].toJSNumber();\r\n            if (xSign) {\r\n                xDigit = highestPower2 - 1 - xDigit; // two's complement for negative numbers\r\n            }\r\n\r\n            yDivMod = divModAny(yRem, highestPower2);\r\n            yDigit = yDivMod[1].toJSNumber();\r\n            if (ySign) {\r\n                yDigit = highestPower2 - 1 - yDigit; // two's complement for negative numbers\r\n            }\r\n\r\n            xRem = xDivMod[0];\r\n            yRem = yDivMod[0];\r\n            result.push(fn(xDigit, yDigit));\r\n        }\r\n        var sum = fn(xSign ? 1 : 0, ySign ? 1 : 0) !== 0 ? bigInt(-1) : bigInt(0);\r\n        for (var i = result.length - 1; i >= 0; i -= 1) {\r\n            sum = sum.multiply(highestPower2).add(bigInt(result[i]));\r\n        }\r\n        return sum;\r\n    }\r\n\r\n    BigInteger.prototype.not = function () {\r\n        return this.negate().prev();\r\n    };\r\n    NativeBigInt.prototype.not = SmallInteger.prototype.not = BigInteger.prototype.not;\r\n\r\n    BigInteger.prototype.and = function (n) {\r\n        return bitwise(this, n, function (a, b) { return a & b; });\r\n    };\r\n    NativeBigInt.prototype.and = SmallInteger.prototype.and = BigInteger.prototype.and;\r\n\r\n    BigInteger.prototype.or = function (n) {\r\n        return bitwise(this, n, function (a, b) { return a | b; });\r\n    };\r\n    NativeBigInt.prototype.or = SmallInteger.prototype.or = BigInteger.prototype.or;\r\n\r\n    BigInteger.prototype.xor = function (n) {\r\n        return bitwise(this, n, function (a, b) { return a ^ b; });\r\n    };\r\n    NativeBigInt.prototype.xor = SmallInteger.prototype.xor = BigInteger.prototype.xor;\r\n\r\n    var LOBMASK_I = 1 << 30, LOBMASK_BI = (BASE & -BASE) * (BASE & -BASE) | LOBMASK_I;\r\n    function roughLOB(n) { // get lowestOneBit (rough)\r\n        // SmallInteger: return Min(lowestOneBit(n), 1 << 30)\r\n        // BigInteger: return Min(lowestOneBit(n), 1 << 14) [BASE=1e7]\r\n        var v = n.value,\r\n            x = typeof v === \"number\" ? v | LOBMASK_I :\r\n                typeof v === \"bigint\" ? v | BigInt(LOBMASK_I) :\r\n                    v[0] + v[1] * BASE | LOBMASK_BI;\r\n        return x & -x;\r\n    }\r\n\r\n    function integerLogarithm(value, base) {\r\n        if (base.compareTo(value) <= 0) {\r\n            var tmp = integerLogarithm(value, base.square(base));\r\n            var p = tmp.p;\r\n            var e = tmp.e;\r\n            var t = p.multiply(base);\r\n            return t.compareTo(value) <= 0 ? { p: t, e: e * 2 + 1 } : { p: p, e: e * 2 };\r\n        }\r\n        return { p: bigInt(1), e: 0 };\r\n    }\r\n\r\n    BigInteger.prototype.bitLength = function () {\r\n        var n = this;\r\n        if (n.compareTo(bigInt(0)) < 0) {\r\n            n = n.negate().subtract(bigInt(1));\r\n        }\r\n        if (n.compareTo(bigInt(0)) === 0) {\r\n            return bigInt(0);\r\n        }\r\n        return bigInt(integerLogarithm(n, bigInt(2)).e).add(bigInt(1));\r\n    }\r\n    NativeBigInt.prototype.bitLength = SmallInteger.prototype.bitLength = BigInteger.prototype.bitLength;\r\n\r\n    function max(a, b) {\r\n        a = parseValue(a);\r\n        b = parseValue(b);\r\n        return a.greater(b) ? a : b;\r\n    }\r\n    function min(a, b) {\r\n        a = parseValue(a);\r\n        b = parseValue(b);\r\n        return a.lesser(b) ? a : b;\r\n    }\r\n    function gcd(a, b) {\r\n        a = parseValue(a).abs();\r\n        b = parseValue(b).abs();\r\n        if (a.equals(b)) return a;\r\n        if (a.isZero()) return b;\r\n        if (b.isZero()) return a;\r\n        var c = Integer[1], d, t;\r\n        while (a.isEven() && b.isEven()) {\r\n            d = min(roughLOB(a), roughLOB(b));\r\n            a = a.divide(d);\r\n            b = b.divide(d);\r\n            c = c.multiply(d);\r\n        }\r\n        while (a.isEven()) {\r\n            a = a.divide(roughLOB(a));\r\n        }\r\n        do {\r\n            while (b.isEven()) {\r\n                b = b.divide(roughLOB(b));\r\n            }\r\n            if (a.greater(b)) {\r\n                t = b; b = a; a = t;\r\n            }\r\n            b = b.subtract(a);\r\n        } while (!b.isZero());\r\n        return c.isUnit() ? a : a.multiply(c);\r\n    }\r\n    function lcm(a, b) {\r\n        a = parseValue(a).abs();\r\n        b = parseValue(b).abs();\r\n        return a.divide(gcd(a, b)).multiply(b);\r\n    }\r\n    function randBetween(a, b, rng) {\r\n        a = parseValue(a);\r\n        b = parseValue(b);\r\n        var usedRNG = rng || Math.random;\r\n        var low = min(a, b), high = max(a, b);\r\n        var range = high.subtract(low).add(1);\r\n        if (range.isSmall) return low.add(Math.floor(usedRNG() * range));\r\n        var digits = toBase(range, BASE).value;\r\n        var result = [], restricted = true;\r\n        for (var i = 0; i < digits.length; i++) {\r\n            var top = restricted ? digits[i] + (i + 1 < digits.length ? digits[i + 1] / BASE : 0) : BASE;\r\n            var digit = truncate(usedRNG() * top);\r\n            result.push(digit);\r\n            if (digit < digits[i]) restricted = false;\r\n        }\r\n        return low.add(Integer.fromArray(result, BASE, false));\r\n    }\r\n\r\n    var parseBase = function (text, base, alphabet, caseSensitive) {\r\n        alphabet = alphabet || DEFAULT_ALPHABET;\r\n        text = String(text);\r\n        if (!caseSensitive) {\r\n            text = text.toLowerCase();\r\n            alphabet = alphabet.toLowerCase();\r\n        }\r\n        var length = text.length;\r\n        var i;\r\n        var absBase = Math.abs(base);\r\n        var alphabetValues = {};\r\n        for (i = 0; i < alphabet.length; i++) {\r\n            alphabetValues[alphabet[i]] = i;\r\n        }\r\n        for (i = 0; i < length; i++) {\r\n            var c = text[i];\r\n            if (c === \"-\") continue;\r\n            if (c in alphabetValues) {\r\n                if (alphabetValues[c] >= absBase) {\r\n                    if (c === \"1\" && absBase === 1) continue;\r\n                    throw new Error(c + \" is not a valid digit in base \" + base + \".\");\r\n                }\r\n            }\r\n        }\r\n        base = parseValue(base);\r\n        var digits = [];\r\n        var isNegative = text[0] === \"-\";\r\n        for (i = isNegative ? 1 : 0; i < text.length; i++) {\r\n            var c = text[i];\r\n            if (c in alphabetValues) digits.push(parseValue(alphabetValues[c]));\r\n            else if (c === \"<\") {\r\n                var start = i;\r\n                do { i++; } while (text[i] !== \">\" && i < text.length);\r\n                digits.push(parseValue(text.slice(start + 1, i)));\r\n            }\r\n            else throw new Error(c + \" is not a valid character\");\r\n        }\r\n        return parseBaseFromArray(digits, base, isNegative);\r\n    };\r\n\r\n    function parseBaseFromArray(digits, base, isNegative) {\r\n        var val = Integer[0], pow = Integer[1], i;\r\n        for (i = digits.length - 1; i >= 0; i--) {\r\n            val = val.add(digits[i].times(pow));\r\n            pow = pow.times(base);\r\n        }\r\n        return isNegative ? val.negate() : val;\r\n    }\r\n\r\n    function stringify(digit, alphabet) {\r\n        alphabet = alphabet || DEFAULT_ALPHABET;\r\n        if (digit < alphabet.length) {\r\n            return alphabet[digit];\r\n        }\r\n        return \"<\" + digit + \">\";\r\n    }\r\n\r\n    function toBase(n, base) {\r\n        base = bigInt(base);\r\n        if (base.isZero()) {\r\n            if (n.isZero()) return { value: [0], isNegative: false };\r\n            throw new Error(\"Cannot convert nonzero numbers to base 0.\");\r\n        }\r\n        if (base.equals(-1)) {\r\n            if (n.isZero()) return { value: [0], isNegative: false };\r\n            if (n.isNegative())\r\n                return {\r\n                    value: [].concat.apply([], Array.apply(null, Array(-n.toJSNumber()))\r\n                        .map(Array.prototype.valueOf, [1, 0])\r\n                    ),\r\n                    isNegative: false\r\n                };\r\n\r\n            var arr = Array.apply(null, Array(n.toJSNumber() - 1))\r\n                .map(Array.prototype.valueOf, [0, 1]);\r\n            arr.unshift([1]);\r\n            return {\r\n                value: [].concat.apply([], arr),\r\n                isNegative: false\r\n            };\r\n        }\r\n\r\n        var neg = false;\r\n        if (n.isNegative() && base.isPositive()) {\r\n            neg = true;\r\n            n = n.abs();\r\n        }\r\n        if (base.isUnit()) {\r\n            if (n.isZero()) return { value: [0], isNegative: false };\r\n\r\n            return {\r\n                value: Array.apply(null, Array(n.toJSNumber()))\r\n                    .map(Number.prototype.valueOf, 1),\r\n                isNegative: neg\r\n            };\r\n        }\r\n        var out = [];\r\n        var left = n, divmod;\r\n        while (left.isNegative() || left.compareAbs(base) >= 0) {\r\n            divmod = left.divmod(base);\r\n            left = divmod.quotient;\r\n            var digit = divmod.remainder;\r\n            if (digit.isNegative()) {\r\n                digit = base.minus(digit).abs();\r\n                left = left.next();\r\n            }\r\n            out.push(digit.toJSNumber());\r\n        }\r\n        out.push(left.toJSNumber());\r\n        return { value: out.reverse(), isNegative: neg };\r\n    }\r\n\r\n    function toBaseString(n, base, alphabet) {\r\n        var arr = toBase(n, base);\r\n        return (arr.isNegative ? \"-\" : \"\") + arr.value.map(function (x) {\r\n            return stringify(x, alphabet);\r\n        }).join('');\r\n    }\r\n\r\n    BigInteger.prototype.toArray = function (radix) {\r\n        return toBase(this, radix);\r\n    };\r\n\r\n    SmallInteger.prototype.toArray = function (radix) {\r\n        return toBase(this, radix);\r\n    };\r\n\r\n    NativeBigInt.prototype.toArray = function (radix) {\r\n        return toBase(this, radix);\r\n    };\r\n\r\n    BigInteger.prototype.toString = function (radix, alphabet) {\r\n        if (radix === undefined) radix = 10;\r\n        if (radix !== 10) return toBaseString(this, radix, alphabet);\r\n        var v = this.value, l = v.length, str = String(v[--l]), zeros = \"0000000\", digit;\r\n        while (--l >= 0) {\r\n            digit = String(v[l]);\r\n            str += zeros.slice(digit.length) + digit;\r\n        }\r\n        var sign = this.sign ? \"-\" : \"\";\r\n        return sign + str;\r\n    };\r\n\r\n    SmallInteger.prototype.toString = function (radix, alphabet) {\r\n        if (radix === undefined) radix = 10;\r\n        if (radix != 10) return toBaseString(this, radix, alphabet);\r\n        return String(this.value);\r\n    };\r\n\r\n    NativeBigInt.prototype.toString = SmallInteger.prototype.toString;\r\n\r\n    NativeBigInt.prototype.toJSON = BigInteger.prototype.toJSON = SmallInteger.prototype.toJSON = function () { return this.toString(); }\r\n\r\n    BigInteger.prototype.valueOf = function () {\r\n        return parseInt(this.toString(), 10);\r\n    };\r\n    BigInteger.prototype.toJSNumber = BigInteger.prototype.valueOf;\r\n\r\n    SmallInteger.prototype.valueOf = function () {\r\n        return this.value;\r\n    };\r\n    SmallInteger.prototype.toJSNumber = SmallInteger.prototype.valueOf;\r\n    NativeBigInt.prototype.valueOf = NativeBigInt.prototype.toJSNumber = function () {\r\n        return parseInt(this.toString(), 10);\r\n    }\r\n\r\n    function parseStringValue(v) {\r\n        if (isPrecise(+v)) {\r\n            var x = +v;\r\n            if (x === truncate(x))\r\n                return supportsNativeBigInt ? new NativeBigInt(BigInt(x)) : new SmallInteger(x);\r\n            throw new Error(\"Invalid integer: \" + v);\r\n        }\r\n        var sign = v[0] === \"-\";\r\n        if (sign) v = v.slice(1);\r\n        var split = v.split(/e/i);\r\n        if (split.length > 2) throw new Error(\"Invalid integer: \" + split.join(\"e\"));\r\n        if (split.length === 2) {\r\n            var exp = split[1];\r\n            if (exp[0] === \"+\") exp = exp.slice(1);\r\n            exp = +exp;\r\n            if (exp !== truncate(exp) || !isPrecise(exp)) throw new Error(\"Invalid integer: \" + exp + \" is not a valid exponent.\");\r\n            var text = split[0];\r\n            var decimalPlace = text.indexOf(\".\");\r\n            if (decimalPlace >= 0) {\r\n                exp -= text.length - decimalPlace - 1;\r\n                text = text.slice(0, decimalPlace) + text.slice(decimalPlace + 1);\r\n            }\r\n            if (exp < 0) throw new Error(\"Cannot include negative exponent part for integers\");\r\n            text += (new Array(exp + 1)).join(\"0\");\r\n            v = text;\r\n        }\r\n        var isValid = /^([0-9][0-9]*)$/.test(v);\r\n        if (!isValid) throw new Error(\"Invalid integer: \" + v);\r\n        if (supportsNativeBigInt) {\r\n            return new NativeBigInt(BigInt(sign ? \"-\" + v : v));\r\n        }\r\n        var r = [], max = v.length, l = LOG_BASE, min = max - l;\r\n        while (max > 0) {\r\n            r.push(+v.slice(min, max));\r\n            min -= l;\r\n            if (min < 0) min = 0;\r\n            max -= l;\r\n        }\r\n        trim(r);\r\n        return new BigInteger(r, sign);\r\n    }\r\n\r\n    function parseNumberValue(v) {\r\n        if (supportsNativeBigInt) {\r\n            return new NativeBigInt(BigInt(v));\r\n        }\r\n        if (isPrecise(v)) {\r\n            if (v !== truncate(v)) throw new Error(v + \" is not an integer.\");\r\n            return new SmallInteger(v);\r\n        }\r\n        return parseStringValue(v.toString());\r\n    }\r\n\r\n    function parseValue(v) {\r\n        if (typeof v === \"number\") {\r\n            return parseNumberValue(v);\r\n        }\r\n        if (typeof v === \"string\") {\r\n            return parseStringValue(v);\r\n        }\r\n        if (typeof v === \"bigint\") {\r\n            return new NativeBigInt(v);\r\n        }\r\n        return v;\r\n    }\r\n    // Pre-define numbers in range [-999,999]\r\n    for (var i = 0; i < 1000; i++) {\r\n        Integer[i] = parseValue(i);\r\n        if (i > 0) Integer[-i] = parseValue(-i);\r\n    }\r\n    // Backwards compatibility\r\n    Integer.one = Integer[1];\r\n    Integer.zero = Integer[0];\r\n    Integer.minusOne = Integer[-1];\r\n    Integer.max = max;\r\n    Integer.min = min;\r\n    Integer.gcd = gcd;\r\n    Integer.lcm = lcm;\r\n    Integer.isInstance = function (x) { return x instanceof BigInteger || x instanceof SmallInteger || x instanceof NativeBigInt; };\r\n    Integer.randBetween = randBetween;\r\n\r\n    Integer.fromArray = function (digits, base, isNegative) {\r\n        return parseBaseFromArray(digits.map(parseValue), parseValue(base || 10), isNegative);\r\n    };\r\n\r\n    return Integer;\r\n})();\r\n\r\n// Node.js check\r\nif (typeof module !== \"undefined\" && module.hasOwnProperty(\"exports\")) {\r\n    module.exports = bigInt;\r\n}\r\n\r\n//amd check\r\nif (typeof define === \"function\" && define.amd) {\r\n    define( function () {\r\n        return bigInt;\r\n    });\r\n}\r\n","import unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nexport default function _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n  if (!it) {\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}","export default function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}","import _typeof from \"@babel/runtime/helpers/typeof\";\nimport assertThisInitialized from \"./assertThisInitialized.js\";\nexport default function _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n\n  return assertThisInitialized(self);\n}","import getPrototypeOf from \"./getPrototypeOf.js\";\nimport isNativeReflectConstruct from \"./isNativeReflectConstruct.js\";\nimport possibleConstructorReturn from \"./possibleConstructorReturn.js\";\nexport default function _createSuper(Derived) {\n  var hasNativeReflectConstruct = isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return possibleConstructorReturn(this, result);\n  };\n}","export default function _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}","import setPrototypeOf from \"./setPrototypeOf.js\";\nexport default function _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  Object.defineProperty(subClass, \"prototype\", {\n    value: Object.create(superClass && superClass.prototype, {\n      constructor: {\n        value: subClass,\n        writable: true,\n        configurable: true\n      }\n    }),\n    writable: false\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}","export default function _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}","import setPrototypeOf from \"./setPrototypeOf.js\";\nimport isNativeReflectConstruct from \"./isNativeReflectConstruct.js\";\nexport default function _construct(Parent, args, Class) {\n  if (isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}","import getPrototypeOf from \"./getPrototypeOf.js\";\nimport setPrototypeOf from \"./setPrototypeOf.js\";\nimport isNativeFunction from \"./isNativeFunction.js\";\nimport construct from \"./construct.js\";\nexport default function _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return construct(Class, arguments, getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return setPrototypeOf(Wrapper, Class);\n  };\n\n  return _wrapNativeSuper(Class);\n}","export default function _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}"],"names":["module","exports","arr","len","length","i","arr2","Array","__esModule","isArray","instance","Constructor","TypeError","_defineProperties","target","props","descriptor","enumerable","configurable","writable","Object","defineProperty","key","protoProps","staticProps","prototype","_i","Symbol","iterator","_s","_e","_arr","_n","_d","call","next","done","push","value","err","arrayWithHoles","iterableToArrayLimit","unsupportedIterableToArray","nonIterableRest","arrayLikeToArray","o","minLen","n","toString","slice","constructor","name","from","test","$","ABS","ADD","ADJ","AND","APPROXRATIO","ARCCOS","ARCCOSH","ARCSIN","ARCSINH","ARCTAN","ARCTANH","ARG","ASSUME_REAL_VARIABLES","ATOMIZE","AUTOEXPAND","BAKE","BESSELJ","BESSELY","BINDING","BINOMIAL","BINOM_check_args","BUF","C1","C2","C3","C4","C5","C6","CEILING","CHECK","CHOOSE","CIRCEXP","CLEAR","CLEARALL","CLEARPATTERNS","CLOCK","COEFF","COFACTOR","CONDENSE","CONJ","CONS","CONTRACT","COS","COSH","Condense","DEBUG","DEBUG_ABS","DEBUG_ARG","DEBUG_CLOCKFORM","DEBUG_IMAG","DEBUG_IS","DEBUG_MULTIPLY","DEBUG_POWER","DEBUG_RATIONALIZE","DEBUG_RECT","DEBUG_SIMPLIFY","DECOMP","DEFINT","DEGREE","DENOMINATOR","DERIVATIVE","DET","DET_check_arg","DIM","DIRAC","DIVISORS","DO","DOT","DOUBLE","DRAW","DRAWX","DSOLVE","E","EIGEN","EIGENVAL","EIGENVEC","EIG_N","EIG_check_arg","EIG_yydd","EIG_yyqq","ERF","ERFC","EVAL","EXP","EXPAND","EXPCOS","EXPSIN","Eval","Eval_Eval","Eval_abs","Eval_add","Eval_adj","Eval_and","Eval_approxratio","Eval_arccos","Eval_arccosh","Eval_arcsin","Eval_arcsinh","Eval_arctan","Eval_arctanh","Eval_arg","Eval_besselj","Eval_bessely","Eval_binding","Eval_binomial","Eval_ceiling","Eval_check","Eval_choose","Eval_circexp","Eval_clear","Eval_clearall","Eval_clearpatterns","Eval_clock","Eval_coeff","Eval_cofactor","Eval_condense","Eval_conj","Eval_cons","Eval_contract","Eval_cos","Eval_cosh","Eval_decomp","Eval_defint","Eval_degree","Eval_denominator","Eval_derivative","Eval_det","Eval_dim","Eval_dirac","Eval_divisors","Eval_do","Eval_dsolve","Eval_eigen","Eval_eigenval","Eval_eigenvec","Eval_erf","Eval_erfc","Eval_exp","Eval_expand","Eval_expcos","Eval_expsin","Eval_factor","Eval_factorial","Eval_factorpoly","Eval_filter","Eval_float","Eval_floor","Eval_for","Eval_function_reference","Eval_gamma","Eval_gcd","Eval_hermite","Eval_hilbert","Eval_imag","Eval_index","Eval_inner","Eval_integral","Eval_inv","Eval_invg","Eval_isinteger","Eval_isprime","Eval_laguerre","Eval_lcm","Eval_leading","Eval_legendre","Eval_log","Eval_lookup","Eval_mod","Eval_multiply","Eval_noexpand","Eval_not","Eval_nroots","Eval_number","Eval_numerator","Eval_operator","Eval_or","Eval_outer","Eval_pattern","Eval_patternsinfo","Eval_polar","Eval_power","Eval_predicate","Eval_prime","Eval_print","Eval_print2dascii","Eval_printcomputer","Eval_printhuman","Eval_printlatex","Eval_printlist","Eval_product","Eval_quote","Eval_quotient","Eval_rank","Eval_rationalize","Eval_real","Eval_rect","Eval_roots","Eval_round","Eval_setq","Eval_sgn","Eval_shape","Eval_silentpattern","Eval_simfac","Eval_simplify","Eval_sin","Eval_sinh","Eval_sqrt","Eval_stop","Eval_subst","Eval_sum","Eval_sym","Eval_symbolsinfo","Eval_tan","Eval_tanh","Eval_taylor","Eval_tensor","Eval_test","Eval_testeq","Eval_testge","Eval_testgt","Eval_testle","Eval_testlt","Eval_transpose","Eval_unit","Eval_user_function","Eval_zero","Evalpoly","FACTOR","FACTORIAL","FACTORPOLY","FILTER","FLOATF","FLOOR","FOR","FORCE_FIXED_PRINTOUT","FUNCTION","Find","GAMMA","GCD","HERMITE","HILBERT","IMAG","INDEX","INNER","INTEGRAL","INV","INVG","INV_check_arg","INV_decomp","ISINTEGER","ISPRIME","LAGUERRE","LAST","LAST_2DASCII_PRINT","LAST_FULL_PRINT","LAST_LATEX_PRINT","LAST_LIST_PRINT","LAST_PLAIN_PRINT","LAST_PRINT","LCM","LEADING","LEGENDRE","LOG","LOOKUP","M","MAXDIM","MAXPRIMETAB","MAX_CONSECUTIVE_APPLICATIONS_OF_ALL_RULES","MAX_CONSECUTIVE_APPLICATIONS_OF_SINGLE_RULE","MAX_FIXED_PRINTOUT_DIGITS","MAX_PROGRAM_SIZE","MEQUAL","METAA","METAB","METAX","MLENGTH","MOD","MSIGN","MULTIPLY","MZERO","N","NIL","NOT","NROOTS","NROOTS_ABS","NROOTS_DELTA","NROOTS_EPSILON","NROOTS_RANDOM","NROOTS_YMAX","NROOTS_divpoly","NSYM","NUM","NUMBER","NUMERATOR","OPERATOR","OR","OUTER","PATTERN","PATTERNSINFO","PI","POLAR","POWER","PRIME","PRINT","PRINT2DASCII","PRINTFULL","PRINTLATEX","PRINTLIST","PRINTMODE_2DASCII","PRINTMODE_COMPUTER","PRINTMODE_HUMAN","PRINTMODE_LATEX","PRINTMODE_LIST","PRINTOUTRESULT","PRINTPLAIN","PRINT_LEAVE_E_ALONE","PRINT_LEAVE_X_ALONE","PRODUCT","QUOTE","QUOTIENT","RANK","RATIONALIZE","REAL","ROOTS","ROUND","SECRETX","SELFTEST","SETQ","SGN","SHAPE","SILENTPATTERN","SIMPLIFY","SIN","SINH","SPACE_BETWEEN_COLUMNS","SPACE_BETWEEN_ROWS","SQRT","STOP","STR","SUBST","SUM","SYM","SYMBOLSINFO","SYMBOL_A","SYMBOL_A_UNDERSCORE","SYMBOL_B","SYMBOL_B_UNDERSCORE","SYMBOL_C","SYMBOL_D","SYMBOL_I","SYMBOL_IDENTITY_MATRIX","SYMBOL_J","SYMBOL_N","SYMBOL_R","SYMBOL_S","SYMBOL_T","SYMBOL_X","SYMBOL_X_UNDERSCORE","SYMBOL_Y","SYMBOL_Z","TAN","TANH","TAYLOR","TENSOR","TEST","TESTEQ","TESTGE","TESTGT","TESTLE","TESTLT","TIMING_DEBUGS","TOS","TRACE","TRANSPOSE","T_DOUBLE","T_EQ","T_FUNCTION","T_GTEQ","T_INTEGER","T_LTEQ","T_NEQ","T_NEWLINE","T_QUOTASSIGN","T_STRING","T_SYMBOL","U","UNIT","USR_SYMBOLS","VERSION","YMAX","YYE","YYRECT","ZERO","__emit_char","__emit_str","__factor_add","__factorial","__is_negative","__is_radical_number","__lcm","__legendre","__legendre2","__legendre3","__normalize_radical_factors","__rationalize_tensor","_print","abs","absValFloat","absval","absval_tensor","add","addSymbolLeftOfAssignment","addSymbolRightOfAssignment","add_all","add_factor_to_accumulator","add_numbers","add_terms","addf","adj","alloc_tensor","allocatedId","any_denominators","approxAll","approxLogs","approxLogsOfRationals","approxOneRatioOnly","approxRadicals","approxRadicalsOfRationals","approxRationalsOfLogs","approxRationalsOfPowersOfE","approxRationalsOfPowersOfPI","approxRationalsOfRadicals","approxSineOfRationalMultiplesOfPI","approxSineOfRationals","approxTrigonometric","approx_just_an_integer","approx_logarithmsOfRationals","approx_nothingUseful","approx_radicalOfRatio","approx_ratioOfRadical","approx_rationalOfE","approx_rationalOfPi","approx_rationalsOfLogarithms","approx_sine_of_pi_times_rational","approx_sine_of_rational","approxratioRecursive","arccos","arccosh","arcsin","arcsinh","arctan","arctanh","areunivarpolysfactoredorexpandedform","arg","arglist","assignmentFound","avoidCalculatingPowersIntoArctans","bake","bake_poly","bake_poly_term","besselj","bessely","bigInt","bignum_factorial","bignum_float","bignum_power_number","bignum_scan_float","bignum_scan_integer","bignum_truncate","binding","binomial","buffer","build_tensor","caaddr","caadr","caar","cadaddr","cadadr","cadar","caddaddr","caddadr","caddar","caddddr","cadddr","caddr","cadr","called_from_Algebra_block","car","cdaddr","cdadr","cdar","cddaddr","cddar","cdddaddr","cddddr","cdddr","cddr","cdr","ceiling","chainOfUserSymbolsNotFunctionsBeingEvaluated","charTabIndex","chartab","checkFloatHasWorkedOutCompletely","check_esc_flag","check_stack","check_tensor_dimensions","choose","choose_check_args","circexp","clearAlgebraEnvironment","clearRenamedVariablesToAvoidBindingToExternalScope","clear_symbols","clear_term","clearall","clockform","cmpGlyphs","cmp_args","cmp_expr","cmp_terms","cmp_terms_count","codeGen","coeff","cofactor","collectLatexStringFromReturnValue","collectUserSymbols","combine_factors","combine_gammas","combine_terms","compareState","compare_numbers","compare_rationals","compare_tensors","compatible","computeDependenciesFromAlgebra","computeResultsAndJavaScriptFromAlgebra","compute_fa","conjugate","cons","consCount","contract","convert_bignum_to_double","convert_rational_to_double","copy_tensor","cosine","cosine_of_angle","cosine_of_angle_sum","count","countOccurrencesOfSymbol","count_denominators","counter","countsize","d_scalar_scalar","d_scalar_scalar_1","d_scalar_tensor","d_tensor_scalar","d_tensor_tensor","dabs","darccos","darccosh","darcsin","darcsinh","darctan","darctanh","dbesselj0","dbesseljn","dbessely0","dbesselyn","dcos","dcosh","dd","decomp","decomp_product","decomp_sum","defineSomeHandyConstants","define_user_function","defn","defn_str","degree","denominator","derf","derfc","derivative","derivative_of_integral","det","determinant","detg","dfunction","dhermite","dirac","display","display_flag","displaychar","divide","divide_numbers","divisors","divisors_onstack","divpoly","dlog","do_clearPatterns","do_clearall","do_simplify_nested_radicals","dontCreateNewRadicalsInDenominatorWhenEvalingMultiplication","dotprod_unicode","doubleToReasonableString","dpow","dpower","dproduct","draw_flag","draw_stop_return","dsgn","dsin","dsinh","dsum","dtan","dtanh","dupl","eigen","elelmIndex","elem","emit_denominator","emit_denominators","emit_expr","emit_factor","emit_factorial_function","emit_flat_tensor","emit_fraction","emit_function","emit_index_function","emit_multiply","emit_number","emit_numerators","emit_numerical_fraction","emit_power","emit_string","emit_subexpr","emit_symbol","emit_tensor","emit_tensor_inner","emit_term","emit_top_expr","emit_unsigned_expr","emit_x","equal","equaln","equalq","erfc","errorMessage","esc_flag","evaluatingAsFloats","evaluatingPolar","exec","expand","expand_get_A","expand_get_AF","expand_get_B","expand_get_C","expand_get_CF","expand_tensor","expanding","expcos","exponential","expr_level","expsin","f1","f10","f2","f3","f4","f5","f9","f_equals_a","factor","factor_a","factor_again","factor_b","factor_number","factor_small_number","factor_term","factorial","factorpoly","factors","fill_buf","filter","filter_main","filter_sum","filter_tensor","findDependenciesInScript","findPossibleClockForm","findPossibleExponentialForm","findroot","fixup_fraction","fixup_power","flag","floatToRatioRoutine","fmt_index","fmt_level","fmt_x","frame","freeze","functionInvokationsScanningStack","gamma","gamma_of_sum","gammaf","gcd","gcd_main","gcd_numbers","gcd_polys","gcd_powers_with_same_base","gcd_product_product","gcd_product_sum","gcd_sum","gcd_sum_product","gcd_sum_sum","gen","getSimpleRoots","getStateHash","get_binding","get_factor_from_complex_root","get_factor_from_real_root","get_innerprod_factors","get_next_token","get_printname","get_size","get_token","getdisplaystr","glyph","gp","guess","hasImaginaryCoeff","hasNegativeRationalExponent","hash_addition","hash_function","hash_multiplication","hash_power","hashcode_values","hashed_itab","hermite","hilbert","i1","imag","imaginaryunit","index_function","init","initNRoots","inited","inner","inner_f","input_str","integral","integral_of_form","integral_of_product","integral_of_sum","inv","inverse","invert_number","invg","isNumberOneOverSomething","isNumericAtom","isNumericAtomOrTensor","isSimpleRoot","isSmall","isSymbolLeftOfAssignment","isSymbolReclaimable","isZeroAtom","isZeroAtomOrTensor","isZeroLikeOrNonZeroLikeOrUndetermined","isZeroTensor","is_denominator","is_factor","is_small_integer","is_square_matrix","is_usr_symbol","isadd","isalnumorunderscore","isalpha","isalphaOrUnderscore","iscomplexnumber","iscomplexnumberdouble","iscons","isdenominator","isdigit","isdouble","iseveninteger","isfactor","isfactorial","isfloating","isfraction","isidentitymatrix","isimaginarynumber","isimaginarynumberdouble","isimaginaryunit","isinnerordot","isinteger","isintegerfactor","isintegerorintegerfloat","isinv","iskeyword","isminusone","isminusoneoversqrttwo","isminusoneovertwo","isminussqrtthreeovertwo","ismultiply","isnegative","isnegativenumber","isnegativeterm","isnonnegativeinteger","isnpi","isone","isoneover","isoneoversqrttwo","isoneovertwo","isplusone","isplustwo","ispolyexpandedform","ispolyexpandedform_expr","ispolyexpandedform_factor","ispolyexpandedform_term","ispolyfactoredorexpandedform","ispolyfactoredorexpandedform_factor","ispolyfactoredorexpandedform_power","isposint","ispositivenumber","ispower","isquarterturn","isrational","isspace","issqrtthree","issqrtthreeovertwo","isstr","issymbol","issymbolic","istensor","istranspose","isunderscore","isunivarpolyfactoredorexpandedform","itab","italu_hashcode","j1","laguerre","laguerre2","lastFoundSymbol","latexErrorSign","lcm","leading","legendre","lessp","level","list","listLength","logarithm","logbuf","lookupsTotal","lu_decomp","madd","makePositive","makeSignSameAs","make_hashed_itab","mask","mcmp","mcmpint","mdiv","mdivrem","meta_mode","mgcd","mini_solve","mint","mmod","mmul","mod","monic","move","moveTos","mp_clr_bit","mp_denominator","mp_numerator","mp_set_bit","mpow","mprime","mroot","mshiftright","msub","mtotal","multinomial_sum","multiply","multiply_all","multiply_all_noexpand","multiply_consecutive_constants","multiply_denominators","multiply_denominators_factor","multiply_denominators_term","multiply_noexpand","multiply_numbers","n_factor_number","negate","negate_expand","negate_noexpand","negate_number","new_integer","new_string","newline_flag","nil_symbols","normaliseDots","normalisedCoeff","normalize_angle","nroots_a","nroots_b","nroots_c","nroots_df","nroots_dx","nroots_fa","nroots_fb","nroots_x","nroots_y","nterms","nthCadr","numerator","numericRootOfPolynomial","one","oneElement","one_as_double","out_buf","out_count","out_of_memory","outer","p0","p1","p2","p3","p4","p5","p6","p7","p8","p9","parse","parse_internal","parse_p1","parse_p2","parse_time_simplifications","partition","patternHasBeenFound","patternsinfo","performing_roots","polar","polarRectAMinusOneBase","polyform","pop","pop_double","pop_frame","pop_integer","power","power_str","power_sum","power_tensor","predefinedSymbolsInGlobalScope_doNotTrackInDependencies","prime","primetab","print2dascii","printMode","print_ABS_latex","print_ARCCOS_codegen","print_ARCSIN_codegen","print_ARCTAN_codegen","print_BINOMIAL_latex","print_COS_codegen","print_DEFINT_latex","print_DOT_codegen","print_DOT_latex","print_DO_codegen","print_FOR_codegen","print_INV_codegen","print_INV_latex","print_PRODUCT_codegen","print_PRODUCT_latex","print_SETQ_codegen","print_SIN_codegen","print_SQRT_latex","print_SUM_codegen","print_SUM_latex","print_TAN_codegen","print_TESTEQ_latex","print_TESTGE_latex","print_TESTGT_latex","print_TESTLE_latex","print_TESTLT_latex","print_TEST_codegen","print_TEST_latex","print_TRANSPOSE_codegen","print_TRANSPOSE_latex","print_UNIT_codegen","print_a_over_b","print_base","print_base_of_denom","print_char","print_denom","print_double","print_expo_of_denom","print_exponent","print_expr","print_factor","print_factorial_function","print_glyphs","print_index_function","print_list","print_multiply_sign","print_number","print_power","print_str","print_subexpr","print_tensor","print_tensor_inner","print_tensor_inner_latex","print_tensor_latex","print_term","printchar","printchar_nowrap","printline","program_buf","promote_tensor","pushTryNotToDuplicate","push_cars","push_double","push_factor","push_frame","push_identity_matrix","push_integer","push_rational","push_symbol","push_term_factors","push_terms","push_zero_matrix","qadd","qdiv","qmul","qpow","qpowf","quickfactor","quickpower","rational","rationalize","rationalize_coefficients","real","reciprocate","rect","recursionLevelNestedRadicalsRemoval","recursiveDependencies","ref","ref1","rememberPrint","remove_negative_exponents","reset_after_error","restore","restoreMetaBindings","rewrite_args","rewrite_args_tensor","roots","roots2","roots3","run","runUserDefinedSimplifications","save","saveMetaBindings","scalar_times_tensor","scan","scan_error","scan_expression","scan_factor","scan_function_call_with_function_name","scan_function_call_without_function_name","scan_index","scan_meta","scan_power","scan_relation","scan_stmt","scan_str","scan_string","scan_subexpr","scan_symbol","scan_tensor","scan_term","scanned","scanningParameters","setM","setSignTo","set_binding","set_component","setq_indexed","sfac_product","sfac_product_f","sgn","shape","show_power_debug","sign","sign_of_term","simfac","simfac_term","simpleComplexityMeasure","simplify","simplifyForCodeGeneration","simplify_1_in_products","simplify_main","simplify_nested_radicals","simplify_polar","simplify_polarRect","simplify_rational_expressions","simplify_rectToClock","simplify_tensor","simplify_trig","simplifyfactorials","sine","sine_of_angle","sine_of_angle_sum","skipRootVariableToBeSolved","sort_stack","square","ssqrt","stack","stackAddsCount","std_symbol","step","step2","stop","strcmp","stringsEmittedByUserPrintouts","subf","subst","subtract","subtract_numbers","swap","symbol","symbolsDependencies","symbolsHavingReassignments","symbolsInExpressionsWithoutAssignments","symbolsLeftOfAssignment","symbolsRightOfAssignment","symbolsinfo","symnum","symtab","take_care_of_nested_radicals","tangent","taylor","tensor","tensor_plus_tensor","tensor_times_scalar","testApprox","test_flag","text_metric","theRandom","token","token_buf","token_str","top","top_level_eval","tos","transform","transpose","transpose_unicode","trigmode","trivial_divide","try_kth_prime","turnErrorMessageToLatex","ucmp","unfreeze","unique","unique_f","update_token_buf","userSimplificationsInListForm","userSimplificationsInStringForm","usr_symbol","verbosing","version","will_be_displayed_as_fraction","ybinomial","ycosh","ydirac","yerf","yerfc","yfloor","yindex","yround","ysinh","yyarg","yybesselj","yybessely","yyceiling","yycondense","yycontract","yycosh","yydegree","yydetg","yydivpoly","yyerf","yyerfc","yyexpand","yyfactorpoly","yyfloat","yyfloor","yyhermite","yyhermite2","yyinvg","yylcm","yylog","yymultiply","yyouter","yypower","yyrationalize","yyround","yysgn","yysimfac","yysinh","yytangent","zero","zzfloat","hasProp","hasOwnProperty","require","a","b","this","q","printname","str","d","k","tag","dim","results","ndim","nelem","h","w","ascent","descent","width","ceil","j","primes","Math","sqrt","x","p","startCount","isPositive","isZero","equals","theArgument","console","trace","log","anyFactorsYet","input","subsetOfStack","sort","concat","t","s","l1","m1","ref2","ref3","ref4","ref5","ref6","ref7","ref8","ref9","numberOfDigitsAfterTheDot","precision","splitBeforeAndAfterDot","supposedlyTheFloat","theFloat","theRatio","split","pow","decimal","AccuracyFactor","DecimalSign","FractionDenominator","FractionNumerator","PreviousDenominator","ScratchValue","Z","ret","isNaN","floor","bestResultSoFar","complexity","error","hypothesis","likelyMultiplier","minimumComplexity","ratio","Number","MAX_VALUE","round","len1","approxRadicalsOfRationalsResult","approxRationalsOfRadicalsResult","approxLogsOfRationalsResult","approxRationalsOfLogsResult","approxSineOfRationalMultiplesOfPIResult","approxSineOfRationalsResult","fraction","sin","approxLogsResult","approxRadicalsResult","approxRationalsOfPowersOfEResult","approxRationalsOfPowersOfPIResult","approxTrigonometricResult","bestApproxSoFar","constantsSum","constantsSumMin","aResult","c","theSum","i2","i3","j2","j3","k3","l2","l3","len2","len3","len4","len5","len6","len7","m2","m3","n1","n2","o1","o2","originalValue","q1","q2","r1","r2","returned","returnedFraction","returnedValue","s1","s2","t1","t2","u1","u2","v1","v2","x1","x2","z1","z2","toFixed","acos","asin","atan","y","z","jn","yn","geq","MIN_SAFE_INTEGER","leq","MAX_SAFE_INTEGER","isNegative","qsub","ab","ba","minusOne","expo","toJSNumber","quotientAndRemainder","divmod","quotient","remainder","theNewInteger","accumulator","buf","scounter","sign_","substring","parseFloat","signed","aAsString","denominatorString","shiftRight","indexOf","indexFound","variableToBeCleared","variable","polynomial","coeffsCount","constant","polynomialWithoutConstant","prev_expanding","row","col","ai","an","l","m","cos","cosh","toBePushed","generalTransform","breakFromOutherWhile","base","result","theta","op","ref10","printstr","ref11","results1","cc","ss","ans","exp","willEvaluateAsFloats","cycleString","positionIfSymbolAlreadyBeingEvaluated","cons_head","Eval_atomize","Eval_draw","checkResult","dsolve","orig","theTensor","A","AxPlusB","B","checkingTheDivision","dividend","factpoly_expo","firstParam","foundComplexRoot","foundRealRoot","partOfPolynomialFactoredSoFar","polycoeff","previousFactorisation","remainingPoly","secondDegreePloly","secondParam","whichRootsAreWeFinding","ratioInverse","a0","evalPolyResult","na0","nan","rootsTries_i","rootsTries_j","testDenominator","testNumerator","testValue","Q","evaluateAt","nodeToCheck","numberOfEs","numberOfMults","numberOfPIs","numberOfPowers","numberOfSums","loopingVariable","polyVar","difference","moretheArguments","operands","refinedOperands","shift","theArguments","arg1","arg2","arg3","subtractionResult","ak","bk","tree","factors_accumulator","hc","tab","u","half","arg_hash","Error","terms","sum","term","term_set","product","base_hash","exp_hash","constexp","f","JSON","stringify","eachEntry","results2","valueOrPredicate","evalledArgument","isEven","minussign","compareAbs","v","theNewString","toReturn","isProbablePrime","index","and","shiftLeft","not","or","append","_gamma","r","random","nrabs","firstArgument","patternPosition","secondArgument","stringKey","thirdArgument","patternsinfoToBePrinted","compare","bigint_one","g","xprime","b_isEven_and_c_isItsInverse","hopefullySimplified","inputBase","inputExp","isThisOne","is_a_moreThanZero","original_test_flag","beenPrinted","passedPrintMode","origPrintMode","theString","theTypeOfPrint","parsedString","originalCodeGen","returnedString","replace","denom","numberOneOverSomething","origAccumulator","previousFactorWasANumber","functionBody","numberOfIntegrals","originalIntegral","theIntegral","theVariable","firstLevel","body","lowerlimit","upperlimit","howManyIfs","exponent","denomExponent","newExponent","numExponent","omitParens","pastFirstFactor","fbody","parameters","character","k1","k2","pPrintName","pString","dx","h1","w1","w2","y1","y2","dy","h2","max_x","max_y","min_x","min_y","emit_sign","tmpString","sIndex","tmpBuffer","eh","ew","ncol","nrow","indexVariable","oldIndexVariableValue","gcdBetweenNumeratorAndDenominator","qadd_ab","qadd_ba","qadd_denominator","qadd_frac1","qadd_frac2","qadd_numerator","resultSum","aa","bb","isOdd","stackIndex","divisor","commonDenominator","eachTerm","imaginaryCoefficients","isSimpleRootPolynomial","divideBy","miniStack","lastCoeff","leadingCoeff","aSol","commonPart","rootsOfOne","C_CHECKED_AS_NOT_ZERO","R_18_a_b_c_d","R_27_a2_d","R_2_b3","R_3_a","R_3_a_C","R_3_a_c","R_4_DELTA03","R_6_a_C","R_C","R_C_over_3a","R_C_simplified_toCheckIfZero","R_DELTA0","R_DELTA0_toBeCheckedIfZero","R_DELTA1","R_Q","R_a2","R_a2_d","R_a2_d2","R_a3","R_a_b_c","R_a_b_c_d","R_a_c","R_b2","R_b2_c2","R_b3","R_b3_d","R_c2","R_c3","R_d2","R_determinant","R_e2","R_e3","R_m","R_m27_a2_d2","R_m4_a_c3","R_m4_b3_d","R_m9_a_b_c","R_m_b_over_3a","R_p","R_q","R_r","ThreePPlus2M","TwoQOversqrtPPlus2M","coeff2","coeff3","coeff4","depressedSolutions","eachSolution","flipSignOFQSoCIsNotZero","i_sqrt3","one_minus_i_sqrt3","one_plus_i_sqrt3","resolventCubicSolutions","root_solution","sqrtPPlus2M","toBeCheckedIFZero","assignmentIsOfQuotedType","existingDependencies","indexOfSymbolLeftOfAssignment","symbolLeftOfAssignment","splice","charCodeAt","firstFactorIsNumber","theSymbol","prefixVar","functionName","RegExp","errmsg","atLeastOneSuccessInRouldOfRulesApplications","eachConsecutiveRuleApplication","eachSimplification","numberOfRulesApplications","originalexpanding","success","args","eval","carp1","oldp1","oldp2","num","theGCD","simplificationWithCondense","simplificationWithoutCondense","somethingSimplified","C","SOLUTION","anyRadicalSimplificationWorked","checkSize","commonBases","commonInnerExponent","countingTerms","firstTerm","innerbase","innerexponent","lowercase_a","lowercase_b","numberOfTerms","possibleNewExpression","possibleNewExpressionValue","possibleRationalSolutions","possibleSolutions","potentialPower","realOfpossibleRationalSolutions","secondTerm","secondTermFactor","termsThatAreNotPowers","max","apply","sinh","expr","newExpr","newTensor","oldExpr","tan","tanh","comparison","wholeAndExpression","andPredicates","somePredicateUnknown","orPredicates","wholeOrExpression","bookmarkTosToPrintDecomps","eachTransformEntry","numberOfDecomps","restTerm","theTransform","transform_h","transformationSuccessful","transformedTerms","fea_i","fea_j","innerTranspSwitch1","innerTranspSwitch2","bodyAndFormalArguments","definitionOfInterest","defn_i","str1","str2","maxFixedPrintoutDigits","stringRepresentation","search","needle","message","stringToBeParsed","dontGenerateCode","bodyForReadableSummaryOfGeneratedCode","cyclesDescriptions","deQuotedDep","dependencyInfo","eachDependency","generatedBody","generatedCode","indexOfEachReplacement","indexOfPartRemainingToBeParsed","newUserSymbol","originalUserSymbol","readableSummaryOfGeneratedCode","recursedDependencies","replacementsFrom","replacementsTo","scriptEvaluation","stringToBeRun","testableString","timeStartFromAlgebra","toBePrinted","userVariablesMentioned","variablesWithCycles","Date","getTime","affectsVariables","affectedBy","error1","variableToBeChecked","arrayWhereDependenciesWillBeAdded","variablesAlreadyFleshedOut","chainBeingChecked","cyclesDescription","theErrorMessage","String","fromCharCode","stringToNormalise","allReturnedLatexStrings","allReturnedPlainStrings","collectedLatexResult","collectedPlainResult","stringToBeReturned","timeStart","timingDebugWrite","generateLatex","selftest","originalArgument","shouldAutoexpand","codeFromAlgebraBlock","code","latexResult","readableSummaryOfCode","stackPos","elementToBeReturned","symbolsinfoToBePrinted","bindingi","symtabi","latexPrint","theSymnum","argu","warn","data","fn","argus","builtin_fns","bind","frozenContents","frozenSymbols","frozen","frozenPatterns","previousHash","frozenHash","undefined","BASE","MAX_INT","MAX_INT_ARR","smallToArray","DEFAULT_ALPHABET","supportsNativeBigInt","BigInt","Integer","radix","alphabet","caseSensitive","parseBase","parseValue","BigInteger","SmallInteger","NativeBigInt","isPrecise","arrayToSmall","trim","createArray","truncate","l_a","l_b","carry","addAny","addSmall","a_l","b_l","borrow","subtractSmall","multiplyLong","a_i","multiplySmall","multiplyKaratsuba","ac","bd","abcd","multiplySmallAndArray","divModSmall","lambda","divModAny","self","quotientDigit","divisorMostSignificantDigit","divMod1","xlen","highx","highy","check","part","unshift","reverse","divMod2","qSign","mSign","isBasicPrime","isUnit","isDivisibleBy","lesser","millerRabinTest","nPrev","prev","modPow","create","plus","subtractAny","minus","small","times","_multiplyBySmall","over","_0","_1","_2","modInv","Infinity","compareTo","eq","notEquals","neq","greater","gt","lt","greaterOrEquals","lesserOrEquals","isPrime","strict","bits","bitLength","logN","iterations","rng","randBetween","lastT","lastR","newT","newR","powersOfTwo","powers2Length","highestPower2","shift_isSmall","bitwise","xSign","ySign","xRem","yRem","xDigit","yDigit","xDivMod","yDivMod","remQuo","xor","LOBMASK_I","roughLOB","integerLogarithm","tmp","e","min","text","toLowerCase","absBase","alphabetValues","digits","start","parseBaseFromArray","val","toBase","map","valueOf","neg","out","left","digit","toBaseString","join","parseStringValue","decimalPlace","parseNumberValue","toArray","toJSON","parseInt","isInstance","usedRNG","low","range","restricted","fromArray","define","_createForOfIteratorHelper","allowArrayLike","it","F","normalCompletion","didErr","_e2","_typeof","obj","_possibleConstructorReturn","assertThisInitialized","_createSuper","Derived","hasNativeReflectConstruct","isNativeReflectConstruct","Super","getPrototypeOf","NewTarget","Reflect","construct","arguments","_getPrototypeOf","setPrototypeOf","__proto__","_inherits","subClass","superClass","_isNativeReflectConstruct","sham","Proxy","Boolean","_construct","Parent","Class","Function","_wrapNativeSuper","_cache","Map","has","get","set","Wrapper"],"sourceRoot":""}