{"version":3,"file":"static/js/813.27506be3.chunk.js","mappings":"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","sources":["math/algebra/functions/exp.js","math/input-signals/signals.js","math/solvers/equation.js","math/algebra/functions/transfer.js","math/algebra/functions/trigonometric.js","math/solvers/formula.js","views/ui-component/cards/MainCard.js"],"sourcesContent":["import Algebra from \"math/algebra\";\r\nimport Complex from \"math/algebra//complex\";\r\nimport { Cos, Sin } from \"./trigonometric\";\r\n\r\nexport default class Exp extends Algebra {\r\n    constructor(a, b, symbol = \"t\", params = {}) {\r\n        // ae^bt\r\n        super(a, { symbol, type: \"exp\", b, ...params });\r\n    }\r\n\r\n    copy = (linkPrevious = false) =>\r\n        new Exp(this.a, this.b, this.symbol, {\r\n            dot: this.dot,\r\n            plus: this.plus,\r\n            previous: linkPrevious ? this.previous : null,\r\n            input: this.input,\r\n        });\r\n\r\n    toSin = () => {\r\n        const exp = this.copy();\r\n        if (exp.type === \"exp\" && exp.b instanceof Complex) {\r\n            if (exp.b instanceof Complex && exp.b.real() === 0) {\r\n                const cos = new Cos(exp.a, exp.b.imaginary());\r\n                const sin = new Sin(exp.a, exp.b.imaginary());\r\n                return new Complex(cos, sin);\r\n            }\r\n        }\r\n        return exp; // if doesnt math the condition then just return exponential function itself\r\n    };\r\n\r\n    amplitude = (t) => {\r\n        // NOT SURE\r\n        // if (this.b instanceof Complex || t instanceof Complex) {\r\n        //     if (this.a === +this.a) return this.a;\r\n        //     else if (this.a instanceof Algebra && this.symbol === this.a.symbol)\r\n        //         return this.a.$(t);\r\n        // } else return this.valueAt(t);\r\n    };\r\n    phase = (w) => {\r\n        const jw = new Complex(0, w);\r\n        let pb = +this.b;\r\n        if(this.b === pb)\r\n            return pb * w;\r\n        if(this.b instanceof Algebra){\r\n            pb = this.b.$(jw);\r\n            return jw.multiply(pb).imaginary();\r\n        }\r\n        \r\n    };\r\n    valueAt = (t) => {\r\n        const numericT = +t;\r\n        if (numericT === t) {\r\n            const a = Algebra.valueOf(this.a, numericT),\r\n                b = Algebra.valueOf(this.b, numericT);\r\n            return a * Math.exp(b * numericT);\r\n        } else if (t instanceof Complex) {\r\n            if (!t.real()) {\r\n                return new Exp(\r\n                    this.a,\r\n                    new Complex(0, this.b * t.imaginary()),\r\n                    this.symbol\r\n                ).toSin();\r\n            } else if (t.imaginary()) {\r\n                // edit this\r\n                return (\r\n                    new Exp(this.a, this.b, this.symbol).valueAt(t.real()) *\r\n                    new Exp(\r\n                        1,\r\n                        new Complex(0, this.b * t.imaginary()),\r\n                        this.symbol\r\n                    ).toSin()\r\n                );\r\n            }\r\n            // t is real\r\n            else return this.valueAt(t.real());\r\n        }\r\n    };\r\n}\r\n","import StandardInputSignal from \"math/input-signals\";\r\nimport Poly from \"math/algebra/functions/poly\";\r\n\r\nexport class Step extends StandardInputSignal {\r\n    constructor(amplitude = 1, symbol = \"t\") {\r\n        super(amplitude, \"u\", symbol); // \\\\delta is the equivalent of small delta in mathjax\r\n    }\r\n    copy = () => new Step(this.amp, this.symbol);\r\n\r\n    $ = (t) => (t >= 0) * this.amp;\r\n}\r\n\r\nexport class Puls extends StandardInputSignal {\r\n    constructor(Delta = 1, amplitude = 1, symbol = \"t\") {\r\n        super(amplitude, \"\\\\sqcap\", symbol);\r\n        this.Delta = Delta;\r\n    }\r\n    copy = () => new Puls(this.Delta, this.amp, this.symbol);\r\n    $ = (t) => (t >= 0 && t <= this.Delta) * this.amp / this.Delta;\r\n}\r\n\r\nexport class Impact extends StandardInputSignal {\r\n    constructor(amplitude = 1, symbol = \"t\") {\r\n        super(amplitude, \"\\\\delta\", symbol); // \\\\delta is the equivalent of small delta in mathjax\r\n    }\r\n    copy = () => new Impact(this.amp, this.symbol);\r\n\r\n    $ = (t) => this.amp * (t === 0);\r\n}\r\n\r\nexport class Ramp extends Poly {\r\n    constructor(amplitude, symbol = \"t\") {\r\n        super([amplitude, 0], symbol);\r\n        this.amplitude = amplitude; // just for calculating the value of this\r\n        this.selfmultiply(Step());\r\n    }\r\n    copy = () => new Ramp(this.amplitude, this.symbol);\r\n\r\n    $ = (t) => (t >= 0) * t * this.amplitude;\r\n}\r\n\r\n\r\nexport class Parabolic extends Poly { //EDIT\r\n    constructor(amplitude, symbol = \"t\") {\r\n        super([amplitude, 0, 0], symbol);\r\n        this.amplitude = amplitude; // just for calculating the value of this\r\n        this.selfmultiply(Step());\r\n    }\r\n    copy = () => new Parabolic(this.amplitude, this.symbol);\r\n    $ = (t) => (t >= 0 ? t * this.amplitude : 0);\r\n}\r\n","import Algebra from \"../algebra/index\";\r\nimport { isDigit, precision, round } from \"math/calculus\";\r\nimport Complex from \"math/algebra/complex\";\r\nimport Poly from \"../algebra/functions/poly\";\r\nconst Algebrite = require(\"algebrite\");\r\n\r\nexport default class Equation {\r\n    static zeroPrecision = round(10 ** -precision.get());\r\n    constructor(exp, symbol = \"x\") {\r\n        if (exp instanceof Array) {\r\n            this.algebra = new Poly(exp);\r\n            this.symbol = symbol;\r\n            this.expression = \"\";\r\n            const n = exp.length - 1;\r\n            this.degree = n;\r\n            for (\r\n                let i = 0;\r\n                i < exp.length;\r\n                this.expression += Equation.GetAlgebriteTerm(\r\n                    n - i,\r\n                    exp[i],\r\n                    i,\r\n                    symbol\r\n                ),\r\n                    i++\r\n            );\r\n        } else if (typeof exp === \"string\") {\r\n            this.expression = exp;\r\n            this.algebra = null;\r\n            this.symbol = symbol;\r\n        } else if (exp instanceof Poly) {\r\n            this.expression = \"\";\r\n            this.algebra = exp.copy();\r\n            this.symbol = this.exp.symbol;\r\n            const expression = this.getA();\r\n            const n = expression.length - 1;\r\n            this.degree = n; // unknown\r\n            for (\r\n                let i = 0;\r\n                i < expression.length;\r\n                this.expression += Equation.GetAlgebriteTerm(\r\n                    n - i,\r\n                    expression[i],\r\n                    i,\r\n                    symbol\r\n                ),\r\n                    i++\r\n            );\r\n        } else if (exp instanceof Algebra) {\r\n            // THIS IS TEMPORARY\r\n            this.expression = exp.toString(); // wrong EDIT THIS LATER\r\n            this.algebra = exp.copy();\r\n            this.symbol = this.exp.symbol;\r\n            this.degree = undefined; // unknown\r\n        }\r\n        this.symbol = symbol;\r\n    }\r\n\r\n    static GetAlgebriteTerm = (termDegree, coef, index, symbol) => {\r\n        if (coef === +coef) {\r\n            // means that coef is not a string\r\n            const intExpI = coef | 0;\r\n            const symbolicPart =\r\n                termDegree > 0 ? `*${symbol}^${termDegree}` : \"\";\r\n            if (intExpI !== coef) {\r\n                // means that coef is a float number\r\n                Algebrite.run(`a${index} = ${coef}`);\r\n                return (coef >= 0 ? \"+\" : \"\") + `a${index}${symbolicPart}`;\r\n            } else\r\n                return (intExpI >= 0 ? \"+\" : \"\") + `${intExpI}${symbolicPart}`;\r\n        }\r\n        // here it means coef is a string like '11/2' or '1/4', ...\r\n        return `${coef}${symbol}^${termDegree}`;\r\n    };\r\n    solve = () => {\r\n        // for factorable equations use: algebrite.roots\r\n        let x = Algebrite.nroots(this.expression)\r\n            .toString()\r\n            .replaceAll(\"...\", \"\");\r\n        x = x.slice(1, x.length - 1);\r\n        x = x.split(\",\").filter((xi) => xi && xi !== \"\"); // now x is converted from a string to the array of x answers (as Numbers);\r\n        // edit string to array\r\n        return x.map((xi, i) => {\r\n            // let [real, image] = xi.split(/\\+|-/).filter((xi) => xi && xi !== \"\");\r\n            let separatorIndex = 1;\r\n            for (; separatorIndex < xi.length; separatorIndex++)\r\n                if (\r\n                    (xi[separatorIndex] === \"+\" ||\r\n                        xi[separatorIndex] === \"-\") &&\r\n                    isDigit(xi[separatorIndex - 1]) &&\r\n                    isDigit(xi[separatorIndex + 1])\r\n                )\r\n                    break;\r\n\r\n            let terms = [];\r\n            terms.push(xi.slice(0, separatorIndex));\r\n            if (separatorIndex < xi.length)\r\n                terms.push(xi.slice(separatorIndex, xi.length - 2));\r\n            \r\n            if (terms.length === 1) {\r\n                const magnitude = terms[0].replace(\"*i\", \"\");\r\n                return magnitude === terms[0]\r\n                    ? new Complex(Number(magnitude))\r\n                    : new Complex(0, Number(magnitude));\r\n            } else return new Complex(Number(terms[0]), Number(terms[1]));\r\n        });\r\n    };\r\n\r\n    // AlgebraRoots = () => {\r\n    //     // convert roots returning string to\r\n    //     if (!this.roots || this.roots.length === 0) this.solve();\r\n    // };\r\n\r\n    approximate = (\r\n        method = Equation.Methods.newton,\r\n        N = 10,\r\n        boundary = 1000\r\n    ) => {\r\n        const allRoots = [];\r\n        // newton reaches to approx fast\r\n        // so N = 10 is enough (?????)\r\n        const isUnique = (newRoot) =>\r\n            !isNaN(newRoot) &&\r\n            allRoots.findIndex((rt) =>\r\n                !(rt instanceof Complex) ? rt === newRoot : rt.equals(newRoot)\r\n            ) === -1;\r\n        const isUniqueComplex = (newRoot) =>\r\n            newRoot instanceof Complex &&\r\n            allRoots.findIndex((rt) => newRoot.equals(rt)) === -1;\r\n\r\n        if (this.expression instanceof Algebra) {\r\n            let a0 = 0;\r\n            for (let i = this.expression.a.length - 1; i >= 0; i--)\r\n                if (this.expression.a[i]) {\r\n                    a0 = this.expression.a[i];\r\n                    break;\r\n                }\r\n            const an = this.expression.a[0];\r\n\r\n            if (a0 && an !== 0) boundary = Math.abs(a0 / an);\r\n\r\n            for (let x0 = -boundary; x0 <= boundary; x0++) {\r\n                let x = method(this.algebra, x0, N);\r\n                if (!isNaN(x)) {\r\n                    const rx = round(x);\r\n                    if (isUnique(rx)) allRoots.push(rx);\r\n                }\r\n                x = method(this.algebra, new Complex(0, x0), N);\r\n                if (isUniqueComplex(x)) allRoots.push(x);\r\n            }\r\n        }\r\n        return allRoots;\r\n    };\r\n    // approximation methods\r\n    durandKerner = (N = 20) => {\r\n        if (this.algebra instanceof Algebra) {\r\n            const f = this.algebra.$;\r\n            const n = this.algebra.degree();\r\n            let guess;\r\n            do {\r\n                guess = new Complex(Math.random(), Math.random());\r\n            } while (guess.isReal());\r\n            const roots = Array(n)\r\n                .fill(0)\r\n                .map((_) => []);\r\n\r\n            roots[0].push(new Complex(1, 0));\r\n            for (let i = 1; i < n; i++)\r\n                roots[i][0] = guess.multiply(roots[i - 1][0]);\r\n            for (let iter = 0; iter < N; iter++) {\r\n                for (let i = 0; i < n; i++) {\r\n                    const xiN = roots[i][iter].copy();\r\n                    let sndTermDen = new Complex(1, 0);\r\n                    for (let j = 0; j < n; j++) {\r\n                        if (i !== j) {\r\n                            const xjN = roots[j][roots[j].length - 1];\r\n                            sndTermDen = sndTermDen.multiply(\r\n                                xiN.substract(xjN)\r\n                            );\r\n                        }\r\n                    }\r\n                    let sndTerm = f(xiN).devide(sndTermDen);\r\n                    // USING PUSH MAY SLOW DOWN THE ALGORITHM\r\n                    roots[i].push(xiN.substract(sndTerm));\r\n                }\r\n            }\r\n            return roots.map((r) => r[r.length - 1]);\r\n        }\r\n    };\r\n\r\n    static Methods = {\r\n        // needs work!\r\n        newton: (algebraf, x0 = 0, N = 20) => {\r\n            const f = algebraf.$;\r\n            const df = algebraf.derivative().$;\r\n            const xs = Array(N + 1).fill(0);\r\n            const dfx0 = df(x0);\r\n            if (dfx0 && (!(dfx0 instanceof Complex) || !dfx0.isZero())) {\r\n                if (x0 instanceof Complex) {\r\n                    xs[0] = x0;\r\n                    for (let i = 0; i < N; i++) {\r\n                        // const dfxsi = df(xs[i]);\r\n                        // console.log(\"xs[i] = \", xs[i].toString(), \"=> f(x) = \", f(xs[i]).toString(), \"=> df =\", dfxsi.toString(), \"res = \", f(xs[i]).devide(df(xs[i])))\r\n                        xs[i + 1] = xs[i].substract(f(xs[i]).devide(df(xs[i])));\r\n                    }\r\n\r\n                    const fx = f(xs[N]);\r\n                    if (\r\n                        Math.abs(fx.real()) > Equation.zeroPrecision ||\r\n                        Math.abs(fx.imaginary()) > Equation.zeroPrecision\r\n                    )\r\n                        return NaN;\r\n                } else {\r\n                    xs[0] = x0;\r\n\r\n                    for (let i = 0; i < N; i++) {\r\n                        xs[i + 1] = xs[i] - f(xs[i]) / df(xs[i]);\r\n                    }\r\n\r\n                    if (f(xs[N]) > Equation.zeroPrecision) return NaN;\r\n                }\r\n                //integrity check!\r\n                return xs[xs.length - 1];\r\n            }\r\n            return NaN;\r\n        },\r\n        // needs work!\r\n        middlePoint: (\r\n            f,\r\n            boundary = 1000\r\n            // decimalPrecision = precision.get()\r\n        ) => {\r\n            // NOTE: works fine for some equations\r\n            // and wronge for some others like:  x ** 2 - 4*x  - 5\r\n            boundary = Math.abs(boundary);\r\n            const expectedRate = Equation.zeroPrecision;\r\n            const poles = [];\r\n            let xa = 0,\r\n                xb = 1;\r\n            for (let i = 0; i < boundary; i++) {\r\n                xa = -boundary + i;\r\n                xb = boundary - i;\r\n\r\n                let rate =\r\n                    (xb - xa) / (2 * Math.max(Math.abs(xa), Math.abs(xb)));\r\n                let p = null;\r\n                while (rate >= expectedRate) {\r\n                    p = (xa + xb) / 2;\r\n                    if (!f(p)) break;\r\n                    else if (f(p) * f(xa) < 0) xb = p;\r\n                    else {\r\n                        xa = p;\r\n                        rate =\r\n                            (xb - xa) /\r\n                            (2 * Math.max(Math.abs(xa), Math.abs(xb)));\r\n                    }\r\n                }\r\n                if (!f(p)) poles.push(round(p));\r\n            }\r\n            return new Set(poles);\r\n        },\r\n    };\r\n}\r\n","import Algebra from \"../index\";\r\nimport Complex from \"../complex\";\r\nimport Exp from \"./exp\";\r\nimport Fraction from \"./fraction\";\r\nimport { Step } from \"math/input-signals/signals\";\r\nimport Poly from \"./poly\";\r\nimport { Cos, Sin } from \"./trigonometric\";\r\nimport { round } from \"math/calculus/index\";\r\nimport Equation from \"math/solvers/equation\";\r\nimport { makeProgress } from \"toolshed\";\r\nimport Formula from \"math/solvers/formula\";\r\n\r\nexport default class TransferFunction extends Fraction {\r\n    static Specials = {\r\n        $1: (k, a) =>\r\n            new TransferFunction([k], [1, a]).setRoots([], [-a]).setOrder(1),\r\n        $2: (k, a, b = a instanceof Complex ? a.conjugate : a) => {\r\n            // k / (s + a)(s + b) => must be converted to => k / (s2 + 2(a+b)s + ab)\r\n            let aplusb =\r\n                a instanceof Algebra\r\n                    ? a.add(b)\r\n                    : b instanceof Algebra\r\n                    ? b.add(a)\r\n                    : b + a;\r\n            let ab =\r\n                a instanceof Algebra\r\n                    ? a.multiply(b)\r\n                    : b instanceof Algebra\r\n                    ? b.multiply(a)\r\n                    : b * a;\r\n            if (aplusb instanceof Complex && aplusb.isReal())\r\n                aplusb = aplusb.real();\r\n            if (ab instanceof Complex && ab.isReal()) ab = ab.real();\r\n\r\n            return new TransferFunction(\r\n                [k],\r\n                [1, aplusb instanceof Algebra ? aplusb.negation() : -aplusb, ab]\r\n            )\r\n                .setRoots([], [a, b])\r\n                .setOrder(2);\r\n        },\r\n        $WnZ: (w_n, zeta) => new TransferFunction(null, null, { w_n, zeta }),\r\n        $design: (t_rise, overshoot) =>\r\n            new TransferFunction(null, null, { overshoot, t_rise }),\r\n    };\r\n\r\n    static omegaZetaPoles = (w_n, zeta) => {\r\n        if (Math.abs(zeta) >= 1) {\r\n            const alpha = -zeta * w_n;\r\n            const beta = w_n * (zeta * zeta - 1) ** 0.5;\r\n            return [alpha + beta, alpha - beta];\r\n        }\r\n        const alpha = -zeta * w_n;\r\n        const beta = w_n * (1 - zeta * zeta) ** 0.5;\r\n        return [new Complex(alpha, beta), new Complex(alpha, -beta)];\r\n    };\r\n    constructor(numerator, denominator, params = {}) {\r\n        let zeros = [],\r\n            poles = [];\r\n        if (params) {\r\n            if (params.overshoot && params.t_rise) {\r\n                params.overshoot = Number(params.overshoot);\r\n                params.t_rise = Number(params.t_rise);\r\n                const logMp = Math.log10(params.overshoot);\r\n                params.zeta =\r\n                    -logMp / (Math.PI * Math.PI + logMp * logMp) ** 0.5;\r\n                params.w_d = Math.PI / params.t_rise;\r\n                params.w_n =\r\n                    params.w_d / (1 - params.zeta * params.zeta) ** 0.5;\r\n            }\r\n\r\n            if (params.w_n) {\r\n                params.w_n = Number(params.w_n);\r\n                params.zeta = Number(params.zeta);\r\n                // if the user sends w_n params it will override the given zero/pole list\r\n                const { w_n, zeta } = params;\r\n                const wn2 = w_n * w_n;\r\n                numerator = wn2;\r\n                denominator = [1, 2 * zeta * w_n, wn2];\r\n                poles = TransferFunction.omegaZetaPoles(w_n, zeta);\r\n                zeros = [];\r\n            }\r\n        }\r\n        super(numerator, denominator, \"s\", params);\r\n        // SIMPL;IFY\r\n        this.poles = [...poles]; //edit solve equations\r\n        this.zeros = [...zeros];\r\n        if (!this.a instanceof Array) this.a = [this.a];\r\n        if (this.a.length === 1 && !this.w_n) {\r\n            if (\r\n                this.b.length === 3 &&\r\n                this.b[this.b.length - 1] === this.a[0]\r\n            ) {\r\n                this.w_n = this.a[0];\r\n                this.zeta = this.b[1] / (2 * this.w_n);\r\n                this.timeConstant = round(1 / (this.zeta * this.w_n));\r\n                this.t_settle = 4 * this.timeConstant;\r\n                if (params && params.w_d) this.w_d = params.w_d;\r\n                else if (this.zeta >= -1 && this.zeta <= 1)\r\n                    this.w_d = this.w_n * (1 - this.zeta ** 2) ** 0.5;\r\n                this.order = 2;\r\n                this.setRoots(\r\n                    [],\r\n                    TransferFunction.omegaZetaPoles(this.w_n, this.zeta)\r\n                );\r\n            }\r\n        }\r\n        if (!this.order)\r\n            this.order =\r\n                denominator instanceof Array ? denominator.length - 1 : 1;\r\n        if (params.overshoot && params.t_rise) {\r\n            [this.overshoot, this.t_rise] = [params.overshoot, params.t_rise];\r\n        } else {\r\n            const dampingCharasteristics =\r\n                this.getDampingSystemCharasteristics();\r\n            if (dampingCharasteristics) {\r\n                this.overshoot = dampingCharasteristics.overshoot;\r\n                this.t_rise = dampingCharasteristics.t_rise;\r\n            }\r\n        }\r\n    }\r\n    static sortRoots = (rt) =>\r\n        rt.sort((ri, rj) =>\r\n            ri instanceof Algebra\r\n                ? ri.substract(rj)\r\n                : rj instanceof Algebra\r\n                ? rj.substract(ri)\r\n                : Math.abs(ri) - Math.abs(rj)\r\n        );\r\n\r\n    roots = () => {\r\n        if (\r\n            (!this.zeros || !this.zeros.length) &&\r\n            (!this.poles || !this.poles.length)\r\n        ) {\r\n            // roots hasnt been decided by user\r\n            if (\r\n                this.a instanceof Array &&\r\n                this.b instanceof Array && // if all elements of numerator and denominator are actual numbers\r\n                !this.a.find((ai) => ai !== +ai) &&\r\n                !this.b.find((bi) => bi !== +bi)\r\n            ) {\r\n                // CONSTANT COEFFICIENT POLYNOMIAL EQUATIONS\r\n                this.zeros =\r\n                    this.a.length > 1\r\n                        ? new Formula(\r\n                              this.numerator().toFormula(),\r\n                              this.symbol\r\n                          ).x()\r\n                        : // ? new Equation(this.a, this.symbol).solve()\r\n                          [];\r\n                this.poles =\r\n                    this.b.length > 1\r\n                        ? new Formula(\r\n                              this.denominator().toFormula(),\r\n                              this.symbol\r\n                          ).x()\r\n                        : //? new Equation(this.b, this.symbol).solve()\r\n                          [];\r\n            } else {\r\n                // if the equation isnt a simple constant coefficient polynomial\r\n            }\r\n        }\r\n        return [\r\n            this.zeros.map((zi) => (zi instanceof Algebra ? zi.copy() : zi)),\r\n            this.poles.map((pi) => (pi instanceof Algebra ? pi.copy() : pi)),\r\n        ];\r\n    };\r\n\r\n    repetitiveRoots = () => {\r\n        let [zeros, poles] = this.roots();\r\n        if (zeros.length < this.a.length - 1) {\r\n            zeros = Formula.RepetitiveFactors(\r\n                this.numerator().toFormula(),\r\n                zeros,\r\n                this.symbol\r\n            );\r\n            // console.log(poles);\r\n        }\r\n        if (poles.length < this.b.length - 1) {\r\n            poles = Formula.RepetitiveFactors(\r\n                this.denominator().toFormula(),\r\n                poles,\r\n                this.symbol\r\n            );\r\n            // console.log(poles);\r\n        }\r\n        return [zeros, poles];\r\n    }\r\n    setRoots = (zeros, poles) => {\r\n        this.poles = poles.map((pi) =>\r\n            pi instanceof Complex ? pi.copy() : new Complex(pi, 0)\r\n        );\r\n        this.zeros = zeros.map((zi) =>\r\n            zi instanceof Complex ? zi.copy() : new Complex(zi, 0)\r\n        );\r\n        return this;\r\n    };\r\n\r\n    getDampingSystemCharasteristics = () =>\r\n        this.w_d\r\n            ? {\r\n                  t_rise: round(Math.PI / this.w_d),\r\n                  // WHAT IF W_D === 0?\r\n                  overshoot:\r\n                      this.zeta >= -1 && this.zeta <= 1\r\n                          ? round(\r\n                                100 *\r\n                                    Math.exp(\r\n                                        -(this.zeta * Math.PI) /\r\n                                            (1 - this.zeta ** 2) ** 0.5\r\n                                    )\r\n                            )\r\n                          : null,\r\n              }\r\n            : null;\r\n\r\n    getOrder = () => this.order;\r\n    setOrder = (order) => {\r\n        this.order = order;\r\n        return this;\r\n    };\r\n    getPoles = () => this.poles;\r\n    setPoles = (poles) => {\r\n        this.poles = TransferFunction.sortRoots(poles).map((pi) =>\r\n            pi instanceof Complex ? pi.copy() : new Complex(pi, 0)\r\n        );\r\n        return this;\r\n    };\r\n    getZeros = () => this.zeros;\r\n    setZeros = (zeros) => {\r\n        this.zeros = zeros.map((zi) =>\r\n            zi instanceof Complex ? zi.copy() : new Complex(zi, 0)\r\n        );\r\n        return this;\r\n    };\r\n\r\n    poleOrder = (pole) =>\r\n        this.poles.filter((pi) => Algebra.areTheseTwoEqual(pole, pi)).length;\r\n\r\n    laplace = () => this.copy(); // actually it has no laplace, this is for disfunctioning the laplace method in the parent class Algebra\r\n    laplaceInverse = () => {\r\n        const m = this.zeros.length - 1; // number of zeros\r\n        const n = this.poles.length - 1; // number of poles\r\n\r\n        if (m === 0) {\r\n            switch (n) {\r\n                case 2:\r\n                    return null;\r\n                case 1:\r\n                    return new Algebra(1, { type: \"exp\" }); //EDITTTTTTTTTTTTTTTT\r\n                case 0:\r\n                    return null; //u(t)\r\n                default:\r\n                    return null; //DEFINE AN UNKNOWN FUNCTION FOR CASE LIKE THIS\r\n            }\r\n        }\r\n    };\r\n\r\n    stepify = () => {\r\n        const lstep = this.copy();\r\n        lstep.b.push(0); //update denominator\r\n        lstep.poles.push(new Complex(0, 0));\r\n        return lstep;\r\n    };\r\n    step = () => {\r\n        // normally will automatically return the time domain answer\r\n        // unless inLaplaceDomain is true\r\n        const [zs, ps] = this.repetitiveRoots();\r\n        this.setRoots(zs, ps);\r\n        const m = this.zeros.length; // number of zeros\r\n        const n = this.poles.length; // number of poles\r\n        const nreal = this.poles.filter(\r\n            (pi) => !(pi instanceof Complex)\r\n        ).length; // number of real poles; can be eig   her 2 or 0\r\n        if (m === 0) {\r\n            const k = this.numerator();\r\n            if (n === 0) {\r\n                // return u(t)\r\n                // DEFINE U(T) IN ALGEBRA\r\n            }\r\n            if (n === 1) {\r\n            } else if (n === 2) {\r\n                const a = -this.poles[0],\r\n                    b = -this.poles[1];\r\n                if (nreal === 2) {\r\n                    // if (a > 0 && b > 0) {\r\n                    if (a !== b)\r\n                        // two independent polesdddd\r\n                        // two negative independent poles\r\n                        return new Exp(1 / a, -a)\r\n                            .add(new Exp(-1 / b, -b))\r\n                            .multiply(k / (a - b))\r\n                            .multiply(new Step())\r\n                            .add(new Step(k / (a * b)));\r\n                    else {\r\n                        const a2 = a * a;\r\n                        return new Exp(-k / a2, -a)\r\n                            .multiply(new Poly([a, 1]))\r\n                            .multiply(new Step())\r\n                            .add(new Step(k / a2));\r\n                    }\r\n                    // } else {\r\n                    //     // repetetive poles\r\n                    // }\r\n                } else if (nreal === 0) {\r\n                    // two conjugated complex poles\r\n                    //UNDERSHOOT BUG FIXLAYS HERE\r\n                    const a = -this.poles[0].real(),\r\n                        b = this.poles[0].imaginary();\r\n                    const ka2b2 = k / (a ** 2 + b ** 2);\r\n                    // FIND BUUUUUUG\r\n                    // return new Exp(-ka2b2, -a)\r\n                    //     .multiply(new Cos(1, b).add(new Sin(a / b, b)))\r\n                    //     .multiply(new Step())\r\n                    //     .add(new Step(ka2b2));\r\n                    return new Exp(-ka2b2, -a)\r\n                        .multiply(new Cos(1, b))\r\n                        .add(new Exp(-ka2b2, -a).multiply(new Sin(a / b, b)))\r\n                        .multiply(new Step())\r\n                        .add(new Step(ka2b2));\r\n                }\r\n                // else if( nreal == 1) // this cant happen, but what if sth went wrong?\r\n            }\r\n        }\r\n        // if its not in special mode:\r\n        return new Formula(this.stepify().toFormula(), this.symbol).iL();\r\n    };\r\n    copy = (linkPrevious = false) =>\r\n        new TransferFunction(this.a, this.b, {\r\n            overshoot: this.overshoot,\r\n            t_rise: this.t_rise,\r\n            t_settle: this.t_settle,\r\n            w_d: this.w_d,\r\n            timeConstant: this.timeConstant,\r\n            w_n: this.w_n,\r\n            zeta: this.zeta,\r\n            dot: this.dot,\r\n            plus: this.plus,\r\n            previous: linkPrevious ? this.previous : null,\r\n            input: this.input,\r\n        }).setRoots(this.zeros, this.poles);\r\n\r\n    lim = (s0) => {\r\n        let num, den;\r\n        // for simple polynomial numerator and denominator fractions\r\n        // IMPLEMENT HOPITAL AS WELL?\r\n        if (!s0) {\r\n            // s -> 0)\r\n\r\n            num = { a: 0, sp: this.a.length - 1 };\r\n            den = { b: 1, sp: this.b.length - 1 };\r\n            for (; num.sp > 0 && this.a[num.sp] === 0; num.sp--);\r\n            num.a = this.a[num.sp];\r\n            for (; den.sp > 0 && this.b[den.sp] === 0; den.sp--);\r\n            den.b = this.b[den.sp];\r\n            num.sp = this.a.length - num.sp - 1;\r\n            den.sp = this.b.length - den.sp - 1;\r\n            if (num.sp === den.sp) return num.a / den.b;\r\n            else {\r\n                const sMinPower = Math.min(den.sp, num.sp);\r\n                if (sMinPower) {\r\n                    num.sp -= sMinPower;\r\n                    den.sp -= sMinPower;\r\n                }\r\n                // now one of num.sp or den.sp is zero\r\n                if (den.sp)\r\n                    // zero on denominator\r\n                    return Infinity;\r\n                // if den.sp == 0 and num.sp != 0\r\n                return 0;\r\n            }\r\n        } else if (s0 === Infinity) {\r\n            // s -> infinity\r\n            num = { a: 0, sp: 0 };\r\n            den = { b: 1, sp: 0 };\r\n            for (; num.sp < this.a.length && this.a[num.sp] === 0; num.sp++);\r\n            num.a = this.a[num.sp];\r\n            for (; den.sp < this.b.length && this.b[den.sp] === 0; den.sp++);\r\n            den.b = this.b[den.sp];\r\n            num.sp = this.a.length - num.sp - 1;\r\n            den.sp = this.b.length - den.sp - 1;\r\n            if (num.sp === den.sp) return num.a / den.b;\r\n            // else\r\n            const sMinPower = Math.min(den.sp, num.sp);\r\n            if (sMinPower) {\r\n                num.sp -= sMinPower;\r\n                den.sp -= sMinPower;\r\n            }\r\n            // now one of num.sp or den.sp is zero\r\n            if (den.sp)\r\n                // zero on denominator\r\n                return 0;\r\n            // if den.sp == 0 and num.sp != 0\r\n            return Infinity;\r\n        } else {\r\n            // if s0 is just a no-zero limited number\r\n            num = this.numerator().$(s0);\r\n            den = this.denominator().$(s0);\r\n            if (den)\r\n                // simple non zero denominator limit\r\n                return num / den;\r\n            // if den == 0\r\n            // use Hopital or other limit methods\r\n            //return (num.a * (s0 ** num.sp)) / (den.b * (s0 ** den.sp));\r\n        }\r\n    };\r\n    errors = () => {\r\n        const sGs = this.multiply(new Poly([1, 0], \"s\"));\r\n        const s2Gs = sGs.multiply(new Poly([1, 0], \"s\"));\r\n        return {\r\n            Ks: round(this.lim(0)),\r\n            Kr: round(sGs.lim(0)),\r\n            Ka: round(s2Gs.lim(0)),\r\n        };\r\n    };\r\n    // $ = (t) => this.laplaceInverse().$(t); // valueOf function in certain point; I used character $ in many places as,\r\n    // acronym for \"set\" in setters, so $ here means that set the t ( or x or whatever) with a certain point\r\n\r\n    amplitude = (w) => {\r\n        // w === omega\r\n        const jw = new Complex(0, w);\r\n        const num = this.numerator(),\r\n            den = this.denominator();\r\n        const numAmp = !(num instanceof Exp)\r\n                ? num.$(jw).magnitude()\r\n                : Math.abs(num.getA()),\r\n            denAmp = !(den instanceof Exp)\r\n                ? den.$(jw).magnitude()\r\n                : Math.abs(den.getB());\r\n        return numAmp / denAmp;\r\n        // this is for find exact match of the devide function\r\n        // but im sure num and den are Complex so i directly stated the result\r\n\r\n        // if(num instanceof Complex)\r\n        //     return num.magnitude() / (den instanceof Complex ? den.magnitude : den).magnitude();\r\n        // if(den instanceof Complex)\r\n        //     return num instanceof Algebra ? num.devide(den.magnitude()) : num / den.magnitude();\r\n        // if(num instanceof Algebra)\r\n        //     return num.devide(den);\r\n        // if(den instanceof Algebra)\r\n        //     return den.devideInverse(num);\r\n        // // signal input?\r\n        // if(den)\r\n        //     return num / den;\r\n        // return NaN;\r\n    };\r\n\r\n    phase = (w) => {\r\n        const jw = new Complex(0, w);\r\n        let num = this.numerator(),\r\n            den = this.denominator();\r\n        const numPhase = !(num instanceof Exp)\r\n                ? num.$(jw).phase()\r\n                : num.phase(w), //exponentials have their own shortcut for phase()\r\n            denPhase = !(den instanceof Exp) ? den.$(jw).phase() : den.phase(w);\r\n        if (+denPhase === denPhase && +numPhase === numPhase)\r\n            return numPhase - denPhase;\r\n        // for now Complex.phase() returns numbers or functions:\r\n        // numPhase or denPhase instanceof Function then:\r\n        return (\r\n            (numPhase instanceof Function ? numPhase(w) : numPhase) -\r\n            (denPhase instanceof Function ? denPhase(w) : denPhase)\r\n        );\r\n        // else if(numPhase instanceof Algebra)\r\n        //     return numPhase.$(w) - den.phase();\r\n        // return NaN;\r\n    };\r\n\r\n    static PolarToComplex = (A, phi) =>\r\n        new Complex(A * Math.cos(phi), A * Math.sin(phi));\r\n    nyquist = (w, method = \"complex\") =>\r\n        method === \"complex\"\r\n            ? this.$(new Complex(0, w))\r\n            : TransferFunction.PolarToComplex(this.amplitude(w), this.phase(w));\r\n\r\n    bode = (w) => 20 * Math.log10(this.amplitude(w));\r\n\r\n    toFormula = () => {\r\n        // const [zeros, poles] = this.repetitiveRoots();\r\n        const num =\r\n            this.zeros.length > 0\r\n                ? this.zeros\r\n                      .map(\r\n                          (zi) =>\r\n                              \"(\" +\r\n                              this.symbol +\r\n                              \" - \" +\r\n                              zi.toString(false, true).replace(\"j\", \"i*\") +\r\n                              \")\"\r\n                      )\r\n                      .join(\"*\")\r\n                : \"1\";\r\n        const den =\r\n            this.poles.length > 0\r\n                ? this.poles\r\n                      .map(\r\n                          (pi) =>\r\n                              \"(\" +\r\n                              this.symbol +\r\n                              \" - \" +\r\n                              pi.toString(false, true).replace(\"j\", \"i*\") +\r\n                              \")\"\r\n                      )\r\n                      .join(\"*\")\r\n                : \"1\";\r\n        return `(${num})/(${den})`;\r\n    };\r\n    // ****************************************************** //\r\n    // SOLVE THIS WITH nerdamer again\r\n    rootLocus = async (k_min, k_max, progressBarObject, N = 1000) => {\r\n        // return root locus values for plotting\r\n\r\n        // TEMPORARY:\r\n        let dk = (k_max - k_min) / N;\r\n        const a = this.getA(), // numerator\r\n            b = this.getB(); // denominator => a / b\r\n        const na = a.length - 1,\r\n            nb = b.length - 1;\r\n        const reals = [],\r\n            imaginaries = [];\r\n        const progressLength = k_max - k_min;\r\n        const newTerm = Formula.GetTerm; // Equation.GetAlgebriteTerm;\r\n        for (let k = k_min, progress = 0; k <= k_max; k += dk, progress += dk) {\r\n            // in this piece: using short form codes and using objects is set to minimum\r\n            // because root locus is time consuming and putting all the codes in one main loop is better\r\n            // const delta = b.add(a.multiply(k));\r\n            let delta = null,\r\n                expression = \"\";\r\n            // USE ARRAY DIRECT PROCESS FOR FASTER RESPONSE\r\n            // NUM + K * DEN\r\n            if (na <= nb) {\r\n                delta = Array(nb);\r\n                const offsetB = nb - na;\r\n                for (\r\n                    let i = 0;\r\n                    i < offsetB;\r\n                    delta[i] = b[i],\r\n                        expression += newTerm(nb - i, delta[i], this.symbol),\r\n                        i++\r\n                );\r\n                for (\r\n                    let i = 0, ib = offsetB;\r\n                    i <= na;\r\n                    delta[ib] = b[ib] + k * a[i],\r\n                        expression += newTerm(na - i, delta[ib], this.symbol),\r\n                        i++,\r\n                        ib++\r\n                );\r\n            } else {\r\n                delta = Array(na);\r\n                const offsetA = na - nb;\r\n                for (\r\n                    let i = 0;\r\n                    i < offsetA;\r\n                    delta[i] = b[i],\r\n                        expression += newTerm(na - i, delta[i], this.symbol),\r\n                        i++\r\n                );\r\n                for (\r\n                    let i = 0, ib = offsetA;\r\n                    i <= nb;\r\n                    delta[ib] = b[ib] + k * a[i],\r\n                        expression += newTerm(nb - i, delta[ib], this.symbol),\r\n                        i++,\r\n                        ib++\r\n                );\r\n            }\r\n            const poles = new Formula(expression, this.symbol).x();\r\n            await makeProgress(\r\n                progressBarObject,\r\n                (100 * progress) / progressLength\r\n            );\r\n\r\n            for (let i = 0; i < poles.length; i++) {\r\n                if (poles[i] instanceof Complex) {\r\n                    reals.push(poles[i].real());\r\n                    imaginaries.push(poles[i].imaginary());\r\n                } else {\r\n                    reals.push(poles[i]);\r\n                    imaginaries.push(0);\r\n                }\r\n            }\r\n        }\r\n        await makeProgress(progressBarObject, 100);\r\n        return [reals, imaginaries];\r\n    };\r\n\r\n    rootsByAlgebriteLocus = async (\r\n        k_min,\r\n        k_max,\r\n        progressBarObject,\r\n        N = 1000\r\n    ) => {\r\n        // return root locus values for plotting\r\n\r\n        // TEMPORARY:\r\n        let dk = (k_max - k_min) / N;\r\n        const a = this.getA(), // numerator\r\n            b = this.getB(); // denominator => a / b\r\n        const na = a.length - 1,\r\n            nb = b.length - 1;\r\n        const reals = [],\r\n            imaginaries = [];\r\n        const progressLength = k_max - k_min;\r\n        const newTerm = Equation.GetAlgebriteTerm;\r\n        for (let k = k_min, progress = 0; k <= k_max; k += dk, progress += dk) {\r\n            // in this piece: using short form codes and using objects is set to minimum\r\n            // because root locus is time consuming and putting all the codes in one main loop is better\r\n            // const delta = b.add(a.multiply(k));\r\n            let delta = null,\r\n                expression = \"\";\r\n            // USE ARRAY DIRECT PROCESS FOR FASTER RESPONSE\r\n            // NUM + K * DEN\r\n            if (na <= nb) {\r\n                delta = Array(nb);\r\n                const offsetB = nb - na;\r\n                for (\r\n                    let i = 0;\r\n                    i < offsetB;\r\n                    delta[i] = b[i],\r\n                        expression += newTerm(nb - i, delta[i], i, this.symbol),\r\n                        i++\r\n                );\r\n                for (\r\n                    let i = 0, ib = offsetB;\r\n                    i <= na;\r\n                    delta[ib] = b[ib] + k * a[i],\r\n                        expression += newTerm(\r\n                            na - i,\r\n                            delta[ib],\r\n                            ib,\r\n                            this.symbol\r\n                        ),\r\n                        i++,\r\n                        ib++\r\n                );\r\n            } else {\r\n                delta = Array(na);\r\n                const offsetA = na - nb;\r\n                for (\r\n                    let i = 0;\r\n                    i < offsetA;\r\n                    delta[i] = b[i],\r\n                        expression += newTerm(na - i, delta[i], i, this.symbol),\r\n                        i++\r\n                );\r\n                for (\r\n                    let i = 0, ib = offsetA;\r\n                    i <= nb;\r\n                    delta[ib] = b[ib] + k * a[i],\r\n                        expression += newTerm(\r\n                            nb - i,\r\n                            delta[ib],\r\n                            ib,\r\n                            this.symbol\r\n                        ),\r\n                        i++,\r\n                        ib++\r\n                );\r\n            }\r\n            // const roots = new Equation(new Poly(delta)).roots();\r\n            const poles = new Equation(expression).solve();\r\n\r\n            await makeProgress(\r\n                progressBarObject,\r\n                (100 * progress) / progressLength\r\n            );\r\n\r\n            for (let i = 0; i < poles.length; i++) {\r\n                if (poles[i] instanceof Complex) {\r\n                    reals.push(poles[i].real());\r\n                    imaginaries.push(poles[i].imaginary());\r\n                } else {\r\n                    reals.push(poles[i]);\r\n                    imaginaries.push(0);\r\n                }\r\n            }\r\n        }\r\n        await makeProgress(progressBarObject, 100);\r\n        return [reals, imaginaries];\r\n    };\r\n}\r\n","import Algebra from \"math/algebra\";\r\nimport Complex from \"math/algebra/complex\";\r\nimport Exp from \"./exp\";\r\nimport Fraction from \"./fraction\";\r\n\r\nexport class Sin extends Algebra {\r\n    constructor(A, w, teta = 0, symbol = \"t\", params = {}) {\r\n        // Ae^wt\r\n        if(w === +w && w < 0){\r\n            w *= -1;\r\n            A *= -1;\r\n        }\r\n        super(A, { symbol, type: \"sin\", b: w, teta, ...params });\r\n    }\r\n    copy = (linkPrevious = false) =>\r\n        new Sin(this.a, this.b, this.teta, this.symbol, {\r\n            dot: this.dot,\r\n            plus: this.plus,\r\n            previous: linkPrevious ? this.previous : null,\r\n            input: this.input,\r\n        });\r\n\r\n    toExp = () => {\r\n        const sin = this.copy();\r\n        const exp1 = new Exp(sin.a / 2, new Complex(0, -sin.b));\r\n        const exp2 = new Exp(-sin.a / 2, new Complex(0, sin.b));\r\n        return new Complex(0, exp1.add(exp2));\r\n    };\r\n\r\n    valueAt = (t) => {\r\n        const A = Algebra.valueOf(this.a, t);\r\n        const w = Algebra.valueOf(this.b, t);\r\n        const teta = Algebra.valueOf(this.teta, t);\r\n        return A * Math.sin(w * t + teta)\r\n    }\r\n}\r\n\r\nexport class Cos extends Algebra {\r\n    constructor(A, w, teta = 0, symbol = \"t\", params = {}) {\r\n        // Ae^wt\r\n        if(+w === w && w < 0) w *= -1; // cos(-w) = cos(w);\r\n        super(A, { symbol, type: \"cos\", b: w, teta, ...params });\r\n    }\r\n    copy = (linkPrevious = false) =>\r\n        new Cos(this.a, this.b, this.teta, this.symbol, {\r\n            dot: this.dot,\r\n            plus: this.plus,\r\n            previous: linkPrevious ? this.previous : null,\r\n            input: this.input,\r\n        });\r\n\r\n    toExp = () => {\r\n        const cos = this.copy();\r\n        const exp1 = new Exp(cos.a / 2, new Complex(0, cos.b));\r\n        const exp2 = new Exp(cos.a / 2, new Complex(0, -cos.b));\r\n        return exp1.add(exp2);\r\n    };\r\n\r\n\r\n    valueAt = (t) => {\r\n        const A = Algebra.valueOf(this.a, t);\r\n        const w = Algebra.valueOf(this.b, t);\r\n        const teta = Algebra.valueOf(this.teta, t);\r\n        return A * Math.cos(w * t + teta)\r\n    }\r\n}\r\n\r\nexport class Tan extends Algebra {\r\n    constructor(A, w, teta = 0, symbol = \"t\", params = {}) {\r\n        // Ae^wt\r\n        super(A, { symbol, type: \"tan\", b: w, teta, ...params });\r\n    }\r\n    copy = (linkPrevious = false) =>\r\n        new Tan(this.a, this.b, this.teta, this.symbol, {\r\n            dot: this.dot,\r\n            plus: this.plus,\r\n            previous: linkPrevious ? this.previous : null,\r\n            input: this.input,\r\n        });\r\n\r\n    toExp = () => {\r\n        const tan = this.copy();\r\n        const exp1 = new Exp(1, new Complex(0, -tan.b));\r\n        const numeratorExp2 = new Exp(-1, new Complex(0, tan.b));\r\n        const denominatorExp2 = new Exp(1, new Complex(0, tan.b));\r\n        return new Fraction(exp1.add(numeratorExp2), exp1.add(denominatorExp2));\r\n    };\r\n\r\n    valueAt = (t) => {\r\n        const A = Algebra.valueOf(this.a, t);\r\n        const w = Algebra.valueOf(this.b, t);\r\n        const teta = Algebra.valueOf(this.teta, t);\r\n        return A * Math.tan(w * t + teta)\r\n    }\r\n}\r\n\r\nexport class Cot extends Algebra {\r\n    constructor(A, w, teta = 0, symbol = \"t\", params = {}) {\r\n        // Ae^wt\r\n        super(A, { symbol, type: \"cot\", b: w, teta, ...params });\r\n    }\r\n    copy = (linkPrevious = false) =>\r\n        new Cot(this.a, this.b, this.teta, this.symbol, {\r\n            dot: this.dot,\r\n            plus: this.plus,\r\n            previous: linkPrevious ? this.previous : null,\r\n            input: this.input,\r\n        });\r\n    toExp = () => {\r\n        const cot = this.copy();\r\n        const exp1 = new Exp(1, new Complex(0, -cot.b));\r\n        const numeratorExp2 = new Exp(-1, new Complex(0, cot.b));\r\n        const denominatorExp2 = new Exp(1, new Complex(0, cot.b));\r\n        return new Fraction(exp1.add(denominatorExp2), exp1.add(numeratorExp2));\r\n    };\r\n\r\n\r\n    valueAt = (t) => {\r\n        const A = Algebra.valueOf(this.a, t);\r\n        const w = Algebra.valueOf(this.b, t);\r\n        const teta = Algebra.valueOf(this.teta, t);\r\n        return A * Math.cot(w * t + teta)\r\n    }\r\n}\r\n","import Algebra from \"math/algebra\";\r\nimport { isDigit } from \"math/calculus\";\r\nimport Complex from \"math/algebra/complex\";\r\nconst nerdamer = require(\"nerdamer/all.min\");\r\n\r\nexport default class Formula {\r\n    constructor(mathPhrase, symbol = null, expressions = null) {\r\n        /// all type of parameters must be converted to an string mathPhrases (f)\r\n        if (mathPhrase instanceof Algebra) {\r\n            this.f = mathPhrase.toFormula();\r\n            this.symbol = mathPhrase.symbol;\r\n        } else if (typeof mathPhrase === \"string\") {\r\n            this.f = mathPhrase;\r\n            this.symbol = symbol;\r\n        }\r\n        this.expressions = expressions ? expressions : nerdamer(this.f); // normally its the nerdamer expressions\r\n    }\r\n\r\n    // differentiate function\r\n    df = (against = this.symbol) => {\r\n        const expressions = nerdamer.diff(this.f, against);\r\n        return new Formula(expressions.toString(), this.symbol, expressions);\r\n    };\r\n    iL = (timeSymbol = \"t\") => {\r\n        // inverse laplace transform\r\n        const expressions = nerdamer(\r\n            `ilt(${this.f}, ${this.symbol}, ${timeSymbol})`\r\n        );\r\n        return new Formula(expressions.toString(), timeSymbol, expressions);\r\n    };\r\n\r\n    L = (frequencySymbol = \"s\") => {\r\n        // laplace\r\n        const expressions = nerdamer(\r\n            `laplace(${this.f}, ${this.symbol}, ${frequencySymbol})`\r\n        );\r\n        return new Formula(\r\n            expressions.toString(),\r\n            frequencySymbol,\r\n            expressions\r\n        );\r\n    };\r\n\r\n    $ = (t = undefined) => {\r\n        // returns the containing f as a normal funtion or single value in a certain point\r\n        // get value at certain point\r\n        const knownVariables = [];\r\n        knownVariables[this.symbol] = t;\r\n        return t\r\n            ? nerdamer(this.f, { ...knownVariables })\r\n                  .evaluate()\r\n                  .toDecimal()\r\n            : nerdamer(this.f).toDecimal();\r\n    };\r\n\r\n    // solve equations\r\n    x = () => {\r\n        // nerdamer.solveEquations(this.f, this.symbol);\r\n\r\n        let roots = nerdamer(this.f)\r\n            .solveFor(this.symbol)\r\n            .map((ri) =>\r\n                (!ri.toString().includes(\"sqrt\")\r\n                    ? ri\r\n                    : ri.evaluate()\r\n                ).toDecimal()\r\n            );\r\n        //roots = roots.split(\",\").filter((ri) => ri && ri !== \"\"); // now x is converted from a string to the array of x answers (as +s);\r\n        // edit string to array\r\n        return roots.map((ri, i) => {\r\n            // let [real, image] = ri.split(/\\+|-/).filter((ri) => ri && ri !== \"\");\r\n            let separatorIndex = 1;\r\n            for (; separatorIndex < ri.length; separatorIndex++)\r\n                if (\r\n                    (ri[separatorIndex] === \"+\" ||\r\n                        ri[separatorIndex] === \"-\") &&\r\n                    (isDigit(ri[separatorIndex - 1]) ||\r\n                        ri[separatorIndex - 1] === \"i\") &&\r\n                    (isDigit(ri[separatorIndex + 1]) ||\r\n                        ri[separatorIndex + 1] === \"i\")\r\n                )\r\n                    break;\r\n\r\n            let terms = [];\r\n            terms.push(ri.slice(0, separatorIndex));\r\n            if (separatorIndex < ri.length)\r\n                terms.push(ri.slice(separatorIndex, ri.length));\r\n\r\n            if (terms.length === 1) {\r\n                const magnitude = terms[0].replace(\"*i\", \"\").replace(\"i\", \"1\");\r\n                return magnitude === terms[0]\r\n                    ? new Complex(+magnitude)\r\n                    : new Complex(0, +magnitude);\r\n            } else {\r\n                let b = terms[1].replace(\"*i\", \"\").replace(\"i\", \"1\");\r\n                if (b !== terms[1]) return new Complex(+terms[0], +b);\r\n                // if not, means the first term was image\r\n                b = terms[0].replace(\"*i\", \"\").replace(\"i\", \"1\");\r\n                return new Complex(+terms[1], +b);\r\n            }\r\n        });\r\n    };\r\n    toString = () => nerdamer(this.f).toTeX();\r\n\r\n    toAlgebra = () => {\r\n        if (this.expressions instanceof Algebra) return this.expressions.copy();\r\n    };\r\n    static GetTerm = (termDegree, coef, symbol) => {\r\n        if (coef === +coef) {\r\n            // means that coef is not a string\r\n            const symbolicPart =\r\n                termDegree > 0 ? `*${symbol}^${termDegree}` : \"\";\r\n            return (coef >= 0 ? \"+\" : \"\") + `${coef}${symbolicPart}`;\r\n        }\r\n        // here it means coef is a string like '11/2' or '1/4', ...\r\n        return `${coef}${symbol}^${termDegree}`;\r\n    };\r\n\r\n    static RepetitiveFactors = (f, roots, symbol) => {\r\n        const fullRoots = [...roots];\r\n        for (const root of roots) {\r\n            const knowns = [];\r\n            knowns[symbol] = root.toString(false, true).replace(\"j\", \"i*\");\r\n            for (\r\n                let fi = nerdamer.diff(f);\r\n                !+nerdamer(fi, {...knowns}).toDecimal();\r\n                fullRoots.push(root.copy()), fi = nerdamer.diff(fi)\r\n            );\r\n        }\r\n        return fullRoots;\r\n    };\r\n}\r\n","import PropTypes from 'prop-types';\r\nimport { forwardRef } from 'react';\r\n\r\n// material-ui\r\nimport { useTheme } from '@mui/material/styles';\r\nimport { Card, CardContent, CardHeader, Divider, Typography } from '@mui/material';\r\n\r\n// constant\r\nconst headerSX = {\r\n    '& .MuiCardHeader-action': { mr: 0 }\r\n};\r\n\r\n// ==============================|| CUSTOM MAIN CARD ||============================== //\r\n\r\nconst MainCard = forwardRef(\r\n    (\r\n        {\r\n            border = true,\r\n            boxShadow,\r\n            children,\r\n            content = true,\r\n            contentClass = '',\r\n            contentSX = {},\r\n            darkTitle,\r\n            secondary,\r\n            shadow,\r\n            sx = {},\r\n            title,\r\n            ...others\r\n        },\r\n        ref\r\n    ) => {\r\n        const theme = useTheme();\r\n\r\n        return (\r\n            <Card\r\n                ref={ref}\r\n                {...others}\r\n                sx={{\r\n                    overflowY: 'auto',\r\n                    border: border ? '1px solid' : 'none',\r\n                    borderColor: theme.palette.primary[200] + 75,\r\n                    ':hover': {\r\n                        boxShadow: boxShadow ? shadow || '0 2px 14px 0 rgb(32 40 45 / 8%)' : 'inherit'\r\n                    },\r\n                    ...sx\r\n                }}\r\n            >\r\n                {/* card header and action */}\r\n                {!darkTitle && title && <CardHeader sx={headerSX} title={title} action={secondary} />}\r\n                {darkTitle && title && (\r\n                    <CardHeader sx={headerSX} title={<Typography variant=\"h3\">{title}</Typography>} action={secondary} />\r\n                )}\r\n\r\n                {/* content & header divider */}\r\n                {title && <Divider />}\r\n\r\n                {/* card content */}\r\n                {content && (\r\n                    <CardContent sx={contentSX} className={contentClass}>\r\n                        {children}\r\n                    </CardContent>\r\n                )}\r\n                {!content && children}\r\n            </Card>\r\n        );\r\n    }\r\n);\r\n\r\nMainCard.propTypes = {\r\n    border: PropTypes.bool,\r\n    boxShadow: PropTypes.bool,\r\n    children: PropTypes.node,\r\n    content: PropTypes.bool,\r\n    contentClass: PropTypes.string,\r\n    contentSX: PropTypes.object,\r\n    darkTitle: PropTypes.bool,\r\n    secondary: PropTypes.oneOfType([PropTypes.node, PropTypes.string, PropTypes.object]),\r\n    shadow: PropTypes.string,\r\n    sx: PropTypes.object,\r\n    title: PropTypes.oneOfType([PropTypes.node, PropTypes.string, PropTypes.object])\r\n};\r\n\r\nexport default MainCard;\r\n"],"names":["Exp","a","b","symbol","params","type","copy","linkPrevious","dot","plus","previous","input","toSin","exp","Complex","real","cos","Cos","imaginary","sin","Sin","amplitude","t","phase","w","jw","pb","Algebra","$","multiply","valueAt","numericT","Math","Step","amp","StandardInputSignal","Algebrite","require","Equation","solve","x","nroots","expression","toString","replaceAll","slice","length","split","filter","xi","map","i","separatorIndex","isDigit","terms","push","magnitude","replace","Number","approximate","method","Methods","newton","N","boundary","allRoots","isUnique","newRoot","isNaN","findIndex","rt","equals","isUniqueComplex","a0","an","abs","x0","algebra","rx","round","durandKerner","guess","f","n","degree","random","isReal","roots","Array","fill","_","iter","xiN","sndTermDen","j","xjN","substract","sndTerm","devide","r","this","Poly","GetAlgebriteTerm","getA","undefined","zeroPrecision","precision","termDegree","coef","index","intExpI","symbolicPart","run","algebraf","df","derivative","xs","dfx0","isZero","fx","NaN","middlePoint","expectedRate","poles","xa","xb","rate","max","p","Set","TransferFunction","numerator","denominator","zeros","overshoot","t_rise","logMp","log10","zeta","PI","w_d","w_n","wn2","omegaZetaPoles","find","ai","bi","Formula","toFormula","zi","pi","repetitiveRoots","setRoots","getDampingSystemCharasteristics","getOrder","order","setOrder","getPoles","setPoles","sortRoots","getZeros","setZeros","poleOrder","pole","laplace","laplaceInverse","m","stepify","lstep","step","zs","ps","nreal","k","add","a2","ka2b2","iL","t_settle","timeConstant","lim","s0","num","den","sp","sMinPower","min","Infinity","errors","sGs","s2Gs","Ks","Kr","Ka","getB","numPhase","denPhase","Function","nyquist","PolarToComplex","bode","join","rootLocus","k_min","k_max","progressBarObject","dk","na","nb","reals","imaginaries","progressLength","newTerm","progress","delta","offsetB","ib","offsetA","makeProgress","rootsByAlgebriteLocus","dampingCharasteristics","Fraction","Specials","$1","$2","conjugate","aplusb","ab","negation","$WnZ","$design","alpha","beta","sort","ri","rj","A","phi","teta","toExp","exp1","exp2","nerdamer","mathPhrase","expressions","against","diff","timeSymbol","L","frequencySymbol","knownVariables","evaluate","toDecimal","solveFor","includes","toTeX","toAlgebra","GetTerm","RepetitiveFactors","fullRoots","root","knowns","fi","headerSX","mr","MainCard","forwardRef","ref","border","boxShadow","children","content","contentClass","contentSX","darkTitle","secondary","shadow","sx","title","others","theme","useTheme","overflowY","borderColor","palette","primary","action","variant","className"],"sourceRoot":""}