{"version":3,"file":"static/js/138.fc7a03e1.chunk.js","mappings":"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","sources":["math/algebra/complex.js","math/algebra/functions/poly.js","errors/algebra/NotScalarError.js","math/algebra/index.js","math/input-signals/index.js"],"sourcesContent":["import Algebra from \".\";\nimport { round, isDigit } from \"../calculus\";\n\nclass Complex extends Algebra {\n    constructor(preal, pimage, params = {}) {\n        super(preal, { symbol: \"j\", type: \"complex\", b: pimage, ...params });\n    }\n\n    hasMultiTerms = () =>\n        this.plus || (this.a.toString() !== \"0\" && this.b.toString() !== \"0\");\n\n    toString = (parenthesis = false) => {\n        if(this.isZero())\n            return \"0\";\n        const rl = this.a;\n        let formula = parenthesis && this.hasMultiTerms() ? \"(\" : \"\";\n        if (rl !== 0)\n            formula +=\n                rl instanceof Algebra\n                    ? rl.toString(rl.hasMultiTerms())\n                    : round(rl);\n        let im = this.b;\n        if (im !== 0) {\n            //if (im < 0 || (im instanceof Algebra)) { im = im.negation()\n            if (im < 0) {\n                im *= -1;\n                formula += \" - \";\n            } else if (rl !== 0) formula += \" + \";\n\n            formula += this.symbol;\n            if (im !== 1)\n                formula +=\n                    im instanceof Algebra\n                        ? im.toString(im.hasMultiTerms())\n                        : round(im);\n        }\n        if (this.plus) formula += this.join(); // if there's a next term: casscade toString() calls\n\n        return parenthesis ? formula + \")\" : formula;\n    }; // a + jb\n\n    real = () => this.a;\n    imaginary = () => this.b;\n\n    copy = (linkPrevious = false) =>\n        new Complex(this.a, this.b, {\n            dot: this.dot,\n            plus: this.plus,\n            previous: linkPrevious ? this.previous : null,\n            input: this.input,\n        });\n\n    conjugate = () =>\n        new Complex(\n            this.a,\n            this.b instanceof Algebra ? this.b.negation() : -this.b\n        );\n\n    negation = () =>\n        new Complex(\n            this.a instanceof Algebra ? this.a.negation() : -this.a,\n            this.b instanceof Algebra ? this.b.negation() : -this.b\n        );\n\n    magnitude$2 = () => this.a ** 2 + this.b ** 2;\n\n    magnitude = () => (this.a ** 2 + this.b ** 2) ** 0.5;\n\n    isReal = () => this.b === 0;\n\n    hasSameTypeWith = (x) =>\n        (this.isReal() && x.isReal()) || (!this.isReal() && !x.isReal()); // both full imaginray or both real\n    realify = () => new Complex(this.a, 0); // return a simple real value in Complex object format (for methods that only accept Complex values)\n\n    add = (operand) => {\n        let Re = null,\n            Im = null;\n        if (operand instanceof Complex) {\n            if (this.a instanceof Algebra) Re = this.a.add(operand.real());\n            else if (operand.real() instanceof Algebra)\n                Re = operand.real().add(this.a);\n            else Re = this.a + operand.real();\n\n            if (this.b instanceof Algebra) Im = this.b.add(operand.imaginary());\n            else if (operand.imaginary() instanceof Algebra)\n                Im = operand.imaginary().add(this.b);\n            else Im = this.b + operand.imaginary();\n        } else {\n            if (this.a instanceof Algebra) Re = this.a.add(operand);\n            else if (operand instanceof Algebra) Re = operand.add(this.a);\n            else Re = this.a + operand;\n\n            Im = this.b;\n        }\n        return new Complex(Re, Im);\n    };\n\n    substract = (operand) => this.add(operand.negation());\n\n    equals = (operand) => {\n        if (operand instanceof Complex) {\n            // two complex number are equal to eachother if both thier real parts are the same, and their imaginary parts are the same\n            let realPartsEqual = false;\n            if (this.a instanceof Algebra)\n                realPartsEqual = this.a.equals(operand.real());\n            else if (operand.real() instanceof Algebra)\n                realPartsEqual = operand.real().equals(this.a);\n            else realPartsEqual = this.a === operand.real();\n            if (!realPartsEqual) return false;\n\n            if (this.b instanceof Algebra)\n                return this.b.equals(operand.imaginary());\n            else if (operand.imaginary() instanceof Algebra)\n                return operand.imaginary().equals(this.b);\n            return this.b === operand.imaginary();\n        }\n\n        // if operand is not a complex number then the only way it can be equal with this object of Complex,\n        // is for this object to have a zero imaginary part:\n        return (\n            this.isReal() &&\n            (operand instanceof Algebra\n                ? operand.equals(this.a)\n                : operand === this.a)\n        );\n    };\n\n    isConjugateWith = (operand) => this.conjugate().equals(operand);\n    multiply = (operand) => {\n        let Re = [],\n            Im = [];\n        if (operand instanceof Complex) {\n            // first term\n            if (this.a instanceof Algebra) {\n                Re.push(this.a.multiply(operand.real()));\n                Im.push(this.a.multiply(operand.imaginary()));\n            } else {\n                Re.push(\n                    operand.a instanceof Algebra\n                        ? operand.a.multiply(this.a)\n                        : operand.a * this.a\n                );\n\n                Im.push(\n                    operand.b instanceof Algebra\n                        ? operand.b.multiply(this.a)\n                        : this.a * operand.b\n                );\n            }\n\n            // second term\n            if (this.b instanceof Algebra) {\n                Re.push(this.b.multiply(operand.imaginary()));\n                Im.push(this.b.multiply(operand.real()));\n            } else {\n                Re.push(\n                    operand.b instanceof Algebra\n                        ? operand.b.multiply(this.b)\n                        : operand.b * this.b\n                );\n\n                Im.push(\n                    operand.a instanceof Algebra\n                        ? operand.a.multiply(this.b)\n                        : this.b * operand.a\n                );\n            }\n            return new Complex(Re[0] - Re[1], Im[0] + Im[1]);\n        } else {\n            Re =\n                this.a instanceof Algebra\n                    ? this.a.multiply(operand)\n                    : operand instanceof Algebra\n                    ? operand.multiply(this.a)\n                    : this.a * operand;\n\n            Im =\n                this.b instanceof Algebra\n                    ? this.b.multiply(operand)\n                    : operand instanceof Algebra\n                    ? operand.multiply(this.b)\n                    : this.b * operand;\n        \n            }\n        return new Complex(Re, Im);\n    };\n\n    devide = (denominator) => {\n        if (denominator instanceof Complex) {\n            const result =  this.multiply(denominator.conjugate()).devide(\n                denominator.magnitude$2()\n                );\n            // CHECK THIS\n            if(isNaN(result.real()))\n                result.setA(0);\n            if(isNaN(result.imaginary()))\n                result.setB(0);\n            return result;\n        } else if (denominator instanceof Algebra) {\n            // USE super().devide ?\n            return this.copy(); // for now to avoid craches\n        } else return this.multiply(1 / denominator); // number\n    };\n\n    raiseTo = (power) => {\n        let result = this.copy(true);\n        // for now power must be integr\n        if (Math.floor(power) === power)\n            for (let i = 1; i < power; i++) {\n                result = result.multiply(this);\n            }\n\n        return result;\n    };\n\n    devideInverse = (k) =>\n        (k instanceof Algebra ? k : new Complex(k, 0)).devide(this);\n\n    static extract = (strNumber) => {\n        // extract a string to a complex object\n\n        strNumber = strNumber.replace(/\\s/g, \"\");\n        let i = strNumber[0] === \"-\" || strNumber[0] === \"+\" ? 1 : 0;\n        let real = 0;\n        if (strNumber[i] !== \"j\") {\n            for (; i < strNumber.length && isDigit(strNumber[i]); i++);\n            real = Number(strNumber.slice(0, i) || 0);\n        }\n\n        let sign = 1;\n        for (\n            ;\n            i < strNumber.length &&\n            (strNumber[i] === \"j\" ||\n                strNumber[i] === \"+\" ||\n                strNumber[i] === \"-\");\n            i++\n        )\n            if (strNumber[i] === \"-\") sign = -1;\n\n        const img = Number(strNumber.slice(i, strNumber.length) || 0);\n        return new Complex(real, sign * img);\n    };\n\n    isZero = () => this.a === 0 && this.b === 0;\n}\n\nexport default Complex;\n","import Algebra from \"math/algebra\";\nimport Complex from \"../complex\";\n\nexport default class Poly extends Algebra {\n    static atn = (a, n, symbol = \"t\") => {\n        const aArray = Array(n + 1).fill(0);\n        aArray[0] = a;\n        return new Poly(aArray, symbol);\n    };\n    constructor(a, symbol = \"t\", params = {}) {\n        // ke^ct\n        super(a, { symbol, type: \"poly\", ...params });\n    }\n\n    copy = (linkPrevious = false) =>\n        new Poly(this.a, this.symbol, {\n            dot: this.dot,\n            plus: this.plus,\n            previous: linkPrevious ? this.previous : null,\n            input: this.input,\n        });\n\n    valueAt = (t) => {\n        if (typeof t === \"number\") return Algebra.polynomialValueAt(this.a, t);\n        else if (t instanceof Complex) {\n            const n = this.a.length - 1;\n            if (n >= 0) {\n                let powerTerm = 1,\n                    result =\n                        this.a[n] instanceof Complex\n                            ? this.a[n].copy()\n                            : new Complex(this.a[n], 0);\n                for (let i = n - 1; i >= 0; i--) {\n                    powerTerm = t.multiply(powerTerm);\n                    result = result.add(powerTerm.multiply(this.a[i]));\n                    \n                }\n                return result;\n            }\n            return 0;\n        }\n        return NaN;\n    };\n\n    static Symbolic = (\n        degree,\n        symbol = \"t\",\n        halfTermsVisible = 2,\n        coef = \"a\",\n        inline = false\n    ) => {\n        let res = inline ? \"\" : \"$$\";\n        if (degree === \"n\") {\n            res += `${coef}_n ${symbol}^n + `;\n            for (let i = 1; i < halfTermsVisible; i++)\n                res += `${coef}_{n - ${i}}${symbol}^{n - ${i}} + `;\n            res += \" ... \";\n            for (let i = halfTermsVisible - 1; i > 0; i--)\n                res += ` + ${coef}_{${i}}${symbol}^{${i}}`;\n            res += ` + ${coef}_0`;\n        } else if (typeof degree === \"number\") {\n            for (; degree >= 0; degree--) {\n                res += `${coef}_{${degree}}`;\n                if (degree > 0) res += `${symbol}^{${degree}} + `;\n            }\n        }\n        return res + (inline ? \"\" : \" $$\");\n    };\n    derivative = () => {\n        const result = this.copy(true);\n        if (!result.dot) {\n            const n = result.a.length - 1;\n            const da = Array(n).fill(0);\n            for (let i = n; i >= 1; i--) da[n - i] = i * result.a[n - i];\n            result.a = [...da];\n        }\n        if (result.plus) result.plus = result.plus.derivative();\n        return result;\n    };\n}\n","import { error_codes } from \"config\";\n\nexport default class NotScalarError extends Error {\n    \n    constructor(cause = null){ // the parameter with problem\n        super(cause ? `${cause} => این عبارت باید اسکالر باشد!!` : \"این خطا بدلیل استفاده از یک عبارت غیر اسکالر در مکان غیر مجاز رخ داده است!\")\n        this.name = \"NotNumberError\";\n        this.type = \"Numeric\";\n        this.code = error_codes.not_scalar;\n        this.cause = cause;\n    }\n\n    describe = () => {\n        console.log(this.message + (this.cause ? \"\\n\" + this.cause : \"\"));\n        return this.message + (this.cause ? \"\\n\" + this.cause.toString() : \"\");\n    }\n}","import { CollectionsOutlined } from \"@mui/icons-material\";\nimport NotScalarError from \"errors/algebra/NotScalarError\";\nimport StandardInputSignal from \"math/input-signals\";\nimport { round, strictPrecisionFormat } from \"../calculus\";\n\nclass Algebra {\n    // symbolic expressions\n    constructor(\n        a,\n        { symbol = \"t\", type = \"poly\", b, dot, plus, teta = 0, previous, input }\n    ) {\n        // dot is the interface between terms\n        // g(t) = a * f(t) * {dot: as Algebra}\n        // teta is the offset for wt + alpha in sin/cos/tan/..\n\n        this.symbol = symbol;\n        this.type = type.toLowerCase();\n        this.setA(a).setB(b).setTeta(teta);\n\n        this.input = input; // u(t), r(t), puls, ...\n        if (dot) {\n            this.dot = dot.copy();\n        } // multiply a Algebra from different type into 'this'\n\n        if (plus) {\n            this.plus = plus.copy();\n            this.simplify();\n        } // add another Algebra with different type to this one\n\n        this.previous = previous; // the previous term in the chained Algebra objects\n        // term.plus => next term, term.previous => previous term, term.dot => an algebra from another type that is multiplied to actual term\n        // F(u) = a.f(u).dot(u) + term.plus(u)\n        this.link();\n    }\n    static identify = (parameter) => {\n        if (parameter instanceof Array)\n            return parameter.map((pi) =>\n                pi instanceof Algebra || pi instanceof StandardInputSignal\n                    ? pi.copy()\n                    : round(pi)\n            );\n        else if (parameter instanceof Algebra) {\n            return parameter.copy();\n        } else if (typeof parameter === \"number\") return round(parameter);\n        else if (!parameter) return 0;\n        console.log(parameter);\n        throw new NotScalarError(parameter);\n    };\n    setA = (a) => {\n        this.a = Algebra.identify(a);\n        return this;\n    };\n    getA = () => this.a;\n\n    setB = (b) => {\n        this.b = Algebra.identify(b);\n        return this;\n    };\n    getB = () => this.b;\n\n    setTeta = (teta) => {\n        this.teta = Algebra.identify(teta);\n        return this;\n    };\n    getTeta = () => this.teta;\n    // CONNECT AND LINK METHODS, FIND FIRST TERM AND LAST TERM AND ...\n    end = () => {\n        // returns the end term in the algebratic chain\n        let last = this;\n        while (last.plus) last = last.plus;\n        return last;\n    };\n\n    first = () => {\n        // returns the first term in the algebratic chain\n        let fst = this;\n        while (fst.previous) fst = fst.previous;\n        return fst;\n    };\n\n    enddot = () => {\n        // returns the end term in the algebratic chain\n        let last = this;\n        while (last.dot) last = last.dot;\n        return last;\n    };\n\n    firstdot = () => {\n        // returns the first term in the algebratic chain\n        let fst = this;\n        // WRONG *****************************\n        //while (fst.previous) fst = fst.previous;\n        return fst;\n    };\n    link = () => {\n        // some times .previous links are broken; so i decided to write this method just to make sure everything is connected\n        let term = this.first();\n        if (!term) term = this; // in case this.first() returns wrong answer\n        while (term.plus) {\n            if (term.plus) term.plus.previous = term;\n            term = term.plus; // go to next term in the chain\n        }\n        return this;\n    };\n\n    copy = (linkPrevious = false) =>\n        new Algebra(this.a, {\n            type: this.type,\n            b: this.b,\n            dot: this.dot,\n            plus: this.plus,\n            symbol: this.symbol,\n            teta: this.teta,\n            input: this.input,\n            previous: linkPrevious ? this.previous : null,\n        });\n\n    // SORT THE MULTIPLIERD TERMS ( TERMS CONNECTED WITH this.dot) IN A SPECIFIC ORDER (FOR BETTER SHOW AND COMPARE AND ETC.)\n    // LOOK HERE IT STILL HAS BUGS\n    sort = () => {\n        // sort .dot in special order: poly - exp - frac - ...\n        const orders = [\"poly\", \"exp\", \"frac\"];\n        let position = this;\n        for (const order of orders) {\n            while (position) {\n                let func = position.dot;\n                while (func) {\n                    if (func.type === order && !position.isPrior(order)) {\n                        const temp = position.copy();\n                        position.a =\n                            func.a instanceof Array ? [...func.a] : func.a;\n                        position.type = func.type;\n                        position.symbol = func.symbol;\n                        if (func.b instanceof Array) position.b = [...func.b];\n                        else position.b = func.b;\n\n                        func.a = temp.a instanceof Array ? [...temp.a] : temp.a;\n                        func.type = temp.type;\n                        func.symbol = temp.symbol;\n                        if (temp.b instanceof Array) func.b = [...temp.b];\n                        else func.b = temp.b;\n                    }\n                    func = func.dot;\n                }\n                position = position.dot;\n            }\n        }\n    };\n\n    isPrior = (order) => {\n        const orders = [\"poly\", \"exp\", \"frac\"];\n        const thisValue = orders.findIndex((or) => or === this.type);\n        const orderValue = orders.findIndex((or) => or === order);\n        return thisValue <= orderValue;\n    };\n\n    // CHECK IF ONE TERMS CAN BE ADDED TO ANOTHER ONE (MEANING THEY HAVE SAME PARAMETRIC TERMS)\n    unifiable = (exp) => {\n        // check if this is unifiable with expression:exp\n        //this.sort();\n        //exp.sort();\n        if (exp && this.type === exp.type && this.symbol === exp.symbol) {\n            // check if this and exp are sumable\n            // check .dot s:\n            if (this.dot || exp.dot)\n                return this.dot && this.dot.unifiable(exp.dot);\n\n            if (this.b instanceof Array && exp.b instanceof Array) {\n                if (this.b.length === exp.b.length) {\n                    const sameOnes = this.b.filter(\n                        (item, idx) => item === exp.b[idx]\n                    );\n                    return this.b.length === sameOnes.length;\n                }\n            }\n            return exp.b === this.b;\n        }\n        return false;\n    };\n\n    static valueOf = (x, t = 0) => {\n        if (x) {\n            let value = 0;\n            if (x instanceof Algebra || x instanceof StandardInputSignal)\n                value = x.$(t);\n            else if (x instanceof Array)\n                value = Algebra.polynomialValueAt(x, t);\n            else value = x;\n            return value;\n        }\n        return 0;\n    };\n\n    static polynomialValueAt = (arr, t) => {\n        let value = 0;\n        const n = arr.length - 1;\n        for (let i = 0; i <= n; i++) {\n            value += arr[i] * t ** (n - i);\n        }\n        return value;\n    };\n    // REMOVE REDUNDANT TERMS, SIGNS AND ETC.\n    simplify = () => {\n        let term = this.first();\n        while (term) {\n            if (term instanceof Algebra) {\n                if (\n                    term.a === 0 ||\n                    Algebra.polynomial(term.a, term.symbol) === 0\n                ) {\n                    if (term.previous) {\n                        term.previous.plus = term.plus;\n                    } else {\n                        // remove first term and transfer the second term to first one\n                        if (this === term) term.redundant = true;\n                        if (term.plus) {\n                            term = term.plus.copy(true);\n                            if (term.plus) {\n                                term.plus = term.plus.plus;\n                                if (term.plus) term.plus.previous = term;\n                            }\n                            term.previous = null;\n                        }\n                    }\n                    // }\n                }\n            }\n            term = term.plus;\n        }\n        return this;\n    };\n\n    $ = (t) => {\n        // valueOf function in certain point\n        // I used character $ in many places as acronym for \"set\" in setters, so $ here means that set the t ( or x or whatever) with a certain point\n        // for each type just implement the method literally\n        let result = this.valueAt(t);\n        if (this.dot) result *= this.dot.$(t);\n        if (this.plus) result += this.plus.$(t);\n\n        return result;\n    };\n\n    label = (name = undefined, index = undefined) =>\n        (name\n            ? name +\n              (index !== undefined ? \"_{\" + index + \"}\" : \"\") +\n              \"(\" +\n              this.symbol +\n              \") = \"\n            : \"\") + this.toString();\n\n    // RETURNS THE BEST AND SIMPLE AND SHORTEST WAY TO SHOW COEFFICIENTS\n    static coefy = (a_i, i, n) => {\n        if (a_i instanceof Algebra) {\n            let str = \"\";\n            let ai = a_i.copy();\n            if (i > 0) {\n                // write a method to edit all the + - occuring next to each other in toString()\n                if (ai.type === \"complex\" && typeof ai.a === \"number\") {\n                    if (ai.a < 0) {\n                        str += \" - \";\n                        ai.a *= -1;\n                    } else if (!ai.a && typeof ai.b === \"number\" && ai.b < 0) {\n                        str += \" - \";\n                        ai.b *= -1;\n                    }\n                } else str += \" + \";\n            }\n            return str + ai.toString(i < n && a_i.hasMultiTerms());\n        }\n        if (a_i instanceof StandardInputSignal) {\n            //EDIT THIS PART TOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO\n            let str = i > 0 ? \" + \" : \"\";\n            return str + a_i.toString(i < n && a_i.hasMultiTerms());\n        } else {\n            if (n === 0) return strictPrecisionFormat(a_i);\n            if (a_i === 0) return \"\";\n            if (i !== 0) {\n                let s = \"\";\n                if (a_i < 0) {\n                    s += \" - \";\n                    a_i *= -1;\n                } else s += \" + \";\n\n                if (a_i === 1 && i < n) return s;\n                return s + strictPrecisionFormat(a_i);\n            }\n            if (a_i === 1) return \"\";\n            if (a_i === -1) return \"-\";\n\n            return strictPrecisionFormat(a_i);\n        }\n    };\n\n    // DECIPHER THE OBJECT TO ITS POLYNOMINAL FORM (IF IT IS ONE ACTUALLY)\n    static polynomial = (coefs, symbol) => {\n        if (coefs instanceof Array) {\n            const n = coefs.length - 1;\n            if (\n                !n ||\n                !coefs.slice(0, n).filter((ci) => ci.toString() !== \"0\").length\n            )\n                return coefs[n].toString();\n            return coefs\n                .map((a_i, i) =>\n                    a_i\n                        ? Algebra.coefy(a_i, i, n) +\n                          (i < n\n                              ? symbol +\n                                (i < n - 1\n                                    ? \"^{\" + (n - i).toString() + \"}\"\n                                    : \"\")\n                              : \"\")\n                        : \"\"\n                )\n                .join(\"\"); // joins all the coefficients, symbols, etc all together as for polynomal functions\n        }\n        return coefs.toString();\n    };\n\n    join = () => {\n        // connect this term to its next terms; considering the right use of + or -\n        if (this.plus) {\n            let operator = \"+\",\n                next = this.plus.copy();\n            if (next.a instanceof Array) {\n                if (next.a[0] < 0) {\n                    operator = \"-\";\n                    next.a[0] *= -1;\n                }\n            } else {\n                if (next.a < 0) {\n                    operator = \"-\";\n                    next.a *= -1;\n                }\n            }\n            return operator + next.toString();\n        }\n        return \"\";\n    };\n\n    hasMultiTerms = () => {\n        if (this.plus) return true;\n        if (this.a instanceof Array && this.type !== \"frac\")\n            return this.a.filter((ai) => ai !== 0).length > 1;\n        return false;\n    };\n    isTriangular = () =>\n        this.type === \"sin\" ||\n        this.type === \"cos\" ||\n        this.type === \"tan\" ||\n        this.type === \"cot\";\n\n    // MATHEMATICAL OPERATIONS\n    // static add = (expressions) => expressions.map((el) => el.toString()).join(\" + \");\n    add = (right) => {\n        // result = this + operand\n        let result = this.link().copy();\n        if (right instanceof Algebra) {\n            let operand = right.link().copy();\n\n            let x = result; // now we try to add each term with its unifiable term in y\n            while (x) {\n                let y = operand;\n                while (y) {\n                    if (x.unifiable(y)) {\n                        if (x.a instanceof Algebra) x.a = x.a.add(y.a);\n                        else if (y.a instanceof Algebra) x.a = y.a.add(x.a);\n                        // **************************************************\n                        // else if x.a || y.a instanceof StandardInputSignal\n                        // *********************************************\n                        else if (x.a instanceof Array) {\n                            if (y.a instanceof Array) {\n                                if (y.a.length > x.a.length) x.a = [...y.a];\n                                for (\n                                    let i = 1;\n                                    i <= y.a.length && i <= x.a.length;\n                                    i++\n                                )\n                                    x.a[x.a.length - i] += y.a[y.a.length - i];\n                            } else {\n                                x.a[x.a.length - 1] += y.a;\n                            }\n                        } else {\n                            x.a += y.a;\n                        }\n                        // remove the term in y that has been processed\n                        if (y.previous) {\n                            y.previous.plus = y.plus;\n                            if (y.plus) y.plus.previous = y.previous;\n                            y.a = 0;\n                        }\n\n                        // its the first term\n                        else operand = operand.plus;\n                        // after this the garbage collector will remove the term because it has no reference to it\n                    }\n                    y = y.plus;\n                }\n                // if(x.plus) x.plus.previous = x;\n                x = x.plus; // go to next term in the chain\n            }\n\n            if (operand) {\n                // if the above algorythm leaves operand with non-null value\n                /// it means there was terms in the operand's algebratic chain that are'nt unifiable with x terms\n                // so we must connect the leftovers to last terms of the result\n                if (Algebra.polynomial(result.a, result.symbol) !== \"0\") {\n                    if (\n                        Algebra.polynomial(operand.getA(), operand.symbol) !==\n                        \"0\"\n                    ) {\n                        let endTerm = result.end();\n                        endTerm.plus = operand;\n                        endTerm.plus.previous = result;\n                    }\n                } else result = operand.copy(); // connect to next term\n            }\n            return result.simplify();\n        } else if (right instanceof StandardInputSignal) {\n            const endTerm = result.end();\n            endTerm.plus = right.copy();\n            endTerm.plus.previous = endTerm;\n        }\n        return result;\n    };\n\n    arrangeDots = () => {\n        let term = this;\n        let input = null;\n        while (term.dot) {\n            // enhance the algo for cases that more than one input signal erxists in .dot chain\n            if (term.dot instanceof StandardInputSignal) {\n                input = term.dot;\n                term.dot = term.dot.dot;\n            }\n            if (term.dot) term = term.dot;\n        }\n        term.dot = input;\n    };\n    // INCOMPLETE ***********\n    multiply = (operand) => {\n        const y = this.copy().link();\n        if (operand instanceof Algebra) {\n            // operand algebra or complex\n            // ***** TODO:  ****************\n            if (operand.type === \"poly\") {\n                if (this.type === \"poly\" || this.type === \"frac\") {\n                    // NEEDS ERDITING for FRACTIONs\n                    if (this.symbol === operand.symbol) {\n                        const ao = operand.getA();\n                        const no = ao.length - 1;\n                        const As = [];\n                        for (let i = no; i >= 0; i--) {\n                            if (operand.a[i]) {\n                                const zeros = Array(no - i).fill(0);\n                                const a = [...y.a].map(\n                                    (yai) => yai * operand.a[i]\n                                );\n                                a.push(...zeros);\n                                As.push(a);\n                            }\n                        }\n                        // now sum all the products\n                        console.table(As);\n                        let product = As.pop();\n                        for (let j = 0; j < As.length; j++)\n                            for (\n                                let i = 1;\n                                i <= As[j].length && i <= product.length;\n                                i++\n                            )\n                                product[product.length - i] +=\n                                    As[j][As[j].length - i];\n\n                        y.a = product;\n                        if (operand.dot) {\n                            // link dots ***IS THIS TRUE?>***\n                            const endDotTerm = y.enddot();\n                            endDotTerm.dot = operand.dot.copy(); // multiply\n                            endDotTerm.dot.previous = endDotTerm;\n                        }\n                    }\n                }\n            } else if (y.type !== operand.type && operand.plus) {\n                // like: exp(f(...)) * [Asin(...) * Bcos(...)]\n                // UPDATE SELF MULTIPLY AFTER SOLVING THIS ISSUE\n                y.plus = y.multiply(operand.plus.copy());\n                const lastyDot = y.enddot();\n                if(typeof y.a === 'number' && typeof operand.a === 'number' && operand.a !== 1){\n                    y.a *= operand.a;\n                    operand.a = 1;\n                }\n                lastyDot.dot = operand.copy();\n                lastyDot.dot.previous = lastyDot;\n                // UPDATE SELF MULTIPLY AFTER SOLVING THIS ISSUE\n\n            } else {\n                const endDotTerm = y.enddot();\n                if (typeof y.a === \"number\" && typeof operand.a === \"number\") {\n                    y.a *= operand.a;\n                    operand.a = 1;\n                }\n                endDotTerm.dot = operand.copy(); // multiply\n                endDotTerm.dot.previous = endDotTerm;\n            }\n            if (y.plus) y.plus = y.plus.multiply(operand);\n            if (operand.plus) y.end().plus = y.multiply(operand.plus);\n            return y; // for now just to avoid crashes\n        } else if (operand instanceof StandardInputSignal) {\n            // const endDotTerm = y.enddot();\n            // endDotTerm.dot = operand.copy(); // multiply\n            // endDotTerm.dot.previous = endDotTerm;\n            y.input = operand.copy();\n            if (y.plus) y.plus = y.plus.multiply(operand);\n        } else {\n            // scalar multiply\n            if (operand instanceof Algebra) {\n            } else {\n                if (y.a instanceof Array) y.a = y.a.map((ai) => operand * ai);\n                else if (y.a instanceof Algebra) y.a = y.a.multiply(operand);\n                else y.a = y.a * operand;\n            }\n            if (y.plus) y.plus = y.plus.multiply(operand);\n        }\n        // console.log(\"y = \", y, \"operand = \", operand)\n        return y;\n    };\n\n    selfmultiply = (operand) => {\n        if (operand instanceof Algebra) {\n            // operand algebra or complex\n            // ***** TODO:  ****************\n            if (operand.type === \"poly\") {\n                if (this.type === \"poly\" || this.type === \"frac\") {\n                    // NEEDS ERDITING for FRACTIONs\n                    if (this.symbol === operand.symbol) {\n                        const ao = operand.getA();\n                        const no = ao.length - 1;\n                        const As = [];\n                        for (let i = no; i >= 0; i--) {\n                            if (ao[i]) {\n                                const zeros = Array(no - i).fill(0);\n                                const a = [...this.a].map(\n                                    (yai) => yai * operand[i]\n                                );\n                                a.push(...zeros);\n                                As.push(a);\n                            }\n                        }\n                        // now sum all the products\n                        const product = As.pop();\n                        for (let i = 0; i < product.length; i++) {\n                            for (let j = 0; j < As.length; j++) {\n                                if (i < As[j].length) product[i] += As[j][i];\n                            }\n                        }\n                        this.a = product;\n                        if (operand.dot) {\n                            // link dots ***IS THIS TRUE?>***\n                            const endDotTerm = this.enddot();\n                            endDotTerm.dot = operand.dot.copy(); // multiply\n                            endDotTerm.dot.previous = endDotTerm;\n                        }\n                    }\n                }\n            } else {\n                const endDotTerm = this.enddot();\n                endDotTerm.dot = operand.copy(); // multiply\n                endDotTerm.dot.previous = endDotTerm;\n                if (this.plus) this.plus = this.plus.multiply(operand);\n            }\n        } else if (operand instanceof StandardInputSignal) {\n            // this.dot = operand.copy(); // multiply\n            // this.dot.previous = this;\n            this.input = operand.copy();\n            if (this.plus) this.plus.selfmultiply(operand);\n            if (operand.plus) this.end().plus = this.multiply(operand.plus);\n        } else {\n            // scalar multiply\n            if (this.a instanceof Array)\n                this.a = this.a.map((ai) => operand * ai);\n            else this.a *= operand;\n\n            if (this.plus) this.plus.selfmultiply(operand);\n        }\n    };\n\n    negation = () => this.multiply(-1);\n\n    substract = (operand) => this.add(operand.negation());\n\n    devide = (operand) => {\n        // u need to handle Complex objects as Algebra using their type to recognize them\n        if (operand instanceof Algebra) {\n            // operand algebra or complex\n            // ***** TODO:  ****************\n            // first u must do everything to simplify\n            // second at the simplest state of the terms,\n            // construct a new Algebra of \"frac\" type\n            return this.copy(); // for now just to avoid crashes\n        } else {\n            // scaler\n            return this.multiply(1 / operand);\n        }\n    };\n\n    laplace = () => {};\n\n    static areTheSame = (el1, el2) => {\n        // checkes the sameness of parameters like .a .b .teta , etc.\n        if(el1 instanceof Algebra && el2 instanceof Algebra)\n            return el1.equals(el2);\n        else if(el1 instanceof Array && el2 instanceof Array){\n            if(el1.length === el2.length){\n                let i = 0;\n                for(i = 0; i < el1.length; i++)\n                    if(el1[i] !== el2[i]) break;\n                return i >= el1.length;\n                \n            }\n        }\n        return typeof el1 === typeof el2 && el1 === el2;\n    }\n    equals = (operand) => operand instanceof Algebra && \n                            this.type === operand.type && \n                            this.symbol === operand.symbol &&\n                            this.type === operand.type &&\n                            this.symbol === operand.symbol &&\n                            Algebra.areTheSame(this.a, operand.a) &&\n                            Algebra.areTheSame(this.b, operand.b) &&\n                            Algebra.areTheSame(this.teta, operand.teta) &&\n                            (!this.dot || this.dot.equals(operand.dot)) &&\n                            (!this.plus || this.plus.equals(operand.plus)) &&\n                            (!this.previous || this.previous.equals(operand.previous));\n\n\n    static areTheseTwoEqual = (p1, p2) =>\n        p1 instanceof Algebra\n            ? p1.equals(p2)\n            : p2 instanceof Algebra\n            ? p2.equals(p1)\n            : p1 === p2;\n    // DECIPHERS THE CONNECT OBJECTS TO UNDERSTANDABLE MATHMATICALLY SHAPED TEXT\n    // IT IS FORMATTED COMPATIBLE FOR MathJax component\n    toString = (parenthesis = false) => {\n        // this.arrangeDots();\n        this.simplify(); // simplify current chain that's left from unknown number of operations\n        let formula = \"\";\n        // if ... + 0 || 0 + ... appears ===>>>>> see below !!\n        if (!this.a) return \"0\"; // what if **************************************** 0 / 0\n        if (parenthesis) formula += \"(\";\n        switch (this.type.toLowerCase()) {\n            case \"exp\": {\n                // if (this.a < 0) formula += \"(\";\n                let a0 = this.a;\n                if (a0 < 0) {\n                    formula += \"-\";\n                    a0 *= -1;\n                }\n                if (a0 !== 1)\n                    if (a0 instanceof Algebra)\n                        formula += a0.toString(\n                            a0 instanceof Algebra && a0.hasMultiTerms()\n                        );\n                    else if (a0 instanceof Array)\n                        // testTEST\n                        formula += Algebra.polynomial(a0, this.symbol);\n                    // FOR TEST\n                    else formula += strictPrecisionFormat(a0);\n                if (this.dot instanceof Algebra)\n                    formula += this.dot.toString(\n                        this.dot instanceof Algebra && this.dot.hasMultiTerms()\n                    );\n                if (this.b !== 0) {\n                    if (this.a !== 0) {\n                        formula += \"e^{\";\n                        let e0 = this.b;\n                        if (this.b instanceof Algebra)\n                            formula += this.b.toString(\n                                this.b instanceof Algebra &&\n                                    this.b.hasMultiTerms()\n                            );\n                        else if (this.b instanceof Array)\n                            formula += Algebra.polynomial(this.b, this.symbol);\n                        else {\n                            if (e0 < 0) {\n                                formula += \"-\";\n                                e0 *= -1;\n                            }\n                            if (e0 !== 1) formula += e0;\n                        }\n                        formula += this.symbol + \"}\";\n                    }\n                    if (this.input) formula += this.input.toString();\n                } else {\n                    if (a0 !== 1 || !this.dot)\n                        formula += strictPrecisionFormat(this.a);\n                }\n                // if (this.a < 0) formula += \")\";\n                if (this.plus) formula += this.join(); // if there's a next term: casscade toString() calls\n                break;\n            }\n            case \"poly\":\n                formula += Algebra.polynomial(this.a, this.symbol);\n                if (this.dot instanceof Algebra)\n                    formula += this.dot.toString(\n                        this.dot instanceof Algebra && this.dot.hasMultiTerms()\n                    );\n                if (this.input) {\n                    formula += (parenthesis ? \")\" : \"\") + this.input.toString();\n                    parenthesis = false;\n                }\n                if (this.plus) formula += this.join(); // if there's a next term: casscade toString() calls\n                break;\n            case \"frac\": {\n                if (this.dot instanceof Algebra)\n                    formula += this.dot.toString(\n                        this.dot instanceof Algebra && this.dot.hasMultiTerms()\n                    );\n                const numerator = Algebra.polynomial(this.a, this.symbol);\n                formula +=\n                    numerator !== \"0\"\n                        ? \"\\\\frac{\" +\n                          numerator +\n                          \"}{\" +\n                          Algebra.polynomial(this.b, this.symbol) +\n                          \"}\"\n                        : \"0\";\n                if (this.input) formula += this.input.toString();\n                if (this.plus) formula += this.join(); // if there's a next term: casscade toString() calls\n\n                break;\n            }\n            case \"sin\":\n            case \"asin\":\n            case \"cos\":\n            case \"tan\":\n            case \"cot\": {\n                // if (this.a < 0) formula += \"(\";\n                let a0 = this.a;\n                if (a0 < 0) {\n                    formula += \"-\";\n                    a0 *= -1;\n                }\n                if (a0 !== 1)\n                    if (a0 instanceof Algebra)\n                        formula += a0.toString(\n                            a0 instanceof Algebra && a0.hasMultiTerms()\n                        );\n                    else if (a0 instanceof Array)\n                        formula += Algebra.polynomial(a0, this.symbol);\n                    // FOR TEST\n                    else formula += strictPrecisionFormat(a0);\n                if (this.a !== 0) {\n                    if (this.dot && this.dot instanceof Algebra)\n                        formula += this.dot.toString(\n                            this.dot instanceof Algebra &&\n                                this.dot.hasMultiTerms()\n                        );\n                    if (this.b !== 0) {\n                        formula += this.type;\n                        if (this.b instanceof Algebra) {\n                            formula += this.b.toString(\n                                this.b instanceof Algebra &&\n                                    this.b.hasMultiTerms()\n                            );\n                        } else if (this.b instanceof Array)\n                            formula += Algebra.polynomial(this.b, this.symbol);\n                        // FOR TEST\n                        else {\n                            let w0 = this.b;\n                            formula += \"(\";\n                            if (w0 < 0) {\n                                formula += \"-\";\n                                w0 *= -1;\n                            }\n                            if (w0 !== 1) formula += strictPrecisionFormat(w0);\n                            formula += this.symbol;\n                            if (this.teta instanceof Algebra)\n                                formula += this.teta.toString();\n                            else if (this.teta) {\n                                let e0 = this.teta;\n                                if (e0 < 0) {\n                                    formula += \" - \";\n                                    e0 *= -1;\n                                } else formula += \" + \";\n                                formula += strictPrecisionFormat(e0);\n                            }\n                            formula += \")\";\n                        }\n                        if (this.input) formula += this.input.toString();\n                    }\n                    // simple num\n                } else {\n                    if (a0 !== 1 || !this.dot)\n                        formula += strictPrecisionFormat(this.a);\n                }\n                // if (this.a < 0) formula += \")\";\n                if (this.plus) formula += this.join(); // if there's a next term: casscade toString() calls\n                break;\n            }\n\n            default:\n                return null;\n        }\n        if (parenthesis) formula += \")\";\n\n        return formula;\n    };\n    toArray = () => {\n        let x = [];\n        const params = [\"a\", \"b\", \"teta\", \"symbol\", \"type\"],\n            linkers = [\"dot\", \"input\", \"plus\", \"previous\"];\n        for (const [key, value] of Object.entries(this)) {\n            if (typeof value !== \"function\") {\n                if (value) {\n                    // maximum toArray call happens\n                    if (params.filter((p) => p === key).length)\n                        x[key] =\n                            value instanceof Algebra ? value.toArray() : value;\n                    //)((value instanceof StandardInputSignal ? value.copy() : ));\n                    else if (linkers.filter((l) => l === key).length)\n                        x[key] =\n                            value instanceof StandardInputSignal\n                                ? value.copy()\n                                : value.toArray();\n                }\n            }\n        }\n        return x;\n    };\n}\n\nexport default Algebra;\n","import { round, strictPrecisionFormat } from \"../calculus\";\n\nexport default class StandardInputSignal {\n    constructor(amplitude = 1, type = \"u\", symbol = \"t\") {\n        this.symbol = symbol;\n        this.type = type;\n        this.amp = round(amplitude);\n    }\n\n    copy = () => new StandardInputSignal(this.amp, this.type, this.symbol);\n\n    toString = () => {\n        let str = \"\",\n            a = this.amp;\n        if (this.amp === -1) {\n            str += \"-\";\n            a *= -1;\n        }\n        if (a !== 1) str += strictPrecisionFormat(a);\n        return str + `${this.type}(${this.symbol})`;\n    };\n\n    ampiltude = () => this.amp;\n}\n"],"names":["Complex","preal","pimage","params","symbol","type","b","hasMultiTerms","plus","a","toString","parenthesis","isZero","rl","formula","Algebra","round","im","join","real","imaginary","copy","linkPrevious","dot","previous","input","conjugate","negation","magnitude$2","magnitude","isReal","hasSameTypeWith","x","realify","add","operand","Re","Im","substract","equals","isConjugateWith","multiply","push","devide","denominator","result","isNaN","setA","setB","raiseTo","power","Math","floor","i","devideInverse","k","extract","strNumber","replace","length","isDigit","Number","slice","sign","img","Poly","valueAt","t","n","powerTerm","NaN","derivative","da","Array","fill","atn","aArray","Symbolic","degree","halfTermsVisible","coef","inline","res","NotScalarError","cause","describe","console","log","message","name","code","error_codes","Error","teta","identify","getA","getB","setTeta","getTeta","end","last","first","fst","enddot","firstdot","link","term","sort","position","order","func","isPrior","temp","orders","findIndex","or","unifiable","exp","sameOnes","filter","item","idx","simplify","polynomial","redundant","$","label","undefined","index","operator","next","ai","isTriangular","right","y","endTerm","StandardInputSignal","arrangeDots","no","As","zeros","map","yai","table","product","pop","j","endDotTerm","lastyDot","selfmultiply","ao","laplace","areTheSame","toLowerCase","a0","strictPrecisionFormat","e0","numerator","w0","toArray","linkers","key","value","p","l","Object","entries","this","parameter","pi","valueOf","polynomialValueAt","arr","coefy","a_i","str","s","coefs","ci","el1","el2","areTheseTwoEqual","p1","p2","amplitude","amp","ampiltude"],"sourceRoot":""}