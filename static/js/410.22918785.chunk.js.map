{"version":3,"file":"static/js/410.22918785.chunk.js","mappings":"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","sources":["math/algebra/functions/exp.js","math/algebra/functions/fraction.js","math/input-signals/signals.js","math/equation/index.js","math/algebra/functions/transfer.js","math/algebra/functions/trigonometric.js"],"sourcesContent":["import Algebra from \"math/algebra\";\nimport Complex from \"math/algebra//complex\";\nimport { Cos, Sin } from \"./trigonometric\";\n\nexport default class Exp extends Algebra {\n    constructor(a, b, symbol = \"t\", params = {}) {\n        // ae^bt\n        super(a, { symbol, type: \"exp\", b, ...params });\n    }\n\n    copy = (linkPrevious = false) =>\n        new Exp(this.a, this.b, this.symbol, {\n            dot: this.dot,\n            plus: this.plus,\n            previous: linkPrevious ? this.previous : null,\n            input: this.input\n        });\n\n    toSin = () => {\n        const exp = this.copy();\n        if (exp.type === \"exp\" && exp.b instanceof Complex) {\n            if (exp.b instanceof Complex && exp.b.real() === 0) {\n                const cos = new Cos(exp.a, exp.b.imaginary());\n                const sin = new Sin(exp.a, -exp.b.imaginary());\n                return new Complex(cos, sin);\n            }\n        }\n        return exp; // if doesnt math the condition then just return exponential function itself\n    };\n\n    valueAt = (t) => {\n        const a = Algebra.valueOf(this.a, t),\n            b = Algebra.valueOf(this.b, t);\n        return a * Math.exp(b * t);\n    }\n}\n","import Algebra from \"math/algebra\";\nimport Poly from \"./poly\";\n\nexport default class Fraction extends Algebra {\n    constructor(num, den = [1], symbol = \"t\", params = {}) {\n        // ke^ct\n        if (!(num instanceof Algebra)) {\n            if (!(num instanceof Array)) num = [num];\n            // this.a\n            else if (num.length === 0) num = [0];\n        }\n        if (!(den instanceof Algebra)) {\n            if (!(den instanceof Array)) den = [den];\n            // this.b\n            else if (den.length === 0) den = [1];\n        }\n        super(num, { symbol, type: \"frac\", b: den, ...params });\n    }\n\n    copy = (linkPrevious = false) =>\n        new Fraction(this.a, this.b, this.symbol, {\n            dot: this.dot,\n            plus: this.plus,\n            previous: linkPrevious ? this.previous : null,\n            input: this.input\n        });\n\n    lim = () => {\n        // for all fractions with all kind of numerator and denominator\n    }\n    \n    numerator = () => new Poly(this.a);\n    denominator = () => new Poly(this.b);\n\n    setNumerator = (num) => {\n        if (!(num instanceof Algebra)) {\n            if (!(num instanceof Array)) num = [num];\n            // this.a\n            else if (num.length === 0) num = [0];\n        }\n        return this.setA(num);\n    }\n\n    setDenominator = (den) => {\n        if (!(den instanceof Algebra)) {\n            if (!(den instanceof Array)) den = [den];\n            // this.b\n            else if (den.length === 0) den = [1];\n        }\n        return this.setB(den);\n    }\n    valueAt = (t) => {\n        const num = Algebra.valueOf(this.a, t);\n        const den = Algebra.valueOf(this.b, t);\n        return num / den;\n    }\n\n}\n","import StandardInputSignal from \"math/input-signals\";\nimport Poly from \"math/algebra/functions/poly\";\n\nexport class Step extends StandardInputSignal {\n    constructor(amplitude = 1, symbol = \"t\") {\n        super(amplitude, \"u\", symbol); // \\\\delta is the equivalent of small delta in mathjax\n    }\n    copy = () => new Step(this.amp, this.symbol);\n\n    $ = (t) => (t >= 0) * this.amp;\n}\n\nexport class Puls extends StandardInputSignal {\n    constructor(Delta = 1, amplitude = 1, symbol = \"t\") {\n        super(amplitude, \"\\\\sqcap\", symbol);\n        this.Delta = Delta;\n    }\n    copy = () => new Puls(this.Delta, this.amp, this.symbol);\n    $ = (t) => (t >= 0 && t <= this.Delta) * this.amp / this.Delta;\n}\n\nexport class Impact extends StandardInputSignal {\n    constructor(amplitude = 1, symbol = \"t\") {\n        super(amplitude, \"\\\\delta\", symbol); // \\\\delta is the equivalent of small delta in mathjax\n    }\n    copy = () => new Impact(this.amp, this.symbol);\n\n    $ = (t) => this.amp * (t === 0);\n}\n\nexport class Ramp extends Poly {\n    constructor(amplitude, symbol = \"t\") {\n        super([amplitude, 0], symbol);\n        this.amplitude = amplitude; // just for calculating the value of this\n        this.selfmultiply(Step());\n    }\n    copy = () => new Ramp(this.amplitude, this.symbol);\n\n    $ = (t) => (t >= 0) * t * this.amplitude;\n}\n\n\nexport class Parabolic extends Poly { //EDIT\n    constructor(amplitude, symbol = \"t\") {\n        super([amplitude, 0, 0], symbol);\n        this.amplitude = amplitude; // just for calculating the value of this\n        this.selfmultiply(Step());\n    }\n    copy = () => new Parabolic(this.amplitude, this.symbol);\n    $ = (t) => (t >= 0 ? t * this.amplitude : 0);\n}\n","import nerdamer from \"nerdamer/nerdamer.core\";\r\nimport \"nerdamer/Algebra\";\r\nimport \"nerdamer/Solve\";\r\nimport \"nerdamer/Calculus\";\r\nimport \"nerdamer/Extra\";\r\nimport Algebra from \"../algebra/index\";\r\nimport { precision, round } from \"math/calculus\";\r\nimport Complex from \"math/algebra/complex\";\r\n\r\nexport default class Equation {\r\n    static zeroPrecision = round(10 ** -precision.get());\r\n    constructor(expression, symbol = null) {\r\n        if (expression instanceof Algebra) {\r\n            this.expression = expression.copy(true);\r\n            this.symbol = this.expression.symbol;\r\n        } else if (typeof expression === \"string\") {\r\n            this.expression = expression;\r\n        }\r\n\r\n        this.symbol = symbol;\r\n    }\r\n\r\n    roots = () => {\r\n        console.log(nerdamer.solve(this.expression, this.symbol));\r\n        let x = nerdamer.solve(this.expression, this.symbol).toDecimal();\r\n        x = x.slice(1, x.length - 1);\r\n        x = x.split(\",\").filter((xi) => xi && xi !== \"\"); // now x is converted from a string to the array of x answers (as Numbers);\r\n        // edit string to array\r\n        return x;\r\n    };\r\n\r\n    AlgebraRoots = () => {\r\n        // convert roots returning string to\r\n        if (!this.roots || this.roots.length === 0) this.solve();\r\n    };\r\n\r\n    // needs work!\r\n    static newton = (polyf, x0 = 0, N = 20) => {\r\n        const f = polyf.$;\r\n        const df = polyf.derivative().$;\r\n        const xs = Array(N + 1).fill(0);\r\n        const dfx0 = df(x0);\r\n        if (dfx0 && (!(dfx0 instanceof Complex) || !dfx0.isZero())) {\r\n            if (x0 instanceof Complex) {\r\n                xs[0] = x0;\r\n                for (let i = 0; i < N; i++) {\r\n                    // const dfxsi = df(xs[i]);\r\n                    // console.log(\"xs[i] = \", xs[i].toString(), \"=> f(x) = \", f(xs[i]).toString(), \"=> df =\", dfxsi.toString(), \"res = \", f(xs[i]).devide(df(xs[i])))\r\n                    xs[i + 1] = xs[i].substract(f(xs[i]).devide(df(xs[i])));\r\n                }\r\n                \r\n                const fx = f(xs[N]);\r\n                if (\r\n                    Math.abs(fx.real()) > Equation.zeroPrecision ||\r\n                    Math.abs(fx.imaginary()) > Equation.zeroPrecision\r\n                )\r\n                    return NaN;\r\n            } else {\r\n                xs[0] = x0;\r\n\r\n                for (let i = 0; i < N; i++) {\r\n                    xs[i + 1] = xs[i] - f(xs[i]) / df(xs[i]);\r\n                }\r\n\r\n                if (f(xs[N]) > Equation.zeroPrecision) return NaN;\r\n            }\r\n            //integrity check!\r\n            return xs[xs.length - 1];\r\n        }\r\n        return NaN;\r\n    };\r\n\r\n    approximate = (method = Equation.newton, boundary = 1000, N = 10) => {\r\n        const allRoots = [];\r\n        // newton reaches to approx fast\r\n        // so N = 10 is enough (?????)\r\n        const isUnique = (newRoot) =>\r\n            !isNaN(newRoot) &&\r\n            allRoots.findIndex((rt) => !(rt instanceof Complex) ? rt === newRoot : rt.equals(newRoot)) === -1;\r\n        const isUniqueComplex = (newRoot) =>\r\n            newRoot instanceof Complex &&\r\n            allRoots.findIndex(\r\n                (rt) => newRoot.equals(rt)\r\n            ) === -1;\r\n\r\n        if (this.expression instanceof Algebra) {\r\n            let a0 = 0;\r\n            for(let i = this.expression.a.length - 1;i >= 0; i--)\r\n                if(this.expression.a[i]){\r\n                    a0 = this.expression.a[i];\r\n                    break;\r\n                }\r\n            const an = this.expression.a[0];\r\n\r\n            if (a0 && an !== 0) boundary = Math.abs(a0 / an);\r\n            \r\n            for (let x0 = -boundary; x0 <= boundary; x0++) {\r\n                let x = method(this.expression, x0, N);\r\n                if (!isNaN(x)) {\r\n                    const rx = round(x);\r\n                    if (isUnique(rx)) allRoots.push(rx);\r\n                }\r\n                x = method(this.expression, new Complex(0, x0), N);\r\n                if (isUniqueComplex(x)) allRoots.push(x);\r\n            }\r\n        }\r\n        return allRoots;\r\n    };\r\n    // needs work!\r\n    static middlePoint = (\r\n        f,\r\n        boundary = 1000\r\n        // decimalPrecision = precision.get()\r\n    ) => {\r\n        // NOTE: works fine for some equations\r\n        // and wronge for some others like:  x ** 2 - 4*x  - 5\r\n        boundary = Math.abs(boundary);\r\n        const expectedRate = Equation.zeroPrecision;\r\n        const poles = [];\r\n        let xa = 0,\r\n            xb = 1;\r\n        for (let i = 0; i < boundary; i++) {\r\n            xa = -boundary + i;\r\n            xb = boundary - i;\r\n\r\n            let rate = (xb - xa) / (2 * Math.max(Math.abs(xa), Math.abs(xb)));\r\n            let p = null;\r\n            while (rate >= expectedRate) {\r\n                p = (xa + xb) / 2;\r\n                if (!f(p)) break;\r\n                else if (f(p) * f(xa) < 0) xb = p;\r\n                else {\r\n                    xa = p;\r\n                    rate =\r\n                        (xb - xa) / (2 * Math.max(Math.abs(xa), Math.abs(xb)));\r\n                }\r\n            }\r\n            if (!f(p)) poles.push(round(p));\r\n        }\r\n        return new Set(poles);\r\n    };\r\n}\r\n","import Algebra from \"../index\";\nimport Complex from \"../complex\";\nimport Exp from \"./exp\";\nimport Fraction from \"./fraction\";\nimport { Step } from \"math/input-signals/signals\";\nimport Poly from \"./poly\";\nimport { Cos, Sin } from \"./trigonometric\";\nimport { round } from \"math/calculus/index\";\nimport Equation from \"math/equation\";\n\nexport default class TransferFunction extends Fraction {\n    static Specials = {\n        $1: (k, a) =>\n            new TransferFunction([k], [1, -a]).setRoots([], [a]).setOrder(1),\n        $2: (k, a, b = a instanceof Complex ? a.conjugate : a) => {\n            // k / (s + a)(s + b) => must be converted to => k / (s2 + 2(a+b)s + ab)\n            let aplusb =\n                a instanceof Algebra\n                    ? a.add(b)\n                    : b instanceof Algebra\n                    ? b.add(a)\n                    : b + a;\n            let ab =\n                a instanceof Algebra\n                    ? a.multiply(b)\n                    : b instanceof Algebra\n                    ? b.multiply(a)\n                    : b * a;\n            if (aplusb instanceof Complex && aplusb.isReal())\n                aplusb = aplusb.real();\n            if (ab instanceof Complex && ab.isReal()) ab = ab.real();\n\n            return new TransferFunction(\n                [k],\n                [1, aplusb instanceof Algebra ? aplusb.negation() : -aplusb, ab]\n            )\n                .setRoots([], [a, b])\n                .setOrder(2);\n        },\n        $WnZ: (w_n, zeta) => new TransferFunction(null, null, { w_n, zeta }),\n        $design: (t_rise, overshoot) =>\n            new TransferFunction(null, null, { overshoot, t_rise }),\n    };\n\n    static omegaZetaPoles = (w_n, zeta) => {\n        if (Math.abs(zeta) >= 1) {\n            const alpha = -zeta * w_n;\n            const beta = w_n * (zeta * zeta - 1) ** 0.5;\n            return [alpha + beta, alpha - beta];\n        }\n        const alpha = -zeta * w_n;\n        const beta = w_n * (1 - zeta * zeta) ** 0.5;\n        return [new Complex(alpha, beta), new Complex(alpha, -beta)];\n    };\n    constructor(numerator, denominator, params = {}) {\n        let zeros = [],\n            poles = [];\n        if (params) {\n            if (params.overshoot && params.t_rise) {\n                params.overshoot = Number(params.overshoot);\n                params.t_rise = Number(params.t_rise);\n                const logMp = Math.log(params.overshoot);\n                params.zeta =\n                    -logMp / (Math.PI * Math.PI + logMp * logMp) ** 0.5;\n                params.w_d = Math.PI / params.t_rise;\n                params.w_n =\n                    params.w_d / (1 - params.zeta * params.zeta) ** 0.5;\n            }\n\n            if (params.w_n) {\n                params.w_n = Number(params.w_n);\n                params.zeta = Number(params.zeta);\n                // if the user sends w_n params it will override the given zero/pole list\n                const { w_n, zeta } = params;\n                const wn2 = w_n * w_n;\n                numerator = wn2;\n                denominator = [1, 2 * zeta * w_n, wn2];\n                poles = TransferFunction.omegaZetaPoles(w_n, zeta);\n                zeros = [];\n            }\n        }\n        super(numerator, denominator, \"s\", params);\n        // SIMPL;IFY\n        this.poles = [...poles]; //edit solve equations\n        this.zeros = [...zeros];\n        if (!this.a instanceof Array) this.a = [this.a];\n        if (this.a.length === 1 && !this.w_n) {\n            if (\n                this.b.length === 3 &&\n                this.b[this.b.length - 1] === this.a[0]\n            ) {\n                this.w_n = this.a[0];\n                this.zeta = this.b[1] / (2 * this.w_n);\n                this.timeConstant = round(1 / (this.zeta * this.w_n));\n                this.t_settle = 4 * this.timeConstant;\n                if (params && params.w_d) this.w_d = params.w_d;\n                else if (this.zeta >= -1 && this.zeta <= 1)\n                    this.w_d = this.w_n * (1 - this.zeta ** 2) ** 0.5;\n                this.order = 2;\n                this.setRoots(\n                    [],\n                    TransferFunction.omegaZetaPoles(this.w_n, this.zeta)\n                );\n            }\n        }\n        if (!this.order)\n            this.order =\n                denominator instanceof Array ? denominator.length - 1 : 1;\n        if (params.overshoot && params.t_rise) {\n            [this.overshoot, this.t_rise] = [params.overshoot, params.t_rise];\n        } else {\n            const dampingCharasteristics =\n                this.getDampingSystemCharasteristics();\n            if (dampingCharasteristics) {\n                this.overshoot = dampingCharasteristics.overshoot;\n                this.t_rise = dampingCharasteristics.t_rise;\n            }\n        }\n    }\n    static sortRoots = (rt) =>\n        rt.sort((ri, rj) =>\n            ri instanceof Algebra\n                ? ri.substract(rj)\n                : rj instanceof Algebra\n                ? rj.substract(ri)\n                : Math.abs(ri) - Math.abs(rj)\n        );\n    roots = () => [this.zeros, this.poles];\n    setRoots = (zeros, poles) => {\n        this.poles = poles.map((pi) =>\n            pi instanceof Complex && pi.isReal() ? pi.real() : pi\n        );\n        this.zeros = zeros.map((zi) =>\n            zi instanceof Complex && zi.isReal() ? zi.real() : zi\n        );\n        return this;\n    };\n\n    getDampingSystemCharasteristics = () =>\n        this.w_d\n            ? {\n                  t_rise: round(Math.PI / this.w_d),\n                  // WHAT IF W_D === 0?\n                  overshoot:\n                      this.zeta >= -1 && this.zeta <= 1\n                          ? round(\n                                100 *\n                                    Math.exp(\n                                        -(this.zeta * Math.PI) /\n                                            (1 - this.zeta ** 2) ** 0.5\n                                    )\n                            )\n                          : null,\n              }\n            : null;\n\n    getOrder = () => this.order;\n    setOrder = (order) => {\n        this.order = order;\n        return this;\n    };\n    getPoles = () => this.poles;\n    setPoles = (poles) => {\n        this.poles = TransferFunction.sortRoots(poles).map((pi) =>\n            pi instanceof Complex && pi.isReal() ? pi.real() : pi\n        );\n        return this;\n    };\n    getZeros = () => this.zeros;\n    setZeros = (zeros) => {\n        this.zeros = zeros.map((pi) =>\n            pi instanceof Complex && pi.isReal() ? pi.real() : pi\n        );\n        return this;\n    };\n\n    poleOrder = (pole) =>\n        this.poles.filter((pi) => Algebra.areTheseTwoEqual(pole, pi)).length;\n\n    laplace = () => this.copy(); // actually it has no laplace, this is for disfunctioning the laplace method in the parent class Algebra\n    laplaceInverse = () => {\n        const m = this.zeros.length - 1; // number of zeros\n        const n = this.poles.length - 1; // number of poles\n\n        if (m === 0) {\n            switch (n) {\n                case 2:\n                    return null;\n                case 1:\n                    return new Algebra(1, { type: \"exp\" }); //EDITTTTTTTTTTTTTTTT\n                case 0:\n                    return null; //u(t)\n                default:\n                    return null; //DEFINE AN UNKNOWN FUNCTION FOR CASE LIKE THIS\n            }\n        }\n    };\n    step = (inTimeDomain = true) => {\n        // normally will automatically return the time domain answer\n        // unless inLaplaceDomain is true\n        if (inTimeDomain) {\n            const m = this.zeros.length; // number of zeros\n            const n = this.poles.length; // number of poles\n            const nreal = this.poles.filter(\n                (pi) => !(pi instanceof Complex)\n            ).length; // number of real poles; can be eigher 2 or 0\n            if (m === 0) {\n                const k = this.numerator();\n                if (n === 0) {\n                    // return u(t)\n                    // DEFINE U(T) IN ALGEBRA\n                }\n                if (n === 1) {\n                } else if (n === 2) {\n                    const a = -this.poles[0],\n                        b = -this.poles[1];\n                    if (nreal === 2) {\n                        // if (a > 0 && b > 0) {\n                        if (a !== b)\n                            // two independent polesdddd\n                            // two negative independent poles\n                            return new Exp(1 / a, -a)\n                                .add(new Exp(-1 / b, -b))\n                                .multiply(k / (a - b))\n                                .multiply(new Step())\n                                .add(new Step(k / (a * b)));\n                        else {\n                            const a2 = a * a;\n                            return new Exp(-k / a2, -a)\n                                .multiply(new Poly([a, 1]))\n                                .multiply(new Step())\n                                .add(new Step(k / a2));\n                        }\n                        // } else {\n                        //     // repetetive poles\n                        // }\n                    } else if (nreal === 0) {\n                        // two conjugated complex poles\n                        //UNDERSHOOT BUG FIXLAYS HERE\n                        const a = -this.poles[0].real(),\n                            b = this.poles[0].imaginary();\n                        const ka2b2 = k / (a ** 2 + b ** 2);\n                        // FIND BUUUUUUG\n                        // return new Exp(-ka2b2, -a)\n                        //     .multiply(new Cos(1, b).add(new Sin(a / b, b)))\n                        //     .multiply(new Step())\n                        //     .add(new Step(ka2b2));\n                        return new Exp(-ka2b2, -a)\n                            .multiply(new Cos(1, b))\n                            .add(\n                                new Exp(-ka2b2, -a).multiply(new Sin(a / b, b))\n                            )\n                            .multiply(new Step())\n                            .add(new Step(ka2b2));\n                    }\n                    // else if( nreal == 1) // this cant happen, but what if sth went wrong?\n                }\n            }\n        } else {\n            const lstep = this.copy();\n            const poles = lstep.getPoles();\n            poles.push(0);\n            lstep.getB().push(0); //update denominator\n            lstep.setPoles(poles).setDenominator(lstep.getB());\n            return lstep;\n        }\n    };\n    copy = (linkPrevious = false) =>\n        new TransferFunction(this.a, this.b, {\n            overshoot: this.overshoot,\n            t_rise: this.t_rise,\n            t_settle: this.t_settle,\n            w_d: this.w_d,\n            timeConstant: this.timeConstant,\n            w_n: this.w_n,\n            zeta: this.zeta,\n            dot: this.dot,\n            plus: this.plus,\n            previous: linkPrevious ? this.previous : null,\n            input: this.input,\n        }).setRoots(this.zeros, this.poles);\n\n    lim = (s0) => {\n        let num, den;\n        // for simple polynomial numerator and denominator fractions\n        // IMPLEMENT HOPITAL AS WELL?\n        if (!s0) {\n            // s -> 0)\n\n            num = { a: 0, sp: this.a.length - 1 };\n            den = { b: 1, sp: this.b.length - 1 };\n            for (; num.sp > 0 && this.a[num.sp] === 0; num.sp--);\n            num.a = this.a[num.sp];\n            for (; den.sp > 0 && this.b[den.sp] === 0; den.sp--);\n            den.b = this.b[den.sp];\n            num.sp = this.a.length - num.sp - 1;\n            den.sp = this.b.length - den.sp - 1;\n            if (num.sp === den.sp) return num.a / den.b;\n            else {\n                const sMinPower = Math.min(den.sp, num.sp);\n                if (sMinPower) {\n                    num.sp -= sMinPower;\n                    den.sp -= sMinPower;\n                }\n                // now one of num.sp or den.sp is zero\n                if (den.sp)\n                    // zero on denominator\n                    return Infinity;\n                // if den.sp == 0 and num.sp != 0\n                return 0;\n            }\n        } else if (s0 === Infinity) {\n            // s -> infinity\n            num = { a: 0, sp: 0 };\n            den = { b: 1, sp: 0 };\n            for (; num.sp < this.a.length && this.a[num.sp] === 0; num.sp++);\n            num.a = this.a[num.sp];\n            for (; den.sp < this.b.length && this.b[den.sp] === 0; den.sp++);\n            den.b = this.b[den.sp];\n            num.sp = this.a.length - num.sp - 1;\n            den.sp = this.b.length - den.sp - 1;\n            if (num.sp === den.sp) return num.a / den.b;\n            // else\n            const sMinPower = Math.min(den.sp, num.sp);\n            if (sMinPower) {\n                num.sp -= sMinPower;\n                den.sp -= sMinPower;\n            }\n            // now one of num.sp or den.sp is zero\n            if (den.sp)\n                // zero on denominator\n                return 0;\n            // if den.sp == 0 and num.sp != 0\n            return Infinity;\n        } else {\n            // if s0 is just a no-zero limited number\n            num = this.numerator().$(s0);\n            den = this.denominator().$(s0);\n            if (den)\n                // simple non zero denominator limit\n                return num / den;\n            // if den == 0\n            // use Hopital or other limit methods\n            //return (num.a * (s0 ** num.sp)) / (den.b * (s0 ** den.sp));\n        }\n    };\n    errors = () => {\n        const sGs = this.multiply(new Poly([1, 0], \"s\"));\n        const s2Gs = sGs.multiply(new Poly([1, 0], \"s\"));\n        console.log(sGs);\n        return {\n            Ks: round(this.lim(0)),\n            Kr: round(sGs.lim(0)),\n            Ka: round(s2Gs.lim(0)),\n        };\n    };\n    $ = (t) => this.laplaceInverse().$(t); // valueOf function in certain point; I used character $ in many places as,\n    // acronym for \"set\" in setters, so $ here means that set the t ( or x or whatever) with a certain point\n\n    rootLocus = (k_min, k_max, N = 100) => {\n        // return root locus values for plotting\n        let dk = (k_max - k_min) / N; //time step size\n        while (dk >= 1) {\n            N *= 10;\n            dk = (k_max - k_min) / N; //time step size\n        }\n\n        const reals = [], imaginaries = [];\n        for (let k = k_min; k <= k_max; k += dk) {\n            const roots = new Equation(this.denominator().add(this.numerator().multiply(k))).approximate();\n            for(const root of roots){\n                if(root instanceof Complex){\n                    reals.push(root.real());\n                    imaginaries.push(root.imaginary());\n                }\n                else {\n                    reals.push(root);\n                    imaginaries.push(0);\n                }\n            }\n        }\n        return [reals, imaginaries];\n    };\n}\n","import Algebra from \"math/algebra\";\nimport Complex from \"math/algebra/complex\";\nimport Exp from \"./exp\";\nimport Fraction from \"./fraction\";\n\nexport class Sin extends Algebra {\n    constructor(A, w, teta = 0, symbol = \"t\", params = {}) {\n        // Ae^wt\n        super(A, { symbol, type: \"sin\", b: w, teta, ...params });\n    }\n    copy = (linkPrevious = false) =>\n        new Sin(this.a, this.b, this.teta, this.symbol, {\n            dot: this.dot,\n            plus: this.plus,\n            previous: linkPrevious ? this.previous : null,\n            input: this.input,\n        });\n\n    toExp = () => {\n        const sin = this.copy();\n        const exp1 = new Exp(sin.a / 2, new Complex(0, -sin.b));\n        const exp2 = new Exp(-sin.a / 2, new Complex(0, sin.b));\n        return new Complex(0, exp1.add(exp2));\n    };\n\n    valueAt = (t) => {\n        const A = Algebra.valueOf(this.a, t);\n        const w = Algebra.valueOf(this.b, t);\n        const teta = Algebra.valueOf(this.teta, t);\n        return A * Math.sin(w * t + teta)\n    }\n}\n\nexport class Cos extends Algebra {\n    constructor(A, w, teta = 0, symbol = \"t\", params = {}) {\n        // Ae^wt\n        super(A, { symbol, type: \"cos\", b: w, teta, ...params });\n    }\n    copy = (linkPrevious = false) =>\n        new Cos(this.a, this.b, this.teta, this.symbol, {\n            dot: this.dot,\n            plus: this.plus,\n            previous: linkPrevious ? this.previous : null,\n            input: this.input,\n        });\n\n    toExp = () => {\n        const cos = this.copy();\n        const exp1 = new Exp(cos.a / 2, new Complex(0, cos.b));\n        const exp2 = new Exp(cos.a / 2, new Complex(0, -cos.b));\n        return exp1.add(exp2);\n    };\n\n\n    valueAt = (t) => {\n        const A = Algebra.valueOf(this.a, t);\n        const w = Algebra.valueOf(this.b, t);\n        const teta = Algebra.valueOf(this.teta, t);\n        return A * Math.cos(w * t + teta)\n    }\n}\n\nexport class Tan extends Algebra {\n    constructor(A, w, teta = 0, symbol = \"t\", params = {}) {\n        // Ae^wt\n        super(A, { symbol, type: \"tan\", b: w, teta, ...params });\n    }\n    copy = (linkPrevious = false) =>\n        new Tan(this.a, this.b, this.teta, this.symbol, {\n            dot: this.dot,\n            plus: this.plus,\n            previous: linkPrevious ? this.previous : null,\n            input: this.input,\n        });\n\n    toExp = () => {\n        const tan = this.copy();\n        const exp1 = new Exp(1, new Complex(0, -tan.b));\n        const numeratorExp2 = new Exp(-1, new Complex(0, tan.b));\n        const denominatorExp2 = new Exp(1, new Complex(0, tan.b));\n        return new Fraction(exp1.add(numeratorExp2), exp1.add(denominatorExp2));\n    };\n\n    valueAt = (t) => {\n        const A = Algebra.valueOf(this.a, t);\n        const w = Algebra.valueOf(this.b, t);\n        const teta = Algebra.valueOf(this.teta, t);\n        return A * Math.tan(w * t + teta)\n    }\n}\n\nexport class Cot extends Algebra {\n    constructor(A, w, teta = 0, symbol = \"t\", params = {}) {\n        // Ae^wt\n        super(A, { symbol, type: \"cot\", b: w, teta, ...params });\n    }\n    copy = (linkPrevious = false) =>\n        new Cot(this.a, this.b, this.teta, this.symbol, {\n            dot: this.dot,\n            plus: this.plus,\n            previous: linkPrevious ? this.previous : null,\n            input: this.input,\n        });\n    toExp = () => {\n        const cot = this.copy();\n        const exp1 = new Exp(1, new Complex(0, -cot.b));\n        const numeratorExp2 = new Exp(-1, new Complex(0, cot.b));\n        const denominatorExp2 = new Exp(1, new Complex(0, cot.b));\n        return new Fraction(exp1.add(denominatorExp2), exp1.add(numeratorExp2));\n    };\n\n\n    valueAt = (t) => {\n        const A = Algebra.valueOf(this.a, t);\n        const w = Algebra.valueOf(this.b, t);\n        const teta = Algebra.valueOf(this.teta, t);\n        return A * Math.cot(w * t + teta)\n    }\n}\n"],"names":["Exp","a","b","symbol","params","type","copy","linkPrevious","dot","plus","previous","input","toSin","exp","Complex","real","cos","Cos","imaginary","sin","Sin","valueAt","t","Algebra","Math","Fraction","num","den","Array","length","lim","numerator","Poly","denominator","setNumerator","setA","setDenominator","setB","Step","amplitude","amp","$","StandardInputSignal","Equation","expression","roots","console","log","nerdamer","x","toDecimal","slice","split","filter","xi","AlgebraRoots","solve","approximate","method","newton","boundary","N","allRoots","isUnique","newRoot","isNaN","findIndex","rt","equals","isUniqueComplex","a0","i","an","abs","x0","rx","round","push","this","zeroPrecision","precision","polyf","f","df","derivative","xs","fill","dfx0","isZero","substract","devide","fx","NaN","middlePoint","expectedRate","poles","xa","xb","rate","max","p","Set","TransferFunction","zeros","overshoot","t_rise","Number","logMp","zeta","PI","w_d","w_n","wn2","omegaZetaPoles","setRoots","map","pi","isReal","zi","getDampingSystemCharasteristics","getOrder","order","setOrder","getPoles","setPoles","sortRoots","getZeros","setZeros","poleOrder","pole","laplace","laplaceInverse","m","n","step","inTimeDomain","lstep","getB","nreal","k","add","multiply","a2","ka2b2","t_settle","timeConstant","s0","sp","sMinPower","min","Infinity","errors","sGs","s2Gs","Ks","Kr","Ka","rootLocus","k_min","k_max","dk","reals","imaginaries","root","dampingCharasteristics","Specials","$1","$2","conjugate","aplusb","ab","negation","$WnZ","$design","alpha","beta","sort","ri","rj","A","w","teta","toExp","exp1","exp2"],"sourceRoot":""}