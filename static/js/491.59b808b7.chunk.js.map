{"version":3,"file":"static/js/491.59b808b7.chunk.js","mappings":"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","sources":["math/algebra/complex.js","math/algebra/functions/fraction.js","math/algebra/functions/poly.js","errors/algebra/NotScalarError.js","math/algebra/index.js","math/input-signals/index.js"],"sourcesContent":["import Algebra from \".\";\r\nimport { round, isDigit } from \"../calculus\";\r\n\r\nclass Complex extends Algebra {\r\n    constructor(preal, pimage = 0, params = {}) {\r\n        super(preal, { symbol: \"j\", type: \"complex\", b: pimage, ...params });\r\n    }\r\n    static ToCouples = (arrComplex) => {\r\n        const n = arrComplex.length;\r\n        if (n >= 1) {\r\n            const reals = Array(n).fill(0),\r\n                imaginaries = Array(n).fill(0);\r\n            for (let i = 0; i < n; i++) {\r\n                if (arrComplex[i] instanceof Complex) {\r\n                    reals[i] = arrComplex[i].real();\r\n                    imaginaries[i] = arrComplex[i].imaginary();\r\n                } else\r\n                    reals[i] = arrComplex[i];\r\n            }\r\n            return [reals, imaginaries];\r\n        }\r\n        return [];\r\n    }\r\n    hasMultiTerms = () =>\r\n        this.plus || (this.a.toString() !== \"0\" && this.b.toString() !== \"0\");\r\n\r\n    toString = (parenthesis = false, showJ1 = false) => {\r\n        if (this.isZero())\r\n            return \"0\";\r\n        const rl = this.a;\r\n        let formula = parenthesis && this.hasMultiTerms() ? \"(\" : \"\";\r\n        if (rl !== 0)\r\n            formula +=\r\n            rl instanceof Algebra ?\r\n            rl.toString(rl.hasMultiTerms()) :\r\n            round(rl);\r\n        let im = this.b;\r\n        if (im !== 0) {\r\n            //if (im < 0 || (im instanceof Algebra)) { im = im.negation()\r\n            if (im < 0) {\r\n                im *= -1;\r\n                formula += \" - \";\r\n            } else if (im instanceof Algebra && im.getA() < 0) {\r\n                im.setA(-im.getA());\r\n                formula += \" - \";\r\n            } else if (rl !== 0) formula += \" + \";\r\n\r\n            formula += this.symbol;\r\n            if (im !== 1 || showJ1)\r\n                formula +=\r\n                im instanceof Algebra ?\r\n                im.toString(im.hasMultiTerms()) :\r\n                round(im);\r\n        }\r\n        if (this.plus) formula += this.join(); // if there's a next term: casscade toString() calls\r\n\r\n        return parenthesis ? formula + \")\" : formula;\r\n    }; // a + jb\r\n\r\n    real = () => this.a;\r\n    imaginary = () => this.b;\r\n\r\n    copy = (linkPrevious = false) =>\r\n        new Complex(this.a, this.b, {\r\n            dot: this.dot,\r\n            plus: this.plus,\r\n            previous: linkPrevious ? this.previous : null,\r\n            input: this.input,\r\n        });\r\n\r\n    conjugate = () =>\r\n        new Complex(\r\n            this.a,\r\n            this.b instanceof Algebra ? this.b.negation() : -this.b\r\n        );\r\n\r\n    negation = () =>\r\n        new Complex(\r\n            this.a instanceof Algebra ? this.a.negation() : -this.a,\r\n            this.b instanceof Algebra ? this.b.negation() : -this.b\r\n        );\r\n\r\n    magnitude$2 = () => this.a ** 2 + this.b ** 2;\r\n\r\n    magnitude = () => (this.a ** 2 + this.b ** 2) ** 0.5;\r\n\r\n    phase = () => {\r\n        const definiteA = +this.a,\r\n            definiteB = +this.b;\r\n        if (this.a === definiteA && this.b === definiteB)\r\n            return Math.atan2(definiteB, definiteA);\r\n        if (this.b instanceof Algebra)\r\n            return t => Math.atan2(this.b.$(t), (this.a instanceof Algebra ? this.a.$(t) : definiteA))\r\n        if (this.a instanceof Algebra)\r\n            return t => Math.atan2(definiteB, this.a.$(t));\r\n        return NaN;\r\n    }\r\n    isReal = () => this.b === 0;\r\n\r\n    hasSameTypeWith = (x) =>\r\n        (this.isReal() && x.isReal()) || (!this.isReal() && !x.isReal()); // both full imaginray or both real\r\n    realify = () => new Complex(this.a, 0); // return a simple real value in Complex object format (for methods that only accept Complex values)\r\n\r\n    add = (operand) => {\r\n        let Re = null,\r\n            Im = null;\r\n        if (operand instanceof Complex) {\r\n            if (this.a instanceof Algebra) Re = this.a.add(operand.real());\r\n            else if (operand.real() instanceof Algebra)\r\n                Re = operand.real().add(this.a);\r\n            else Re = this.a + operand.real();\r\n\r\n            if (this.b instanceof Algebra) Im = this.b.add(operand.imaginary());\r\n            else if (operand.imaginary() instanceof Algebra)\r\n                Im = operand.imaginary().add(this.b);\r\n            else Im = this.b + operand.imaginary();\r\n        } else {\r\n            if (this.a instanceof Algebra) Re = this.a.add(operand);\r\n            else if (operand instanceof Algebra) Re = operand.add(this.a);\r\n            else Re = this.a + operand;\r\n\r\n            Im = this.b;\r\n        }\r\n        return new Complex(Re, Im);\r\n    };\r\n\r\n    substract = (operand) => this.add(operand.negation());\r\n\r\n    equals = (operand) => {\r\n        if (operand instanceof Complex) {\r\n            // two complex number are equal to eachother if both thier real parts are the same, and their imaginary parts are the same\r\n            let realPartsEqual = false;\r\n            if (this.a instanceof Algebra)\r\n                realPartsEqual = this.a.equals(operand.real());\r\n            else if (operand.real() instanceof Algebra)\r\n                realPartsEqual = operand.real().equals(this.a);\r\n            else realPartsEqual = this.a === operand.real();\r\n            if (!realPartsEqual) return false;\r\n\r\n            if (this.b instanceof Algebra)\r\n                return this.b.equals(operand.imaginary());\r\n            else if (operand.imaginary() instanceof Algebra)\r\n                return operand.imaginary().equals(this.b);\r\n            return this.b === operand.imaginary();\r\n        }\r\n\r\n        // if operand is not a complex number then the only way it can be equal with this object of Complex,\r\n        // is for this object to have a zero imaginary part:\r\n        return (\r\n            this.isReal() &&\r\n            (operand instanceof Algebra ?\r\n                operand.equals(this.a) :\r\n                operand === this.a)\r\n        );\r\n    };\r\n\r\n    isConjugateWith = (operand) => this.conjugate().equals(operand);\r\n    multiply = (operand) => {\r\n        let Re = [],\r\n            Im = [];\r\n        if (operand instanceof Complex) {\r\n            // first term\r\n            if (this.a instanceof Algebra) {\r\n                Re.push(this.a.multiply(operand.real()));\r\n                Im.push(this.a.multiply(operand.imaginary()));\r\n            } else {\r\n                Re.push(\r\n                    operand.a instanceof Algebra ?\r\n                    operand.a.multiply(this.a) :\r\n                    operand.a * this.a\r\n                );\r\n\r\n                Im.push(\r\n                    operand.b instanceof Algebra ?\r\n                    operand.b.multiply(this.a) :\r\n                    this.a * operand.b\r\n                );\r\n            }\r\n\r\n            // second term\r\n            if (this.b instanceof Algebra) {\r\n                Re.push(this.b.multiply(operand.imaginary()));\r\n                Im.push(this.b.multiply(operand.real()));\r\n            } else {\r\n                Re.push(\r\n                    operand.b instanceof Algebra ?\r\n                    operand.b.multiply(this.b) :\r\n                    operand.b * this.b\r\n                );\r\n\r\n                Im.push(\r\n                    operand.a instanceof Algebra ?\r\n                    operand.a.multiply(this.b) :\r\n                    this.b * operand.a\r\n                );\r\n            }\r\n            return new Complex(Re[0] - Re[1], Im[0] + Im[1]);\r\n        } else {\r\n            Re =\r\n                this.a instanceof Algebra ?\r\n                this.a.multiply(operand) :\r\n                operand instanceof Algebra ?\r\n                operand.multiply(this.a) :\r\n                this.a * operand;\r\n\r\n            Im =\r\n                this.b instanceof Algebra ?\r\n                this.b.multiply(operand) :\r\n                operand instanceof Algebra ?\r\n                operand.multiply(this.b) :\r\n                this.b * operand;\r\n\r\n        }\r\n        return new Complex(Re, Im);\r\n    };\r\n\r\n    devide = (denominator) => {\r\n        if (denominator instanceof Complex) {\r\n            const result = this.multiply(denominator.conjugate()).devide(\r\n                denominator.magnitude$2()\r\n            );\r\n            // CHECK THIS\r\n            if (isNaN(result.real()))\r\n                result.setA(0);\r\n            if (isNaN(result.imaginary()))\r\n                result.setB(0);\r\n            return result;\r\n        } else if (denominator instanceof Algebra) {\r\n            // USE super().devide ?\r\n            return this.copy(); // for now to avoid craches\r\n        } else return this.multiply(1 / denominator); // number\r\n    };\r\n\r\n    raiseTo = (power) => {\r\n        let result = this.copy(true);\r\n        // for now power must be integr\r\n        if (Math.floor(power) === power)\r\n            for (let i = 1; i < power; i++) {\r\n                result = result.multiply(this);\r\n            }\r\n\r\n        return result;\r\n    };\r\n\r\n    devideInverse = (k) =>\r\n        (k instanceof Algebra ? k : new Complex(k, 0)).devide(this);\r\n\r\n    static extract = (strNumber) => {\r\n        // extract a string to a complex object\r\n\r\n        strNumber = strNumber.replace(/\\s/g, \"\");\r\n        let i = strNumber[0] === \"-\" || strNumber[0] === \"+\" ? 1 : 0;\r\n        let real = 0;\r\n        if (strNumber[i] !== \"j\") {\r\n            for (; i < strNumber.length && isDigit(strNumber[i]); i++);\r\n            real = Number(strNumber.slice(0, i) || 0);\r\n        }\r\n\r\n        let sign = 1;\r\n        for (; i < strNumber.length &&\r\n            (strNumber[i] === \"j\" ||\r\n                strNumber[i] === \"+\" ||\r\n                strNumber[i] === \"-\"); i++\r\n        )\r\n            if (strNumber[i] === \"-\") sign = -1;\r\n\r\n        const img = Number(strNumber.slice(i, strNumber.length) || 0);\r\n        return new Complex(real, sign * img);\r\n    };\r\n\r\n    isZero = () => this.a === 0 && this.b === 0;\r\n}\r\n\r\nexport default Complex;","import Algebra from \"math/algebra\";\r\nimport Poly from \"./poly\";\r\n\r\nexport default class Fraction extends Algebra {\r\n    constructor(num, den = [1], symbol = \"t\", params = {}) {\r\n        // ke^ct\r\n        if (!(num instanceof Algebra)) {\r\n            if (!(num instanceof Array)) num = [num];\r\n            // this.a\r\n            else if (num.length === 0) num = [0];\r\n        }\r\n        if (!(den instanceof Algebra)) {\r\n            if (!(den instanceof Array)) den = [den];\r\n            // this.b\r\n            else if (den.length === 0) den = [1];\r\n        }\r\n        super(num, { symbol, type: \"frac\", b: den, ...params });\r\n    }\r\n\r\n    copy = (linkPrevious = false) =>\r\n        new Fraction(this.a, this.b, this.symbol, {\r\n            dot: this.dot,\r\n            plus: this.plus,\r\n            previous: linkPrevious ? this.previous : null,\r\n            input: this.input\r\n        });\r\n\r\n    lim = () => {\r\n        // for all fractions with all kind of numerator and denominator\r\n    }\r\n    \r\n    numerator = () => this.a instanceof Algebra ? this.a.copy(true) : new Poly(this.a, this.symbol);\r\n    denominator = () => this.b instanceof Algebra ? this.b.copy(true) : new Poly(this.b, this.symbol);\r\n\r\n    setNumerator = (num) => {\r\n        if (!(num instanceof Algebra)) {\r\n            if (!(num instanceof Array)) num = [num];\r\n            // this.a\r\n            else if (num.length === 0) num = [0];\r\n        }\r\n        return this.setA(num);\r\n    }\r\n\r\n    setDenominator = (den) => {\r\n        if (!(den instanceof Algebra)) {\r\n            if (!(den instanceof Array)) den = [den];\r\n            // this.b\r\n            else if (den.length === 0) den = [1];\r\n        }\r\n        return this.setB(den);\r\n    }\r\n    valueAt = (t) => {\r\n        const num = this.numerator().$(t);\r\n        const den = this.denominator().$(t);\r\n       \r\n        if(num instanceof Algebra)\r\n            return num.devide(den);\r\n        if(den instanceof Algebra)\r\n            return den.devideInverse(num);\r\n        if(den)\r\n            return num / den;\r\n        // THROW zero denominator ERROR \r\n        return undefined;\r\n    }\r\n\r\n    toFormula = () => \"(\" + this.numerator().toFormula() + \")/(\" + this.denominator().toFormula() + \")\"; \r\n}\r\n","import Algebra from \"math/algebra\";\r\nimport Complex from \"../complex\";\r\nimport Fraction from \"./fraction\";\r\n\r\nexport default class Poly extends Algebra {\r\n    static atn = (a, n, symbol = \"t\") => {\r\n        const aArray = Array(n + 1).fill(0);\r\n        aArray[0] = a;\r\n        return new Poly(aArray, symbol);\r\n    };\r\n    constructor(a, symbol = \"t\", params = {}) {\r\n        // ke^ct\r\n        super(a, { symbol, type: \"poly\", ...params });\r\n    }\r\n\r\n    copy = (linkPrevious = false) =>\r\n        new Poly(this.a, this.symbol, {\r\n            dot: this.dot,\r\n            plus: this.plus,\r\n            previous: linkPrevious ? this.previous : null,\r\n            input: this.input,\r\n        });\r\n\r\n    degree = () => this.a.length - 1;\r\n\r\n    valueAt = (t) => {\r\n        if (typeof t === \"number\") return Algebra.polynomialValueAt(this.a, t);\r\n        else if (t instanceof Complex) {\r\n            const n = this.a.length - 1;\r\n            if (n >= 0) {\r\n                let powerTerm = 1,\r\n                    result =\r\n                        this.a[n] instanceof Complex\r\n                            ? this.a[n].copy()\r\n                            : new Complex(this.a[n], 0);\r\n                for (let i = n - 1; i >= 0; i--) {\r\n                    powerTerm = t.multiply(powerTerm);\r\n                    result = result.add(powerTerm.multiply(this.a[i]));\r\n                }\r\n                return result;\r\n            }\r\n            return 0;\r\n        }\r\n        return NaN;\r\n    };\r\n\r\n    static Symbolic = (\r\n        degree,\r\n        symbol = \"t\",\r\n        halfTermsVisible = 2,\r\n        coef = \"a\",\r\n        inline = false\r\n    ) => {\r\n        let res = inline ? \"\" : \"$$\";\r\n        if (degree === \"n\") {\r\n            res += `${coef}_n ${symbol}^n + `;\r\n            for (let i = 1; i < halfTermsVisible; i++)\r\n                res += `${coef}_{n - ${i}}${symbol}^{n - ${i}} + `;\r\n            res += \" ... \";\r\n            for (let i = halfTermsVisible - 1; i > 0; i--)\r\n                res += ` + ${coef}_{${i}}${symbol}^{${i}}`;\r\n            res += ` + ${coef}_0`;\r\n        } else if (typeof degree === \"number\") {\r\n            for (; degree >= 0; degree--) {\r\n                res += `${coef}_{${degree}}`;\r\n                if (degree > 0) res += `${symbol}^{${degree}} + `;\r\n            }\r\n        }\r\n        return res + (inline ? \"\" : \" $$\");\r\n    };\r\n    derivative = () => {\r\n        const result = this.copy(true);\r\n        if (!result.dot) {\r\n            const n = result.a.length - 1;\r\n            const da = Array(n).fill(0);\r\n            for (let i = n; i >= 1; i--) da[n - i] = i * result.a[n - i];\r\n            result.a = [...da];\r\n        }\r\n        if (result.plus) result.plus = result.plus.derivative();\r\n        return result;\r\n    };\r\n\r\n    expression = () => {\r\n        if (this.a instanceof Array) {\r\n            const n = this.a.length - 1;\r\n            if (\r\n                !n ||\r\n                !this.a.slice(0, n).filter((ci) => ci.toString() !== \"0\").length\r\n            )\r\n                return this.a[n].toString();\r\n            return this.a\r\n                .map((a_i, i) =>\r\n                    a_i\r\n                        ? Algebra.coefy(a_i, i, n) +\r\n                          (i < n\r\n                              ? this.symbol +\r\n                                (i < n - 1 ? \"^\" + (n - i).toString() : \"\")\r\n                              : \"\")\r\n                        : \"\"\r\n                )\r\n                .join(\"\"); // joins all the coefficients, symbols, etc all together as for polynomal functions\r\n        }\r\n        return this.a.toString();\r\n    };\r\n\r\n    devide = (operand) => {\r\n        if (operand instanceof Poly && this.symbol === operand.symbol) {\r\n            return new Fraction(this.getA(), operand.getA(), this.symbol);\r\n        }\r\n        if (operand === +operand) return this.multiply(1 / Number(operand));\r\n        // is it true??\r\n        return super.devide();\r\n    };\r\n\r\n    // edit this function to remove unnecessary white spaces\r\n    toFormula = () => {\r\n        if (this.a instanceof Array) {\r\n            const n = this.a.length - 1;\r\n            if (\r\n                !n ||\r\n                !this.a.slice(0, n).filter((ci) => ci.toString() !== \"0\").length\r\n            )\r\n                return this.a[n].toString();\r\n            return this.a\r\n                .map((a_i, i) =>\r\n                    a_i\r\n                        ? Algebra.coefy(a_i, i, n) +\r\n                          (i < n\r\n                              ? this.symbol +\r\n                                (i < n - 1 ? \"^\" + (n - i).toString() : \"\")\r\n                              : \"\")\r\n                        : \"\"\r\n                )\r\n                .join(\"\"); // joins all the coefficients, symbols, etc all together as for polynomal functions\r\n        }\r\n        return this.a.toString();\r\n    };\r\n}\r\n","import { error_codes } from \"config\";\r\n\r\nexport default class NotScalarError extends Error {\r\n    \r\n    constructor(cause = null){ // the parameter with problem\r\n        super(cause ? `${cause} => این عبارت باید اسکالر باشد!!` : \"این خطا بدلیل استفاده از یک عبارت غیر اسکالر در مکان غیر مجاز رخ داده است!\")\r\n        this.name = \"NotNumberError\";\r\n        this.type = \"Numeric\";\r\n        this.code = error_codes.not_scalar;\r\n        this.cause = cause;\r\n    }\r\n\r\n    describe = () => {\r\n        console.log(this.message + (this.cause ? \"\\n\" + this.cause : \"\"));\r\n        return this.message + (this.cause ? \"\\n\" + this.cause.toString() : \"\");\r\n    }\r\n}","import NotScalarError from \"errors/algebra/NotScalarError\";\r\nimport StandardInputSignal from \"math/input-signals\";\r\nimport { round, strictPrecisionFormat } from \"../calculus\";\r\n\r\nclass Algebra {\r\n    // symbolic expressions\r\n    constructor(\r\n        a,\r\n        { symbol = \"t\", type = \"poly\", b, dot, plus, teta = 0, previous, input }\r\n    ) {\r\n        // dot is the interface between terms\r\n        // g(t) = a * f(t) * {dot: as Algebra}\r\n        // teta is the offset for wt + alpha in sin/cos/tan/..\r\n\r\n        this.symbol = symbol;\r\n        this.type = type.toLowerCase();\r\n        this.setA(a).setB(b).setTeta(teta);\r\n\r\n        this.input = input; // u(t), r(t), puls, ...\r\n        if (dot) {\r\n            this.dot = dot.copy();\r\n        } // multiply a Algebra from different type into 'this'\r\n\r\n        if (plus) {\r\n            this.plus = plus.copy();\r\n            this.simplify();\r\n        } // add another Algebra with different type to this one\r\n\r\n        this.previous = previous; // the previous term in the chained Algebra objects\r\n        // term.plus => next term, term.previous => previous term, term.dot => an algebra from another type that is multiplied to actual term\r\n        // F(u) = a.f(u).dot(u) + term.plus(u)\r\n        this.link();\r\n    }\r\n    static identify = (parameter) => {\r\n        if (parameter instanceof Array)\r\n            return parameter.map((pi) =>\r\n                pi instanceof Algebra || pi instanceof StandardInputSignal\r\n                    ? pi.copy()\r\n                    : round(pi)\r\n            );\r\n        else if (parameter instanceof Algebra) {\r\n            return parameter.copy();\r\n        } else if (typeof parameter === \"number\") return round(parameter);\r\n        else if(typeof parameter === 'string') return parameter;\r\n        else if (!parameter) return 0;\r\n        throw new NotScalarError(parameter);\r\n    };\r\n    setA = (a) => {\r\n        this.a = Algebra.identify(a);\r\n        return this;\r\n    };\r\n    getA = () => this.a;\r\n\r\n    setB = (b) => {\r\n        this.b = Algebra.identify(b);\r\n        return this;\r\n    };\r\n    getB = () => this.b;\r\n\r\n    setTeta = (teta) => {\r\n        this.teta = Algebra.identify(teta);\r\n        return this;\r\n    };\r\n    getTeta = () => this.teta;\r\n    // CONNECT AND LINK METHODS, FIND FIRST TERM AND LAST TERM AND ...\r\n    end = () => {\r\n        // returns the end term in the algebratic chain\r\n        let last = this;\r\n        while (last.plus) last = last.plus;\r\n        return last;\r\n    };\r\n\r\n    first = () => {\r\n        // returns the first term in the algebratic chain\r\n        let fst = this;\r\n        while (fst.previous) fst = fst.previous;\r\n        return fst;\r\n    };\r\n\r\n    enddot = () => {\r\n        // returns the end term in the algebratic chain\r\n        let last = this;\r\n        while (last.dot) last = last.dot;\r\n        return last;\r\n    };\r\n\r\n    firstdot = () => {\r\n        // returns the first term in the algebratic chain\r\n        let fst = this;\r\n        // WRONG *****************************\r\n        //while (fst.previous) fst = fst.previous;\r\n        return fst;\r\n    };\r\n    link = () => {\r\n        // some times .previous links are broken; so i decided to write this method just to make sure everything is connected\r\n        let term = this.first();\r\n        if (!term) term = this; // in case this.first() returns wrong answer\r\n        while (term.plus) {\r\n            if (term.plus) term.plus.previous = term;\r\n            term = term.plus; // go to next term in the chain\r\n        }\r\n        return this;\r\n    };\r\n\r\n    copy = (linkPrevious = false) =>\r\n        new Algebra(this.a, {\r\n            type: this.type,\r\n            b: this.b,\r\n            dot: this.dot,\r\n            plus: this.plus,\r\n            symbol: this.symbol,\r\n            teta: this.teta,\r\n            input: this.input,\r\n            previous: linkPrevious ? this.previous : null,\r\n        });\r\n\r\n    // SORT THE MULTIPLIERD TERMS ( TERMS CONNECTED WITH this.dot) IN A SPECIFIC ORDER (FOR BETTER SHOW AND COMPARE AND ETC.)\r\n    // LOOK HERE IT STILL HAS BUGS\r\n    sort = () => {\r\n        // sort .dot in special order: poly - exp - frac - ...\r\n        const orders = [\"poly\", \"exp\", \"frac\"];\r\n        let position = this;\r\n        for (const order of orders) {\r\n            while (position) {\r\n                let func = position.dot;\r\n                while (func) {\r\n                    if (func.type === order && !position.isPrior(order)) {\r\n                        const temp = position.copy();\r\n                        position.a =\r\n                            func.a instanceof Array ? [...func.a] : func.a;\r\n                        position.type = func.type;\r\n                        position.symbol = func.symbol;\r\n                        if (func.b instanceof Array) position.b = [...func.b];\r\n                        else position.b = func.b;\r\n\r\n                        func.a = temp.a instanceof Array ? [...temp.a] : temp.a;\r\n                        func.type = temp.type;\r\n                        func.symbol = temp.symbol;\r\n                        if (temp.b instanceof Array) func.b = [...temp.b];\r\n                        else func.b = temp.b;\r\n                    }\r\n                    func = func.dot;\r\n                }\r\n                position = position.dot;\r\n            }\r\n        }\r\n    };\r\n\r\n    isPrior = (order) => {\r\n        const orders = [\"poly\", \"exp\", \"frac\"];\r\n        const thisValue = orders.findIndex((or) => or === this.type);\r\n        const orderValue = orders.findIndex((or) => or === order);\r\n        return thisValue <= orderValue;\r\n    };\r\n\r\n    // CHECK IF ONE TERMS CAN BE ADDED TO ANOTHER ONE (MEANING THEY HAVE SAME PARAMETRIC TERMS)\r\n    unifiable = (exp) => {\r\n        // check if this is unifiable with expression:exp\r\n        //this.sort();\r\n        //exp.sort();\r\n        if (exp && this.type === exp.type && this.symbol === exp.symbol) {\r\n            // check if this and exp are sumable\r\n            // check .dot s:\r\n            let isUnifiable = true;\r\n            if (this.dot || exp.dot)\r\n                isUnifiable = this.dot && this.dot.unifiable(exp.dot);\r\n            \r\n            if (this.b instanceof Array && exp.b instanceof Array) {\r\n                if (this.b.length === exp.b.length) {\r\n                    const sameOnes = this.b.filter(\r\n                        (item, idx) => item === exp.b[idx]\r\n                    );\r\n                    return isUnifiable && this.b.length === sameOnes.length;\r\n                }\r\n            }\r\n            else if(this.b instanceof Algebra)\r\n                return isUnifiable && this.b.equals(exp.b);\r\n            return isUnifiable && exp.b === this.b;\r\n        }\r\n        return false;\r\n    };\r\n\r\n    static valueOf = (x, t = 0) => {\r\n        if (x) {\r\n            let value = 0;\r\n            if (x instanceof Algebra || x instanceof StandardInputSignal)\r\n                value = x.$(t);\r\n            else if (x instanceof Array)\r\n                value = Algebra.polynomialValueAt(x, t);\r\n            else value = x;\r\n            return value;\r\n        }\r\n        return 0;\r\n    };\r\n\r\n    static polynomialValueAt = (arr, t) => {\r\n        let value = 0;\r\n        const n = arr.length - 1;\r\n        for (let i = 0; i <= n; i++) {\r\n            value += arr[i] * t ** (n - i);\r\n        }\r\n        return value;\r\n    };\r\n    // REMOVE REDUNDANT TERMS, SIGNS AND ETC.\r\n    simplify = () => {\r\n        let term = this.first();\r\n        while (term) {\r\n            if (term instanceof Algebra) {\r\n                if (\r\n                    term.a === 0 ||\r\n                    Algebra.polynomial(term.a, term.symbol) === 0\r\n                ) {\r\n                    if (term.previous) {\r\n                        term.previous.plus = term.plus;\r\n                    } else {\r\n                        // remove first term and transfer the second term to first one\r\n                        if (this === term) term.redundant = true;\r\n                        if (term.plus) {\r\n                            term = term.plus.copy(true);\r\n                            if (term.plus) {\r\n                                term.plus = term.plus.plus;\r\n                                if (term.plus) term.plus.previous = term;\r\n                            }\r\n                            term.previous = null;\r\n                        }\r\n                    }\r\n                    // }\r\n                }\r\n            }\r\n            term = term.plus;\r\n        }\r\n        return this;\r\n    };\r\n\r\n    $ = (t) => {\r\n        // valueOf function in certain point\r\n        // I used character $ in many places as acronym for \"set\" in setters, so $ here means that set the t ( or x or whatever) with a certain point\r\n        // for each type just implement the method literally\r\n        let result = this.valueAt(t);\r\n        if (this.dot) result *= this.dot.$(t);\r\n        if (this.plus) result += this.plus.$(t);\r\n\r\n        return result;\r\n    };\r\n\r\n    label = (name = undefined, index = undefined) =>\r\n        (name\r\n            ? name +\r\n              (index !== undefined ? \"_{\" + index + \"}\" : \"\") +\r\n              \"(\" +\r\n              this.symbol +\r\n              \") = \"\r\n            : \"\") + this.toString();\r\n\r\n    // RETURNS THE BEST AND SIMPLE AND SHORTEST WAY TO SHOW COEFFICIENTS\r\n    static coefy = (a_i, i, n) => {\r\n        if (a_i instanceof Algebra) {\r\n            let str = \"\";\r\n            let ai = a_i.copy();\r\n            if (i > 0) {\r\n                // write a method to edit all the + - occuring next to each other in toString()\r\n                if (ai.type === \"complex\" && typeof ai.a === \"number\") {\r\n                    if (ai.a < 0) {\r\n                        str += \" - \";\r\n                        ai.a *= -1;\r\n                    } else if (!ai.a && typeof ai.b === \"number\" && ai.b < 0) {\r\n                        str += \" - \";\r\n                        ai.b *= -1;\r\n                    }\r\n                } else str += \" + \";\r\n            }\r\n            return str + ai.toString(i < n && a_i.hasMultiTerms());\r\n        }\r\n        if (a_i instanceof StandardInputSignal) {\r\n            //EDIT THIS PART TOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO\r\n            let str = i > 0 ? \" + \" : \"\";\r\n            return str + a_i.toString(i < n && a_i.hasMultiTerms());\r\n        } else {\r\n            if (n === 0) return strictPrecisionFormat(a_i);\r\n            if (a_i === 0) return \"\";\r\n            if (i !== 0) {\r\n                let s = \"\";\r\n                if (a_i < 0) {\r\n                    s += \" - \";\r\n                    a_i *= -1;\r\n                } else s += \" + \";\r\n\r\n                if (a_i === 1 && i < n) return s;\r\n                return s + strictPrecisionFormat(a_i);\r\n            }\r\n            if (a_i === 1) return \"\";\r\n            if (a_i === -1) return \"-\";\r\n\r\n            return strictPrecisionFormat(a_i);\r\n        }\r\n    };\r\n\r\n    // DECIPHER THE OBJECT TO ITS POLYNOMINAL FORM (IF IT IS ONE ACTUALLY)\r\n    static polynomial = (coefs, symbol) => {\r\n        if (coefs instanceof Array) {\r\n            const n = coefs.length - 1;\r\n            if (\r\n                !n ||\r\n                !coefs.slice(0, n).filter((ci) => ci.toString() !== \"0\").length\r\n            )\r\n                return coefs[n].toString();\r\n            return coefs\r\n                .map((a_i, i) =>\r\n                    a_i\r\n                        ? Algebra.coefy(a_i, i, n) +\r\n                          (i < n\r\n                              ? symbol +\r\n                                (i < n - 1\r\n                                    ? \"^{\" + (n - i).toString() + \"}\"\r\n                                    : \"\")\r\n                              : \"\")\r\n                        : \"\"\r\n                )\r\n                .join(\"\"); // joins all the coefficients, symbols, etc all together as for polynomal functions\r\n        }\r\n        return coefs.toString();\r\n    };\r\n\r\n    join = () => {\r\n        // connect this term to its next terms; considering the right use of + or -\r\n        if (this.plus) {\r\n            let operator = \"+\",\r\n                next = this.plus.copy();\r\n            if (next.a instanceof Array) {\r\n                if (next.a[0] < 0) {\r\n                    operator = \"-\";\r\n                    next.a[0] *= -1;\r\n                }\r\n            } else {\r\n                if (next.a < 0) {\r\n                    operator = \"-\";\r\n                    next.a *= -1;\r\n                }\r\n            }\r\n            return operator + next.toString();\r\n        }\r\n        return \"\";\r\n    };\r\n\r\n    hasMultiTerms = () => {\r\n        if (this.plus) return true;\r\n        if (this.a instanceof Array && this.type !== \"frac\")\r\n            return this.a.filter((ai) => ai !== 0).length > 1;\r\n        return false;\r\n    };\r\n    isTriangular = () =>\r\n        this.type === \"sin\" ||\r\n        this.type === \"cos\" ||\r\n        this.type === \"tan\" ||\r\n        this.type === \"cot\";\r\n\r\n    // MATHEMATICAL OPERATIONS\r\n    // static add = (expressions) => expressions.map((el) => el.toString()).join(\" + \");\r\n    add = (right) => {\r\n        // result = this + operand\r\n        let result = this.link().copy();\r\n        if (right instanceof Algebra) {\r\n            let operand = right.link().copy();\r\n\r\n            let x = result; // now we try to add each term with its unifiable term in y\r\n            while (x) {\r\n                let y = operand;\r\n                while (y) {\r\n                    if (x.unifiable(y)) {\r\n                        if (x.a instanceof Algebra) x.a = x.a.add(y.a);\r\n                        else if (y.a instanceof Algebra) x.a = y.a.add(x.a);\r\n                        // **************************************************\r\n                        // else if x.a || y.a instanceof StandardInputSignal\r\n                        // *********************************************\r\n                        else if (x.a instanceof Array) {\r\n                            if (y.a instanceof Array) {\r\n                                if (y.a.length > x.a.length) x.a = [...y.a];\r\n                                for (\r\n                                    let i = 1;\r\n                                    i <= y.a.length && i <= x.a.length;\r\n                                    i++\r\n                                )\r\n                                    x.a[x.a.length - i] += y.a[y.a.length - i];\r\n                            } else {\r\n                                x.a[x.a.length - 1] += y.a;\r\n                            }\r\n                        } else {\r\n                            x.a += y.a;\r\n                        }\r\n                        // remove the term in y that has been processed\r\n                        if (y.previous) {\r\n                            y.previous.plus = y.plus;\r\n                            if (y.plus) y.plus.previous = y.previous;\r\n                            y.a = 0;\r\n                        }\r\n\r\n                        // its the first term\r\n                        else operand = operand.plus;\r\n                        // after this the garbage collector will remove the term because it has no reference to it\r\n                    }\r\n                    y = y.plus;\r\n                }\r\n                // if(x.plus) x.plus.previous = x;\r\n                x = x.plus; // go to next term in the chain\r\n            }\r\n\r\n            if (operand) {\r\n                // if the above algorythm leaves operand with non-null value\r\n                /// it means there was terms in the operand's algebratic chain that are'nt unifiable with x terms\r\n                // so we must connect the leftovers to last terms of the result\r\n                if (Algebra.polynomial(result.a, result.symbol) !== \"0\") {\r\n                    if (\r\n                        Algebra.polynomial(operand.getA(), operand.symbol) !==\r\n                        \"0\"\r\n                    ) {\r\n                        let endTerm = result.end();\r\n                        endTerm.plus = operand;\r\n                        endTerm.plus.previous = result;\r\n                    }\r\n                } else result = operand.copy(); // connect to next term\r\n            }\r\n            return result.simplify();\r\n        } else if (right instanceof StandardInputSignal) {\r\n            const endTerm = result.end();\r\n            endTerm.plus = right.copy();\r\n            endTerm.plus.previous = endTerm;\r\n        }\r\n        return result;\r\n    };\r\n\r\n    arrangeDots = () => {\r\n        let term = this;\r\n        let input = null;\r\n        while (term.dot) {\r\n            // enhance the algo for cases that more than one input signal erxists in .dot chain\r\n            if (term.dot instanceof StandardInputSignal) {\r\n                input = term.dot;\r\n                term.dot = term.dot.dot;\r\n            }\r\n            if (term.dot) term = term.dot;\r\n        }\r\n        term.dot = input;\r\n    };\r\n    // INCOMPLETE ***********\r\n    multiply = (operand) => {\r\n        const y = this.copy().link();\r\n        if (operand instanceof Algebra) {\r\n            // operand algebra or complex\r\n            // ***** TODO:  ****************\r\n            if (operand.type === \"poly\") {\r\n                if (this.type === \"poly\" || this.type === \"frac\") {\r\n                    // NEEDS ERDITING for FRACTIONs\r\n                    if (this.symbol === operand.symbol) {\r\n                        const ao = operand.getA();\r\n                        const no = ao.length - 1;\r\n                        const As = [];\r\n                        for (let i = no; i >= 0; i--) {\r\n                            if (operand.a[i]) {\r\n                                const zeros = Array(no - i).fill(0);\r\n                                const a = [...y.a].map(\r\n                                    (yai) => yai * operand.a[i]\r\n                                );\r\n                                a.push(...zeros);\r\n                                As.push(a);\r\n                            }\r\n                        }\r\n                        // now sum all the products\r\n                        console.table(As);\r\n                        let product = As.pop();\r\n                        for (let j = 0; j < As.length; j++)\r\n                            for (\r\n                                let i = 1;\r\n                                i <= As[j].length && i <= product.length;\r\n                                i++\r\n                            )\r\n                                product[product.length - i] +=\r\n                                    As[j][As[j].length - i];\r\n\r\n                        y.a = product;\r\n                        if (operand.dot) {\r\n                            // link dots ***IS THIS TRUE?>***\r\n                            const endDotTerm = y.enddot();\r\n                            endDotTerm.dot = operand.dot.copy(); // multiply\r\n                            endDotTerm.dot.previous = endDotTerm;\r\n                        }\r\n                    }\r\n                }\r\n            } else if (y.type !== operand.type && operand.plus) {\r\n                // like: exp(f(...)) * [Asin(...) * Bcos(...)]\r\n                // UPDATE SELF MULTIPLY AFTER SOLVING THIS ISSUE\r\n                y.plus = y.multiply(operand.plus.copy());\r\n                const lastyDot = y.enddot();\r\n                if(typeof y.a === 'number' && typeof operand.a === 'number' && operand.a !== 1){\r\n                    y.a *= operand.a;\r\n                    operand.a = 1;\r\n                }\r\n                lastyDot.dot = operand.copy();\r\n                lastyDot.dot.previous = lastyDot;\r\n                // UPDATE SELF MULTIPLY AFTER SOLVING THIS ISSUE\r\n\r\n            } else {\r\n                const endDotTerm = y.enddot();\r\n                if (typeof y.a === \"number\" && typeof operand.a === \"number\") {\r\n                    y.a *= operand.a;\r\n                    operand.a = 1;\r\n                }\r\n                endDotTerm.dot = operand.copy(); // multiply\r\n                endDotTerm.dot.previous = endDotTerm;\r\n            }\r\n            if (y.plus) y.plus = y.plus.multiply(operand);\r\n            if (operand.plus) y.end().plus = y.multiply(operand.plus);\r\n            return y; // for now just to avoid crashes\r\n        } else if (operand instanceof StandardInputSignal) {\r\n            // const endDotTerm = y.enddot();\r\n            // endDotTerm.dot = operand.copy(); // multiply\r\n            // endDotTerm.dot.previous = endDotTerm;\r\n            y.input = operand.copy();\r\n            if (y.plus) y.plus = y.plus.multiply(operand);\r\n        } else {\r\n            // scalar multiply\r\n            if (operand instanceof Algebra) {\r\n            } else {\r\n                if (y.a instanceof Array) y.a = y.a.map((ai) => operand * ai);\r\n                else if (y.a instanceof Algebra) y.a = y.a.multiply(operand);\r\n                else y.a = y.a * operand;\r\n            }\r\n            if (y.plus) y.plus = y.plus.multiply(operand);\r\n        }\r\n        // console.log(\"y = \", y, \"operand = \", operand)\r\n        return y;\r\n    };\r\n\r\n    selfmultiply = (operand) => {\r\n        if (operand instanceof Algebra) {\r\n            // operand algebra or complex\r\n            // ***** TODO:  ****************\r\n            if (operand.type === \"poly\") {\r\n                if (this.type === \"poly\" || this.type === \"frac\") {\r\n                    // NEEDS ERDITING for FRACTIONs\r\n                    if (this.symbol === operand.symbol) {\r\n                        const ao = operand.getA();\r\n                        const no = ao.length - 1;\r\n                        const As = [];\r\n                        for (let i = no; i >= 0; i--) {\r\n                            if (ao[i]) {\r\n                                const zeros = Array(no - i).fill(0);\r\n                                const a = [...this.a].map(\r\n                                    (yai) => yai * operand[i]\r\n                                );\r\n                                a.push(...zeros);\r\n                                As.push(a);\r\n                            }\r\n                        }\r\n                        // now sum all the products\r\n                        const product = As.pop();\r\n                        for (let i = 0; i < product.length; i++) {\r\n                            for (let j = 0; j < As.length; j++) {\r\n                                if (i < As[j].length) product[i] += As[j][i];\r\n                            }\r\n                        }\r\n                        this.a = product;\r\n                        if (operand.dot) {\r\n                            // link dots ***IS THIS TRUE?>***\r\n                            const endDotTerm = this.enddot();\r\n                            endDotTerm.dot = operand.dot.copy(); // multiply\r\n                            endDotTerm.dot.previous = endDotTerm;\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                const endDotTerm = this.enddot();\r\n                endDotTerm.dot = operand.copy(); // multiply\r\n                endDotTerm.dot.previous = endDotTerm;\r\n                if (this.plus) this.plus = this.plus.multiply(operand);\r\n            }\r\n        } else if (operand instanceof StandardInputSignal) {\r\n            // this.dot = operand.copy(); // multiply\r\n            // this.dot.previous = this;\r\n            this.input = operand.copy();\r\n            if (this.plus) this.plus.selfmultiply(operand);\r\n            if (operand.plus) this.end().plus = this.multiply(operand.plus);\r\n        } else {\r\n            // scalar multiply\r\n            if (this.a instanceof Array)\r\n                this.a = this.a.map((ai) => operand * ai);\r\n            else this.a *= operand;\r\n\r\n            if (this.plus) this.plus.selfmultiply(operand);\r\n        }\r\n    };\r\n\r\n    negation = () => this.multiply(-1);\r\n\r\n    substract = (operand) => this.add(operand.negation());\r\n\r\n    devide = (operand) => {\r\n        if(operand === +operand)\r\n            // scaler\r\n            return this.multiply(1 / Number(operand));\r\n        \r\n        // u need to handle Complex objects as Algebra using their type to recognize them\r\n        if (operand instanceof Algebra) {\r\n            // operand algebra or complex\r\n            // ***** TODO:  ****************\r\n            // first u must do everything to simplify\r\n            // second at the simplest state of the terms,\r\n            // construct a new Algebra of \"frac\" type\r\n            return this.copy(); // for now just to avoid crashes\r\n        } \r\n    };\r\n\r\n    devideInverse = (k) =>{\r\n        if(k === +k){\r\n            return new Algebra([k], {symbol: this.symbol, type: \"frac\", b: [1]});\r\n        }\r\n        else if(k instanceof Algebra)\r\n            return k.devide(this);\r\n    }\r\n\r\n    laplace = () => {};\r\n\r\n    static areTheSame = (el1, el2) => {\r\n        // checkes the sameness of parameters like .a .b .teta , etc.\r\n        if(el1 instanceof Algebra && el2 instanceof Algebra)\r\n            return el1.equals(el2);\r\n        else if(el1 instanceof Array && el2 instanceof Array){\r\n            if(el1.length === el2.length){\r\n                let i = 0;\r\n                for(i = 0; i < el1.length; i++)\r\n                    if(el1[i] !== el2[i]) break;\r\n                return i >= el1.length;\r\n                \r\n            }\r\n        }\r\n        return typeof el1 === typeof el2 && el1 === el2;\r\n    }\r\n    equals = (operand) => operand instanceof Algebra && \r\n                            this.type === operand.type && \r\n                            this.symbol === operand.symbol &&\r\n                            this.type === operand.type &&\r\n                            this.symbol === operand.symbol &&\r\n                            Algebra.areTheSame(this.a, operand.a) &&\r\n                            Algebra.areTheSame(this.b, operand.b) &&\r\n                            Algebra.areTheSame(this.teta, operand.teta) &&\r\n                            (!this.dot || this.dot.equals(operand.dot)) &&\r\n                            (!this.plus || this.plus.equals(operand.plus)) &&\r\n                            (!this.previous || this.previous.equals(operand.previous));\r\n\r\n\r\n    static areTheseTwoEqual = (p1, p2) =>\r\n        p1 instanceof Algebra\r\n            ? p1.equals(p2)\r\n            : p2 instanceof Algebra\r\n            ? p2.equals(p1)\r\n            : p1 === p2;\r\n    // DECIPHERS THE CONNECT OBJECTS TO UNDERSTANDABLE MATHMATICALLY SHAPED TEXT\r\n    // IT IS FORMATTED COMPATIBLE FOR MathJax component\r\n    toString = (parenthesis = false) => {\r\n        // this.arrangeDots();\r\n        this.simplify(); // simplify current chain that's left from unknown number of operations\r\n        let formula = \"\";\r\n        // if ... + 0 || 0 + ... appears ===>>>>> see below !!\r\n        if (!this.a) return \"0\"; // what if **************************************** 0 / 0\r\n        if (parenthesis) formula += \"(\";\r\n        switch (this.type.toLowerCase()) {\r\n            case \"exp\": {\r\n                // if (this.a < 0) formula += \"(\";\r\n                let a0 = this.a;\r\n                if (a0 < 0) {\r\n                    formula += \"-\";\r\n                    a0 *= -1;\r\n                }\r\n                if (a0 !== 1)\r\n                    if (a0 instanceof Algebra)\r\n                        formula += a0.toString(\r\n                            a0 instanceof Algebra && a0.hasMultiTerms()\r\n                        );\r\n                    else if (a0 instanceof Array)\r\n                        // testTEST\r\n                        formula += Algebra.polynomial(a0, this.symbol);\r\n                    // FOR TEST\r\n                    else formula += strictPrecisionFormat(a0);\r\n                if (this.dot instanceof Algebra)\r\n                    formula += this.dot.toString(\r\n                        this.dot instanceof Algebra && this.dot.hasMultiTerms()\r\n                    );\r\n                if (this.b !== 0) {\r\n                    if (this.a !== 0) {\r\n                        formula += \"e^{\";\r\n                        let e0 = this.b;\r\n                        if (this.b instanceof Algebra)\r\n                            formula += this.b.toString(\r\n                                this.b instanceof Algebra &&\r\n                                    this.b.hasMultiTerms()\r\n                            );\r\n                        else if (this.b instanceof Array)\r\n                            formula += Algebra.polynomial(this.b, this.symbol);\r\n                        else {\r\n                            if (e0 < 0) {\r\n                                formula += \"-\";\r\n                                e0 *= -1;\r\n                            }\r\n                            if (e0 !== 1) formula += e0;\r\n                        }\r\n                        formula += this.symbol + \"}\";\r\n                    }\r\n                    if (this.input) formula += this.input.toString();\r\n                } else {\r\n                    if (a0 !== 1 || !this.dot)\r\n                        formula += strictPrecisionFormat(this.a);\r\n                }\r\n                // if (this.a < 0) formula += \")\";\r\n                if (this.plus) formula += this.join(); // if there's a next term: casscade toString() calls\r\n                break;\r\n            }\r\n            case \"poly\":\r\n                formula += Algebra.polynomial(this.a, this.symbol);\r\n                if (this.dot instanceof Algebra)\r\n                    formula += this.dot.toString(\r\n                        this.dot instanceof Algebra && this.dot.hasMultiTerms()\r\n                    );\r\n                if (this.input) {\r\n                    formula += (parenthesis ? \")\" : \"\") + this.input.toString();\r\n                    parenthesis = false;\r\n                }\r\n                if (this.plus) formula += this.join(); // if there's a next term: casscade toString() calls\r\n                break;\r\n            case \"frac\": {\r\n                if (this.dot instanceof Algebra)\r\n                    formula += this.dot.toString(\r\n                        this.dot instanceof Algebra && this.dot.hasMultiTerms()\r\n                    );\r\n                const numerator = Algebra.polynomial(this.a, this.symbol);\r\n                formula +=\r\n                    numerator !== \"0\"\r\n                        ? \"\\\\frac{\" +\r\n                          numerator +\r\n                          \"}{\" +\r\n                          Algebra.polynomial(this.b, this.symbol) +\r\n                          \"}\"\r\n                        : \"0\";\r\n                if (this.input) formula += this.input.toString();\r\n                if (this.plus) formula += this.join(); // if there's a next term: casscade toString() calls\r\n\r\n                break;\r\n            }\r\n            case \"sin\":\r\n            case \"asin\":\r\n            case \"cos\":\r\n            case \"tan\":\r\n            case \"cot\": {\r\n                // if (this.a < 0) formula += \"(\";\r\n                let a0 = this.a;\r\n                if (a0 < 0) {\r\n                    formula += \"-\";\r\n                    a0 *= -1;\r\n                }\r\n                if (a0 !== 1)\r\n                    if (a0 instanceof Algebra)\r\n                        formula += a0.toString(\r\n                            a0 instanceof Algebra && a0.hasMultiTerms()\r\n                        );\r\n                    else if (a0 instanceof Array)\r\n                        formula += Algebra.polynomial(a0, this.symbol);\r\n                    // FOR TEST\r\n                    else formula += strictPrecisionFormat(a0);\r\n                if (this.a !== 0) {\r\n                    if (this.dot && this.dot instanceof Algebra)\r\n                        formula += this.dot.toString(\r\n                            this.dot instanceof Algebra &&\r\n                                this.dot.hasMultiTerms()\r\n                        );\r\n                    if (this.b !== 0) {\r\n                        formula += this.type;\r\n                        if (this.b instanceof Algebra) {\r\n                            formula += this.b.toString(\r\n                                this.b instanceof Algebra &&\r\n                                    this.b.hasMultiTerms()\r\n                            );\r\n                        } else if (this.b instanceof Array)\r\n                            formula += Algebra.polynomial(this.b, this.symbol);\r\n                        // FOR TEST\r\n                        else {\r\n                            let w0 = this.b;\r\n                            formula += \"(\";\r\n                            if (w0 < 0) {\r\n                                formula += \"-\";\r\n                                w0 *= -1;\r\n                            }\r\n                            if (w0 !== 1) formula += strictPrecisionFormat(w0);\r\n                            formula += this.symbol;\r\n                            if (this.teta instanceof Algebra)\r\n                                formula += this.teta.toString();\r\n                            else if (this.teta) {\r\n                                let e0 = this.teta;\r\n                                if (e0 < 0) {\r\n                                    formula += \" - \";\r\n                                    e0 *= -1;\r\n                                } else formula += \" + \";\r\n                                formula += strictPrecisionFormat(e0);\r\n                            }\r\n                            formula += \")\";\r\n                        }\r\n                        if (this.input) formula += this.input.toString();\r\n                    }\r\n                    // simple num\r\n                } else {\r\n                    if (a0 !== 1 || !this.dot)\r\n                        formula += strictPrecisionFormat(this.a);\r\n                }\r\n                // if (this.a < 0) formula += \")\";\r\n                if (this.plus) formula += this.join(); // if there's a next term: casscade toString() calls\r\n                break;\r\n            }\r\n\r\n            default:\r\n                return null;\r\n        }\r\n        if (parenthesis) formula += \")\";\r\n\r\n        return formula;\r\n    };\r\n    toArray = () => {\r\n        let x = [];\r\n        const params = [\"a\", \"b\", \"teta\", \"symbol\", \"type\"],\r\n            linkers = [\"dot\", \"input\", \"plus\", \"previous\"];\r\n        for (const [key, value] of Object.entries(this)) {\r\n            if (typeof value !== \"function\") {\r\n                if (value) {\r\n                    // maximum toArray call happens\r\n                    if (params.filter((p) => p === key).length)\r\n                        x[key] =\r\n                            value instanceof Algebra ? value.toArray() : value;\r\n                    //)((value instanceof StandardInputSignal ? value.copy() : ));\r\n                    else if (linkers.filter((l) => l === key).length)\r\n                        x[key] =\r\n                            value instanceof StandardInputSignal\r\n                                ? value.copy()\r\n                                : value.toArray();\r\n                }\r\n            }\r\n        }\r\n        return x;\r\n    };\r\n}\r\n\r\nexport default Algebra;\r\n","import { round, strictPrecisionFormat } from \"../calculus\";\r\n\r\nexport default class StandardInputSignal {\r\n    constructor(amplitude = 1, type = \"u\", symbol = \"t\") {\r\n        this.symbol = symbol;\r\n        this.type = type;\r\n        this.amp = round(amplitude);\r\n    }\r\n\r\n    copy = () => new StandardInputSignal(this.amp, this.type, this.symbol);\r\n\r\n    toString = () => {\r\n        let str = \"\",\r\n            a = this.amp;\r\n        if (this.amp === -1) {\r\n            str += \"-\";\r\n            a *= -1;\r\n        }\r\n        if (a !== 1) str += strictPrecisionFormat(a);\r\n        return str + `${this.type}(${this.symbol})`;\r\n    };\r\n\r\n    ampiltude = () => this.amp;\r\n}\r\n"],"names":["Complex","preal","pimage","params","symbol","type","b","hasMultiTerms","plus","a","toString","parenthesis","showJ1","isZero","rl","formula","Algebra","round","im","getA","setA","join","real","imaginary","copy","linkPrevious","dot","previous","input","conjugate","negation","magnitude$2","magnitude","phase","definiteA","definiteB","Math","atan2","t","$","NaN","isReal","hasSameTypeWith","x","realify","add","operand","Re","Im","substract","equals","isConjugateWith","multiply","push","devide","denominator","result","isNaN","setB","raiseTo","power","floor","i","devideInverse","k","ToCouples","arrComplex","n","length","reals","Array","fill","imaginaries","extract","strNumber","replace","isDigit","Number","slice","sign","img","Fraction","num","den","lim","numerator","Poly","setNumerator","setDenominator","valueAt","toFormula","degree","powerTerm","derivative","da","expression","filter","ci","map","a_i","atn","aArray","Symbolic","halfTermsVisible","coef","inline","res","NotScalarError","cause","describe","console","log","message","name","code","error_codes","Error","teta","identify","getB","setTeta","getTeta","end","last","first","fst","enddot","firstdot","link","term","sort","position","order","func","isPrior","temp","orders","findIndex","or","unifiable","exp","isUnifiable","sameOnes","item","idx","simplify","polynomial","redundant","label","undefined","index","operator","next","ai","isTriangular","right","y","endTerm","StandardInputSignal","arrangeDots","no","As","zeros","yai","table","product","pop","j","endDotTerm","lastyDot","selfmultiply","ao","laplace","areTheSame","toLowerCase","a0","strictPrecisionFormat","e0","w0","toArray","linkers","key","value","p","l","Object","entries","this","parameter","pi","valueOf","polynomialValueAt","arr","coefy","str","s","coefs","el1","el2","areTheseTwoEqual","p1","p2","amplitude","amp","ampiltude"],"sourceRoot":""}