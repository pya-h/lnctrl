{"version":3,"file":"static/js/491.707c91b8.chunk.js","mappings":"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","sources":["math/algebra/complex.js","math/algebra/functions/fraction.js","math/algebra/functions/poly.js","errors/algebra/NotScalarError.js","math/algebra/index.js","math/input-signals/index.js"],"sourcesContent":["import Algebra from \".\";\r\nimport { round, isDigit } from \"../calculus\";\r\n\r\nclass Complex extends Algebra {\r\n    constructor(preal, pimage = 0, params = {}) {\r\n        super(preal, { symbol: \"j\", type: \"complex\", b: pimage, ...params });\r\n    }\r\n    static ToCouples = (arrComplex) => {\r\n        const n = arrComplex.length;\r\n        if (n >= 1) {\r\n            const reals = Array(n).fill(0),\r\n                imaginaries = Array(n).fill(0);\r\n            for (let i = 0; i < n; i++) {\r\n                if (arrComplex[i] instanceof Complex) {\r\n                    reals[i] = arrComplex[i].real();\r\n                    imaginaries[i] = arrComplex[i].imaginary();\r\n                } else\r\n                    reals[i] = arrComplex[i];\r\n            }\r\n            return [reals, imaginaries];\r\n        }\r\n        return [];\r\n    }\r\n    hasMultiTerms = () =>\r\n        this.plus || (this.a.toString() !== \"0\" && this.b.toString() !== \"0\");\r\n\r\n    toString = (parenthesis = false) => {\r\n        if (this.isZero())\r\n            return \"0\";\r\n        const rl = this.a;\r\n        let formula = parenthesis && this.hasMultiTerms() ? \"(\" : \"\";\r\n        if (rl !== 0)\r\n            formula +=\r\n            rl instanceof Algebra ?\r\n            rl.toString(rl.hasMultiTerms()) :\r\n            round(rl);\r\n        let im = this.b;\r\n        if (im !== 0) {\r\n            //if (im < 0 || (im instanceof Algebra)) { im = im.negation()\r\n            if (im < 0) {\r\n                im *= -1;\r\n                formula += \" - \";\r\n            } else if (im instanceof Algebra && im.getA() < 0) {\r\n                im.setA(-im.getA());\r\n                formula += \" - \";\r\n            } else if (rl !== 0) formula += \" + \";\r\n\r\n            formula += this.symbol;\r\n            if (im !== 1)\r\n                formula +=\r\n                im instanceof Algebra ?\r\n                im.toString(im.hasMultiTerms()) :\r\n                round(im);\r\n        }\r\n        if (this.plus) formula += this.join(); // if there's a next term: casscade toString() calls\r\n\r\n        return parenthesis ? formula + \")\" : formula;\r\n    }; // a + jb\r\n\r\n    real = () => this.a;\r\n    imaginary = () => this.b;\r\n\r\n    copy = (linkPrevious = false) =>\r\n        new Complex(this.a, this.b, {\r\n            dot: this.dot,\r\n            plus: this.plus,\r\n            previous: linkPrevious ? this.previous : null,\r\n            input: this.input,\r\n        });\r\n\r\n    conjugate = () =>\r\n        new Complex(\r\n            this.a,\r\n            this.b instanceof Algebra ? this.b.negation() : -this.b\r\n        );\r\n\r\n    negation = () =>\r\n        new Complex(\r\n            this.a instanceof Algebra ? this.a.negation() : -this.a,\r\n            this.b instanceof Algebra ? this.b.negation() : -this.b\r\n        );\r\n\r\n    magnitude$2 = () => this.a ** 2 + this.b ** 2;\r\n\r\n    magnitude = () => (this.a ** 2 + this.b ** 2) ** 0.5;\r\n\r\n    phase = () => {\r\n        const definiteA = +this.a,\r\n            definiteB = +this.b;\r\n        if (this.a === definiteA && this.b === definiteB)\r\n            return Math.atan2(definiteB, definiteA);\r\n        if (this.b instanceof Algebra)\r\n            return t => Math.atan2(this.b.$(t), (this.a instanceof Algebra ? this.a.$(t) : definiteA))\r\n        if (this.a instanceof Algebra)\r\n            return t => Math.atan2(definiteB, this.a.$(t));\r\n        return NaN;\r\n    }\r\n    isReal = () => this.b === 0;\r\n\r\n    hasSameTypeWith = (x) =>\r\n        (this.isReal() && x.isReal()) || (!this.isReal() && !x.isReal()); // both full imaginray or both real\r\n    realify = () => new Complex(this.a, 0); // return a simple real value in Complex object format (for methods that only accept Complex values)\r\n\r\n    add = (operand) => {\r\n        let Re = null,\r\n            Im = null;\r\n        if (operand instanceof Complex) {\r\n            if (this.a instanceof Algebra) Re = this.a.add(operand.real());\r\n            else if (operand.real() instanceof Algebra)\r\n                Re = operand.real().add(this.a);\r\n            else Re = this.a + operand.real();\r\n\r\n            if (this.b instanceof Algebra) Im = this.b.add(operand.imaginary());\r\n            else if (operand.imaginary() instanceof Algebra)\r\n                Im = operand.imaginary().add(this.b);\r\n            else Im = this.b + operand.imaginary();\r\n        } else {\r\n            if (this.a instanceof Algebra) Re = this.a.add(operand);\r\n            else if (operand instanceof Algebra) Re = operand.add(this.a);\r\n            else Re = this.a + operand;\r\n\r\n            Im = this.b;\r\n        }\r\n        return new Complex(Re, Im);\r\n    };\r\n\r\n    substract = (operand) => this.add(operand.negation());\r\n\r\n    equals = (operand) => {\r\n        if (operand instanceof Complex) {\r\n            // two complex number are equal to eachother if both thier real parts are the same, and their imaginary parts are the same\r\n            let realPartsEqual = false;\r\n            if (this.a instanceof Algebra)\r\n                realPartsEqual = this.a.equals(operand.real());\r\n            else if (operand.real() instanceof Algebra)\r\n                realPartsEqual = operand.real().equals(this.a);\r\n            else realPartsEqual = this.a === operand.real();\r\n            if (!realPartsEqual) return false;\r\n\r\n            if (this.b instanceof Algebra)\r\n                return this.b.equals(operand.imaginary());\r\n            else if (operand.imaginary() instanceof Algebra)\r\n                return operand.imaginary().equals(this.b);\r\n            return this.b === operand.imaginary();\r\n        }\r\n\r\n        // if operand is not a complex number then the only way it can be equal with this object of Complex,\r\n        // is for this object to have a zero imaginary part:\r\n        return (\r\n            this.isReal() &&\r\n            (operand instanceof Algebra ?\r\n                operand.equals(this.a) :\r\n                operand === this.a)\r\n        );\r\n    };\r\n\r\n    isConjugateWith = (operand) => this.conjugate().equals(operand);\r\n    multiply = (operand) => {\r\n        let Re = [],\r\n            Im = [];\r\n        if (operand instanceof Complex) {\r\n            // first term\r\n            if (this.a instanceof Algebra) {\r\n                Re.push(this.a.multiply(operand.real()));\r\n                Im.push(this.a.multiply(operand.imaginary()));\r\n            } else {\r\n                Re.push(\r\n                    operand.a instanceof Algebra ?\r\n                    operand.a.multiply(this.a) :\r\n                    operand.a * this.a\r\n                );\r\n\r\n                Im.push(\r\n                    operand.b instanceof Algebra ?\r\n                    operand.b.multiply(this.a) :\r\n                    this.a * operand.b\r\n                );\r\n            }\r\n\r\n            // second term\r\n            if (this.b instanceof Algebra) {\r\n                Re.push(this.b.multiply(operand.imaginary()));\r\n                Im.push(this.b.multiply(operand.real()));\r\n            } else {\r\n                Re.push(\r\n                    operand.b instanceof Algebra ?\r\n                    operand.b.multiply(this.b) :\r\n                    operand.b * this.b\r\n                );\r\n\r\n                Im.push(\r\n                    operand.a instanceof Algebra ?\r\n                    operand.a.multiply(this.b) :\r\n                    this.b * operand.a\r\n                );\r\n            }\r\n            return new Complex(Re[0] - Re[1], Im[0] + Im[1]);\r\n        } else {\r\n            Re =\r\n                this.a instanceof Algebra ?\r\n                this.a.multiply(operand) :\r\n                operand instanceof Algebra ?\r\n                operand.multiply(this.a) :\r\n                this.a * operand;\r\n\r\n            Im =\r\n                this.b instanceof Algebra ?\r\n                this.b.multiply(operand) :\r\n                operand instanceof Algebra ?\r\n                operand.multiply(this.b) :\r\n                this.b * operand;\r\n\r\n        }\r\n        return new Complex(Re, Im);\r\n    };\r\n\r\n    devide = (denominator) => {\r\n        if (denominator instanceof Complex) {\r\n            const result = this.multiply(denominator.conjugate()).devide(\r\n                denominator.magnitude$2()\r\n            );\r\n            // CHECK THIS\r\n            if (isNaN(result.real()))\r\n                result.setA(0);\r\n            if (isNaN(result.imaginary()))\r\n                result.setB(0);\r\n            return result;\r\n        } else if (denominator instanceof Algebra) {\r\n            // USE super().devide ?\r\n            return this.copy(); // for now to avoid craches\r\n        } else return this.multiply(1 / denominator); // number\r\n    };\r\n\r\n    raiseTo = (power) => {\r\n        let result = this.copy(true);\r\n        // for now power must be integr\r\n        if (Math.floor(power) === power)\r\n            for (let i = 1; i < power; i++) {\r\n                result = result.multiply(this);\r\n            }\r\n\r\n        return result;\r\n    };\r\n\r\n    devideInverse = (k) =>\r\n        (k instanceof Algebra ? k : new Complex(k, 0)).devide(this);\r\n\r\n    static extract = (strNumber) => {\r\n        // extract a string to a complex object\r\n\r\n        strNumber = strNumber.replace(/\\s/g, \"\");\r\n        let i = strNumber[0] === \"-\" || strNumber[0] === \"+\" ? 1 : 0;\r\n        let real = 0;\r\n        if (strNumber[i] !== \"j\") {\r\n            for (; i < strNumber.length && isDigit(strNumber[i]); i++);\r\n            real = Number(strNumber.slice(0, i) || 0);\r\n        }\r\n\r\n        let sign = 1;\r\n        for (; i < strNumber.length &&\r\n            (strNumber[i] === \"j\" ||\r\n                strNumber[i] === \"+\" ||\r\n                strNumber[i] === \"-\"); i++\r\n        )\r\n            if (strNumber[i] === \"-\") sign = -1;\r\n\r\n        const img = Number(strNumber.slice(i, strNumber.length) || 0);\r\n        return new Complex(real, sign * img);\r\n    };\r\n\r\n    isZero = () => this.a === 0 && this.b === 0;\r\n}\r\n\r\nexport default Complex;","import Algebra from \"math/algebra\";\r\nimport Poly from \"./poly\";\r\n\r\nexport default class Fraction extends Algebra {\r\n    constructor(num, den = [1], symbol = \"t\", params = {}) {\r\n        // ke^ct\r\n        if (!(num instanceof Algebra)) {\r\n            if (!(num instanceof Array)) num = [num];\r\n            // this.a\r\n            else if (num.length === 0) num = [0];\r\n        }\r\n        if (!(den instanceof Algebra)) {\r\n            if (!(den instanceof Array)) den = [den];\r\n            // this.b\r\n            else if (den.length === 0) den = [1];\r\n        }\r\n        super(num, { symbol, type: \"frac\", b: den, ...params });\r\n    }\r\n\r\n    copy = (linkPrevious = false) =>\r\n        new Fraction(this.a, this.b, this.symbol, {\r\n            dot: this.dot,\r\n            plus: this.plus,\r\n            previous: linkPrevious ? this.previous : null,\r\n            input: this.input\r\n        });\r\n\r\n    lim = () => {\r\n        // for all fractions with all kind of numerator and denominator\r\n    }\r\n    \r\n    numerator = () => this.a instanceof Algebra ? this.a.copy(true) : new Poly(this.a);\r\n    denominator = () => this.b instanceof Algebra ? this.b.copy(true) : new Poly(this.b);\r\n\r\n    setNumerator = (num) => {\r\n        if (!(num instanceof Algebra)) {\r\n            if (!(num instanceof Array)) num = [num];\r\n            // this.a\r\n            else if (num.length === 0) num = [0];\r\n        }\r\n        return this.setA(num);\r\n    }\r\n\r\n    setDenominator = (den) => {\r\n        if (!(den instanceof Algebra)) {\r\n            if (!(den instanceof Array)) den = [den];\r\n            // this.b\r\n            else if (den.length === 0) den = [1];\r\n        }\r\n        return this.setB(den);\r\n    }\r\n    valueAt = (t) => {\r\n        const num = this.numerator().$(t);\r\n        const den = this.denominator().$(t);\r\n       \r\n        if(num instanceof Algebra)\r\n            return num.devide(den);\r\n        if(den instanceof Algebra)\r\n            return den.devideInverse(num);\r\n        if(den)\r\n            return num / den;\r\n        // THROW zero denominator ERROR \r\n        return undefined;\r\n    }\r\n\r\n}\r\n","import Algebra from \"math/algebra\";\r\nimport Complex from \"../complex\";\r\nimport Fraction from \"./fraction\";\r\n\r\nexport default class Poly extends Algebra {\r\n    static atn = (a, n, symbol = \"t\") => {\r\n        const aArray = Array(n + 1).fill(0);\r\n        aArray[0] = a;\r\n        return new Poly(aArray, symbol);\r\n    };\r\n    constructor(a, symbol = \"t\", params = {}) {\r\n        // ke^ct\r\n        super(a, { symbol, type: \"poly\", ...params });\r\n    }\r\n\r\n    copy = (linkPrevious = false) =>\r\n        new Poly(this.a, this.symbol, {\r\n            dot: this.dot,\r\n            plus: this.plus,\r\n            previous: linkPrevious ? this.previous : null,\r\n            input: this.input,\r\n        });\r\n\r\n    degree = () => this.a.length - 1;\r\n    \r\n    valueAt = (t) => {\r\n        if (typeof t === \"number\") return Algebra.polynomialValueAt(this.a, t);\r\n        else if (t instanceof Complex) {\r\n            const n = this.a.length - 1;\r\n            if (n >= 0) {\r\n                let powerTerm = 1,\r\n                    result =\r\n                        this.a[n] instanceof Complex\r\n                            ? this.a[n].copy()\r\n                            : new Complex(this.a[n], 0);\r\n                for (let i = n - 1; i >= 0; i--) {\r\n                    powerTerm = t.multiply(powerTerm);\r\n                    result = result.add(powerTerm.multiply(this.a[i]));\r\n                    \r\n                }\r\n                return result;\r\n            }\r\n            return 0;\r\n        }\r\n        return NaN;\r\n    };\r\n\r\n    static Symbolic = (\r\n        degree,\r\n        symbol = \"t\",\r\n        halfTermsVisible = 2,\r\n        coef = \"a\",\r\n        inline = false\r\n    ) => {\r\n        let res = inline ? \"\" : \"$$\";\r\n        if (degree === \"n\") {\r\n            res += `${coef}_n ${symbol}^n + `;\r\n            for (let i = 1; i < halfTermsVisible; i++)\r\n                res += `${coef}_{n - ${i}}${symbol}^{n - ${i}} + `;\r\n            res += \" ... \";\r\n            for (let i = halfTermsVisible - 1; i > 0; i--)\r\n                res += ` + ${coef}_{${i}}${symbol}^{${i}}`;\r\n            res += ` + ${coef}_0`;\r\n        } else if (typeof degree === \"number\") {\r\n            for (; degree >= 0; degree--) {\r\n                res += `${coef}_{${degree}}`;\r\n                if (degree > 0) res += `${symbol}^{${degree}} + `;\r\n            }\r\n        }\r\n        return res + (inline ? \"\" : \" $$\");\r\n    };\r\n    derivative = () => {\r\n        const result = this.copy(true);\r\n        if (!result.dot) {\r\n            const n = result.a.length - 1;\r\n            const da = Array(n).fill(0);\r\n            for (let i = n; i >= 1; i--) da[n - i] = i * result.a[n - i];\r\n            result.a = [...da];\r\n        }\r\n        if (result.plus) result.plus = result.plus.derivative();\r\n        return result;\r\n    };\r\n\r\n\r\n    expression = () => {\r\n        if (this.a instanceof Array) {\r\n            const n = this.a.length - 1;\r\n            if (\r\n                !n ||\r\n                !this.a.slice(0, n).filter((ci) => ci.toString() !== \"0\").length\r\n            )\r\n                return this.a[n].toString();\r\n            return this.a\r\n                .map((a_i, i) =>\r\n                    a_i\r\n                        ? Algebra.coefy(a_i, i, n) +\r\n                          (i < n\r\n                              ? this.symbol +\r\n                                (i < n - 1\r\n                                    ? \"^\" + (n - i).toString()\r\n                                    : \"\")\r\n                              : \"\")\r\n                        : \"\"\r\n                )\r\n                .join(\"\"); // joins all the coefficients, symbols, etc all together as for polynomal functions\r\n        }\r\n        return this.a.toString();\r\n    }\r\n\r\n    devide = (operand) => {\r\n        if(operand instanceof Poly && this.symbol === operand.symbol){\r\n            return new Fraction(this.getA(), operand.getA(), this.symbol);\r\n        }\r\n        if(operand === +operand)\r\n            return this.multiply(1 / Number(operand));\r\n        // is it true??\r\n        return super.devide();\r\n    }\r\n}\r\n","import { error_codes } from \"config\";\r\n\r\nexport default class NotScalarError extends Error {\r\n    \r\n    constructor(cause = null){ // the parameter with problem\r\n        super(cause ? `${cause} => این عبارت باید اسکالر باشد!!` : \"این خطا بدلیل استفاده از یک عبارت غیر اسکالر در مکان غیر مجاز رخ داده است!\")\r\n        this.name = \"NotNumberError\";\r\n        this.type = \"Numeric\";\r\n        this.code = error_codes.not_scalar;\r\n        this.cause = cause;\r\n    }\r\n\r\n    describe = () => {\r\n        console.log(this.message + (this.cause ? \"\\n\" + this.cause : \"\"));\r\n        return this.message + (this.cause ? \"\\n\" + this.cause.toString() : \"\");\r\n    }\r\n}","import NotScalarError from \"errors/algebra/NotScalarError\";\r\nimport StandardInputSignal from \"math/input-signals\";\r\nimport { round, strictPrecisionFormat } from \"../calculus\";\r\n\r\nclass Algebra {\r\n    // symbolic expressions\r\n    constructor(\r\n        a,\r\n        { symbol = \"t\", type = \"poly\", b, dot, plus, teta = 0, previous, input }\r\n    ) {\r\n        // dot is the interface between terms\r\n        // g(t) = a * f(t) * {dot: as Algebra}\r\n        // teta is the offset for wt + alpha in sin/cos/tan/..\r\n\r\n        this.symbol = symbol;\r\n        this.type = type.toLowerCase();\r\n        this.setA(a).setB(b).setTeta(teta);\r\n\r\n        this.input = input; // u(t), r(t), puls, ...\r\n        if (dot) {\r\n            this.dot = dot.copy();\r\n        } // multiply a Algebra from different type into 'this'\r\n\r\n        if (plus) {\r\n            this.plus = plus.copy();\r\n            this.simplify();\r\n        } // add another Algebra with different type to this one\r\n\r\n        this.previous = previous; // the previous term in the chained Algebra objects\r\n        // term.plus => next term, term.previous => previous term, term.dot => an algebra from another type that is multiplied to actual term\r\n        // F(u) = a.f(u).dot(u) + term.plus(u)\r\n        this.link();\r\n    }\r\n    static identify = (parameter) => {\r\n        if (parameter instanceof Array)\r\n            return parameter.map((pi) =>\r\n                pi instanceof Algebra || pi instanceof StandardInputSignal\r\n                    ? pi.copy()\r\n                    : round(pi)\r\n            );\r\n        else if (parameter instanceof Algebra) {\r\n            return parameter.copy();\r\n        } else if (typeof parameter === \"number\") return round(parameter);\r\n        else if(typeof parameter === 'string') return parameter;\r\n        else if (!parameter) return 0;\r\n        throw new NotScalarError(parameter);\r\n    };\r\n    setA = (a) => {\r\n        this.a = Algebra.identify(a);\r\n        return this;\r\n    };\r\n    getA = () => this.a;\r\n\r\n    setB = (b) => {\r\n        this.b = Algebra.identify(b);\r\n        return this;\r\n    };\r\n    getB = () => this.b;\r\n\r\n    setTeta = (teta) => {\r\n        this.teta = Algebra.identify(teta);\r\n        return this;\r\n    };\r\n    getTeta = () => this.teta;\r\n    // CONNECT AND LINK METHODS, FIND FIRST TERM AND LAST TERM AND ...\r\n    end = () => {\r\n        // returns the end term in the algebratic chain\r\n        let last = this;\r\n        while (last.plus) last = last.plus;\r\n        return last;\r\n    };\r\n\r\n    first = () => {\r\n        // returns the first term in the algebratic chain\r\n        let fst = this;\r\n        while (fst.previous) fst = fst.previous;\r\n        return fst;\r\n    };\r\n\r\n    enddot = () => {\r\n        // returns the end term in the algebratic chain\r\n        let last = this;\r\n        while (last.dot) last = last.dot;\r\n        return last;\r\n    };\r\n\r\n    firstdot = () => {\r\n        // returns the first term in the algebratic chain\r\n        let fst = this;\r\n        // WRONG *****************************\r\n        //while (fst.previous) fst = fst.previous;\r\n        return fst;\r\n    };\r\n    link = () => {\r\n        // some times .previous links are broken; so i decided to write this method just to make sure everything is connected\r\n        let term = this.first();\r\n        if (!term) term = this; // in case this.first() returns wrong answer\r\n        while (term.plus) {\r\n            if (term.plus) term.plus.previous = term;\r\n            term = term.plus; // go to next term in the chain\r\n        }\r\n        return this;\r\n    };\r\n\r\n    copy = (linkPrevious = false) =>\r\n        new Algebra(this.a, {\r\n            type: this.type,\r\n            b: this.b,\r\n            dot: this.dot,\r\n            plus: this.plus,\r\n            symbol: this.symbol,\r\n            teta: this.teta,\r\n            input: this.input,\r\n            previous: linkPrevious ? this.previous : null,\r\n        });\r\n\r\n    // SORT THE MULTIPLIERD TERMS ( TERMS CONNECTED WITH this.dot) IN A SPECIFIC ORDER (FOR BETTER SHOW AND COMPARE AND ETC.)\r\n    // LOOK HERE IT STILL HAS BUGS\r\n    sort = () => {\r\n        // sort .dot in special order: poly - exp - frac - ...\r\n        const orders = [\"poly\", \"exp\", \"frac\"];\r\n        let position = this;\r\n        for (const order of orders) {\r\n            while (position) {\r\n                let func = position.dot;\r\n                while (func) {\r\n                    if (func.type === order && !position.isPrior(order)) {\r\n                        const temp = position.copy();\r\n                        position.a =\r\n                            func.a instanceof Array ? [...func.a] : func.a;\r\n                        position.type = func.type;\r\n                        position.symbol = func.symbol;\r\n                        if (func.b instanceof Array) position.b = [...func.b];\r\n                        else position.b = func.b;\r\n\r\n                        func.a = temp.a instanceof Array ? [...temp.a] : temp.a;\r\n                        func.type = temp.type;\r\n                        func.symbol = temp.symbol;\r\n                        if (temp.b instanceof Array) func.b = [...temp.b];\r\n                        else func.b = temp.b;\r\n                    }\r\n                    func = func.dot;\r\n                }\r\n                position = position.dot;\r\n            }\r\n        }\r\n    };\r\n\r\n    isPrior = (order) => {\r\n        const orders = [\"poly\", \"exp\", \"frac\"];\r\n        const thisValue = orders.findIndex((or) => or === this.type);\r\n        const orderValue = orders.findIndex((or) => or === order);\r\n        return thisValue <= orderValue;\r\n    };\r\n\r\n    // CHECK IF ONE TERMS CAN BE ADDED TO ANOTHER ONE (MEANING THEY HAVE SAME PARAMETRIC TERMS)\r\n    unifiable = (exp) => {\r\n        // check if this is unifiable with expression:exp\r\n        //this.sort();\r\n        //exp.sort();\r\n        if (exp && this.type === exp.type && this.symbol === exp.symbol) {\r\n            // check if this and exp are sumable\r\n            // check .dot s:\r\n            let isUnifiable = true;\r\n            if (this.dot || exp.dot)\r\n                isUnifiable = this.dot && this.dot.unifiable(exp.dot);\r\n            \r\n            console.log(\"first: \", this.toString());\r\n            console.log(\"first: \", exp.toString());\r\n            if (this.b instanceof Array && exp.b instanceof Array) {\r\n                if (this.b.length === exp.b.length) {\r\n                    const sameOnes = this.b.filter(\r\n                        (item, idx) => item === exp.b[idx]\r\n                    );\r\n                    return isUnifiable && this.b.length === sameOnes.length;\r\n                }\r\n            }\r\n            else if(this.b instanceof Algebra)\r\n                return isUnifiable && this.b.equals(exp.b);\r\n            return isUnifiable && exp.b === this.b;\r\n        }\r\n        return false;\r\n    };\r\n\r\n    static valueOf = (x, t = 0) => {\r\n        if (x) {\r\n            let value = 0;\r\n            if (x instanceof Algebra || x instanceof StandardInputSignal)\r\n                value = x.$(t);\r\n            else if (x instanceof Array)\r\n                value = Algebra.polynomialValueAt(x, t);\r\n            else value = x;\r\n            return value;\r\n        }\r\n        return 0;\r\n    };\r\n\r\n    static polynomialValueAt = (arr, t) => {\r\n        let value = 0;\r\n        const n = arr.length - 1;\r\n        for (let i = 0; i <= n; i++) {\r\n            value += arr[i] * t ** (n - i);\r\n        }\r\n        return value;\r\n    };\r\n    // REMOVE REDUNDANT TERMS, SIGNS AND ETC.\r\n    simplify = () => {\r\n        let term = this.first();\r\n        while (term) {\r\n            if (term instanceof Algebra) {\r\n                if (\r\n                    term.a === 0 ||\r\n                    Algebra.polynomial(term.a, term.symbol) === 0\r\n                ) {\r\n                    if (term.previous) {\r\n                        term.previous.plus = term.plus;\r\n                    } else {\r\n                        // remove first term and transfer the second term to first one\r\n                        if (this === term) term.redundant = true;\r\n                        if (term.plus) {\r\n                            term = term.plus.copy(true);\r\n                            if (term.plus) {\r\n                                term.plus = term.plus.plus;\r\n                                if (term.plus) term.plus.previous = term;\r\n                            }\r\n                            term.previous = null;\r\n                        }\r\n                    }\r\n                    // }\r\n                }\r\n            }\r\n            term = term.plus;\r\n        }\r\n        return this;\r\n    };\r\n\r\n    $ = (t) => {\r\n        // valueOf function in certain point\r\n        // I used character $ in many places as acronym for \"set\" in setters, so $ here means that set the t ( or x or whatever) with a certain point\r\n        // for each type just implement the method literally\r\n        let result = this.valueAt(t);\r\n        if (this.dot) result *= this.dot.$(t);\r\n        if (this.plus) result += this.plus.$(t);\r\n\r\n        return result;\r\n    };\r\n\r\n    label = (name = undefined, index = undefined) =>\r\n        (name\r\n            ? name +\r\n              (index !== undefined ? \"_{\" + index + \"}\" : \"\") +\r\n              \"(\" +\r\n              this.symbol +\r\n              \") = \"\r\n            : \"\") + this.toString();\r\n\r\n    // RETURNS THE BEST AND SIMPLE AND SHORTEST WAY TO SHOW COEFFICIENTS\r\n    static coefy = (a_i, i, n) => {\r\n        if (a_i instanceof Algebra) {\r\n            let str = \"\";\r\n            let ai = a_i.copy();\r\n            if (i > 0) {\r\n                // write a method to edit all the + - occuring next to each other in toString()\r\n                if (ai.type === \"complex\" && typeof ai.a === \"number\") {\r\n                    if (ai.a < 0) {\r\n                        str += \" - \";\r\n                        ai.a *= -1;\r\n                    } else if (!ai.a && typeof ai.b === \"number\" && ai.b < 0) {\r\n                        str += \" - \";\r\n                        ai.b *= -1;\r\n                    }\r\n                } else str += \" + \";\r\n            }\r\n            return str + ai.toString(i < n && a_i.hasMultiTerms());\r\n        }\r\n        if (a_i instanceof StandardInputSignal) {\r\n            //EDIT THIS PART TOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO\r\n            let str = i > 0 ? \" + \" : \"\";\r\n            return str + a_i.toString(i < n && a_i.hasMultiTerms());\r\n        } else {\r\n            if (n === 0) return strictPrecisionFormat(a_i);\r\n            if (a_i === 0) return \"\";\r\n            if (i !== 0) {\r\n                let s = \"\";\r\n                if (a_i < 0) {\r\n                    s += \" - \";\r\n                    a_i *= -1;\r\n                } else s += \" + \";\r\n\r\n                if (a_i === 1 && i < n) return s;\r\n                return s + strictPrecisionFormat(a_i);\r\n            }\r\n            if (a_i === 1) return \"\";\r\n            if (a_i === -1) return \"-\";\r\n\r\n            return strictPrecisionFormat(a_i);\r\n        }\r\n    };\r\n\r\n    // DECIPHER THE OBJECT TO ITS POLYNOMINAL FORM (IF IT IS ONE ACTUALLY)\r\n    static polynomial = (coefs, symbol) => {\r\n        if (coefs instanceof Array) {\r\n            const n = coefs.length - 1;\r\n            if (\r\n                !n ||\r\n                !coefs.slice(0, n).filter((ci) => ci.toString() !== \"0\").length\r\n            )\r\n                return coefs[n].toString();\r\n            return coefs\r\n                .map((a_i, i) =>\r\n                    a_i\r\n                        ? Algebra.coefy(a_i, i, n) +\r\n                          (i < n\r\n                              ? symbol +\r\n                                (i < n - 1\r\n                                    ? \"^{\" + (n - i).toString() + \"}\"\r\n                                    : \"\")\r\n                              : \"\")\r\n                        : \"\"\r\n                )\r\n                .join(\"\"); // joins all the coefficients, symbols, etc all together as for polynomal functions\r\n        }\r\n        return coefs.toString();\r\n    };\r\n\r\n    join = () => {\r\n        // connect this term to its next terms; considering the right use of + or -\r\n        if (this.plus) {\r\n            let operator = \"+\",\r\n                next = this.plus.copy();\r\n            if (next.a instanceof Array) {\r\n                if (next.a[0] < 0) {\r\n                    operator = \"-\";\r\n                    next.a[0] *= -1;\r\n                }\r\n            } else {\r\n                if (next.a < 0) {\r\n                    operator = \"-\";\r\n                    next.a *= -1;\r\n                }\r\n            }\r\n            return operator + next.toString();\r\n        }\r\n        return \"\";\r\n    };\r\n\r\n    hasMultiTerms = () => {\r\n        if (this.plus) return true;\r\n        if (this.a instanceof Array && this.type !== \"frac\")\r\n            return this.a.filter((ai) => ai !== 0).length > 1;\r\n        return false;\r\n    };\r\n    isTriangular = () =>\r\n        this.type === \"sin\" ||\r\n        this.type === \"cos\" ||\r\n        this.type === \"tan\" ||\r\n        this.type === \"cot\";\r\n\r\n    // MATHEMATICAL OPERATIONS\r\n    // static add = (expressions) => expressions.map((el) => el.toString()).join(\" + \");\r\n    add = (right) => {\r\n        // result = this + operand\r\n        let result = this.link().copy();\r\n        if (right instanceof Algebra) {\r\n            let operand = right.link().copy();\r\n\r\n            let x = result; // now we try to add each term with its unifiable term in y\r\n            while (x) {\r\n                let y = operand;\r\n                while (y) {\r\n                    if (x.unifiable(y)) {\r\n                        if (x.a instanceof Algebra) x.a = x.a.add(y.a);\r\n                        else if (y.a instanceof Algebra) x.a = y.a.add(x.a);\r\n                        // **************************************************\r\n                        // else if x.a || y.a instanceof StandardInputSignal\r\n                        // *********************************************\r\n                        else if (x.a instanceof Array) {\r\n                            if (y.a instanceof Array) {\r\n                                if (y.a.length > x.a.length) x.a = [...y.a];\r\n                                for (\r\n                                    let i = 1;\r\n                                    i <= y.a.length && i <= x.a.length;\r\n                                    i++\r\n                                )\r\n                                    x.a[x.a.length - i] += y.a[y.a.length - i];\r\n                            } else {\r\n                                x.a[x.a.length - 1] += y.a;\r\n                            }\r\n                        } else {\r\n                            x.a += y.a;\r\n                        }\r\n                        // remove the term in y that has been processed\r\n                        if (y.previous) {\r\n                            y.previous.plus = y.plus;\r\n                            if (y.plus) y.plus.previous = y.previous;\r\n                            y.a = 0;\r\n                        }\r\n\r\n                        // its the first term\r\n                        else operand = operand.plus;\r\n                        // after this the garbage collector will remove the term because it has no reference to it\r\n                    }\r\n                    y = y.plus;\r\n                }\r\n                // if(x.plus) x.plus.previous = x;\r\n                x = x.plus; // go to next term in the chain\r\n            }\r\n\r\n            if (operand) {\r\n                // if the above algorythm leaves operand with non-null value\r\n                /// it means there was terms in the operand's algebratic chain that are'nt unifiable with x terms\r\n                // so we must connect the leftovers to last terms of the result\r\n                if (Algebra.polynomial(result.a, result.symbol) !== \"0\") {\r\n                    if (\r\n                        Algebra.polynomial(operand.getA(), operand.symbol) !==\r\n                        \"0\"\r\n                    ) {\r\n                        let endTerm = result.end();\r\n                        endTerm.plus = operand;\r\n                        endTerm.plus.previous = result;\r\n                    }\r\n                } else result = operand.copy(); // connect to next term\r\n            }\r\n            return result.simplify();\r\n        } else if (right instanceof StandardInputSignal) {\r\n            const endTerm = result.end();\r\n            endTerm.plus = right.copy();\r\n            endTerm.plus.previous = endTerm;\r\n        }\r\n        return result;\r\n    };\r\n\r\n    arrangeDots = () => {\r\n        let term = this;\r\n        let input = null;\r\n        while (term.dot) {\r\n            // enhance the algo for cases that more than one input signal erxists in .dot chain\r\n            if (term.dot instanceof StandardInputSignal) {\r\n                input = term.dot;\r\n                term.dot = term.dot.dot;\r\n            }\r\n            if (term.dot) term = term.dot;\r\n        }\r\n        term.dot = input;\r\n    };\r\n    // INCOMPLETE ***********\r\n    multiply = (operand) => {\r\n        const y = this.copy().link();\r\n        if (operand instanceof Algebra) {\r\n            // operand algebra or complex\r\n            // ***** TODO:  ****************\r\n            if (operand.type === \"poly\") {\r\n                if (this.type === \"poly\" || this.type === \"frac\") {\r\n                    // NEEDS ERDITING for FRACTIONs\r\n                    if (this.symbol === operand.symbol) {\r\n                        const ao = operand.getA();\r\n                        const no = ao.length - 1;\r\n                        const As = [];\r\n                        for (let i = no; i >= 0; i--) {\r\n                            if (operand.a[i]) {\r\n                                const zeros = Array(no - i).fill(0);\r\n                                const a = [...y.a].map(\r\n                                    (yai) => yai * operand.a[i]\r\n                                );\r\n                                a.push(...zeros);\r\n                                As.push(a);\r\n                            }\r\n                        }\r\n                        // now sum all the products\r\n                        console.table(As);\r\n                        let product = As.pop();\r\n                        for (let j = 0; j < As.length; j++)\r\n                            for (\r\n                                let i = 1;\r\n                                i <= As[j].length && i <= product.length;\r\n                                i++\r\n                            )\r\n                                product[product.length - i] +=\r\n                                    As[j][As[j].length - i];\r\n\r\n                        y.a = product;\r\n                        if (operand.dot) {\r\n                            // link dots ***IS THIS TRUE?>***\r\n                            const endDotTerm = y.enddot();\r\n                            endDotTerm.dot = operand.dot.copy(); // multiply\r\n                            endDotTerm.dot.previous = endDotTerm;\r\n                        }\r\n                    }\r\n                }\r\n            } else if (y.type !== operand.type && operand.plus) {\r\n                // like: exp(f(...)) * [Asin(...) * Bcos(...)]\r\n                // UPDATE SELF MULTIPLY AFTER SOLVING THIS ISSUE\r\n                y.plus = y.multiply(operand.plus.copy());\r\n                const lastyDot = y.enddot();\r\n                if(typeof y.a === 'number' && typeof operand.a === 'number' && operand.a !== 1){\r\n                    y.a *= operand.a;\r\n                    operand.a = 1;\r\n                }\r\n                lastyDot.dot = operand.copy();\r\n                lastyDot.dot.previous = lastyDot;\r\n                // UPDATE SELF MULTIPLY AFTER SOLVING THIS ISSUE\r\n\r\n            } else {\r\n                const endDotTerm = y.enddot();\r\n                if (typeof y.a === \"number\" && typeof operand.a === \"number\") {\r\n                    y.a *= operand.a;\r\n                    operand.a = 1;\r\n                }\r\n                endDotTerm.dot = operand.copy(); // multiply\r\n                endDotTerm.dot.previous = endDotTerm;\r\n            }\r\n            if (y.plus) y.plus = y.plus.multiply(operand);\r\n            if (operand.plus) y.end().plus = y.multiply(operand.plus);\r\n            return y; // for now just to avoid crashes\r\n        } else if (operand instanceof StandardInputSignal) {\r\n            // const endDotTerm = y.enddot();\r\n            // endDotTerm.dot = operand.copy(); // multiply\r\n            // endDotTerm.dot.previous = endDotTerm;\r\n            y.input = operand.copy();\r\n            if (y.plus) y.plus = y.plus.multiply(operand);\r\n        } else {\r\n            // scalar multiply\r\n            if (operand instanceof Algebra) {\r\n            } else {\r\n                if (y.a instanceof Array) y.a = y.a.map((ai) => operand * ai);\r\n                else if (y.a instanceof Algebra) y.a = y.a.multiply(operand);\r\n                else y.a = y.a * operand;\r\n            }\r\n            if (y.plus) y.plus = y.plus.multiply(operand);\r\n        }\r\n        // console.log(\"y = \", y, \"operand = \", operand)\r\n        return y;\r\n    };\r\n\r\n    selfmultiply = (operand) => {\r\n        if (operand instanceof Algebra) {\r\n            // operand algebra or complex\r\n            // ***** TODO:  ****************\r\n            if (operand.type === \"poly\") {\r\n                if (this.type === \"poly\" || this.type === \"frac\") {\r\n                    // NEEDS ERDITING for FRACTIONs\r\n                    if (this.symbol === operand.symbol) {\r\n                        const ao = operand.getA();\r\n                        const no = ao.length - 1;\r\n                        const As = [];\r\n                        for (let i = no; i >= 0; i--) {\r\n                            if (ao[i]) {\r\n                                const zeros = Array(no - i).fill(0);\r\n                                const a = [...this.a].map(\r\n                                    (yai) => yai * operand[i]\r\n                                );\r\n                                a.push(...zeros);\r\n                                As.push(a);\r\n                            }\r\n                        }\r\n                        // now sum all the products\r\n                        const product = As.pop();\r\n                        for (let i = 0; i < product.length; i++) {\r\n                            for (let j = 0; j < As.length; j++) {\r\n                                if (i < As[j].length) product[i] += As[j][i];\r\n                            }\r\n                        }\r\n                        this.a = product;\r\n                        if (operand.dot) {\r\n                            // link dots ***IS THIS TRUE?>***\r\n                            const endDotTerm = this.enddot();\r\n                            endDotTerm.dot = operand.dot.copy(); // multiply\r\n                            endDotTerm.dot.previous = endDotTerm;\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                const endDotTerm = this.enddot();\r\n                endDotTerm.dot = operand.copy(); // multiply\r\n                endDotTerm.dot.previous = endDotTerm;\r\n                if (this.plus) this.plus = this.plus.multiply(operand);\r\n            }\r\n        } else if (operand instanceof StandardInputSignal) {\r\n            // this.dot = operand.copy(); // multiply\r\n            // this.dot.previous = this;\r\n            this.input = operand.copy();\r\n            if (this.plus) this.plus.selfmultiply(operand);\r\n            if (operand.plus) this.end().plus = this.multiply(operand.plus);\r\n        } else {\r\n            // scalar multiply\r\n            if (this.a instanceof Array)\r\n                this.a = this.a.map((ai) => operand * ai);\r\n            else this.a *= operand;\r\n\r\n            if (this.plus) this.plus.selfmultiply(operand);\r\n        }\r\n    };\r\n\r\n    negation = () => this.multiply(-1);\r\n\r\n    substract = (operand) => this.add(operand.negation());\r\n\r\n    devide = (operand) => {\r\n        if(operand === +operand)\r\n            // scaler\r\n            return this.multiply(1 / Number(operand));\r\n        \r\n        // u need to handle Complex objects as Algebra using their type to recognize them\r\n        if (operand instanceof Algebra) {\r\n            // operand algebra or complex\r\n            // ***** TODO:  ****************\r\n            // first u must do everything to simplify\r\n            // second at the simplest state of the terms,\r\n            // construct a new Algebra of \"frac\" type\r\n            return this.copy(); // for now just to avoid crashes\r\n        } \r\n    };\r\n\r\n    devideInverse = (k) =>{\r\n        if(k === +k){\r\n            return new Algebra([k], {symbol: this.symbol, type: \"frac\", b: [1]});\r\n        }\r\n        else if(k instanceof Algebra)\r\n            return k.devide(this);\r\n    }\r\n\r\n    laplace = () => {};\r\n\r\n    static areTheSame = (el1, el2) => {\r\n        // checkes the sameness of parameters like .a .b .teta , etc.\r\n        if(el1 instanceof Algebra && el2 instanceof Algebra)\r\n            return el1.equals(el2);\r\n        else if(el1 instanceof Array && el2 instanceof Array){\r\n            if(el1.length === el2.length){\r\n                let i = 0;\r\n                for(i = 0; i < el1.length; i++)\r\n                    if(el1[i] !== el2[i]) break;\r\n                return i >= el1.length;\r\n                \r\n            }\r\n        }\r\n        return typeof el1 === typeof el2 && el1 === el2;\r\n    }\r\n    equals = (operand) => operand instanceof Algebra && \r\n                            this.type === operand.type && \r\n                            this.symbol === operand.symbol &&\r\n                            this.type === operand.type &&\r\n                            this.symbol === operand.symbol &&\r\n                            Algebra.areTheSame(this.a, operand.a) &&\r\n                            Algebra.areTheSame(this.b, operand.b) &&\r\n                            Algebra.areTheSame(this.teta, operand.teta) &&\r\n                            (!this.dot || this.dot.equals(operand.dot)) &&\r\n                            (!this.plus || this.plus.equals(operand.plus)) &&\r\n                            (!this.previous || this.previous.equals(operand.previous));\r\n\r\n\r\n    static areTheseTwoEqual = (p1, p2) =>\r\n        p1 instanceof Algebra\r\n            ? p1.equals(p2)\r\n            : p2 instanceof Algebra\r\n            ? p2.equals(p1)\r\n            : p1 === p2;\r\n    // DECIPHERS THE CONNECT OBJECTS TO UNDERSTANDABLE MATHMATICALLY SHAPED TEXT\r\n    // IT IS FORMATTED COMPATIBLE FOR MathJax component\r\n    toString = (parenthesis = false) => {\r\n        // this.arrangeDots();\r\n        this.simplify(); // simplify current chain that's left from unknown number of operations\r\n        let formula = \"\";\r\n        // if ... + 0 || 0 + ... appears ===>>>>> see below !!\r\n        if (!this.a) return \"0\"; // what if **************************************** 0 / 0\r\n        if (parenthesis) formula += \"(\";\r\n        switch (this.type.toLowerCase()) {\r\n            case \"exp\": {\r\n                // if (this.a < 0) formula += \"(\";\r\n                let a0 = this.a;\r\n                if (a0 < 0) {\r\n                    formula += \"-\";\r\n                    a0 *= -1;\r\n                }\r\n                if (a0 !== 1)\r\n                    if (a0 instanceof Algebra)\r\n                        formula += a0.toString(\r\n                            a0 instanceof Algebra && a0.hasMultiTerms()\r\n                        );\r\n                    else if (a0 instanceof Array)\r\n                        // testTEST\r\n                        formula += Algebra.polynomial(a0, this.symbol);\r\n                    // FOR TEST\r\n                    else formula += strictPrecisionFormat(a0);\r\n                if (this.dot instanceof Algebra)\r\n                    formula += this.dot.toString(\r\n                        this.dot instanceof Algebra && this.dot.hasMultiTerms()\r\n                    );\r\n                if (this.b !== 0) {\r\n                    if (this.a !== 0) {\r\n                        formula += \"e^{\";\r\n                        let e0 = this.b;\r\n                        if (this.b instanceof Algebra)\r\n                            formula += this.b.toString(\r\n                                this.b instanceof Algebra &&\r\n                                    this.b.hasMultiTerms()\r\n                            );\r\n                        else if (this.b instanceof Array)\r\n                            formula += Algebra.polynomial(this.b, this.symbol);\r\n                        else {\r\n                            if (e0 < 0) {\r\n                                formula += \"-\";\r\n                                e0 *= -1;\r\n                            }\r\n                            if (e0 !== 1) formula += e0;\r\n                        }\r\n                        formula += this.symbol + \"}\";\r\n                    }\r\n                    if (this.input) formula += this.input.toString();\r\n                } else {\r\n                    if (a0 !== 1 || !this.dot)\r\n                        formula += strictPrecisionFormat(this.a);\r\n                }\r\n                // if (this.a < 0) formula += \")\";\r\n                if (this.plus) formula += this.join(); // if there's a next term: casscade toString() calls\r\n                break;\r\n            }\r\n            case \"poly\":\r\n                formula += Algebra.polynomial(this.a, this.symbol);\r\n                if (this.dot instanceof Algebra)\r\n                    formula += this.dot.toString(\r\n                        this.dot instanceof Algebra && this.dot.hasMultiTerms()\r\n                    );\r\n                if (this.input) {\r\n                    formula += (parenthesis ? \")\" : \"\") + this.input.toString();\r\n                    parenthesis = false;\r\n                }\r\n                if (this.plus) formula += this.join(); // if there's a next term: casscade toString() calls\r\n                break;\r\n            case \"frac\": {\r\n                if (this.dot instanceof Algebra)\r\n                    formula += this.dot.toString(\r\n                        this.dot instanceof Algebra && this.dot.hasMultiTerms()\r\n                    );\r\n                const numerator = Algebra.polynomial(this.a, this.symbol);\r\n                formula +=\r\n                    numerator !== \"0\"\r\n                        ? \"\\\\frac{\" +\r\n                          numerator +\r\n                          \"}{\" +\r\n                          Algebra.polynomial(this.b, this.symbol) +\r\n                          \"}\"\r\n                        : \"0\";\r\n                if (this.input) formula += this.input.toString();\r\n                if (this.plus) formula += this.join(); // if there's a next term: casscade toString() calls\r\n\r\n                break;\r\n            }\r\n            case \"sin\":\r\n            case \"asin\":\r\n            case \"cos\":\r\n            case \"tan\":\r\n            case \"cot\": {\r\n                // if (this.a < 0) formula += \"(\";\r\n                let a0 = this.a;\r\n                if (a0 < 0) {\r\n                    formula += \"-\";\r\n                    a0 *= -1;\r\n                }\r\n                if (a0 !== 1)\r\n                    if (a0 instanceof Algebra)\r\n                        formula += a0.toString(\r\n                            a0 instanceof Algebra && a0.hasMultiTerms()\r\n                        );\r\n                    else if (a0 instanceof Array)\r\n                        formula += Algebra.polynomial(a0, this.symbol);\r\n                    // FOR TEST\r\n                    else formula += strictPrecisionFormat(a0);\r\n                if (this.a !== 0) {\r\n                    if (this.dot && this.dot instanceof Algebra)\r\n                        formula += this.dot.toString(\r\n                            this.dot instanceof Algebra &&\r\n                                this.dot.hasMultiTerms()\r\n                        );\r\n                    if (this.b !== 0) {\r\n                        formula += this.type;\r\n                        if (this.b instanceof Algebra) {\r\n                            formula += this.b.toString(\r\n                                this.b instanceof Algebra &&\r\n                                    this.b.hasMultiTerms()\r\n                            );\r\n                        } else if (this.b instanceof Array)\r\n                            formula += Algebra.polynomial(this.b, this.symbol);\r\n                        // FOR TEST\r\n                        else {\r\n                            let w0 = this.b;\r\n                            formula += \"(\";\r\n                            if (w0 < 0) {\r\n                                formula += \"-\";\r\n                                w0 *= -1;\r\n                            }\r\n                            if (w0 !== 1) formula += strictPrecisionFormat(w0);\r\n                            formula += this.symbol;\r\n                            if (this.teta instanceof Algebra)\r\n                                formula += this.teta.toString();\r\n                            else if (this.teta) {\r\n                                let e0 = this.teta;\r\n                                if (e0 < 0) {\r\n                                    formula += \" - \";\r\n                                    e0 *= -1;\r\n                                } else formula += \" + \";\r\n                                formula += strictPrecisionFormat(e0);\r\n                            }\r\n                            formula += \")\";\r\n                        }\r\n                        if (this.input) formula += this.input.toString();\r\n                    }\r\n                    // simple num\r\n                } else {\r\n                    if (a0 !== 1 || !this.dot)\r\n                        formula += strictPrecisionFormat(this.a);\r\n                }\r\n                // if (this.a < 0) formula += \")\";\r\n                if (this.plus) formula += this.join(); // if there's a next term: casscade toString() calls\r\n                break;\r\n            }\r\n\r\n            default:\r\n                return null;\r\n        }\r\n        if (parenthesis) formula += \")\";\r\n\r\n        return formula;\r\n    };\r\n    toArray = () => {\r\n        let x = [];\r\n        const params = [\"a\", \"b\", \"teta\", \"symbol\", \"type\"],\r\n            linkers = [\"dot\", \"input\", \"plus\", \"previous\"];\r\n        for (const [key, value] of Object.entries(this)) {\r\n            if (typeof value !== \"function\") {\r\n                if (value) {\r\n                    // maximum toArray call happens\r\n                    if (params.filter((p) => p === key).length)\r\n                        x[key] =\r\n                            value instanceof Algebra ? value.toArray() : value;\r\n                    //)((value instanceof StandardInputSignal ? value.copy() : ));\r\n                    else if (linkers.filter((l) => l === key).length)\r\n                        x[key] =\r\n                            value instanceof StandardInputSignal\r\n                                ? value.copy()\r\n                                : value.toArray();\r\n                }\r\n            }\r\n        }\r\n        return x;\r\n    };\r\n}\r\n\r\nexport default Algebra;\r\n","import { round, strictPrecisionFormat } from \"../calculus\";\r\n\r\nexport default class StandardInputSignal {\r\n    constructor(amplitude = 1, type = \"u\", symbol = \"t\") {\r\n        this.symbol = symbol;\r\n        this.type = type;\r\n        this.amp = round(amplitude);\r\n    }\r\n\r\n    copy = () => new StandardInputSignal(this.amp, this.type, this.symbol);\r\n\r\n    toString = () => {\r\n        let str = \"\",\r\n            a = this.amp;\r\n        if (this.amp === -1) {\r\n            str += \"-\";\r\n            a *= -1;\r\n        }\r\n        if (a !== 1) str += strictPrecisionFormat(a);\r\n        return str + `${this.type}(${this.symbol})`;\r\n    };\r\n\r\n    ampiltude = () => this.amp;\r\n}\r\n"],"names":["Complex","preal","pimage","params","symbol","type","b","hasMultiTerms","plus","a","toString","parenthesis","isZero","rl","formula","Algebra","round","im","getA","setA","join","real","imaginary","copy","linkPrevious","dot","previous","input","conjugate","negation","magnitude$2","magnitude","phase","definiteA","definiteB","Math","atan2","t","$","NaN","isReal","hasSameTypeWith","x","realify","add","operand","Re","Im","substract","equals","isConjugateWith","multiply","push","devide","denominator","result","isNaN","setB","raiseTo","power","floor","i","devideInverse","k","ToCouples","arrComplex","n","length","reals","Array","fill","imaginaries","extract","strNumber","replace","isDigit","Number","slice","sign","img","Fraction","num","den","lim","numerator","Poly","setNumerator","setDenominator","valueAt","degree","powerTerm","derivative","da","expression","filter","ci","map","a_i","atn","aArray","Symbolic","halfTermsVisible","coef","inline","res","NotScalarError","cause","describe","console","log","message","name","code","error_codes","Error","teta","identify","getB","setTeta","getTeta","end","last","first","fst","enddot","firstdot","link","term","sort","position","order","func","isPrior","temp","orders","findIndex","or","unifiable","exp","isUnifiable","sameOnes","item","idx","simplify","polynomial","redundant","label","undefined","index","operator","next","ai","isTriangular","right","y","endTerm","StandardInputSignal","arrangeDots","no","As","zeros","yai","table","product","pop","j","endDotTerm","lastyDot","selfmultiply","ao","laplace","areTheSame","toLowerCase","a0","strictPrecisionFormat","e0","w0","toArray","linkers","key","value","p","l","Object","entries","this","parameter","pi","valueOf","polynomialValueAt","arr","coefy","str","s","coefs","el1","el2","areTheseTwoEqual","p1","p2","amplitude","amp","ampiltude"],"sourceRoot":""}