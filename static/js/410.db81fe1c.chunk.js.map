{"version":3,"file":"static/js/410.db81fe1c.chunk.js","mappings":"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","sources":["math/algebra/functions/exp.js","math/algebra/functions/fraction.js","math/input-signals/signals.js","math/equation/index.js","math/algebra/functions/transfer.js","math/algebra/functions/trigonometric.js"],"sourcesContent":["import Algebra from \"math/algebra\";\nimport Complex from \"math/algebra//complex\";\nimport { Cos, Sin } from \"./trigonometric\";\n\nexport default class Exp extends Algebra {\n    constructor(a, b, symbol = \"t\", params = {}) {\n        // ae^bt\n        super(a, { symbol, type: \"exp\", b, ...params });\n    }\n\n    copy = (linkPrevious = false) =>\n        new Exp(this.a, this.b, this.symbol, {\n            dot: this.dot,\n            plus: this.plus,\n            previous: linkPrevious ? this.previous : null,\n            input: this.input\n        });\n\n    toSin = () => {\n        const exp = this.copy();\n        if (exp.type === \"exp\" && exp.b instanceof Complex) {\n            if (exp.b instanceof Complex && exp.b.real() === 0) {\n                const cos = new Cos(exp.a, exp.b.imaginary());\n                const sin = new Sin(exp.a, -exp.b.imaginary());\n                return new Complex(cos, sin);\n            }\n        }\n        return exp; // if doesnt math the condition then just return exponential function itself\n    };\n\n    valueAt = (t) => {\n        const a = Algebra.valueOf(this.a, t),\n            b = Algebra.valueOf(this.b, t);\n        return a * Math.exp(b * t);\n    }\n}\n","import Algebra from \"math/algebra\";\nimport Poly from \"./poly\";\n\nexport default class Fraction extends Algebra {\n    constructor(num, den = [1], symbol = \"t\", params = {}) {\n        // ke^ct\n        if (!(num instanceof Algebra)) {\n            if (!(num instanceof Array)) num = [num];\n            // this.a\n            else if (num.length === 0) num = [0];\n        }\n        if (!(den instanceof Algebra)) {\n            if (!(den instanceof Array)) den = [den];\n            // this.b\n            else if (den.length === 0) den = [1];\n        }\n        super(num, { symbol, type: \"frac\", b: den, ...params });\n    }\n\n    copy = (linkPrevious = false) =>\n        new Fraction(this.a, this.b, this.symbol, {\n            dot: this.dot,\n            plus: this.plus,\n            previous: linkPrevious ? this.previous : null,\n            input: this.input\n        });\n\n    lim = () => {\n        // for all fractions with all kind of numerator and denominator\n    }\n    \n    numerator = () => new Poly(this.a);\n    denominator = () => new Poly(this.b);\n\n    setNumerator = (num) => {\n        if (!(num instanceof Algebra)) {\n            if (!(num instanceof Array)) num = [num];\n            // this.a\n            else if (num.length === 0) num = [0];\n        }\n        return this.setA(num);\n    }\n\n    setDenominator = (den) => {\n        if (!(den instanceof Algebra)) {\n            if (!(den instanceof Array)) den = [den];\n            // this.b\n            else if (den.length === 0) den = [1];\n        }\n        return this.setB(den);\n    }\n    valueAt = (t) => {\n        const num = Algebra.valueOf(this.a, t);\n        const den = Algebra.valueOf(this.b, t);\n        return num / den;\n    }\n\n}\n","import StandardInputSignal from \"math/input-signals\";\nimport Poly from \"math/algebra/functions/poly\";\n\nexport class Step extends StandardInputSignal {\n    constructor(amplitude = 1, symbol = \"t\") {\n        super(amplitude, \"u\", symbol); // \\\\delta is the equivalent of small delta in mathjax\n    }\n    copy = () => new Step(this.amp, this.symbol);\n\n    $ = (t) => (t >= 0) * this.amp;\n}\n\nexport class Puls extends StandardInputSignal {\n    constructor(Delta = 1, amplitude = 1, symbol = \"t\") {\n        super(amplitude, \"\\\\sqcap\", symbol);\n        this.Delta = Delta;\n    }\n    copy = () => new Puls(this.Delta, this.amp, this.symbol);\n    $ = (t) => (t >= 0 && t <= this.Delta) * this.amp / this.Delta;\n}\n\nexport class Impact extends StandardInputSignal {\n    constructor(amplitude = 1, symbol = \"t\") {\n        super(amplitude, \"\\\\delta\", symbol); // \\\\delta is the equivalent of small delta in mathjax\n    }\n    copy = () => new Impact(this.amp, this.symbol);\n\n    $ = (t) => this.amp * (t === 0);\n}\n\nexport class Ramp extends Poly {\n    constructor(amplitude, symbol = \"t\") {\n        super([amplitude, 0], symbol);\n        this.amplitude = amplitude; // just for calculating the value of this\n        this.selfmultiply(Step());\n    }\n    copy = () => new Ramp(this.amplitude, this.symbol);\n\n    $ = (t) => (t >= 0) * t * this.amplitude;\n}\n\n\nexport class Parabolic extends Poly { //EDIT\n    constructor(amplitude, symbol = \"t\") {\n        super([amplitude, 0, 0], symbol);\n        this.amplitude = amplitude; // just for calculating the value of this\n        this.selfmultiply(Step());\n    }\n    copy = () => new Parabolic(this.amplitude, this.symbol);\n    $ = (t) => (t >= 0 ? t * this.amplitude : 0);\n}\n","import Algebra from \"../algebra/index\";\r\nimport { isDigit, precision, round } from \"math/calculus\";\r\nimport Complex from \"math/algebra/complex\";\r\nimport Poly from \"../algebra/functions/poly\";\r\nimport { ConsoleView } from \"react-device-detect\";\r\nconst Algebrite = require(\"algebrite\");\r\n\r\nexport default class Equation {\r\n    static zeroPrecision = round(10 ** -precision.get());\r\n    constructor(exp, symbol = \"x\") {\r\n        if (exp instanceof Poly) {\r\n            this.expression = exp.expression();\r\n            this.algebra = exp.copy();\r\n            this.symbol = exp.symbol;\r\n            this.degree = exp.degree();\r\n        } else if (exp instanceof Algebra) {\r\n            this.expression = exp.toString();\r\n            this.algebra = exp.copy();\r\n            this.symbol = this.exp.symbol;\r\n            this.degree = undefined; // unknown\r\n        } else if (exp instanceof Array) {\r\n            this.algebra = new Poly(exp);\r\n            this.symbol = symbol;\r\n            this.expression = \"\";\r\n            const n = exp.length - 1;\r\n            this.degree = n;\r\n            for (\r\n                let i = 0;\r\n                i < exp.length;\r\n                this.expression += Equation.GetAlgebriteTerm(\r\n                    n - i,\r\n                    exp[i],\r\n                    i,\r\n                    symbol\r\n                ),\r\n                    i++\r\n            );\r\n        } else if (typeof exp === \"string\") {\r\n            this.expression = exp;\r\n            this.algebra = null;\r\n            this.symbol = symbol;\r\n        }\r\n\r\n        this.symbol = symbol;\r\n    }\r\n\r\n    static GetAlgebriteTerm = (termDegree, coef, index, symbol) => {\r\n        if (coef === +coef) {\r\n            // means that coef is not a string\r\n            const intExpI = coef | 0;\r\n            if (intExpI !== coef) {\r\n                // means that coef is a float number\r\n                Algebrite.run(`a${index} = ${coef}`);\r\n                return (\r\n                    (coef >= 0 ? \"+\" : \"\") +\r\n                    `a${index}*${symbol}^${termDegree}`\r\n                );\r\n            } else\r\n                return (\r\n                    (intExpI >= 0 ? \"+\" : \"\") + `${intExpI}${symbol}^${termDegree}`\r\n                );\r\n        }\r\n        // here it means coef is a string like '11/2' or '1/4', ...\r\n        return `${coef}${symbol}^${termDegree}`;\r\n    };\r\n    roots = () => {\r\n        // for factorable equations use: algebrite.roots\r\n        let x = Algebrite.nroots(this.expression)\r\n            .toString()\r\n            .replaceAll(\"...\", \"\");\r\n        x = x.slice(1, x.length - 1);\r\n        x = x.split(\",\").filter((xi) => xi && xi !== \"\"); // now x is converted from a string to the array of x answers (as Numbers);\r\n        // edit string to array\r\n        return x.map((xi, i) => {\r\n            // let [real, image] = xi.split(/\\+|-/).filter((xi) => xi && xi !== \"\");\r\n            let separatorIndex = 1;\r\n            for (; separatorIndex < xi.length; separatorIndex++)\r\n                if (\r\n                    (xi[separatorIndex] === \"+\" ||\r\n                        xi[separatorIndex] === \"-\") &&\r\n                    isDigit(xi[separatorIndex - 1]) &&\r\n                    isDigit(xi[separatorIndex + 1])\r\n                )\r\n                    break;\r\n\r\n            let terms = [];\r\n            terms.push(xi.slice(0, separatorIndex));\r\n            if (separatorIndex < xi.length)\r\n                terms.push(xi.slice(separatorIndex, xi.length - 2));\r\n\r\n            if (terms.length === 1) {\r\n                const magnitude = terms[0].replace(\"*i\");\r\n                return magnitude === terms[0]\r\n                    ? new Complex(Number(magnitude))\r\n                    : new Complex(0, Number(magnitude));\r\n            } else return new Complex(Number(terms[0]), Number(terms[1]));\r\n        });\r\n    };\r\n\r\n    AlgebraRoots = () => {\r\n        // convert roots returning string to\r\n        if (!this.roots || this.roots.length === 0) this.solve();\r\n    };\r\n\r\n    approximate = (\r\n        method = Equation.Methods.newton,\r\n        N = 10,\r\n        boundary = 1000\r\n    ) => {\r\n        const allRoots = [];\r\n        // newton reaches to approx fast\r\n        // so N = 10 is enough (?????)\r\n        const isUnique = (newRoot) =>\r\n            !isNaN(newRoot) &&\r\n            allRoots.findIndex((rt) =>\r\n                !(rt instanceof Complex) ? rt === newRoot : rt.equals(newRoot)\r\n            ) === -1;\r\n        const isUniqueComplex = (newRoot) =>\r\n            newRoot instanceof Complex &&\r\n            allRoots.findIndex((rt) => newRoot.equals(rt)) === -1;\r\n\r\n        if (this.expression instanceof Algebra) {\r\n            let a0 = 0;\r\n            for (let i = this.expression.a.length - 1; i >= 0; i--)\r\n                if (this.expression.a[i]) {\r\n                    a0 = this.expression.a[i];\r\n                    break;\r\n                }\r\n            const an = this.expression.a[0];\r\n\r\n            if (a0 && an !== 0) boundary = Math.abs(a0 / an);\r\n\r\n            for (let x0 = -boundary; x0 <= boundary; x0++) {\r\n                let x = method(this.algebra, x0, N);\r\n                if (!isNaN(x)) {\r\n                    const rx = round(x);\r\n                    if (isUnique(rx)) allRoots.push(rx);\r\n                }\r\n                x = method(this.algebra, new Complex(0, x0), N);\r\n                if (isUniqueComplex(x)) allRoots.push(x);\r\n            }\r\n        }\r\n        return allRoots;\r\n    };\r\n    // approximation methods\r\n    durandKerner = (N = 20) => {\r\n        if (this.algebra instanceof Algebra) {\r\n            const f = this.algebra.$;\r\n            const n = this.algebra.degree();\r\n            let guess;\r\n            do {\r\n                guess = new Complex(Math.random(), Math.random());\r\n            } while (guess.isReal());\r\n            const roots = Array(n)\r\n                .fill(0)\r\n                .map((_) => []);\r\n\r\n            roots[0].push(new Complex(1, 0));\r\n            for (let i = 1; i < n; i++)\r\n                roots[i][0] = guess.multiply(roots[i - 1][0]);\r\n            for (let iter = 0; iter < N; iter++) {\r\n                for (let i = 0; i < n; i++) {\r\n                    const xiN = roots[i][iter].copy();\r\n                    let sndTermDen = new Complex(1, 0);\r\n                    for (let j = 0; j < n; j++) {\r\n                        if (i !== j) {\r\n                            const xjN = roots[j][roots[j].length - 1];\r\n                            sndTermDen = sndTermDen.multiply(\r\n                                xiN.substract(xjN)\r\n                            );\r\n                        }\r\n                    }\r\n                    let sndTerm = f(xiN).devide(sndTermDen);\r\n                    // USING PUSH MAY SLOW DOWN THE ALGORITHM\r\n                    roots[i].push(xiN.substract(sndTerm));\r\n                }\r\n            }\r\n            return roots.map((r) => r[r.length - 1]);\r\n        }\r\n    };\r\n\r\n    static Methods = {\r\n        // needs work!\r\n        newton: (algebraf, x0 = 0, N = 20) => {\r\n            const f = algebraf.$;\r\n            const df = algebraf.derivative().$;\r\n            const xs = Array(N + 1).fill(0);\r\n            const dfx0 = df(x0);\r\n            if (dfx0 && (!(dfx0 instanceof Complex) || !dfx0.isZero())) {\r\n                if (x0 instanceof Complex) {\r\n                    xs[0] = x0;\r\n                    for (let i = 0; i < N; i++) {\r\n                        // const dfxsi = df(xs[i]);\r\n                        // console.log(\"xs[i] = \", xs[i].toString(), \"=> f(x) = \", f(xs[i]).toString(), \"=> df =\", dfxsi.toString(), \"res = \", f(xs[i]).devide(df(xs[i])))\r\n                        xs[i + 1] = xs[i].substract(f(xs[i]).devide(df(xs[i])));\r\n                    }\r\n\r\n                    const fx = f(xs[N]);\r\n                    if (\r\n                        Math.abs(fx.real()) > Equation.zeroPrecision ||\r\n                        Math.abs(fx.imaginary()) > Equation.zeroPrecision\r\n                    )\r\n                        return NaN;\r\n                } else {\r\n                    xs[0] = x0;\r\n\r\n                    for (let i = 0; i < N; i++) {\r\n                        xs[i + 1] = xs[i] - f(xs[i]) / df(xs[i]);\r\n                    }\r\n\r\n                    if (f(xs[N]) > Equation.zeroPrecision) return NaN;\r\n                }\r\n                //integrity check!\r\n                return xs[xs.length - 1];\r\n            }\r\n            return NaN;\r\n        },\r\n        // needs work!\r\n        middlePoint: (\r\n            f,\r\n            boundary = 1000\r\n            // decimalPrecision = precision.get()\r\n        ) => {\r\n            // NOTE: works fine for some equations\r\n            // and wronge for some others like:  x ** 2 - 4*x  - 5\r\n            boundary = Math.abs(boundary);\r\n            const expectedRate = Equation.zeroPrecision;\r\n            const poles = [];\r\n            let xa = 0,\r\n                xb = 1;\r\n            for (let i = 0; i < boundary; i++) {\r\n                xa = -boundary + i;\r\n                xb = boundary - i;\r\n\r\n                let rate =\r\n                    (xb - xa) / (2 * Math.max(Math.abs(xa), Math.abs(xb)));\r\n                let p = null;\r\n                while (rate >= expectedRate) {\r\n                    p = (xa + xb) / 2;\r\n                    if (!f(p)) break;\r\n                    else if (f(p) * f(xa) < 0) xb = p;\r\n                    else {\r\n                        xa = p;\r\n                        rate =\r\n                            (xb - xa) /\r\n                            (2 * Math.max(Math.abs(xa), Math.abs(xb)));\r\n                    }\r\n                }\r\n                if (!f(p)) poles.push(round(p));\r\n            }\r\n            return new Set(poles);\r\n        },\r\n    };\r\n}\r\n","import Algebra from \"../index\";\nimport Complex from \"../complex\";\nimport Exp from \"./exp\";\nimport Fraction from \"./fraction\";\nimport { Step } from \"math/input-signals/signals\";\nimport Poly from \"./poly\";\nimport { Cos, Sin } from \"./trigonometric\";\nimport { round } from \"math/calculus/index\";\nimport Equation from \"math/equation\";\n\nexport default class TransferFunction extends Fraction {\n    static Specials = {\n        $1: (k, a) =>\n            new TransferFunction([k], [1, -a]).setRoots([], [a]).setOrder(1),\n        $2: (k, a, b = a instanceof Complex ? a.conjugate : a) => {\n            // k / (s + a)(s + b) => must be converted to => k / (s2 + 2(a+b)s + ab)\n            let aplusb =\n                a instanceof Algebra\n                    ? a.add(b)\n                    : b instanceof Algebra\n                    ? b.add(a)\n                    : b + a;\n            let ab =\n                a instanceof Algebra\n                    ? a.multiply(b)\n                    : b instanceof Algebra\n                    ? b.multiply(a)\n                    : b * a;\n            if (aplusb instanceof Complex && aplusb.isReal())\n                aplusb = aplusb.real();\n            if (ab instanceof Complex && ab.isReal()) ab = ab.real();\n\n            return new TransferFunction(\n                [k],\n                [1, aplusb instanceof Algebra ? aplusb.negation() : -aplusb, ab]\n            )\n                .setRoots([], [a, b])\n                .setOrder(2);\n        },\n        $WnZ: (w_n, zeta) => new TransferFunction(null, null, { w_n, zeta }),\n        $design: (t_rise, overshoot) =>\n            new TransferFunction(null, null, { overshoot, t_rise }),\n    };\n\n    static omegaZetaPoles = (w_n, zeta) => {\n        if (Math.abs(zeta) >= 1) {\n            const alpha = -zeta * w_n;\n            const beta = w_n * (zeta * zeta - 1) ** 0.5;\n            return [alpha + beta, alpha - beta];\n        }\n        const alpha = -zeta * w_n;\n        const beta = w_n * (1 - zeta * zeta) ** 0.5;\n        return [new Complex(alpha, beta), new Complex(alpha, -beta)];\n    };\n    constructor(numerator, denominator, params = {}) {\n        let zeros = [],\n            poles = [];\n        if (params) {\n            if (params.overshoot && params.t_rise) {\n                params.overshoot = Number(params.overshoot);\n                params.t_rise = Number(params.t_rise);\n                const logMp = Math.log(params.overshoot);\n                params.zeta =\n                    -logMp / (Math.PI * Math.PI + logMp * logMp) ** 0.5;\n                params.w_d = Math.PI / params.t_rise;\n                params.w_n =\n                    params.w_d / (1 - params.zeta * params.zeta) ** 0.5;\n            }\n\n            if (params.w_n) {\n                params.w_n = Number(params.w_n);\n                params.zeta = Number(params.zeta);\n                // if the user sends w_n params it will override the given zero/pole list\n                const { w_n, zeta } = params;\n                const wn2 = w_n * w_n;\n                numerator = wn2;\n                denominator = [1, 2 * zeta * w_n, wn2];\n                poles = TransferFunction.omegaZetaPoles(w_n, zeta);\n                zeros = [];\n            }\n        }\n        super(numerator, denominator, \"s\", params);\n        // SIMPL;IFY\n        this.poles = [...poles]; //edit solve equations\n        this.zeros = [...zeros];\n        if (!this.a instanceof Array) this.a = [this.a];\n        if (this.a.length === 1 && !this.w_n) {\n            if (\n                this.b.length === 3 &&\n                this.b[this.b.length - 1] === this.a[0]\n            ) {\n                this.w_n = this.a[0];\n                this.zeta = this.b[1] / (2 * this.w_n);\n                this.timeConstant = round(1 / (this.zeta * this.w_n));\n                this.t_settle = 4 * this.timeConstant;\n                if (params && params.w_d) this.w_d = params.w_d;\n                else if (this.zeta >= -1 && this.zeta <= 1)\n                    this.w_d = this.w_n * (1 - this.zeta ** 2) ** 0.5;\n                this.order = 2;\n                this.setRoots(\n                    [],\n                    TransferFunction.omegaZetaPoles(this.w_n, this.zeta)\n                );\n            }\n        }\n        if (!this.order)\n            this.order =\n                denominator instanceof Array ? denominator.length - 1 : 1;\n        if (params.overshoot && params.t_rise) {\n            [this.overshoot, this.t_rise] = [params.overshoot, params.t_rise];\n        } else {\n            const dampingCharasteristics =\n                this.getDampingSystemCharasteristics();\n            if (dampingCharasteristics) {\n                this.overshoot = dampingCharasteristics.overshoot;\n                this.t_rise = dampingCharasteristics.t_rise;\n            }\n        }\n    }\n    static sortRoots = (rt) =>\n        rt.sort((ri, rj) =>\n            ri instanceof Algebra\n                ? ri.substract(rj)\n                : rj instanceof Algebra\n                ? rj.substract(ri)\n                : Math.abs(ri) - Math.abs(rj)\n        );\n    roots = () => [this.zeros, this.poles];\n    setRoots = (zeros, poles) => {\n        this.poles = poles.map((pi) =>\n            pi instanceof Complex && pi.isReal() ? pi.real() : pi\n        );\n        this.zeros = zeros.map((zi) =>\n            zi instanceof Complex && zi.isReal() ? zi.real() : zi\n        );\n        return this;\n    };\n\n    getDampingSystemCharasteristics = () =>\n        this.w_d\n            ? {\n                  t_rise: round(Math.PI / this.w_d),\n                  // WHAT IF W_D === 0?\n                  overshoot:\n                      this.zeta >= -1 && this.zeta <= 1\n                          ? round(\n                                100 *\n                                    Math.exp(\n                                        -(this.zeta * Math.PI) /\n                                            (1 - this.zeta ** 2) ** 0.5\n                                    )\n                            )\n                          : null,\n              }\n            : null;\n\n    getOrder = () => this.order;\n    setOrder = (order) => {\n        this.order = order;\n        return this;\n    };\n    getPoles = () => this.poles;\n    setPoles = (poles) => {\n        this.poles = TransferFunction.sortRoots(poles).map((pi) =>\n            pi instanceof Complex && pi.isReal() ? pi.real() : pi\n        );\n        return this;\n    };\n    getZeros = () => this.zeros;\n    setZeros = (zeros) => {\n        this.zeros = zeros.map((pi) =>\n            pi instanceof Complex && pi.isReal() ? pi.real() : pi\n        );\n        return this;\n    };\n\n    poleOrder = (pole) =>\n        this.poles.filter((pi) => Algebra.areTheseTwoEqual(pole, pi)).length;\n\n    laplace = () => this.copy(); // actually it has no laplace, this is for disfunctioning the laplace method in the parent class Algebra\n    laplaceInverse = () => {\n        const m = this.zeros.length - 1; // number of zeros\n        const n = this.poles.length - 1; // number of poles\n\n        if (m === 0) {\n            switch (n) {\n                case 2:\n                    return null;\n                case 1:\n                    return new Algebra(1, { type: \"exp\" }); //EDITTTTTTTTTTTTTTTT\n                case 0:\n                    return null; //u(t)\n                default:\n                    return null; //DEFINE AN UNKNOWN FUNCTION FOR CASE LIKE THIS\n            }\n        }\n    };\n    step = (inTimeDomain = true) => {\n        // normally will automatically return the time domain answer\n        // unless inLaplaceDomain is true\n        if (inTimeDomain) {\n            const m = this.zeros.length; // number of zeros\n            const n = this.poles.length; // number of poles\n            const nreal = this.poles.filter(\n                (pi) => !(pi instanceof Complex)\n            ).length; // number of real poles; can be eigher 2 or 0\n            if (m === 0) {\n                const k = this.numerator();\n                if (n === 0) {\n                    // return u(t)\n                    // DEFINE U(T) IN ALGEBRA\n                }\n                if (n === 1) {\n                } else if (n === 2) {\n                    const a = -this.poles[0],\n                        b = -this.poles[1];\n                    if (nreal === 2) {\n                        // if (a > 0 && b > 0) {\n                        if (a !== b)\n                            // two independent polesdddd\n                            // two negative independent poles\n                            return new Exp(1 / a, -a)\n                                .add(new Exp(-1 / b, -b))\n                                .multiply(k / (a - b))\n                                .multiply(new Step())\n                                .add(new Step(k / (a * b)));\n                        else {\n                            const a2 = a * a;\n                            return new Exp(-k / a2, -a)\n                                .multiply(new Poly([a, 1]))\n                                .multiply(new Step())\n                                .add(new Step(k / a2));\n                        }\n                        // } else {\n                        //     // repetetive poles\n                        // }\n                    } else if (nreal === 0) {\n                        // two conjugated complex poles\n                        //UNDERSHOOT BUG FIXLAYS HERE\n                        const a = -this.poles[0].real(),\n                            b = this.poles[0].imaginary();\n                        const ka2b2 = k / (a ** 2 + b ** 2);\n                        // FIND BUUUUUUG\n                        // return new Exp(-ka2b2, -a)\n                        //     .multiply(new Cos(1, b).add(new Sin(a / b, b)))\n                        //     .multiply(new Step())\n                        //     .add(new Step(ka2b2));\n                        return new Exp(-ka2b2, -a)\n                            .multiply(new Cos(1, b))\n                            .add(\n                                new Exp(-ka2b2, -a).multiply(new Sin(a / b, b))\n                            )\n                            .multiply(new Step())\n                            .add(new Step(ka2b2));\n                    }\n                    // else if( nreal == 1) // this cant happen, but what if sth went wrong?\n                }\n            }\n        } else {\n            const lstep = this.copy();\n            const poles = lstep.getPoles();\n            poles.push(0);\n            lstep.getB().push(0); //update denominator\n            lstep.setPoles(poles).setDenominator(lstep.getB());\n            return lstep;\n        }\n    };\n    copy = (linkPrevious = false) =>\n        new TransferFunction(this.a, this.b, {\n            overshoot: this.overshoot,\n            t_rise: this.t_rise,\n            t_settle: this.t_settle,\n            w_d: this.w_d,\n            timeConstant: this.timeConstant,\n            w_n: this.w_n,\n            zeta: this.zeta,\n            dot: this.dot,\n            plus: this.plus,\n            previous: linkPrevious ? this.previous : null,\n            input: this.input,\n        }).setRoots(this.zeros, this.poles);\n\n    lim = (s0) => {\n        let num, den;\n        // for simple polynomial numerator and denominator fractions\n        // IMPLEMENT HOPITAL AS WELL?\n        if (!s0) {\n            // s -> 0)\n\n            num = { a: 0, sp: this.a.length - 1 };\n            den = { b: 1, sp: this.b.length - 1 };\n            for (; num.sp > 0 && this.a[num.sp] === 0; num.sp--);\n            num.a = this.a[num.sp];\n            for (; den.sp > 0 && this.b[den.sp] === 0; den.sp--);\n            den.b = this.b[den.sp];\n            num.sp = this.a.length - num.sp - 1;\n            den.sp = this.b.length - den.sp - 1;\n            if (num.sp === den.sp) return num.a / den.b;\n            else {\n                const sMinPower = Math.min(den.sp, num.sp);\n                if (sMinPower) {\n                    num.sp -= sMinPower;\n                    den.sp -= sMinPower;\n                }\n                // now one of num.sp or den.sp is zero\n                if (den.sp)\n                    // zero on denominator\n                    return Infinity;\n                // if den.sp == 0 and num.sp != 0\n                return 0;\n            }\n        } else if (s0 === Infinity) {\n            // s -> infinity\n            num = { a: 0, sp: 0 };\n            den = { b: 1, sp: 0 };\n            for (; num.sp < this.a.length && this.a[num.sp] === 0; num.sp++);\n            num.a = this.a[num.sp];\n            for (; den.sp < this.b.length && this.b[den.sp] === 0; den.sp++);\n            den.b = this.b[den.sp];\n            num.sp = this.a.length - num.sp - 1;\n            den.sp = this.b.length - den.sp - 1;\n            if (num.sp === den.sp) return num.a / den.b;\n            // else\n            const sMinPower = Math.min(den.sp, num.sp);\n            if (sMinPower) {\n                num.sp -= sMinPower;\n                den.sp -= sMinPower;\n            }\n            // now one of num.sp or den.sp is zero\n            if (den.sp)\n                // zero on denominator\n                return 0;\n            // if den.sp == 0 and num.sp != 0\n            return Infinity;\n        } else {\n            // if s0 is just a no-zero limited number\n            num = this.numerator().$(s0);\n            den = this.denominator().$(s0);\n            if (den)\n                // simple non zero denominator limit\n                return num / den;\n            // if den == 0\n            // use Hopital or other limit methods\n            //return (num.a * (s0 ** num.sp)) / (den.b * (s0 ** den.sp));\n        }\n    };\n    errors = () => {\n        const sGs = this.multiply(new Poly([1, 0], \"s\"));\n        const s2Gs = sGs.multiply(new Poly([1, 0], \"s\"));\n        console.log(sGs);\n        return {\n            Ks: round(this.lim(0)),\n            Kr: round(sGs.lim(0)),\n            Ka: round(s2Gs.lim(0)),\n        };\n    };\n    $ = (t) => this.laplaceInverse().$(t); // valueOf function in certain point; I used character $ in many places as,\n    // acronym for \"set\" in setters, so $ here means that set the t ( or x or whatever) with a certain point\n\n    rootLocus = (k_min, k_max, N = 100) => {\n        // return root locus values for plotting\n        /* let dk = (k_max - k_min) / N; //time step size\n        while (dk >= 1) {\n            N *= 10;\n            dk = (k_max - k_min) / N; //time step size\n        }*/\n        // TEMPORARY:\n        let dk = 0.05;\n        const a = this.getA(), // numerator\n            b = this.getB(); // denominator => a / b\n        const na = a.length - 1,\n            nb = b.length - 1;\n        const reals = [],\n            imaginaries = [];\n\n        const newTerm = Equation.GetAlgebriteTerm;\n\n        for (let k = k_min; k <= k_max; k += dk) {\n            // in this piece: using short form codes and using objects is set to minimum\n            // because root locus is time consuming and putting all the codes in one main loop is better\n            // const delta = b.add(a.multiply(k));\n            let delta = null,\n                expression = \"\";\n            // USE ARRAY DIRECT PROCESS FOR FASTER RESPONSE\n            // NUM + K * DEN\n            if (na <= nb) {\n                delta = Array(nb);\n                const offsetB = nb - na;\n                for (\n                    let i = 0;\n                    i < offsetB;\n                    delta[i] = b[i],\n                        expression += newTerm(\n                            nb - i,\n                            delta[i],\n                            i,\n                            this.symbol\n                        ),\n                        i++\n                );\n                for (\n                    let i = 0, ib = offsetB;\n                    i <= na;\n                    delta[ib] = b[ib] + k * a[i],\n                        expression += newTerm(\n                            na - i,\n                            delta[ib],\n                            ib,\n                            this.symbol\n                        ),\n                        i++,\n                        ib++\n                );\n            } else {\n                delta = Array(na);\n                const offsetA = na - nb;\n                for (\n                    let i = 0;\n                    i < offsetA;\n                    delta[i] = b[i],\n                        expression += newTerm(\n                            na - i,\n                            delta[i],\n                            i,\n                            this.symbol\n                        ),\n                        i++\n                );\n                for (\n                    let i = 0, ib = offsetA;\n                    i <= nb;\n                    delta[ib] = b[ib] + k * a[i],\n                        expression += newTerm(\n                            nb - i,\n                            delta[ib],\n                            ib,\n                            this.symbol\n                        ),\n                        i++,\n                        ib++\n                );\n            }\n            // const roots = new Equation(new Poly(delta)).roots();\n            const roots = new Equation(expression).roots();\n\n            for (let i = 0; i < roots.length; i++) {\n                if (roots[i] instanceof Complex) {\n                    reals.push(roots[i].real());\n                    imaginaries.push(roots[i].imaginary());\n                } else {\n                    reals.push(roots[i]);\n                    imaginaries.push(0);\n                }\n            }\n        }\n        return [reals, imaginaries];\n    };\n}\n","import Algebra from \"math/algebra\";\nimport Complex from \"math/algebra/complex\";\nimport Exp from \"./exp\";\nimport Fraction from \"./fraction\";\n\nexport class Sin extends Algebra {\n    constructor(A, w, teta = 0, symbol = \"t\", params = {}) {\n        // Ae^wt\n        super(A, { symbol, type: \"sin\", b: w, teta, ...params });\n    }\n    copy = (linkPrevious = false) =>\n        new Sin(this.a, this.b, this.teta, this.symbol, {\n            dot: this.dot,\n            plus: this.plus,\n            previous: linkPrevious ? this.previous : null,\n            input: this.input,\n        });\n\n    toExp = () => {\n        const sin = this.copy();\n        const exp1 = new Exp(sin.a / 2, new Complex(0, -sin.b));\n        const exp2 = new Exp(-sin.a / 2, new Complex(0, sin.b));\n        return new Complex(0, exp1.add(exp2));\n    };\n\n    valueAt = (t) => {\n        const A = Algebra.valueOf(this.a, t);\n        const w = Algebra.valueOf(this.b, t);\n        const teta = Algebra.valueOf(this.teta, t);\n        return A * Math.sin(w * t + teta)\n    }\n}\n\nexport class Cos extends Algebra {\n    constructor(A, w, teta = 0, symbol = \"t\", params = {}) {\n        // Ae^wt\n        super(A, { symbol, type: \"cos\", b: w, teta, ...params });\n    }\n    copy = (linkPrevious = false) =>\n        new Cos(this.a, this.b, this.teta, this.symbol, {\n            dot: this.dot,\n            plus: this.plus,\n            previous: linkPrevious ? this.previous : null,\n            input: this.input,\n        });\n\n    toExp = () => {\n        const cos = this.copy();\n        const exp1 = new Exp(cos.a / 2, new Complex(0, cos.b));\n        const exp2 = new Exp(cos.a / 2, new Complex(0, -cos.b));\n        return exp1.add(exp2);\n    };\n\n\n    valueAt = (t) => {\n        const A = Algebra.valueOf(this.a, t);\n        const w = Algebra.valueOf(this.b, t);\n        const teta = Algebra.valueOf(this.teta, t);\n        return A * Math.cos(w * t + teta)\n    }\n}\n\nexport class Tan extends Algebra {\n    constructor(A, w, teta = 0, symbol = \"t\", params = {}) {\n        // Ae^wt\n        super(A, { symbol, type: \"tan\", b: w, teta, ...params });\n    }\n    copy = (linkPrevious = false) =>\n        new Tan(this.a, this.b, this.teta, this.symbol, {\n            dot: this.dot,\n            plus: this.plus,\n            previous: linkPrevious ? this.previous : null,\n            input: this.input,\n        });\n\n    toExp = () => {\n        const tan = this.copy();\n        const exp1 = new Exp(1, new Complex(0, -tan.b));\n        const numeratorExp2 = new Exp(-1, new Complex(0, tan.b));\n        const denominatorExp2 = new Exp(1, new Complex(0, tan.b));\n        return new Fraction(exp1.add(numeratorExp2), exp1.add(denominatorExp2));\n    };\n\n    valueAt = (t) => {\n        const A = Algebra.valueOf(this.a, t);\n        const w = Algebra.valueOf(this.b, t);\n        const teta = Algebra.valueOf(this.teta, t);\n        return A * Math.tan(w * t + teta)\n    }\n}\n\nexport class Cot extends Algebra {\n    constructor(A, w, teta = 0, symbol = \"t\", params = {}) {\n        // Ae^wt\n        super(A, { symbol, type: \"cot\", b: w, teta, ...params });\n    }\n    copy = (linkPrevious = false) =>\n        new Cot(this.a, this.b, this.teta, this.symbol, {\n            dot: this.dot,\n            plus: this.plus,\n            previous: linkPrevious ? this.previous : null,\n            input: this.input,\n        });\n    toExp = () => {\n        const cot = this.copy();\n        const exp1 = new Exp(1, new Complex(0, -cot.b));\n        const numeratorExp2 = new Exp(-1, new Complex(0, cot.b));\n        const denominatorExp2 = new Exp(1, new Complex(0, cot.b));\n        return new Fraction(exp1.add(denominatorExp2), exp1.add(numeratorExp2));\n    };\n\n\n    valueAt = (t) => {\n        const A = Algebra.valueOf(this.a, t);\n        const w = Algebra.valueOf(this.b, t);\n        const teta = Algebra.valueOf(this.teta, t);\n        return A * Math.cot(w * t + teta)\n    }\n}\n"],"names":["Exp","a","b","symbol","params","type","copy","linkPrevious","dot","plus","previous","input","toSin","exp","Complex","real","cos","Cos","imaginary","sin","Sin","valueAt","t","Algebra","Math","Fraction","num","den","Array","length","lim","numerator","Poly","denominator","setNumerator","setA","setDenominator","setB","Step","amplitude","amp","$","StandardInputSignal","Algebrite","require","Equation","roots","x","nroots","expression","toString","replaceAll","slice","split","filter","xi","map","i","separatorIndex","isDigit","terms","push","magnitude","replace","Number","AlgebraRoots","solve","approximate","method","Methods","newton","N","boundary","allRoots","isUnique","newRoot","isNaN","findIndex","rt","equals","isUniqueComplex","a0","an","abs","x0","algebra","rx","round","durandKerner","guess","f","n","degree","random","isReal","fill","_","multiply","iter","xiN","sndTermDen","j","xjN","substract","sndTerm","devide","r","this","undefined","GetAlgebriteTerm","zeroPrecision","precision","termDegree","coef","index","intExpI","run","algebraf","df","derivative","xs","dfx0","isZero","fx","NaN","middlePoint","expectedRate","poles","xa","xb","rate","max","p","Set","TransferFunction","zeros","overshoot","t_rise","logMp","log","zeta","PI","w_d","w_n","wn2","omegaZetaPoles","setRoots","pi","zi","getDampingSystemCharasteristics","getOrder","order","setOrder","getPoles","setPoles","sortRoots","getZeros","setZeros","poleOrder","pole","laplace","laplaceInverse","m","step","inTimeDomain","lstep","getB","nreal","k","add","a2","ka2b2","t_settle","timeConstant","s0","sp","sMinPower","min","Infinity","errors","sGs","s2Gs","console","Ks","Kr","Ka","rootLocus","k_min","k_max","dk","getA","na","nb","reals","imaginaries","newTerm","delta","offsetB","ib","offsetA","dampingCharasteristics","Specials","$1","$2","conjugate","aplusb","ab","negation","$WnZ","$design","alpha","beta","sort","ri","rj","A","w","teta","toExp","exp1","exp2"],"sourceRoot":""}