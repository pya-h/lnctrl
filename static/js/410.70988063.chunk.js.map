{"version":3,"file":"static/js/410.70988063.chunk.js","mappings":"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","sources":["math/algebra/functions/exp.js","math/algebra/functions/fraction.js","math/input-signals/signals.js","math/equation/index.js","math/algebra/functions/transfer.js","math/algebra/functions/trigonometric.js"],"sourcesContent":["import Algebra from \"math/algebra\";\nimport Complex from \"math/algebra//complex\";\nimport { Cos, Sin } from \"./trigonometric\";\n\nexport default class Exp extends Algebra {\n    constructor(a, b, symbol = \"t\", params = {}) {\n        // ae^bt\n        super(a, { symbol, type: \"exp\", b, ...params });\n    }\n\n    copy = (linkPrevious = false) =>\n        new Exp(this.a, this.b, this.symbol, {\n            dot: this.dot,\n            plus: this.plus,\n            previous: linkPrevious ? this.previous : null,\n            input: this.input\n        });\n\n    toSin = () => {\n        const exp = this.copy();\n        if (exp.type === \"exp\" && exp.b instanceof Complex) {\n            if (exp.b instanceof Complex && exp.b.real() === 0) {\n                const cos = new Cos(exp.a, exp.b.imaginary());\n                const sin = new Sin(exp.a, -exp.b.imaginary());\n                return new Complex(cos, sin);\n            }\n        }\n        return exp; // if doesnt math the condition then just return exponential function itself\n    };\n\n    valueAt = (t) => {\n        const a = Algebra.valueOf(this.a, t),\n            b = Algebra.valueOf(this.b, t);\n        return a * Math.exp(b * t);\n    }\n}\n","import Algebra from \"math/algebra\";\nimport Poly from \"./poly\";\n\nexport default class Fraction extends Algebra {\n    constructor(num, den = [1], symbol = \"t\", params = {}) {\n        // ke^ct\n        if (!(num instanceof Algebra)) {\n            if (!(num instanceof Array)) num = [num];\n            // this.a\n            else if (num.length === 0) num = [0];\n        }\n        if (!(den instanceof Algebra)) {\n            if (!(den instanceof Array)) den = [den];\n            // this.b\n            else if (den.length === 0) den = [1];\n        }\n        super(num, { symbol, type: \"frac\", b: den, ...params });\n    }\n\n    copy = (linkPrevious = false) =>\n        new Fraction(this.a, this.b, this.symbol, {\n            dot: this.dot,\n            plus: this.plus,\n            previous: linkPrevious ? this.previous : null,\n            input: this.input\n        });\n\n    lim = () => {\n        // for all fractions with all kind of numerator and denominator\n    }\n    \n    numerator = () => new Poly(this.a);\n    denominator = () => new Poly(this.b);\n\n    setNumerator = (num) => {\n        if (!(num instanceof Algebra)) {\n            if (!(num instanceof Array)) num = [num];\n            // this.a\n            else if (num.length === 0) num = [0];\n        }\n        return this.setA(num);\n    }\n\n    setDenominator = (den) => {\n        if (!(den instanceof Algebra)) {\n            if (!(den instanceof Array)) den = [den];\n            // this.b\n            else if (den.length === 0) den = [1];\n        }\n        return this.setB(den);\n    }\n    valueAt = (t) => {\n        const num = Algebra.valueOf(this.a, t);\n        const den = Algebra.valueOf(this.b, t);\n        return num / den;\n    }\n\n}\n","import StandardInputSignal from \"math/input-signals\";\nimport Poly from \"math/algebra/functions/poly\";\n\nexport class Step extends StandardInputSignal {\n    constructor(amplitude = 1, symbol = \"t\") {\n        super(amplitude, \"u\", symbol); // \\\\delta is the equivalent of small delta in mathjax\n    }\n    copy = () => new Step(this.amp, this.symbol);\n\n    $ = (t) => (t >= 0) * this.amp;\n}\n\nexport class Puls extends StandardInputSignal {\n    constructor(Delta = 1, amplitude = 1, symbol = \"t\") {\n        super(amplitude, \"\\\\sqcap\", symbol);\n        this.Delta = Delta;\n    }\n    copy = () => new Puls(this.Delta, this.amp, this.symbol);\n    $ = (t) => (t >= 0 && t <= this.Delta) * this.amp / this.Delta;\n}\n\nexport class Impact extends StandardInputSignal {\n    constructor(amplitude = 1, symbol = \"t\") {\n        super(amplitude, \"\\\\delta\", symbol); // \\\\delta is the equivalent of small delta in mathjax\n    }\n    copy = () => new Impact(this.amp, this.symbol);\n\n    $ = (t) => this.amp * (t === 0);\n}\n\nexport class Ramp extends Poly {\n    constructor(amplitude, symbol = \"t\") {\n        super([amplitude, 0], symbol);\n        this.amplitude = amplitude; // just for calculating the value of this\n        this.selfmultiply(Step());\n    }\n    copy = () => new Ramp(this.amplitude, this.symbol);\n\n    $ = (t) => (t >= 0) * t * this.amplitude;\n}\n\n\nexport class Parabolic extends Poly { //EDIT\n    constructor(amplitude, symbol = \"t\") {\n        super([amplitude, 0, 0], symbol);\n        this.amplitude = amplitude; // just for calculating the value of this\n        this.selfmultiply(Step());\n    }\n    copy = () => new Parabolic(this.amplitude, this.symbol);\n    $ = (t) => (t >= 0 ? t * this.amplitude : 0);\n}\n","import Algebra from \"../algebra/index\";\r\nimport { isDigit, precision, round } from \"math/calculus\";\r\nimport Complex from \"math/algebra/complex\";\r\nimport Poly from \"../algebra/functions/poly\";\r\nconst Algebrite = require(\"algebrite\");\r\n\r\nexport default class Equation {\r\n    static zeroPrecision = round(10 ** -precision.get());\r\n    constructor(exp, symbol = null) {\r\n        if (exp instanceof Poly) {\r\n            this.expression = exp.expression();\r\n            this.symbol = exp.symbol;\r\n        } else if (exp instanceof Algebra) {\r\n            this.exp = exp.toString();\r\n            this.symbol = this.exp.symbol;\r\n        } else if (typeof exp === \"string\") {\r\n            this.exp = exp;\r\n        }\r\n\r\n        this.symbol = symbol;\r\n    }\r\n\r\n    roots = () => {\r\n        // for factorable equations use: algebrite.roots\r\n        let x = Algebrite.nroots(this.expression)\r\n            .toString()\r\n            .replaceAll(\"...\", \"\");\r\n        x = x.slice(1, x.length - 1);\r\n        x = x.split(\",\").filter((xi) => xi && xi !== \"\"); // now x is converted from a string to the array of x answers (as Numbers);\r\n        // edit string to array\r\n        return x.map((xi, i) => {\r\n            // let [real, image] = xi.split(/\\+|-/).filter((xi) => xi && xi !== \"\");\r\n            let separatorIndex = 1;\r\n            for (; separatorIndex < xi.length; separatorIndex++)\r\n                if (\r\n                    (xi[separatorIndex] === \"+\" ||\r\n                        xi[separatorIndex] === \"-\") &&\r\n                    isDigit(xi[separatorIndex - 1]) &&\r\n                    isDigit(xi[separatorIndex + 1])\r\n                )\r\n                    break;\r\n\r\n            let terms = [];\r\n            terms.push(xi.slice(0, separatorIndex));\r\n            if (separatorIndex < xi.length)\r\n                terms.push(xi.slice(separatorIndex, xi.length - 2));\r\n\r\n            if (terms.length === 1) {\r\n                const magnitude = terms[0].replace(\"*i\");\r\n                return magnitude === terms[0]\r\n                    ? new Complex(Number(magnitude))\r\n                    : new Complex(0, Number(magnitude));\r\n            } else return new Complex(Number(terms[0]), Number(terms[1]));\r\n        });\r\n    };\r\n\r\n    AlgebraRoots = () => {\r\n        // convert roots returning string to\r\n        if (!this.roots || this.roots.length === 0) this.solve();\r\n    };\r\n\r\n    approximate = (\r\n        method = Equation.Methods.durandKerner,\r\n        N = 10,\r\n        boundary = 1000\r\n    ) => {\r\n        const allRoots = [];\r\n        // newton reaches to approx fast\r\n        // so N = 10 is enough (?????)\r\n        const isUnique = (newRoot) =>\r\n            !isNaN(newRoot) &&\r\n            allRoots.findIndex((rt) =>\r\n                !(rt instanceof Complex) ? rt === newRoot : rt.equals(newRoot)\r\n            ) === -1;\r\n        const isUniqueComplex = (newRoot) =>\r\n            newRoot instanceof Complex &&\r\n            allRoots.findIndex((rt) => newRoot.equals(rt)) === -1;\r\n\r\n        if (this.expression instanceof Algebra) {\r\n            let a0 = 0;\r\n            for (let i = this.expression.a.length - 1; i >= 0; i--)\r\n                if (this.expression.a[i]) {\r\n                    a0 = this.expression.a[i];\r\n                    break;\r\n                }\r\n            const an = this.expression.a[0];\r\n\r\n            if (a0 && an !== 0) boundary = Math.abs(a0 / an);\r\n\r\n            for (let x0 = -boundary; x0 <= boundary; x0++) {\r\n                let x = method(this.expression, x0, N);\r\n                if (!isNaN(x)) {\r\n                    const rx = round(x);\r\n                    if (isUnique(rx)) allRoots.push(rx);\r\n                }\r\n                x = method(this.expression, new Complex(0, x0), N);\r\n                if (isUniqueComplex(x)) allRoots.push(x);\r\n            }\r\n        }\r\n        return allRoots;\r\n    };\r\n    // approximation methods\r\n    static Methods = {\r\n        // needs work!\r\n        newton: (polyf, x0 = 0, N = 20) => {\r\n            const f = polyf.$;\r\n            const df = polyf.derivative().$;\r\n            const xs = Array(N + 1).fill(0);\r\n            const dfx0 = df(x0);\r\n            if (dfx0 && (!(dfx0 instanceof Complex) || !dfx0.isZero())) {\r\n                if (x0 instanceof Complex) {\r\n                    xs[0] = x0;\r\n                    for (let i = 0; i < N; i++) {\r\n                        // const dfxsi = df(xs[i]);\r\n                        // console.log(\"xs[i] = \", xs[i].toString(), \"=> f(x) = \", f(xs[i]).toString(), \"=> df =\", dfxsi.toString(), \"res = \", f(xs[i]).devide(df(xs[i])))\r\n                        xs[i + 1] = xs[i].substract(f(xs[i]).devide(df(xs[i])));\r\n                    }\r\n\r\n                    const fx = f(xs[N]);\r\n                    if (\r\n                        Math.abs(fx.real()) > Equation.zeroPrecision ||\r\n                        Math.abs(fx.imaginary()) > Equation.zeroPrecision\r\n                    )\r\n                        return NaN;\r\n                } else {\r\n                    xs[0] = x0;\r\n\r\n                    for (let i = 0; i < N; i++) {\r\n                        xs[i + 1] = xs[i] - f(xs[i]) / df(xs[i]);\r\n                    }\r\n\r\n                    if (f(xs[N]) > Equation.zeroPrecision) return NaN;\r\n                }\r\n                //integrity check!\r\n                return xs[xs.length - 1];\r\n            }\r\n            return NaN;\r\n        },\r\n\r\n        durandKerner: (polyf, N = 20) => {\r\n            if (polyf instanceof Algebra) {\r\n                const f = polyf.$;\r\n                const n = polyf.degree();\r\n                let guess;\r\n                do {\r\n                    guess = new Complex(Math.random(), Math.random());\r\n                } while (guess.isReal());\r\n                const roots = Array(n)\r\n                    .fill(0)\r\n                    .map((_) => []);\r\n\r\n                roots[0].push(new Complex(1, 0));\r\n                for (let i = 1; i < n; i++)\r\n                    roots[i][0] = guess.multiply(roots[i - 1][0]);\r\n                for (let iter = 0; iter < N; iter++) {\r\n                    for (let i = 0; i < n; i++) {\r\n                        const xiN = roots[i][iter].copy();\r\n                        let sndTermDen = new Complex(1, 0);\r\n                        for (let j = 0; j < n; j++) {\r\n                            if (i !== j) {\r\n                                const xjN = roots[j][roots[j].length - 1];\r\n                                sndTermDen = sndTermDen.multiply(\r\n                                    xiN.substract(xjN)\r\n                                );\r\n                            }\r\n                        }\r\n                        let sndTerm = f(xiN).devide(sndTermDen);\r\n                        roots[i].push(xiN.substract(sndTerm));\r\n                    }\r\n                }\r\n                console.table(roots.map((r) => r[r.length - 1].toString()));\r\n                return roots;\r\n            }\r\n        },\r\n        // needs work!\r\n        middlePoint: (\r\n            f,\r\n            boundary = 1000\r\n            // decimalPrecision = precision.get()\r\n        ) => {\r\n            // NOTE: works fine for some equations\r\n            // and wronge for some others like:  x ** 2 - 4*x  - 5\r\n            boundary = Math.abs(boundary);\r\n            const expectedRate = Equation.zeroPrecision;\r\n            const poles = [];\r\n            let xa = 0,\r\n                xb = 1;\r\n            for (let i = 0; i < boundary; i++) {\r\n                xa = -boundary + i;\r\n                xb = boundary - i;\r\n\r\n                let rate =\r\n                    (xb - xa) / (2 * Math.max(Math.abs(xa), Math.abs(xb)));\r\n                let p = null;\r\n                while (rate >= expectedRate) {\r\n                    p = (xa + xb) / 2;\r\n                    if (!f(p)) break;\r\n                    else if (f(p) * f(xa) < 0) xb = p;\r\n                    else {\r\n                        xa = p;\r\n                        rate =\r\n                            (xb - xa) /\r\n                            (2 * Math.max(Math.abs(xa), Math.abs(xb)));\r\n                    }\r\n                }\r\n                if (!f(p)) poles.push(round(p));\r\n            }\r\n            return new Set(poles);\r\n        },\r\n    };\r\n}\r\n","import Algebra from \"../index\";\nimport Complex from \"../complex\";\nimport Exp from \"./exp\";\nimport Fraction from \"./fraction\";\nimport { Step } from \"math/input-signals/signals\";\nimport Poly from \"./poly\";\nimport { Cos, Sin } from \"./trigonometric\";\nimport { round } from \"math/calculus/index\";\nimport Equation from \"math/equation\";\n\nexport default class TransferFunction extends Fraction {\n    static Specials = {\n        $1: (k, a) =>\n            new TransferFunction([k], [1, -a]).setRoots([], [a]).setOrder(1),\n        $2: (k, a, b = a instanceof Complex ? a.conjugate : a) => {\n            // k / (s + a)(s + b) => must be converted to => k / (s2 + 2(a+b)s + ab)\n            let aplusb =\n                a instanceof Algebra\n                    ? a.add(b)\n                    : b instanceof Algebra\n                    ? b.add(a)\n                    : b + a;\n            let ab =\n                a instanceof Algebra\n                    ? a.multiply(b)\n                    : b instanceof Algebra\n                    ? b.multiply(a)\n                    : b * a;\n            if (aplusb instanceof Complex && aplusb.isReal())\n                aplusb = aplusb.real();\n            if (ab instanceof Complex && ab.isReal()) ab = ab.real();\n\n            return new TransferFunction(\n                [k],\n                [1, aplusb instanceof Algebra ? aplusb.negation() : -aplusb, ab]\n            )\n                .setRoots([], [a, b])\n                .setOrder(2);\n        },\n        $WnZ: (w_n, zeta) => new TransferFunction(null, null, { w_n, zeta }),\n        $design: (t_rise, overshoot) =>\n            new TransferFunction(null, null, { overshoot, t_rise }),\n    };\n\n    static omegaZetaPoles = (w_n, zeta) => {\n        if (Math.abs(zeta) >= 1) {\n            const alpha = -zeta * w_n;\n            const beta = w_n * (zeta * zeta - 1) ** 0.5;\n            return [alpha + beta, alpha - beta];\n        }\n        const alpha = -zeta * w_n;\n        const beta = w_n * (1 - zeta * zeta) ** 0.5;\n        return [new Complex(alpha, beta), new Complex(alpha, -beta)];\n    };\n    constructor(numerator, denominator, params = {}) {\n        let zeros = [],\n            poles = [];\n        if (params) {\n            if (params.overshoot && params.t_rise) {\n                params.overshoot = Number(params.overshoot);\n                params.t_rise = Number(params.t_rise);\n                const logMp = Math.log(params.overshoot);\n                params.zeta =\n                    -logMp / (Math.PI * Math.PI + logMp * logMp) ** 0.5;\n                params.w_d = Math.PI / params.t_rise;\n                params.w_n =\n                    params.w_d / (1 - params.zeta * params.zeta) ** 0.5;\n            }\n\n            if (params.w_n) {\n                params.w_n = Number(params.w_n);\n                params.zeta = Number(params.zeta);\n                // if the user sends w_n params it will override the given zero/pole list\n                const { w_n, zeta } = params;\n                const wn2 = w_n * w_n;\n                numerator = wn2;\n                denominator = [1, 2 * zeta * w_n, wn2];\n                poles = TransferFunction.omegaZetaPoles(w_n, zeta);\n                zeros = [];\n            }\n        }\n        super(numerator, denominator, \"s\", params);\n        // SIMPL;IFY\n        this.poles = [...poles]; //edit solve equations\n        this.zeros = [...zeros];\n        if (!this.a instanceof Array) this.a = [this.a];\n        if (this.a.length === 1 && !this.w_n) {\n            if (\n                this.b.length === 3 &&\n                this.b[this.b.length - 1] === this.a[0]\n            ) {\n                this.w_n = this.a[0];\n                this.zeta = this.b[1] / (2 * this.w_n);\n                this.timeConstant = round(1 / (this.zeta * this.w_n));\n                this.t_settle = 4 * this.timeConstant;\n                if (params && params.w_d) this.w_d = params.w_d;\n                else if (this.zeta >= -1 && this.zeta <= 1)\n                    this.w_d = this.w_n * (1 - this.zeta ** 2) ** 0.5;\n                this.order = 2;\n                this.setRoots(\n                    [],\n                    TransferFunction.omegaZetaPoles(this.w_n, this.zeta)\n                );\n            }\n        }\n        if (!this.order)\n            this.order =\n                denominator instanceof Array ? denominator.length - 1 : 1;\n        if (params.overshoot && params.t_rise) {\n            [this.overshoot, this.t_rise] = [params.overshoot, params.t_rise];\n        } else {\n            const dampingCharasteristics =\n                this.getDampingSystemCharasteristics();\n            if (dampingCharasteristics) {\n                this.overshoot = dampingCharasteristics.overshoot;\n                this.t_rise = dampingCharasteristics.t_rise;\n            }\n        }\n    }\n    static sortRoots = (rt) =>\n        rt.sort((ri, rj) =>\n            ri instanceof Algebra\n                ? ri.substract(rj)\n                : rj instanceof Algebra\n                ? rj.substract(ri)\n                : Math.abs(ri) - Math.abs(rj)\n        );\n    roots = () => [this.zeros, this.poles];\n    setRoots = (zeros, poles) => {\n        this.poles = poles.map((pi) =>\n            pi instanceof Complex && pi.isReal() ? pi.real() : pi\n        );\n        this.zeros = zeros.map((zi) =>\n            zi instanceof Complex && zi.isReal() ? zi.real() : zi\n        );\n        return this;\n    };\n\n    getDampingSystemCharasteristics = () =>\n        this.w_d\n            ? {\n                  t_rise: round(Math.PI / this.w_d),\n                  // WHAT IF W_D === 0?\n                  overshoot:\n                      this.zeta >= -1 && this.zeta <= 1\n                          ? round(\n                                100 *\n                                    Math.exp(\n                                        -(this.zeta * Math.PI) /\n                                            (1 - this.zeta ** 2) ** 0.5\n                                    )\n                            )\n                          : null,\n              }\n            : null;\n\n    getOrder = () => this.order;\n    setOrder = (order) => {\n        this.order = order;\n        return this;\n    };\n    getPoles = () => this.poles;\n    setPoles = (poles) => {\n        this.poles = TransferFunction.sortRoots(poles).map((pi) =>\n            pi instanceof Complex && pi.isReal() ? pi.real() : pi\n        );\n        return this;\n    };\n    getZeros = () => this.zeros;\n    setZeros = (zeros) => {\n        this.zeros = zeros.map((pi) =>\n            pi instanceof Complex && pi.isReal() ? pi.real() : pi\n        );\n        return this;\n    };\n\n    poleOrder = (pole) =>\n        this.poles.filter((pi) => Algebra.areTheseTwoEqual(pole, pi)).length;\n\n    laplace = () => this.copy(); // actually it has no laplace, this is for disfunctioning the laplace method in the parent class Algebra\n    laplaceInverse = () => {\n        const m = this.zeros.length - 1; // number of zeros\n        const n = this.poles.length - 1; // number of poles\n\n        if (m === 0) {\n            switch (n) {\n                case 2:\n                    return null;\n                case 1:\n                    return new Algebra(1, { type: \"exp\" }); //EDITTTTTTTTTTTTTTTT\n                case 0:\n                    return null; //u(t)\n                default:\n                    return null; //DEFINE AN UNKNOWN FUNCTION FOR CASE LIKE THIS\n            }\n        }\n    };\n    step = (inTimeDomain = true) => {\n        // normally will automatically return the time domain answer\n        // unless inLaplaceDomain is true\n        if (inTimeDomain) {\n            const m = this.zeros.length; // number of zeros\n            const n = this.poles.length; // number of poles\n            const nreal = this.poles.filter(\n                (pi) => !(pi instanceof Complex)\n            ).length; // number of real poles; can be eigher 2 or 0\n            if (m === 0) {\n                const k = this.numerator();\n                if (n === 0) {\n                    // return u(t)\n                    // DEFINE U(T) IN ALGEBRA\n                }\n                if (n === 1) {\n                } else if (n === 2) {\n                    const a = -this.poles[0],\n                        b = -this.poles[1];\n                    if (nreal === 2) {\n                        // if (a > 0 && b > 0) {\n                        if (a !== b)\n                            // two independent polesdddd\n                            // two negative independent poles\n                            return new Exp(1 / a, -a)\n                                .add(new Exp(-1 / b, -b))\n                                .multiply(k / (a - b))\n                                .multiply(new Step())\n                                .add(new Step(k / (a * b)));\n                        else {\n                            const a2 = a * a;\n                            return new Exp(-k / a2, -a)\n                                .multiply(new Poly([a, 1]))\n                                .multiply(new Step())\n                                .add(new Step(k / a2));\n                        }\n                        // } else {\n                        //     // repetetive poles\n                        // }\n                    } else if (nreal === 0) {\n                        // two conjugated complex poles\n                        //UNDERSHOOT BUG FIXLAYS HERE\n                        const a = -this.poles[0].real(),\n                            b = this.poles[0].imaginary();\n                        const ka2b2 = k / (a ** 2 + b ** 2);\n                        // FIND BUUUUUUG\n                        // return new Exp(-ka2b2, -a)\n                        //     .multiply(new Cos(1, b).add(new Sin(a / b, b)))\n                        //     .multiply(new Step())\n                        //     .add(new Step(ka2b2));\n                        return new Exp(-ka2b2, -a)\n                            .multiply(new Cos(1, b))\n                            .add(\n                                new Exp(-ka2b2, -a).multiply(new Sin(a / b, b))\n                            )\n                            .multiply(new Step())\n                            .add(new Step(ka2b2));\n                    }\n                    // else if( nreal == 1) // this cant happen, but what if sth went wrong?\n                }\n            }\n        } else {\n            const lstep = this.copy();\n            const poles = lstep.getPoles();\n            poles.push(0);\n            lstep.getB().push(0); //update denominator\n            lstep.setPoles(poles).setDenominator(lstep.getB());\n            return lstep;\n        }\n    };\n    copy = (linkPrevious = false) =>\n        new TransferFunction(this.a, this.b, {\n            overshoot: this.overshoot,\n            t_rise: this.t_rise,\n            t_settle: this.t_settle,\n            w_d: this.w_d,\n            timeConstant: this.timeConstant,\n            w_n: this.w_n,\n            zeta: this.zeta,\n            dot: this.dot,\n            plus: this.plus,\n            previous: linkPrevious ? this.previous : null,\n            input: this.input,\n        }).setRoots(this.zeros, this.poles);\n\n    lim = (s0) => {\n        let num, den;\n        // for simple polynomial numerator and denominator fractions\n        // IMPLEMENT HOPITAL AS WELL?\n        if (!s0) {\n            // s -> 0)\n\n            num = { a: 0, sp: this.a.length - 1 };\n            den = { b: 1, sp: this.b.length - 1 };\n            for (; num.sp > 0 && this.a[num.sp] === 0; num.sp--);\n            num.a = this.a[num.sp];\n            for (; den.sp > 0 && this.b[den.sp] === 0; den.sp--);\n            den.b = this.b[den.sp];\n            num.sp = this.a.length - num.sp - 1;\n            den.sp = this.b.length - den.sp - 1;\n            if (num.sp === den.sp) return num.a / den.b;\n            else {\n                const sMinPower = Math.min(den.sp, num.sp);\n                if (sMinPower) {\n                    num.sp -= sMinPower;\n                    den.sp -= sMinPower;\n                }\n                // now one of num.sp or den.sp is zero\n                if (den.sp)\n                    // zero on denominator\n                    return Infinity;\n                // if den.sp == 0 and num.sp != 0\n                return 0;\n            }\n        } else if (s0 === Infinity) {\n            // s -> infinity\n            num = { a: 0, sp: 0 };\n            den = { b: 1, sp: 0 };\n            for (; num.sp < this.a.length && this.a[num.sp] === 0; num.sp++);\n            num.a = this.a[num.sp];\n            for (; den.sp < this.b.length && this.b[den.sp] === 0; den.sp++);\n            den.b = this.b[den.sp];\n            num.sp = this.a.length - num.sp - 1;\n            den.sp = this.b.length - den.sp - 1;\n            if (num.sp === den.sp) return num.a / den.b;\n            // else\n            const sMinPower = Math.min(den.sp, num.sp);\n            if (sMinPower) {\n                num.sp -= sMinPower;\n                den.sp -= sMinPower;\n            }\n            // now one of num.sp or den.sp is zero\n            if (den.sp)\n                // zero on denominator\n                return 0;\n            // if den.sp == 0 and num.sp != 0\n            return Infinity;\n        } else {\n            // if s0 is just a no-zero limited number\n            num = this.numerator().$(s0);\n            den = this.denominator().$(s0);\n            if (den)\n                // simple non zero denominator limit\n                return num / den;\n            // if den == 0\n            // use Hopital or other limit methods\n            //return (num.a * (s0 ** num.sp)) / (den.b * (s0 ** den.sp));\n        }\n    };\n    errors = () => {\n        const sGs = this.multiply(new Poly([1, 0], \"s\"));\n        const s2Gs = sGs.multiply(new Poly([1, 0], \"s\"));\n        console.log(sGs);\n        return {\n            Ks: round(this.lim(0)),\n            Kr: round(sGs.lim(0)),\n            Ka: round(s2Gs.lim(0)),\n        };\n    };\n    $ = (t) => this.laplaceInverse().$(t); // valueOf function in certain point; I used character $ in many places as,\n    // acronym for \"set\" in setters, so $ here means that set the t ( or x or whatever) with a certain point\n\n    rootLocus = (k_min, k_max, N = 1000) => {\n        // return root locus values for plotting\n        /* let dk = (k_max - k_min) / N; //time step size\n        while (dk >= 1) {\n            N *= 10;\n            dk = (k_max - k_min) / N; //time step size\n        }*/\n        // TEMPORARY:\n        let  dk = 1;\n\n        const reals = [], imaginaries = [];\n        for (let k = k_min; k <= k_max; k += dk) {\n            const roots = new Equation(this.denominator().add(this.numerator().multiply(k))).roots();\n            for(const root of roots){\n                if(root instanceof Complex){\n                    reals.push(root.real());\n                    imaginaries.push(root.imaginary());\n                }\n                else {\n                    reals.push(root);\n                    imaginaries.push(0);\n                }\n            }\n        }\n        return [reals, imaginaries];\n    };\n}\n","import Algebra from \"math/algebra\";\nimport Complex from \"math/algebra/complex\";\nimport Exp from \"./exp\";\nimport Fraction from \"./fraction\";\n\nexport class Sin extends Algebra {\n    constructor(A, w, teta = 0, symbol = \"t\", params = {}) {\n        // Ae^wt\n        super(A, { symbol, type: \"sin\", b: w, teta, ...params });\n    }\n    copy = (linkPrevious = false) =>\n        new Sin(this.a, this.b, this.teta, this.symbol, {\n            dot: this.dot,\n            plus: this.plus,\n            previous: linkPrevious ? this.previous : null,\n            input: this.input,\n        });\n\n    toExp = () => {\n        const sin = this.copy();\n        const exp1 = new Exp(sin.a / 2, new Complex(0, -sin.b));\n        const exp2 = new Exp(-sin.a / 2, new Complex(0, sin.b));\n        return new Complex(0, exp1.add(exp2));\n    };\n\n    valueAt = (t) => {\n        const A = Algebra.valueOf(this.a, t);\n        const w = Algebra.valueOf(this.b, t);\n        const teta = Algebra.valueOf(this.teta, t);\n        return A * Math.sin(w * t + teta)\n    }\n}\n\nexport class Cos extends Algebra {\n    constructor(A, w, teta = 0, symbol = \"t\", params = {}) {\n        // Ae^wt\n        super(A, { symbol, type: \"cos\", b: w, teta, ...params });\n    }\n    copy = (linkPrevious = false) =>\n        new Cos(this.a, this.b, this.teta, this.symbol, {\n            dot: this.dot,\n            plus: this.plus,\n            previous: linkPrevious ? this.previous : null,\n            input: this.input,\n        });\n\n    toExp = () => {\n        const cos = this.copy();\n        const exp1 = new Exp(cos.a / 2, new Complex(0, cos.b));\n        const exp2 = new Exp(cos.a / 2, new Complex(0, -cos.b));\n        return exp1.add(exp2);\n    };\n\n\n    valueAt = (t) => {\n        const A = Algebra.valueOf(this.a, t);\n        const w = Algebra.valueOf(this.b, t);\n        const teta = Algebra.valueOf(this.teta, t);\n        return A * Math.cos(w * t + teta)\n    }\n}\n\nexport class Tan extends Algebra {\n    constructor(A, w, teta = 0, symbol = \"t\", params = {}) {\n        // Ae^wt\n        super(A, { symbol, type: \"tan\", b: w, teta, ...params });\n    }\n    copy = (linkPrevious = false) =>\n        new Tan(this.a, this.b, this.teta, this.symbol, {\n            dot: this.dot,\n            plus: this.plus,\n            previous: linkPrevious ? this.previous : null,\n            input: this.input,\n        });\n\n    toExp = () => {\n        const tan = this.copy();\n        const exp1 = new Exp(1, new Complex(0, -tan.b));\n        const numeratorExp2 = new Exp(-1, new Complex(0, tan.b));\n        const denominatorExp2 = new Exp(1, new Complex(0, tan.b));\n        return new Fraction(exp1.add(numeratorExp2), exp1.add(denominatorExp2));\n    };\n\n    valueAt = (t) => {\n        const A = Algebra.valueOf(this.a, t);\n        const w = Algebra.valueOf(this.b, t);\n        const teta = Algebra.valueOf(this.teta, t);\n        return A * Math.tan(w * t + teta)\n    }\n}\n\nexport class Cot extends Algebra {\n    constructor(A, w, teta = 0, symbol = \"t\", params = {}) {\n        // Ae^wt\n        super(A, { symbol, type: \"cot\", b: w, teta, ...params });\n    }\n    copy = (linkPrevious = false) =>\n        new Cot(this.a, this.b, this.teta, this.symbol, {\n            dot: this.dot,\n            plus: this.plus,\n            previous: linkPrevious ? this.previous : null,\n            input: this.input,\n        });\n    toExp = () => {\n        const cot = this.copy();\n        const exp1 = new Exp(1, new Complex(0, -cot.b));\n        const numeratorExp2 = new Exp(-1, new Complex(0, cot.b));\n        const denominatorExp2 = new Exp(1, new Complex(0, cot.b));\n        return new Fraction(exp1.add(denominatorExp2), exp1.add(numeratorExp2));\n    };\n\n\n    valueAt = (t) => {\n        const A = Algebra.valueOf(this.a, t);\n        const w = Algebra.valueOf(this.b, t);\n        const teta = Algebra.valueOf(this.teta, t);\n        return A * Math.cot(w * t + teta)\n    }\n}\n"],"names":["Exp","a","b","symbol","params","type","copy","linkPrevious","dot","plus","previous","input","toSin","exp","Complex","real","cos","Cos","imaginary","sin","Sin","valueAt","t","Algebra","Math","Fraction","num","den","Array","length","lim","numerator","Poly","denominator","setNumerator","setA","setDenominator","setB","Step","amplitude","amp","$","StandardInputSignal","Algebrite","require","Equation","roots","x","nroots","expression","toString","replaceAll","slice","split","filter","xi","map","i","separatorIndex","isDigit","terms","push","magnitude","replace","Number","AlgebraRoots","solve","approximate","method","Methods","durandKerner","N","boundary","allRoots","isUnique","newRoot","isNaN","findIndex","rt","equals","isUniqueComplex","a0","an","abs","x0","rx","round","this","zeroPrecision","precision","newton","polyf","f","df","derivative","xs","fill","dfx0","isZero","substract","devide","fx","NaN","guess","n","degree","random","isReal","_","multiply","iter","xiN","sndTermDen","j","xjN","sndTerm","console","table","r","middlePoint","expectedRate","poles","xa","xb","rate","max","p","Set","TransferFunction","zeros","overshoot","t_rise","logMp","log","zeta","PI","w_d","w_n","wn2","omegaZetaPoles","setRoots","pi","zi","getDampingSystemCharasteristics","getOrder","order","setOrder","getPoles","setPoles","sortRoots","getZeros","setZeros","poleOrder","pole","laplace","laplaceInverse","m","step","inTimeDomain","lstep","getB","nreal","k","add","a2","ka2b2","t_settle","timeConstant","s0","sp","sMinPower","min","Infinity","errors","sGs","s2Gs","Ks","Kr","Ka","rootLocus","k_min","k_max","dk","reals","imaginaries","root","dampingCharasteristics","Specials","$1","$2","conjugate","aplusb","ab","negation","$WnZ","$design","alpha","beta","sort","ri","rj","A","w","teta","toExp","exp1","exp2"],"sourceRoot":""}