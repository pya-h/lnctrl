{"version":3,"file":"static/js/695.6229efe9.chunk.js","mappings":"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","sources":["math/algebra/complex.js","math/algebra/functions/exp.js","math/algebra/functions/fraction.js","math/algebra/functions/poly.js","math/input-signals/signals.js","math/solvers/equation.js","math/solvers/formula.js","math/algebra/functions/zero.js","math/algebra/functions/transfer.js","math/algebra/functions/trigonometric.js","errors/algebra/NotScalarError.js","math/algebra/index.js","math/input-signals/index.js"],"sourcesContent":["import Algebra from \".\";\r\nimport { round, isDigit } from \"../calculus\";\r\n\r\nclass Complex extends Algebra {\r\n    constructor(preal, pimage = 0, params = {}) {\r\n        super(preal, { symbol: \"j\", type: \"complex\", b: pimage, ...params });\r\n    }\r\n    static ToCouples = (arrComplex) => {\r\n        const n = arrComplex.length;\r\n        if (n >= 1) {\r\n            const reals = Array(n).fill(0),\r\n                imaginaries = Array(n).fill(0);\r\n            for (let i = 0; i < n; i++) {\r\n                if (arrComplex[i] instanceof Complex) {\r\n                    reals[i] = arrComplex[i].real();\r\n                    imaginaries[i] = arrComplex[i].imaginary();\r\n                } else reals[i] = arrComplex[i];\r\n            }\r\n            return [reals, imaginaries];\r\n        }\r\n        return [];\r\n    };\r\n    hasMultiTerms = () =>\r\n        this.plus || (this.a.toString() !== \"0\" && this.b.toString() !== \"0\");\r\n\r\n    toString = (parenthesis = false, showJ1 = false) => {\r\n        if (this.isZero()) return \"0\";\r\n        const rl = this.a;\r\n        let formula = parenthesis && this.hasMultiTerms() ? \"(\" : \"\";\r\n        if (rl !== 0)\r\n            formula +=\r\n                rl instanceof Algebra\r\n                    ? rl.toString(rl.hasMultiTerms())\r\n                    : round(rl);\r\n        let im = this.b;\r\n        if (im !== 0) {\r\n            //if (im < 0 || (im instanceof Algebra)) { im = im.negation()\r\n            if (im < 0) {\r\n                im *= -1;\r\n                formula += \" - \";\r\n            } else if (im instanceof Algebra && im.getA() < 0) {\r\n                im.setA(-im.getA());\r\n                formula += \" - \";\r\n            } else if (rl !== 0) formula += \" + \";\r\n\r\n            formula += this.symbol;\r\n            if (im !== 1 || showJ1)\r\n                formula +=\r\n                    im instanceof Algebra\r\n                        ? im.toString(im.hasMultiTerms())\r\n                        : round(im);\r\n        }\r\n        if (this.plus) formula += this.join(); // if there's a next term: casscade toString() calls\r\n\r\n        return parenthesis ? formula + \")\" : formula;\r\n    }; // a + jb\r\n\r\n    real = () => this.a;\r\n    imaginary = () => this.b;\r\n\r\n    copy = (linkPrevious = false) =>\r\n        new Complex(this.a, this.b, {\r\n            dot: this.dot,\r\n            plus: this.plus,\r\n            previous: linkPrevious ? this.previous : null,\r\n            input: this.input,\r\n        });\r\n    hardcopy = () =>\r\n        new Complex(this.a, this.b, {\r\n            dot: this.dot,\r\n            input: this.input,\r\n        });\r\n\r\n    conjugate = () =>\r\n        new Complex(\r\n            this.a,\r\n            this.b instanceof Algebra ? this.b.negation() : -this.b\r\n        );\r\n\r\n    negation = () =>\r\n        new Complex(\r\n            this.a instanceof Algebra ? this.a.negation() : -this.a,\r\n            this.b instanceof Algebra ? this.b.negation() : -this.b\r\n        );\r\n\r\n    magnitude$2 = () => this.a ** 2 + this.b ** 2;\r\n\r\n    magnitude = () => (this.a ** 2 + this.b ** 2) ** 0.5;\r\n\r\n    phase = () => {\r\n        const definiteA = +this.a,\r\n            definiteB = +this.b;\r\n        if (this.a === definiteA && this.b === definiteB)\r\n            return Math.atan2(definiteB, definiteA);\r\n        if (this.b instanceof Algebra)\r\n            return (t) =>\r\n                Math.atan2(\r\n                    this.b.$(t),\r\n                    this.a instanceof Algebra ? this.a.$(t) : definiteA\r\n                );\r\n        if (this.a instanceof Algebra)\r\n            return (t) => Math.atan2(definiteB, this.a.$(t));\r\n        return NaN;\r\n    };\r\n    isReal = () => this.b === 0;\r\n\r\n    hasSameTypeWith = (x) =>\r\n        (this.isReal() && x.isReal()) || (!this.isReal() && !x.isReal()); // both full imaginray or both real\r\n    realify = () => new Complex(this.a, 0); // return a simple real value in Complex object format (for methods that only accept Complex values)\r\n\r\n    add = (operand) => {\r\n        let Re = null,\r\n            Im = null;\r\n        if (operand instanceof Complex) {\r\n            if (this.a instanceof Algebra) Re = this.a.add(operand.real());\r\n            else if (operand.real() instanceof Algebra)\r\n                Re = operand.real().add(this.a);\r\n            else Re = this.a + operand.real();\r\n\r\n            if (this.b instanceof Algebra) Im = this.b.add(operand.imaginary());\r\n            else if (operand.imaginary() instanceof Algebra)\r\n                Im = operand.imaginary().add(this.b);\r\n            else Im = this.b + operand.imaginary();\r\n        } else {\r\n            if (this.a instanceof Algebra) Re = this.a.add(operand);\r\n            else if (operand instanceof Algebra) Re = operand.add(this.a);\r\n            else Re = this.a + operand;\r\n\r\n            Im = this.b;\r\n        }\r\n        return new Complex(Re, Im);\r\n    };\r\n\r\n    substract = (operand) => this.add(operand.negation());\r\n\r\n    equals = (operand) => {\r\n        if (operand instanceof Complex) {\r\n            // two complex number are equal to eachother if both thier real parts are the same, and their imaginary parts are the same\r\n            let realPartsEqual = false;\r\n            if (this.a instanceof Algebra)\r\n                realPartsEqual = this.a.equals(operand.real());\r\n            else if (operand.real() instanceof Algebra)\r\n                realPartsEqual = operand.real().equals(this.a);\r\n            else realPartsEqual = this.a === operand.real();\r\n            if (!realPartsEqual) return false;\r\n\r\n            if (this.b instanceof Algebra)\r\n                return this.b.equals(operand.imaginary());\r\n            else if (operand.imaginary() instanceof Algebra)\r\n                return operand.imaginary().equals(this.b);\r\n            return this.b === operand.imaginary();\r\n        }\r\n\r\n        // if operand is not a complex number then the only way it can be equal with this object of Complex,\r\n        // is for this object to have a zero imaginary part:\r\n        return (\r\n            this.isReal() &&\r\n            (operand instanceof Algebra\r\n                ? operand.equals(this.a)\r\n                : operand === this.a)\r\n        );\r\n    };\r\n\r\n    isConjugateWith = (operand) => this.conjugate().equals(operand);\r\n    multiply = (operand) => {\r\n        let Re = [],\r\n            Im = [];\r\n        if (operand instanceof Complex) {\r\n            // first term\r\n            if (this.a instanceof Algebra) {\r\n                Re.push(this.a.multiply(operand.real()));\r\n                Im.push(this.a.multiply(operand.imaginary()));\r\n            } else {\r\n                Re.push(\r\n                    operand.a instanceof Algebra\r\n                        ? operand.a.multiply(this.a)\r\n                        : operand.a * this.a\r\n                );\r\n\r\n                Im.push(\r\n                    operand.b instanceof Algebra\r\n                        ? operand.b.multiply(this.a)\r\n                        : this.a * operand.b\r\n                );\r\n            }\r\n\r\n            // second term\r\n            if (this.b instanceof Algebra) {\r\n                Re.push(this.b.multiply(operand.imaginary()));\r\n                Im.push(this.b.multiply(operand.real()));\r\n            } else {\r\n                Re.push(\r\n                    operand.b instanceof Algebra\r\n                        ? operand.b.multiply(this.b)\r\n                        : operand.b * this.b\r\n                );\r\n\r\n                Im.push(\r\n                    operand.a instanceof Algebra\r\n                        ? operand.a.multiply(this.b)\r\n                        : this.b * operand.a\r\n                );\r\n            }\r\n            return new Complex(Re[0] - Re[1], Im[0] + Im[1]);\r\n        } else {\r\n            Re =\r\n                this.a instanceof Algebra\r\n                    ? this.a.multiply(operand)\r\n                    : operand instanceof Algebra\r\n                    ? operand.multiply(this.a)\r\n                    : this.a * operand;\r\n\r\n            Im =\r\n                this.b instanceof Algebra\r\n                    ? this.b.multiply(operand)\r\n                    : operand instanceof Algebra\r\n                    ? operand.multiply(this.b)\r\n                    : this.b * operand;\r\n        }\r\n        return new Complex(Re, Im);\r\n    };\r\n\r\n    devide = (denominator) => {\r\n        if (denominator instanceof Complex) {\r\n            const result = this.multiply(denominator.conjugate()).devide(\r\n                denominator.magnitude$2()\r\n            );\r\n            // CHECK THIS\r\n            if (isNaN(result.real())) result.setA(0);\r\n            if (isNaN(result.imaginary())) result.setB(0);\r\n            return result;\r\n        } else if (denominator instanceof Algebra) {\r\n            // USE super().devide ?\r\n            return this.copy(); // for now to avoid craches\r\n        } else return this.multiply(1 / denominator); // number\r\n    };\r\n\r\n    raiseTo = (power) => {\r\n        let result = this.copy(true);\r\n        // for now power must be integr\r\n        if (Math.floor(power) === power)\r\n            for (let i = 1; i < power; i++) {\r\n                result = result.multiply(this);\r\n            }\r\n\r\n        return result;\r\n    };\r\n\r\n    devideInverse = (k) =>\r\n        (k instanceof Algebra ? k : new Complex(k, 0)).devide(this);\r\n\r\n    static extract = (strNumber) => {\r\n        // extract a string to a complex object\r\n\r\n        strNumber = strNumber.replace(/\\s/g, \"\");\r\n        let i = strNumber[0] === \"-\" || strNumber[0] === \"+\" ? 1 : 0;\r\n        let real = 0;\r\n        if (strNumber[i] !== \"j\") {\r\n            for (; i < strNumber.length && isDigit(strNumber[i]); i++);\r\n            real = Number(strNumber.slice(0, i) || 0);\r\n        }\r\n\r\n        let sign = 1;\r\n        for (\r\n            ;\r\n            i < strNumber.length &&\r\n            (strNumber[i] === \"j\" ||\r\n                strNumber[i] === \"+\" ||\r\n                strNumber[i] === \"-\");\r\n            i++\r\n        )\r\n            if (strNumber[i] === \"-\") sign = -1;\r\n\r\n        const img = Number(strNumber.slice(i, strNumber.length) || 0);\r\n        return new Complex(real, sign * img);\r\n    };\r\n\r\n    isZero = () => this.a === 0 && this.b === 0;\r\n\r\n    static MultiplyFactors = (factors, s) => {\r\n        // list of factors (usually roots) multiply at a certain point\r\n        // (s + f1) * (s + f2) * ... * (s + fn)\r\n        if (!(s instanceof Complex)) s = new Complex(s, 0);\r\n        let result = new Complex(1, 0);\r\n        for (const factor of factors) {\r\n            let term = s.substract(factor.value);\r\n            if (factor.order > 1) term = term.raiseTo(factor.order);\r\n            result = result.multiply(term);\r\n        }\r\n        return result;\r\n    };\r\n\r\n    actual = () => (this.isReal() ? this.real() : this);\r\n}\r\n\r\nexport default Complex;\r\n","import Algebra from \"math/algebra\";\r\nimport Complex from \"math/algebra//complex\";\r\nimport { Cos, Sin } from \"./trigonometric\";\r\n\r\nexport default class Exp extends Algebra {\r\n    constructor(a, b, symbol = \"t\", params = {}) {\r\n        // ae^bt\r\n        super(a, { symbol, type: \"exp\", b, ...params });\r\n    }\r\n\r\n    copy = (linkPrevious = false) => // copy everything\r\n        new Exp(this.a, this.b, this.symbol, {\r\n            dot: this.dot,\r\n            plus: this.plus,\r\n            previous: linkPrevious ? this.previous : null,\r\n            input: this.input,\r\n        });\r\n\r\n    hardcopy = () => // shallow copy just for single term copy\r\n        new Exp(this.a, this.b, this.symbol, {\r\n            dot: this.dot,\r\n            input: this.input,\r\n        });\r\n    toSin = () => {\r\n        const exp = this.copy();\r\n        if (exp.type === \"exp\" && exp.b instanceof Complex) {\r\n            if (exp.b instanceof Complex && exp.b.real() === 0) {\r\n                const cos = new Cos(exp.a, exp.b.imaginary());\r\n                const sin = new Sin(exp.a, exp.b.imaginary());\r\n                return new Complex(cos, sin);\r\n            }\r\n        }\r\n        return exp; // if doesnt math the condition then just return exponential function itself\r\n    };\r\n\r\n    amplitude = (t) => {\r\n        // NOT SURE\r\n        // if (this.b instanceof Complex || t instanceof Complex) {\r\n        //     if (this.a === +this.a) return this.a;\r\n        //     else if (this.a instanceof Algebra && this.symbol === this.a.symbol)\r\n        //         return this.a.$(t);\r\n        // } else return this.valueAt(t);\r\n    };\r\n    phase = (w) => {\r\n        const jw = new Complex(0, w);\r\n        let pb = +this.b;\r\n        if (this.b === pb) return pb * w;\r\n        if (this.b instanceof Algebra) {\r\n            pb = this.b.$(jw);\r\n            return jw.multiply(pb).imaginary();\r\n        }\r\n    };\r\n    valueAt = (t) => {\r\n        const numericT = +t;\r\n        if (numericT === t) {\r\n            const a = Algebra.valueOf(this.a, numericT),\r\n                b = Algebra.valueOf(this.b, numericT);\r\n            return a * Math.exp(b * numericT);\r\n        } else if (t instanceof Complex) {\r\n            if (!t.real()) {\r\n                return new Exp(\r\n                    this.a,\r\n                    new Complex(0, this.b * t.imaginary()),\r\n                    this.symbol\r\n                ).toSin();\r\n            } else if (t.imaginary()) {\r\n                // edit this\r\n                return (\r\n                    new Exp(this.a, this.b, this.symbol).valueAt(t.real()) *\r\n                    new Exp(\r\n                        1,\r\n                        new Complex(0, this.b * t.imaginary()),\r\n                        this.symbol\r\n                    ).toSin()\r\n                );\r\n            }\r\n            // t is real\r\n            else return this.valueAt(t.real());\r\n        }\r\n    };\r\n}\r\n","import Algebra from \"math/algebra\";\r\nimport Poly from \"./poly\";\r\nimport TransferFunction from \"./transfer\";\r\n\r\nexport default class Fraction extends Algebra {\r\n    constructor(num, den = [1], symbol = \"t\", params = {}) {\r\n        // ke^ct\r\n        if (!(num instanceof Algebra)) {\r\n            if (!(num instanceof Array)) num = [num];\r\n            // this.a\r\n            else if (num.length === 0) num = [0];\r\n        }\r\n        if (!(den instanceof Algebra)) {\r\n            if (!(den instanceof Array)) den = [den];\r\n            // this.b\r\n            else if (den.length === 0) den = [1];\r\n        }\r\n        super(num, { symbol, type: \"frac\", b: den, ...params });\r\n    }\r\n\r\n    copy = (\r\n        linkPrevious = false // copy everything\r\n    ) =>\r\n        new Fraction(this.a, this.b, this.symbol, {\r\n            dot: this.dot,\r\n            plus: this.plus,\r\n            previous: linkPrevious ? this.previous : null,\r\n            input: this.input,\r\n        });\r\n\r\n    hardcopy = () =>\r\n        // shallow copy just for copying single term\r\n        new Fraction(this.a, this.b, this.symbol, {\r\n            dot: this.dot,\r\n            input: this.input,\r\n        });\r\n    lim = () => {\r\n        // for all fractions with all kind of numerator and denominator\r\n    };\r\n\r\n    numerator = () =>\r\n        this.a instanceof Algebra\r\n            ? this.a.copy(true)\r\n            : new Poly(this.a, this.symbol);\r\n    denominator = () =>\r\n        this.b instanceof Algebra\r\n            ? this.b.copy(true)\r\n            : new Poly(this.b, this.symbol);\r\n\r\n    setNumerator = (num) => {\r\n        if (!(num instanceof Algebra)) {\r\n            if (!(num instanceof Array)) num = [num];\r\n            // this.a\r\n            else if (num.length === 0) num = [0];\r\n        }\r\n        return this.setA(num);\r\n    };\r\n\r\n    setDenominator = (den) => {\r\n        if (!(den instanceof Algebra)) {\r\n            if (!(den instanceof Array)) den = [den];\r\n            // this.b\r\n            else if (den.length === 0) den = [1];\r\n        }\r\n        return this.setB(den);\r\n    };\r\n    valueAt = (t) => {\r\n        const num = this.numerator().$(t);\r\n        const den = this.denominator().$(t);\r\n\r\n        if (num instanceof Algebra) return num.devide(den);\r\n        if (den instanceof Algebra) return den.devideInverse(num);\r\n        if (den) return num / den;\r\n        // THROW zero denominator ERROR\r\n        return undefined;\r\n    };\r\n\r\n    multiply = (operand) => {\r\n        let y = this.copy(true);\r\n        if (operand instanceof Fraction) {\r\n            const num = this.numerator().multiply(operand.numerator()),\r\n                den = this.denominator().multiply(operand.denominator());\r\n            y = num.devide(den);\r\n        } else {\r\n            const num = this.numerator().multiply(operand);\r\n            y = num.devide(this.denominator());\r\n        }\r\n        if (this.plus) y.plus = this.plus.multiply(operand);\r\n        return y;\r\n    };\r\n    toFormula = () =>\r\n        \"(\" +\r\n        this.numerator().toFormula() +\r\n        \")/(\" +\r\n        this.denominator().toFormula() +\r\n        \")\";\r\n\r\n    toTransferFunction = () => new TransferFunction(this.getA(), this.getB());\r\n\r\n    isIntegrator = () => this.toTransferFunction().isIntegrator();\r\n}\r\n","import Algebra from \"math/algebra\";\r\nimport Complex from \"../complex\";\r\nimport Fraction from \"./fraction\";\r\n\r\nexport default class Poly extends Algebra {\r\n    static atn = (a, n, symbol = \"t\") => {\r\n        const aArray = Array(n + 1).fill(0);\r\n        aArray[0] = a;\r\n        return new Poly(aArray, symbol);\r\n    };\r\n    constructor(a, symbol = \"t\", params = {}) {\r\n        // ke^ct\r\n        if(typeof a === 'number')\r\n            a = [a];\r\n        super(a, { symbol, type: \"poly\", ...params });\r\n    }\r\n\r\n    copy = (\r\n        linkPrevious = false // copy everything\r\n    ) =>\r\n        new Poly(this.a, this.symbol, {\r\n            dot: this.dot,\r\n            plus: this.plus,\r\n            previous: linkPrevious ? this.previous : null,\r\n            input: this.input,\r\n        });\r\n    hardcopy = () =>\r\n        // shallow copy; signle term copy\r\n        new Poly(this.a, this.symbol, {\r\n            dot: this.dot,\r\n            input: this.input,\r\n        });\r\n    degree = () => this.a.length - 1;\r\n\r\n    valueAt = (t) => {\r\n        if (typeof t === \"number\") return Algebra.polynomialValueAt(this.a, t);\r\n        else if (t instanceof Complex) {\r\n            const n = this.a.length - 1;\r\n            if (n >= 0) {\r\n                let powerTerm = 1,\r\n                    result =\r\n                        this.a[n] instanceof Complex\r\n                            ? this.a[n].copy()\r\n                            : new Complex(this.a[n], 0);\r\n                for (let i = n - 1; i >= 0; i--) {\r\n                    powerTerm = t.multiply(powerTerm);\r\n                    result = result.add(powerTerm.multiply(this.a[i]));\r\n                }\r\n                return result;\r\n            }\r\n            return 0;\r\n        }\r\n        return NaN;\r\n    };\r\n\r\n    static Symbolic = (\r\n        degree,\r\n        symbol = \"t\",\r\n        halfTermsVisible = 2,\r\n        coef = \"a\",\r\n        inline = false\r\n    ) => {\r\n        let res = inline ? \"\" : \"$$\";\r\n        if (degree === \"n\") {\r\n            res += `${coef}_n ${symbol}^n + `;\r\n            for (let i = 1; i < halfTermsVisible; i++)\r\n                res += `${coef}_{n - ${i}}${symbol}^{n - ${i}} + `;\r\n            res += \" ... \";\r\n            for (let i = halfTermsVisible - 1; i > 0; i--)\r\n                res += ` + ${coef}_{${i}}${symbol}^{${i}}`;\r\n            res += ` + ${coef}_0`;\r\n        } else if (typeof degree === \"number\") {\r\n            for (; degree >= 0; degree--) {\r\n                res += `${coef}_{${degree}}`;\r\n                if (degree > 0) res += `${symbol}^{${degree}} + `;\r\n            }\r\n        }\r\n        return res + (inline ? \"\" : \" $$\");\r\n    };\r\n    derivative = (against = this.symbol) => {\r\n        const result = this.copy(true);\r\n        if (against === this.symbol) {\r\n            if (!result.dot) {\r\n                const n = result.a.length - 1;\r\n                const da = Array(n).fill(0);\r\n                for (let i = n; i >= 1; i--) da[n - i] = i * result.a[n - i];\r\n                result.a = [...da];\r\n            }\r\n            if (result.plus) result.plus = result.plus.derivative();\r\n        }\r\n        return result;\r\n    };\r\n\r\n    expression = () => {\r\n        if (this.a instanceof Array) {\r\n            const n = this.a.length - 1;\r\n            if (\r\n                !n ||\r\n                !this.a.slice(0, n).filter((ci) => ci.toString() !== \"0\").length\r\n            )\r\n                return this.a[n].toString();\r\n            return this.a\r\n                .map((a_i, i) =>\r\n                    a_i\r\n                        ? Algebra.coefy(a_i, i, n) +\r\n                          (i < n\r\n                              ? this.symbol +\r\n                                (i < n - 1 ? \"^\" + (n - i).toString() : \"\")\r\n                              : \"\")\r\n                        : \"\"\r\n                )\r\n                .join(\"\"); // joins all the coefficients, symbols, etc all together as for polynomal functions\r\n        }\r\n        return this.a.toString();\r\n    };\r\n\r\n    devide = (operand) => {\r\n        if (operand instanceof Poly && this.symbol === operand.symbol) {\r\n            return new Fraction(this.getA(), operand.getA(), this.symbol);\r\n        }\r\n        if (operand === +operand) return this.multiply(1 / Number(operand));\r\n        else if(operand instanceof Algebra) return new Fraction(this.getA(), operand, this.symbol);\r\n        return this.copy();\r\n        // is it true??\r\n        // return super.devide();\r\n    };\r\n\r\n    // edit this function to remove unnecessary white spaces\r\n    toFormula = () => {\r\n        if (this.a instanceof Array) {\r\n            const n = this.a.length - 1;\r\n            if (\r\n                !n ||\r\n                !this.a.slice(0, n).filter((ci) => ci.toString() !== \"0\").length\r\n            )\r\n                return this.a[n].toString();\r\n            return this.a\r\n                .map((a_i, i) =>\r\n                    a_i\r\n                        ? Algebra.coefy(a_i, i, n) +\r\n                          (i < n\r\n                              ? this.symbol +\r\n                                (i < n - 1 ? \"^\" + (n - i).toString() : \"\")\r\n                              : \"\")\r\n                        : \"\"\r\n                )\r\n                .join(\"\"); // joins all the coefficients, symbols, etc all together as for polynomal functions\r\n        }\r\n        return this.a.toString();\r\n    };\r\n}\r\n","import StandardInputSignal from \"math/input-signals\";\r\nimport Poly from \"math/algebra/functions/poly\";\r\n\r\nexport class Step extends StandardInputSignal {\r\n    constructor(amplitude = 1, symbol = \"t\") {\r\n        super(amplitude, \"u\", symbol); // \\\\delta is the equivalent of small delta in mathjax\r\n    }\r\n    copy = () => new Step(this.amp, this.symbol);\r\n\r\n    $ = (t) => (t >= 0) * this.amp;\r\n}\r\n\r\nexport class Puls extends StandardInputSignal {\r\n    constructor(Delta = 1, amplitude = 1, symbol = \"t\") {\r\n        super(amplitude, \"\\\\sqcap\", symbol);\r\n        this.Delta = Delta;\r\n    }\r\n    copy = () => new Puls(this.Delta, this.amp, this.symbol);\r\n    $ = (t) => (t >= 0 && t <= this.Delta) * this.amp / this.Delta;\r\n}\r\n\r\nexport class Impact extends StandardInputSignal {\r\n    constructor(amplitude = 1, symbol = \"t\") {\r\n        super(amplitude, \"\\\\delta\", symbol); // \\\\delta is the equivalent of small delta in mathjax\r\n    }\r\n    copy = () => new Impact(this.amp, this.symbol);\r\n\r\n    $ = (t) => this.amp * (t === 0);\r\n}\r\n\r\nexport class Ramp extends Poly {\r\n    constructor(amplitude, symbol = \"t\") {\r\n        super([amplitude, 0], symbol);\r\n        this.amplitude = amplitude; // just for calculating the value of this\r\n        this.selfmultiply(Step());\r\n    }\r\n    copy = () => new Ramp(this.amplitude, this.symbol);\r\n\r\n    $ = (t) => (t >= 0) * t * this.amplitude;\r\n}\r\n\r\n\r\nexport class Parabolic extends Poly { //EDIT\r\n    constructor(amplitude, symbol = \"t\") {\r\n        super([amplitude, 0, 0], symbol);\r\n        this.amplitude = amplitude; // just for calculating the value of this\r\n        this.selfmultiply(Step());\r\n    }\r\n    copy = () => new Parabolic(this.amplitude, this.symbol);\r\n    $ = (t) => (t >= 0 ? t * this.amplitude : 0);\r\n}\r\n","import Algebra from \"../algebra/index\";\r\nimport { isDigit, precision, round } from \"math/calculus\";\r\nimport Complex from \"math/algebra/complex\";\r\nimport Poly from \"../algebra/functions/poly\";\r\nconst Algebrite = require(\"algebrite\");\r\n\r\nexport default class Equation {\r\n    static zeroPrecision = round(10 ** -precision.get());\r\n    constructor(exp, symbol = \"x\") {\r\n        if (exp instanceof Array) {\r\n            this.algebra = new Poly(exp);\r\n            this.symbol = symbol;\r\n            this.expression = \"\";\r\n            const n = exp.length - 1;\r\n            this.degree = n;\r\n            for (\r\n                let i = 0;\r\n                i < exp.length;\r\n                this.expression += Equation.GetAlgebriteTerm(\r\n                    n - i,\r\n                    exp[i],\r\n                    i,\r\n                    symbol\r\n                ),\r\n                    i++\r\n            );\r\n        } else if (typeof exp === \"string\") {\r\n            this.expression = exp;\r\n            this.algebra = null;\r\n            this.symbol = symbol;\r\n        } else if (exp instanceof Poly) {\r\n            this.expression = \"\";\r\n            this.algebra = exp.copy();\r\n            this.symbol = this.exp.symbol;\r\n            const expression = this.getA();\r\n            const n = expression.length - 1;\r\n            this.degree = n; // unknown\r\n            for (\r\n                let i = 0;\r\n                i < expression.length;\r\n                this.expression += Equation.GetAlgebriteTerm(\r\n                    n - i,\r\n                    expression[i],\r\n                    i,\r\n                    symbol\r\n                ),\r\n                    i++\r\n            );\r\n        } else if (exp instanceof Algebra) {\r\n            // THIS IS TEMPORARY\r\n            this.expression = exp.toString(); // wrong EDIT THIS LATER\r\n            this.algebra = exp.copy();\r\n            this.symbol = this.exp.symbol;\r\n            this.degree = undefined; // unknown\r\n        }\r\n        this.symbol = symbol;\r\n    }\r\n\r\n    static GetAlgebriteTerm = (termDegree, coef, index, symbol) => {\r\n        if (coef === +coef) {\r\n            // means that coef is not a string\r\n            const intExpI = coef | 0;\r\n            const symbolicPart =\r\n                termDegree > 0 ? `*${symbol}^${termDegree}` : \"\";\r\n            if (intExpI !== coef) {\r\n                // means that coef is a float number\r\n                Algebrite.run(`a${index} = ${coef}`);\r\n                return (coef >= 0 ? \"+\" : \"\") + `a${index}${symbolicPart}`;\r\n            } else\r\n                return (intExpI >= 0 ? \"+\" : \"\") + `${intExpI}${symbolicPart}`;\r\n        }\r\n        // here it means coef is a string like '11/2' or '1/4', ...\r\n        return `${coef}${symbol}^${termDegree}`;\r\n    };\r\n    solve = () => {\r\n        // for factorable equations use: algebrite.roots\r\n        let x = Algebrite.nroots(this.expression)\r\n            .toString()\r\n            .replaceAll(\"...\", \"\");\r\n        x = x.slice(1, x.length - 1);\r\n        x = x.split(\",\").filter((xi) => xi && xi !== \"\"); // now x is converted from a string to the array of x answers (as Numbers);\r\n        // edit string to array\r\n        return x.map((xi, i) => {\r\n            // let [real, image] = xi.split(/\\+|-/).filter((xi) => xi && xi !== \"\");\r\n            let separatorIndex = 1;\r\n            for (; separatorIndex < xi.length; separatorIndex++)\r\n                if (\r\n                    (xi[separatorIndex] === \"+\" ||\r\n                        xi[separatorIndex] === \"-\") &&\r\n                    isDigit(xi[separatorIndex - 1]) &&\r\n                    isDigit(xi[separatorIndex + 1])\r\n                )\r\n                    break;\r\n\r\n            let terms = [];\r\n            terms.push(xi.slice(0, separatorIndex));\r\n            if (separatorIndex < xi.length)\r\n                terms.push(xi.slice(separatorIndex, xi.length - 2));\r\n            \r\n            if (terms.length === 1) {\r\n                const magnitude = terms[0].replace(\"*i\", \"\");\r\n                return magnitude === terms[0]\r\n                    ? new Complex(Number(magnitude))\r\n                    : new Complex(0, Number(magnitude));\r\n            } else return new Complex(Number(terms[0]), Number(terms[1]));\r\n        });\r\n    };\r\n\r\n    // AlgebraRoots = () => {\r\n    //     // convert roots returning string to\r\n    //     if (!this.roots || this.roots.length === 0) this.solve();\r\n    // };\r\n\r\n    approximate = (\r\n        method = Equation.Methods.newton,\r\n        N = 10,\r\n        boundary = 1000\r\n    ) => {\r\n        const allRoots = [];\r\n        // newton reaches to approx fast\r\n        // so N = 10 is enough (?????)\r\n        const isUnique = (newRoot) =>\r\n            !isNaN(newRoot) &&\r\n            allRoots.findIndex((rt) =>\r\n                !(rt instanceof Complex) ? rt === newRoot : rt.equals(newRoot)\r\n            ) === -1;\r\n        const isUniqueComplex = (newRoot) =>\r\n            newRoot instanceof Complex &&\r\n            allRoots.findIndex((rt) => newRoot.equals(rt)) === -1;\r\n\r\n        if (this.expression instanceof Algebra) {\r\n            let a0 = 0;\r\n            for (let i = this.expression.a.length - 1; i >= 0; i--)\r\n                if (this.expression.a[i]) {\r\n                    a0 = this.expression.a[i];\r\n                    break;\r\n                }\r\n            const an = this.expression.a[0];\r\n\r\n            if (a0 && an !== 0) boundary = Math.abs(a0 / an);\r\n\r\n            for (let x0 = -boundary; x0 <= boundary; x0++) {\r\n                let x = method(this.algebra, x0, N);\r\n                if (!isNaN(x)) {\r\n                    const rx = round(x);\r\n                    if (isUnique(rx)) allRoots.push(rx);\r\n                }\r\n                x = method(this.algebra, new Complex(0, x0), N);\r\n                if (isUniqueComplex(x)) allRoots.push(x);\r\n            }\r\n        }\r\n        return allRoots;\r\n    };\r\n    // approximation methods\r\n    durandKerner = (N = 20) => {\r\n        if (this.algebra instanceof Algebra) {\r\n            const f = this.algebra.$;\r\n            const n = this.algebra.degree();\r\n            let guess;\r\n            do {\r\n                guess = new Complex(Math.random(), Math.random());\r\n            } while (guess.isReal());\r\n            const roots = Array(n)\r\n                .fill(0)\r\n                .map((_) => []);\r\n\r\n            roots[0].push(new Complex(1, 0));\r\n            for (let i = 1; i < n; i++)\r\n                roots[i][0] = guess.multiply(roots[i - 1][0]);\r\n            for (let iter = 0; iter < N; iter++) {\r\n                for (let i = 0; i < n; i++) {\r\n                    const xiN = roots[i][iter].copy();\r\n                    let sndTermDen = new Complex(1, 0);\r\n                    for (let j = 0; j < n; j++) {\r\n                        if (i !== j) {\r\n                            const xjN = roots[j][roots[j].length - 1];\r\n                            sndTermDen = sndTermDen.multiply(\r\n                                xiN.substract(xjN)\r\n                            );\r\n                        }\r\n                    }\r\n                    let sndTerm = f(xiN).devide(sndTermDen);\r\n                    // USING PUSH MAY SLOW DOWN THE ALGORITHM\r\n                    roots[i].push(xiN.substract(sndTerm));\r\n                }\r\n            }\r\n            return roots.map((r) => r[r.length - 1]);\r\n        }\r\n    };\r\n\r\n    static Methods = {\r\n        // needs work!\r\n        newton: (algebraf, x0 = 0, N = 20) => {\r\n            const f = algebraf.$;\r\n            const df = algebraf.derivative().$;\r\n            const xs = Array(N + 1).fill(0);\r\n            const dfx0 = df(x0);\r\n            if (dfx0 && (!(dfx0 instanceof Complex) || !dfx0.isZero())) {\r\n                if (x0 instanceof Complex) {\r\n                    xs[0] = x0;\r\n                    for (let i = 0; i < N; i++) {\r\n                        // const dfxsi = df(xs[i]);\r\n                        xs[i + 1] = xs[i].substract(f(xs[i]).devide(df(xs[i])));\r\n                    }\r\n\r\n                    const fx = f(xs[N]);\r\n                    if (\r\n                        Math.abs(fx.real()) > Equation.zeroPrecision ||\r\n                        Math.abs(fx.imaginary()) > Equation.zeroPrecision\r\n                    )\r\n                        return NaN;\r\n                } else {\r\n                    xs[0] = x0;\r\n\r\n                    for (let i = 0; i < N; i++) {\r\n                        xs[i + 1] = xs[i] - f(xs[i]) / df(xs[i]);\r\n                    }\r\n\r\n                    if (f(xs[N]) > Equation.zeroPrecision) return NaN;\r\n                }\r\n                //integrity check!\r\n                return xs[xs.length - 1];\r\n            }\r\n            return NaN;\r\n        },\r\n        // needs work!\r\n        middlePoint: (\r\n            f,\r\n            boundary = 1000\r\n            // decimalPrecision = precision.get()\r\n        ) => {\r\n            // NOTE: works fine for some equations\r\n            // and wronge for some others like:  x ** 2 - 4*x  - 5\r\n            boundary = Math.abs(boundary);\r\n            const expectedRate = Equation.zeroPrecision;\r\n            const poles = [];\r\n            let xa = 0,\r\n                xb = 1;\r\n            for (let i = 0; i < boundary; i++) {\r\n                xa = -boundary + i;\r\n                xb = boundary - i;\r\n\r\n                let rate =\r\n                    (xb - xa) / (2 * Math.max(Math.abs(xa), Math.abs(xb)));\r\n                let p = null;\r\n                while (rate >= expectedRate) {\r\n                    p = (xa + xb) / 2;\r\n                    if (!f(p)) break;\r\n                    else if (f(p) * f(xa) < 0) xb = p;\r\n                    else {\r\n                        xa = p;\r\n                        rate =\r\n                            (xb - xa) /\r\n                            (2 * Math.max(Math.abs(xa), Math.abs(xb)));\r\n                    }\r\n                }\r\n                if (!f(p)) poles.push(round(p));\r\n            }\r\n            return new Set(poles);\r\n        },\r\n    };\r\n}\r\n","import Algebra from \"math/algebra\";\r\nimport { isDigit } from \"math/calculus\";\r\nimport Complex from \"math/algebra/complex\";\r\nconst nerdamer = require(\"nerdamer/all.min\");\r\n\r\nexport default class Formula {\r\n    constructor(mathPhrase, symbol = null, expressions = null) {\r\n        /// all type of parameters must be converted to an string mathPhrases (f)\r\n        if (mathPhrase instanceof Algebra) {\r\n            this.f = mathPhrase.toFormula();\r\n            this.symbol = mathPhrase.symbol;\r\n        } else if (typeof mathPhrase === \"string\") {\r\n            this.f = mathPhrase;\r\n            this.symbol = symbol;\r\n        }\r\n        this.expressions = expressions ? expressions : nerdamer(this.f); // normally its the nerdamer expressions\r\n    }\r\n\r\n    // differentiate function\r\n    df = (against = this.symbol) => {\r\n        const expressions = nerdamer.diff(this.f, against);\r\n        return new Formula(expressions.toString(), this.symbol, expressions);\r\n    };\r\n    iL = (timeSymbol = \"t\") => {\r\n        // inverse laplace transform\r\n        const expressions = nerdamer(\r\n            `ilt(${this.f}, ${this.symbol}, ${timeSymbol})`\r\n        );\r\n        return new Formula(expressions.toString(), timeSymbol, expressions);\r\n    };\r\n\r\n    L = (frequencySymbol = \"s\") => {\r\n        // laplace\r\n        const expressions = nerdamer(\r\n            `laplace(${this.f}, ${this.symbol}, ${frequencySymbol})`\r\n        );\r\n        return new Formula(\r\n            expressions.toString(),\r\n            frequencySymbol,\r\n            expressions\r\n        );\r\n    };\r\n\r\n    $ = (t = undefined) => {\r\n        // returns the containing f as a normal funtion or single value in a certain point\r\n        // get value at certain point\r\n        const knownVariables = [];\r\n        knownVariables[this.symbol] = t;\r\n        return t\r\n            ? nerdamer(this.f, { ...knownVariables })\r\n                  .evaluate()\r\n                  .toDecimal()\r\n            : nerdamer(this.f).toDecimal();\r\n    };\r\n\r\n    // solve equations\r\n    x = () => {\r\n        // nerdamer.solveEquations(this.f, this.symbol);\r\n\r\n        let roots = nerdamer(this.f)\r\n            .solveFor(this.symbol)\r\n            .map((ri) =>\r\n                (!ri.toString().includes(\"sqrt\")\r\n                    ? ri\r\n                    : ri.evaluate()\r\n                ).toDecimal()\r\n            );\r\n        //roots = roots.split(\",\").filter((ri) => ri && ri !== \"\"); // now x is converted from a string to the array of x answers (as +s);\r\n        // edit string to array\r\n        return roots.map((ri, i) => {\r\n            // let [real, image] = ri.split(/\\+|-/).filter((ri) => ri && ri !== \"\");\r\n            let separatorIndex = 1;\r\n            for (; separatorIndex < ri.length; separatorIndex++)\r\n                if (\r\n                    (ri[separatorIndex] === \"+\" ||\r\n                        ri[separatorIndex] === \"-\") &&\r\n                    (isDigit(ri[separatorIndex - 1]) ||\r\n                        ri[separatorIndex - 1] === \"i\") &&\r\n                    (isDigit(ri[separatorIndex + 1]) ||\r\n                        ri[separatorIndex + 1] === \"i\")\r\n                )\r\n                    break;\r\n\r\n            let terms = [];\r\n            terms.push(ri.slice(0, separatorIndex));\r\n            if (separatorIndex < ri.length)\r\n                terms.push(ri.slice(separatorIndex, ri.length));\r\n\r\n            if (terms.length === 1) {\r\n                const magnitude = terms[0].replace(\"*i\", \"\").replace(\"i\", \"1\");\r\n                return magnitude === terms[0]\r\n                    ? new Complex(+magnitude)\r\n                    : new Complex(0, +magnitude);\r\n            } else {\r\n                let b = terms[1].replace(\"*i\", \"\").replace(\"i\", \"1\");\r\n                if (b !== terms[1]) return new Complex(+terms[0], +b);\r\n                // if not, means the first term was image\r\n                b = terms[0].replace(\"*i\", \"\").replace(\"i\", \"1\");\r\n                return new Complex(+terms[1], +b);\r\n            }\r\n        });\r\n    };\r\n    toString = () => nerdamer(this.f).toTeX();\r\n\r\n    toAlgebra = () => {\r\n        if (this.expressions instanceof Algebra) return this.expressions.copy();\r\n    };\r\n    static GetTerm = (termDegree, coef, symbol) => {\r\n        if (coef === +coef) {\r\n            // means that coef is not a string\r\n            const symbolicPart =\r\n                termDegree > 0 ? `*${symbol}^${termDegree}` : \"\";\r\n            return (coef >= 0 ? \"+\" : \"\") + `${coef}${symbolicPart}`;\r\n        }\r\n        // here it means coef is a string like '11/2' or '1/4', ...\r\n        return `${coef}${symbol}^${termDegree}`;\r\n    };\r\n\r\n    static RepetitiveFactors = (f, roots, symbol) => {\r\n        const fullRoots = [...roots];\r\n        for (const root of roots) {\r\n            const knowns = [];\r\n            knowns[symbol] = root.toString(false, true).replace(\"j\", \"i*\");\r\n            for (\r\n                let fi = nerdamer.diff(f);\r\n                !+nerdamer(fi, {...knowns}).toDecimal();\r\n                fullRoots.push(root.copy()), fi = nerdamer.diff(fi)\r\n            );\r\n        }\r\n        return fullRoots;\r\n    };\r\n}\r\n","import Algebra from \"math/algebra\";\n\nexport default class Zero extends Algebra {\n    constructor(params) {\n        // ke^ct\n        super(0, { symbol: null, type: \"poly\"});\n    }\n\n    degree = () => 0;\n\n    valueAt = (t) => 0;\n\n    toString = () => {\n        let str = \"0\";\n        if (this.plus) str = this.plus.toString();\n\n        return str;\n    };\n    devide = (operand) => new Zero();\n\n    add = (operand) => operand.hardcopy().linkPlus(this.plus);\n\n    multiply = (operand) => new Zero();\n\n    replace = (operand) => {\n        this.a = operand.getA();\n        this.b = operand.getB();\n        this.teta = operand.getTeta();\n        this.symbol = operand.getSymbol();\n        this.type = operand.getType();\n        this.dot = operand.dot.copy();\n    };\n}\n","import Algebra from \"../index\";\r\nimport Complex from \"../complex\";\r\nimport Exp from \"./exp\";\r\nimport Fraction from \"./fraction\";\r\nimport { Step } from \"math/input-signals/signals\";\r\nimport Poly from \"./poly\";\r\nimport { Cos, Sin } from \"./trigonometric\";\r\nimport { round } from \"math/calculus/index\";\r\nimport Equation from \"math/solvers/equation\";\r\nimport { makeProgress } from \"toolshed\";\r\nimport Formula from \"math/solvers/formula\";\r\nimport Zero from \"./zero\";\r\nimport { min } from \"../../calculus/index\";\r\n\r\nexport default class TransferFunction extends Fraction {\r\n    static Shortcuts = {\r\n        $1: (k, a) =>\r\n            new TransferFunction([k], [1, a]).setRoots([], [-a]).setOrder(1),\r\n        $2: (k, a, b = a instanceof Complex ? a.conjugate : a) => {\r\n            // k / (s + a)(s + b) => must be converted to => k / (s2 + 2(a+b)s + ab)\r\n            let aplusb =\r\n                a instanceof Algebra\r\n                    ? a.add(b)\r\n                    : b instanceof Algebra\r\n                    ? b.add(a)\r\n                    : b + a;\r\n            let ab =\r\n                a instanceof Algebra\r\n                    ? a.multiply(b)\r\n                    : b instanceof Algebra\r\n                    ? b.multiply(a)\r\n                    : b * a;\r\n            if (aplusb instanceof Complex && aplusb.isReal())\r\n                aplusb = aplusb.real();\r\n            if (ab instanceof Complex && ab.isReal()) ab = ab.real();\r\n\r\n            return new TransferFunction(\r\n                [k],\r\n                [1, aplusb instanceof Algebra ? aplusb.negation() : -aplusb, ab]\r\n            )\r\n                .setRoots([], [a, b])\r\n                .setOrder(2);\r\n        },\r\n        $WnZ: (w_n, zeta) => new TransferFunction(null, null, { w_n, zeta }),\r\n        $design: (t_rise, overshoot) =>\r\n            new TransferFunction(null, null, { overshoot, t_rise }),\r\n\r\n        $PID: (Kp, Ti, Td) =>\r\n            Ti !== 0\r\n                ? new TransferFunction([Kp * Ti * Td, Kp * Ti, Kp], [Ti, 0])\r\n                : new TransferFunction([Kp * Td, Kp], [1]),\r\n        $Roots: (zeros, poles) => {\r\n            let num = new Poly([1], \"s\"),\r\n                den = new Poly([1], \"s\");\r\n            for (let i = 0; i < zeros.length; i++) {\r\n                if (zeros[i] instanceof Complex)\r\n                    num = num.multiply(new Poly([1, zeros[i].negation()], \"s\"));\r\n                else {\r\n                    num = num.multiply(new Poly([1, -zeros[i]], \"s\"));\r\n                    zeros[i] = new Complex(zeros[i], 0);\r\n                }\r\n            }\r\n            for (let i = 0; i < poles.length; i++) {\r\n                if (poles[i] instanceof Complex)\r\n                    den = den.multiply(new Poly([1, poles[i].negation()], \"s\"));\r\n                else {\r\n                    den = den.multiply(new Poly([1, -poles[i]], \"s\"));\r\n                    poles[i] = new Complex(poles[i], 0);\r\n                }\r\n            }\r\n            return num.devide(den).toTransferFunction().setRoots(zeros, poles);\r\n        },\r\n        $DelayedIntegrator: (amplitude, delay, degree) =>\r\n            // k / (s + a) ^ n : k =amplitude, a = delay, n = degree\r\n            // new TransferFunction(amplitude, [new Poly([1, delay], \"s\"), ...Array(degree).fill(0)])\r\n            new TransferFunction(1, [1, delay])\r\n                .raise(degree)\r\n                .multiply(amplitude),\r\n    };\r\n\r\n    static RootOrders = (Roots) => {\r\n        Roots = Roots.sort((p1, p2) => p1.real() - p2.real());\r\n        const orders = [];\r\n        for (let i = 0; i < Roots.length; i++) {\r\n            let j = i + 1,\r\n                order = 1;\r\n            for (; j < Roots.length && Roots[i].equals(Roots[j]); j++, order++);\r\n            orders.push({ value: Roots[i], order });\r\n            i = j - 1;\r\n        }\r\n        return orders;\r\n    };\r\n\r\n    getSimplifiedRoots = () => {\r\n        let temp = this.copy();\r\n        for (let i = 0; i < temp.zeros.length; i++) {\r\n            temp.zeros[i] = temp.zeros[i] instanceof Complex ? temp.zeros[i] : new Complex(temp.zeros[i], 0);\r\n            const pi = temp.poles.findIndex((p) => temp.zeros[i].equals(p));\r\n            if (pi !== -1) {\r\n                // temp.zeros.splice(i, 1);\r\n                // temp.poles.splice(pi, 1);\r\n                temp.zeros[i] = null;\r\n                temp.poles[pi] = null;\r\n            }\r\n        }\r\n        return [temp.zeros.filter((zi) => zi), temp.poles.filter((pi) => pi)];\r\n    };\r\n\r\n    getSimplifiedOrderedRoots = () => {\r\n        let temp = this.copy();\r\n        for (let i = 0; i < temp.orderedZeros.length; i++) {\r\n            const pi = temp.orderedPoles.findIndex((p) =>\r\n                p.value.equals(temp.orderedZeros[i].value)\r\n            );\r\n            if (pi !== -1) {\r\n                const minOrder = min(temp.orderedZeros[i].order, pi.order);\r\n                temp.orderedZeros[i].order -= minOrder;\r\n                temp.orderedPoles[pi].order -= minOrder;\r\n            }\r\n        }\r\n        return [\r\n            temp.orderedZeros.filter((zi) => zi.order),\r\n            temp.orderedPoles.filter((pi) => pi.order),\r\n        ];\r\n    };\r\n\r\n    static OmegaZetaPoles = (w_n, zeta) => {\r\n        if (Math.abs(zeta) >= 1) {\r\n            const alpha = -zeta * w_n;\r\n            const beta = w_n * (zeta * zeta - 1) ** 0.5;\r\n            return [alpha + beta, alpha - beta];\r\n        }\r\n        const alpha = -zeta * w_n;\r\n        const beta = w_n * (1 - zeta * zeta) ** 0.5;\r\n        return [new Complex(alpha, beta), new Complex(alpha, -beta)];\r\n    };\r\n    constructor(numerator, denominator, params = {}) {\r\n        let zeros = [],\r\n            poles = [];\r\n        if (params) {\r\n            if (params.overshoot && params.t_rise) {\r\n                params.overshoot = Number(params.overshoot);\r\n                params.t_rise = Number(params.t_rise);\r\n                const logMp = Math.log10(params.overshoot);\r\n                params.zeta =\r\n                    -logMp / (Math.PI * Math.PI + logMp * logMp) ** 0.5;\r\n                params.w_d = Math.PI / params.t_rise;\r\n                params.w_n =\r\n                    params.w_d / (1 - params.zeta * params.zeta) ** 0.5;\r\n            }\r\n\r\n            if (params.w_n) {\r\n                params.w_n = Number(params.w_n);\r\n                params.zeta = Number(params.zeta);\r\n                // if the user sends w_n params it will override the given zero/pole list\r\n                const { w_n, zeta } = params;\r\n                const wn2 = w_n * w_n;\r\n                numerator = wn2;\r\n                denominator = [1, 2 * zeta * w_n, wn2];\r\n                poles = TransferFunction.OmegaZetaPoles(w_n, zeta);\r\n                zeros = [];\r\n            }\r\n        }\r\n        super(numerator, denominator, \"s\", params);\r\n        // SIMPL;IFY\r\n        this.poles = [...poles]; //edit solve equations\r\n        this.zeros = [...zeros];\r\n        if (!this.a instanceof Array) this.a = [this.a];\r\n        if (this.a.length === 1 && !this.w_n) {\r\n            if (\r\n                this.b.length === 3 &&\r\n                this.b[this.b.length - 1] === this.a[0]\r\n            ) {\r\n                this.w_n = this.a[0];\r\n                this.zeta = this.b[1] / (2 * this.w_n);\r\n                this.timeConstant = round(1 / (this.zeta * this.w_n));\r\n                this.t_settle = 4 * this.timeConstant;\r\n                if (params && params.w_d) this.w_d = params.w_d;\r\n                else if (this.zeta >= -1 && this.zeta <= 1)\r\n                    this.w_d = this.w_n * (1 - this.zeta ** 2) ** 0.5;\r\n                this.order = 2;\r\n                this.setRoots(\r\n                    [],\r\n                    TransferFunction.OmegaZetaPoles(this.w_n, this.zeta)\r\n                );\r\n            }\r\n        }\r\n        if (!this.order)\r\n            this.order =\r\n                denominator instanceof Array ? denominator.length - 1 : 1;\r\n        if (params.overshoot && params.t_rise) {\r\n            [this.overshoot, this.t_rise] = [params.overshoot, params.t_rise];\r\n        } else {\r\n            const dampingCharasteristics =\r\n                this.getDampingSystemCharasteristics();\r\n            if (dampingCharasteristics) {\r\n                this.overshoot = dampingCharasteristics.overshoot;\r\n                this.t_rise = dampingCharasteristics.t_rise;\r\n            }\r\n        }\r\n        if (\r\n            (!this.zeros || !this.zeros.length) &&\r\n            (!this.poles || !this.poles.length)\r\n        )\r\n            this.updateRoots();\r\n    }\r\n\r\n    roots = () => {\r\n        // roots hasnt been decided by user\r\n        let zeros = [],\r\n            poles = [];\r\n        if (\r\n            this.a instanceof Array &&\r\n            this.b instanceof Array && // if all elements of numerator and denominator are actual numbers\r\n            !this.a.find((ai) => ai !== +ai) &&\r\n            !this.b.find((bi) => bi !== +bi)\r\n        ) {\r\n            // CONSTANT COEFFICIENT POLYNOMIAL EQUATIONS\r\n            zeros =\r\n                this.a.length > 1\r\n                    ? new Formula(this.numerator().toFormula(), this.symbol).x()\r\n                    : // ? new Equation(this.a, this.symbol).solve()\r\n                      [];\r\n            poles =\r\n                this.b.length > 1\r\n                    ? new Formula(\r\n                          this.denominator().toFormula(),\r\n                          this.symbol\r\n                      ).x()\r\n                    : //? new Equation(this.b, this.symbol).solve()\r\n                      [];\r\n            if (zeros.length < this.a.length - 1) {\r\n                zeros = Formula.RepetitiveFactors(\r\n                    this.numerator().toFormula(),\r\n                    zeros,\r\n                    this.symbol\r\n                );\r\n            }\r\n            if (poles.length < this.b.length - 1) {\r\n                poles = Formula.RepetitiveFactors(\r\n                    this.denominator().toFormula(),\r\n                    poles,\r\n                    this.symbol\r\n                );\r\n            }\r\n        } else {\r\n            // if the equation isnt a simple constant coefficient polynomial\r\n        }\r\n\r\n        return [zeros, poles];\r\n    };\r\n\r\n    setRoots = (zeros, poles) => {\r\n        this.poles = poles\r\n            .map((pi) =>\r\n                pi instanceof Complex ? pi.copy() : new Complex(pi, 0)\r\n            )\r\n            .sort((p1, p2) => p1.real() - p2.real());\r\n        this.zeros = zeros\r\n            .map((zi) =>\r\n                zi instanceof Complex ? zi.copy() : new Complex(zi, 0)\r\n            )\r\n            .sort((z1, z2) => z1.real() - z2.real());\r\n        this.orderedZeros = TransferFunction.RootOrders(this.zeros);\r\n        this.orderedPoles = TransferFunction.RootOrders(this.poles);\r\n        return this;\r\n    };\r\n\r\n    updateRoots = () => {\r\n        const [zeros, poles] = this.roots();\r\n        return this.setRoots(zeros, poles);\r\n    };\r\n    getDampingSystemCharasteristics = () =>\r\n        this.w_d\r\n            ? {\r\n                  t_rise: round(Math.PI / this.w_d),\r\n                  // WHAT IF W_D === 0?\r\n                  overshoot:\r\n                      this.zeta >= -1 && this.zeta <= 1\r\n                          ? round(\r\n                                100 *\r\n                                    Math.exp(\r\n                                        -(this.zeta * Math.PI) /\r\n                                            (1 - this.zeta ** 2) ** 0.5\r\n                                    )\r\n                            )\r\n                          : null,\r\n              }\r\n            : null;\r\n\r\n    getOrder = () => this.order;\r\n    setOrder = (order) => {\r\n        this.order = order;\r\n        return this;\r\n    };\r\n    getPoles = () => this.poles;\r\n    setPoles = (poles) => {\r\n        this.poles = TransferFunction.map((pi) =>\r\n            pi instanceof Complex ? pi.copy() : new Complex(pi, 0)\r\n        );\r\n        return this;\r\n    };\r\n    getZeros = () => this.zeros;\r\n    setZeros = (zeros) => {\r\n        this.zeros = zeros.map((zi) =>\r\n            zi instanceof Complex ? zi.copy() : new Complex(zi, 0)\r\n        );\r\n        return this;\r\n    };\r\n\r\n    poleOrder = (pole) =>\r\n        this.poles.filter((pi) => Algebra.areTheseTwoEqual(pole, pi)).length;\r\n\r\n    derivative = (against = this.symbol) => {\r\n        let result = this.copy(true);\r\n        if (against === this.symbol) {\r\n            const rplus = result.plus;\r\n            if (!result.dot) {\r\n                const f = this.numerator(),\r\n                    g = this.denominator();\r\n                const num = f\r\n                    .derivative()\r\n                    .multiply(g)\r\n                    .substract(g.derivative().multiply(f));\r\n                result = num.devide(g.multiply(g)).toTransferFunction();\r\n            }\r\n            if (rplus) result.plus = rplus.derivative();\r\n        }\r\n        return result;\r\n    };\r\n    laplace = () => this.copy(); // actually it has no laplace, this is for disfunctioning the laplace method in the parent class Algebra\r\n    laplaceInverse = () => {\r\n        this.updateRoots();\r\n        const f_s = this.simplify();\r\n        console.log(f_s.isIntegrator())\r\n        if (f_s.isIntegrator()) {\r\n            const denCoef = f_s.b.filter((bi) => bi !== 0)[0];\r\n            return {\r\n                $s: f_s.copy(),\r\n                $t: Poly.atn(\r\n                    (f_s.a instanceof Array ? f_s.a[0] : f_s.a) / denCoef,\r\n                    f_s.denominator().degree() - 1\r\n                ).setInputSignal(new Step()),\r\n            };\r\n        }\r\n        const coefs = [];\r\n        const zeros = f_s.orderedZeros,\r\n            poles = f_s.orderedPoles; // shortcuts\r\n        for (let i = 0; i < poles.length; i++) {\r\n            // for(let j  = 0; j < poles[i].order; i++)\r\n            const s = poles[i].value;\r\n            const otherPoles = [...poles];\r\n            otherPoles.splice(i, 1);\r\n            const num =\r\n                    zeros.length > 0\r\n                        ? Complex.MultiplyFactors(zeros, s)\r\n                        : new Complex(1, 0),\r\n                den = Complex.MultiplyFactors(otherPoles, s);\r\n            coefs.push(num.devide(den));\r\n            if (poles[i].order > 1) {\r\n                coefs[i] = [coefs[i]];\r\n                let dF = TransferFunction.Shortcuts.$Roots(\r\n                    zeros.map((z) => z.value),\r\n                    otherPoles.map((p) => p.value)\r\n                );\r\n                let factoriel = 1;\r\n                for (let q = 1; q < poles[i].order; q++) {\r\n                    dF = dF.derivative();\r\n                    let coef = dF.$(s);\r\n                    coef =\r\n                        coef instanceof Complex ? coef : new Complex(coef, 0);\r\n                    factoriel *= q;\r\n                    coefs[i].push(coef.devide(factoriel));\r\n                }\r\n            }\r\n        }\r\n        // edit THIIIIIIIIIIIIIS\r\n        let g_s = new Zero(),\r\n            c_t = new Zero();\r\n        for (let i = 0; i < coefs.length; i++) {\r\n            if (coefs[i] instanceof Array && poles[i].order > 1) {\r\n                const n = poles[i].order;\r\n                for (let q = 0; q < n; q++) {\r\n                    g_s = g_s.add(\r\n                        TransferFunction.Shortcuts.$DelayedIntegrator(\r\n                            coefs[i][q].actual(),\r\n                            poles[i].value.negation().actual(),\r\n                            n - q\r\n                        )\r\n                    );\r\n                    // const ap = [coefs[i][q].actual()];\r\n                    // for(let k = 0; k < poles[i].order - q - 1; k++)\r\n                    //     ap.push(0);\r\n                    const ap = Poly.atn(\r\n                        coefs[i][q].actual(),\r\n                        poles[i].order - q - 1\r\n                    );\r\n                    c_t = !poles[i].value.isZero()\r\n                        ? c_t.add(\r\n                              new Exp(ap, poles[i].value.actual(), \"t\", {\r\n                                  input: new Step(),\r\n                              })\r\n                          )\r\n                        : c_t.add(ap).multiply(new Step());\r\n                }\r\n            } else {\r\n                g_s = g_s.add(\r\n                    new TransferFunction(coefs[i].actual(), [\r\n                        1,\r\n                        poles[i].value.negation().actual(),\r\n                    ])\r\n                );\r\n                c_t = c_t.add(\r\n                    !poles[i].value.isZero()\r\n                        ? new Exp(\r\n                              coefs[i].actual(),\r\n                              poles[i].value.actual(),\r\n                              \"t\",\r\n                              { input: new Step() }\r\n                          )\r\n                        : new Poly(coefs[i].actual(), \"t\", {\r\n                              input: new Step(),\r\n                          })\r\n                );\r\n            }\r\n        }\r\n        return { $s: g_s, $t: c_t };\r\n    };\r\n\r\n    stepify = () => {\r\n        const lstep = this.copy();\r\n        lstep.b.push(0); //update denominator\r\n        lstep.poles.push(new Complex(0, 0));\r\n        return lstep;\r\n    };\r\n    step = () => {\r\n        // normally will automatically return the time domain answer\r\n        // unless inLaplaceDomain is true\r\n        // PUT INPUT SIGNAL AT THE END\r\n        const m = this.zeros.length; // number of zeros\r\n        const n = this.poles.length; // number of poles\r\n        const nreal = this.poles.filter(\r\n            (pi) => !(pi instanceof Complex) || pi.isReal()\r\n        ).length; // number of real poles; can be eig   her 2 or 0\r\n        if (m === 0) {\r\n            const k = this.numerator();\r\n            if (n === 0) {\r\n                // return u(t)\r\n                // DEFINE U(T) IN ALGEBRA\r\n            }\r\n            if (n === 1) {\r\n            } else if (n === 2) {\r\n                const a = -this.poles[0],\r\n                    b = -this.poles[1];\r\n                if (nreal === 2) {\r\n                    // if (a > 0 && b > 0) {\r\n                    if (a !== b)\r\n                        // two independent polesdddd\r\n                        // two negative independent poles\r\n                        return new Exp(1 / a, -a)\r\n                            .add(new Exp(-1 / b, -b))\r\n                            .multiply(k / (a - b))\r\n                            .multiply(new Step())\r\n                            .add(new Step(k / (a * b)));\r\n                    else {\r\n                        const a2 = a * a;\r\n                        return new Exp(-k / a2, -a)\r\n                            .multiply(new Poly([a, 1]))\r\n                            .multiply(new Step())\r\n                            .add(new Step(k / a2));\r\n                    }\r\n                    // } else {\r\n                    //     // repetetive poles\r\n                    // }\r\n                } else if (nreal === 0) {\r\n                    // two conjugated complex poles\r\n                    //UNDERSHOOT BUG FIXLAYS HERE\r\n                    const a = -this.poles[0].real(),\r\n                        b = this.poles[0].imaginary();\r\n                    const ka2b2 = k / (a ** 2 + b ** 2);\r\n                    // FIND BUUUUUUG\r\n                    // return new Exp(-ka2b2, -a)\r\n                    //     .multiply(new Cos(1, b).add(new Sin(a / b, b)))\r\n                    //     .multiply(new Step())\r\n                    //     .add(new Step(ka2b2));\r\n                    return new Exp(-ka2b2, -a)\r\n                        .multiply(new Cos(1, b))\r\n                        .add(new Exp(-ka2b2, -a).multiply(new Sin(a / b, b)))\r\n                        .multiply(new Step())\r\n                        .add(new Step(ka2b2));\r\n                }\r\n                // else if( nreal == 1) // this cant happen, but what if sth went wrong?\r\n            }\r\n        }\r\n        // if its not in special mode:\r\n        return new Formula(this.stepify().toFormula(), this.symbol).iL();\r\n    };\r\n    copy = (\r\n        linkPrevious = false // copy everything\r\n    ) =>\r\n        new TransferFunction(this.a, this.b, {\r\n            overshoot: this.overshoot,\r\n            t_rise: this.t_rise,\r\n            t_settle: this.t_settle,\r\n            w_d: this.w_d,\r\n            timeConstant: this.timeConstant,\r\n            w_n: this.w_n,\r\n            zeta: this.zeta,\r\n            dot: this.dot,\r\n            plus: this.plus,\r\n            previous: linkPrevious ? this.previous : null,\r\n            input: this.input,\r\n        }).setRoots(this.zeros, this.poles);\r\n\r\n    hardcopy = () =>\r\n        // shallow-singleterm copy\r\n        new TransferFunction(this.a, this.b, {\r\n            dot: this.dot,\r\n            input: this.input,\r\n        });\r\n    lim = (s0) => {\r\n        let num, den;\r\n        // for simple polynomial numerator and denominator fractions\r\n        // IMPLEMENT HOPITAL AS WELL?\r\n        if (!s0) {\r\n            // s -> 0)\r\n\r\n            num = { a: 0, sp: this.a.length - 1 };\r\n            den = { b: 1, sp: this.b.length - 1 };\r\n            for (; num.sp > 0 && this.a[num.sp] === 0; num.sp--);\r\n            num.a = this.a[num.sp];\r\n            for (; den.sp > 0 && this.b[den.sp] === 0; den.sp--);\r\n            den.b = this.b[den.sp];\r\n            num.sp = this.a.length - num.sp - 1;\r\n            den.sp = this.b.length - den.sp - 1;\r\n            if (num.sp === den.sp) return num.a / den.b;\r\n            else {\r\n                const sMinPower = Math.min(den.sp, num.sp);\r\n                if (sMinPower) {\r\n                    num.sp -= sMinPower;\r\n                    den.sp -= sMinPower;\r\n                }\r\n                // now one of num.sp or den.sp is zero\r\n                if (den.sp)\r\n                    // zero on denominator\r\n                    return Infinity;\r\n                // if den.sp == 0 and num.sp != 0\r\n                return 0;\r\n            }\r\n        } else if (s0 === Infinity) {\r\n            // s -> infinity\r\n            num = { a: 0, sp: 0 };\r\n            den = { b: 1, sp: 0 };\r\n            for (; num.sp < this.a.length && this.a[num.sp] === 0; num.sp++);\r\n            num.a = this.a[num.sp];\r\n            for (; den.sp < this.b.length && this.b[den.sp] === 0; den.sp++);\r\n            den.b = this.b[den.sp];\r\n            num.sp = this.a.length - num.sp - 1;\r\n            den.sp = this.b.length - den.sp - 1;\r\n            if (num.sp === den.sp) return num.a / den.b;\r\n            // else\r\n            const sMinPower = Math.min(den.sp, num.sp);\r\n            if (sMinPower) {\r\n                num.sp -= sMinPower;\r\n                den.sp -= sMinPower;\r\n            }\r\n            // now one of num.sp or den.sp is zero\r\n            if (den.sp)\r\n                // zero on denominator\r\n                return 0;\r\n            // if den.sp == 0 and num.sp != 0\r\n            return Infinity;\r\n        } else {\r\n            // if s0 is just a no-zero limited number\r\n            num = this.numerator().$(s0);\r\n            den = this.denominator().$(s0);\r\n            if (den)\r\n                // simple non zero denominator limit\r\n                return num / den;\r\n            // if den == 0\r\n            // use Hopital or other limit methods\r\n            //return (num.a * (s0 ** num.sp)) / (den.b * (s0 ** den.sp));\r\n        }\r\n    };\r\n    errors = () => {\r\n        const sGs = this.multiply(new Poly([1, 0], \"s\"));\r\n        const s2Gs = sGs.multiply(new Poly([1, 0], \"s\"));\r\n        return {\r\n            Ks: round(this.lim(0)),\r\n            Kr: round(sGs.lim(0)),\r\n            Ka: round(s2Gs.lim(0)),\r\n        };\r\n    };\r\n    // $ = (t) => this.laplaceInverse().$(t); // valueOf function in certain point; I used character $ in many places as,\r\n    // acronym for \"set\" in setters, so $ here means that set the t ( or x or whatever) with a certain point\r\n\r\n    amplitude = (w) => {\r\n        // w === omega\r\n        const jw = new Complex(0, w);\r\n        const num = this.numerator(),\r\n            den = this.denominator();\r\n        const numAmp = !(num instanceof Exp)\r\n                ? num.$(jw).magnitude()\r\n                : Math.abs(num.getA()),\r\n            denAmp = !(den instanceof Exp)\r\n                ? den.$(jw).magnitude()\r\n                : Math.abs(den.getB());\r\n        return numAmp / denAmp;\r\n        // this is for find exact match of the devide function\r\n        // but im sure num and den are Complex so i directly stated the result\r\n\r\n        // if(num instanceof Complex)\r\n        //     return num.magnitude() / (den instanceof Complex ? den.magnitude : den).magnitude();\r\n        // if(den instanceof Complex)\r\n        //     return num instanceof Algebra ? num.devide(den.magnitude()) : num / den.magnitude();\r\n        // if(num instanceof Algebra)\r\n        //     return num.devide(den);\r\n        // if(den instanceof Algebra)\r\n        //     return den.devideInverse(num);\r\n        // // signal input?\r\n        // if(den)\r\n        //     return num / den;\r\n        // return NaN;\r\n    };\r\n\r\n    phase = (w) => {\r\n        const jw = new Complex(0, w);\r\n        let num = this.numerator(),\r\n            den = this.denominator();\r\n        const numPhase = !(num instanceof Exp)\r\n                ? num.$(jw).phase()\r\n                : num.phase(w), //exponentials have their own shortcut for phase()\r\n            denPhase = !(den instanceof Exp) ? den.$(jw).phase() : den.phase(w);\r\n        if (+denPhase === denPhase && +numPhase === numPhase)\r\n            return numPhase - denPhase;\r\n        // for now Complex.phase() returns numbers or functions:\r\n        // numPhase or denPhase instanceof Function then:\r\n        return (\r\n            (numPhase instanceof Function ? numPhase(w) : numPhase) -\r\n            (denPhase instanceof Function ? denPhase(w) : denPhase)\r\n        );\r\n        // else if(numPhase instanceof Algebra)\r\n        //     return numPhase.$(w) - den.phase();\r\n        // return NaN;\r\n    };\r\n\r\n    static PolarToComplex = (A, phi) =>\r\n        new Complex(A * Math.cos(phi), A * Math.sin(phi));\r\n    nyquist = (w, method = \"complex\") =>\r\n        method === \"complex\"\r\n            ? this.$(new Complex(0, w))\r\n            : TransferFunction.PolarToComplex(this.amplitude(w), this.phase(w));\r\n\r\n    bode = (w) => 20 * Math.log10(this.amplitude(w));\r\n\r\n    toFormula = () => {\r\n        // const [zeros, poles] = this.repetitiveRoots();\r\n        const num =\r\n            this.zeros.length > 0\r\n                ? this.zeros\r\n                      .map(\r\n                          (zi) =>\r\n                              \"(\" +\r\n                              this.symbol +\r\n                              \" - \" +\r\n                              zi.toString(false, true).replace(\"j\", \"i*\") +\r\n                              \")\"\r\n                      )\r\n                      .join(\"*\")\r\n                : \"1\";\r\n        const den =\r\n            this.poles.length > 0\r\n                ? this.poles\r\n                      .map(\r\n                          (pi) =>\r\n                              \"(\" +\r\n                              this.symbol +\r\n                              \" - \" +\r\n                              pi.toString(false, true).replace(\"j\", \"i*\") +\r\n                              \")\"\r\n                      )\r\n                      .join(\"*\")\r\n                : \"1\";\r\n        return `(${num})/(${den})`;\r\n    };\r\n\r\n    // ****************************************************** //\r\n    // SOLVE THIS WITH nerdamer again\r\n    rootLocus = async (k_min, k_max, progressBarObject, N = 1000) => {\r\n        // return root locus values for plotting\r\n\r\n        // TEMPORARY:\r\n        let dk = (k_max - k_min) / N;\r\n        const a = this.getA(), // numerator\r\n            b = this.getB(); // denominator => a / b\r\n        const na = a.length - 1,\r\n            nb = b.length - 1;\r\n        const reals = [],\r\n            imaginaries = [];\r\n        const progressLength = k_max - k_min;\r\n        const newTerm = Formula.GetTerm; // Equation.GetAlgebriteTerm;\r\n        for (let k = k_min, progress = 0; k <= k_max; k += dk, progress += dk) {\r\n            // in this piece: using short form codes and using objects is set to minimum\r\n            // because root locus is time consuming and putting all the codes in one main loop is better\r\n            // const delta = b.add(a.multiply(k));\r\n            let delta = null,\r\n                expression = \"\";\r\n            // USE ARRAY DIRECT PROCESS FOR FASTER RESPONSE\r\n            // NUM + K * DEN\r\n            if (na <= nb) {\r\n                delta = Array(nb);\r\n                const offsetB = nb - na;\r\n                for (\r\n                    let i = 0;\r\n                    i < offsetB;\r\n                    delta[i] = b[i],\r\n                        expression += newTerm(nb - i, delta[i], this.symbol),\r\n                        i++\r\n                );\r\n                for (\r\n                    let i = 0, ib = offsetB;\r\n                    i <= na;\r\n                    delta[ib] = b[ib] + k * a[i],\r\n                        expression += newTerm(na - i, delta[ib], this.symbol),\r\n                        i++,\r\n                        ib++\r\n                );\r\n            } else {\r\n                delta = Array(na);\r\n                const offsetA = na - nb;\r\n                for (\r\n                    let i = 0;\r\n                    i < offsetA;\r\n                    delta[i] = b[i],\r\n                        expression += newTerm(na - i, delta[i], this.symbol),\r\n                        i++\r\n                );\r\n                for (\r\n                    let i = 0, ib = offsetA;\r\n                    i <= nb;\r\n                    delta[ib] = b[ib] + k * a[i],\r\n                        expression += newTerm(nb - i, delta[ib], this.symbol),\r\n                        i++,\r\n                        ib++\r\n                );\r\n            }\r\n            const poles = new Formula(expression, this.symbol).x();\r\n            await makeProgress(\r\n                progressBarObject,\r\n                (100 * progress) / progressLength\r\n            );\r\n\r\n            for (let i = 0; i < poles.length; i++) {\r\n                if (poles[i] instanceof Complex) {\r\n                    reals.push(poles[i].real());\r\n                    imaginaries.push(poles[i].imaginary());\r\n                } else {\r\n                    reals.push(poles[i]);\r\n                    imaginaries.push(0);\r\n                }\r\n            }\r\n        }\r\n        await makeProgress(progressBarObject, 100);\r\n        return [reals, imaginaries];\r\n    };\r\n\r\n    rootsByAlgebriteLocus = async (\r\n        k_min,\r\n        k_max,\r\n        progressBarObject,\r\n        N = 1000\r\n    ) => {\r\n        // return root locus values for plotting\r\n\r\n        // TEMPORARY:\r\n        let dk = (k_max - k_min) / N;\r\n        const a = this.getA(), // numerator\r\n            b = this.getB(); // denominator => a / b\r\n        const na = a.length - 1,\r\n            nb = b.length - 1;\r\n        const reals = [],\r\n            imaginaries = [];\r\n        const progressLength = k_max - k_min;\r\n        const newTerm = Equation.GetAlgebriteTerm;\r\n        for (let k = k_min, progress = 0; k <= k_max; k += dk, progress += dk) {\r\n            // in this piece: using short form codes and using objects is set to minimum\r\n            // because root locus is time consuming and putting all the codes in one main loop is better\r\n            // const delta = b.add(a.multiply(k));\r\n            let delta = null,\r\n                expression = \"\";\r\n            // USE ARRAY DIRECT PROCESS FOR FASTER RESPONSE\r\n            // NUM + K * DEN\r\n            if (na <= nb) {\r\n                delta = Array(nb);\r\n                const offsetB = nb - na;\r\n                for (\r\n                    let i = 0;\r\n                    i < offsetB;\r\n                    delta[i] = b[i],\r\n                        expression += newTerm(nb - i, delta[i], i, this.symbol),\r\n                        i++\r\n                );\r\n                for (\r\n                    let i = 0, ib = offsetB;\r\n                    i <= na;\r\n                    delta[ib] = b[ib] + k * a[i],\r\n                        expression += newTerm(\r\n                            na - i,\r\n                            delta[ib],\r\n                            ib,\r\n                            this.symbol\r\n                        ),\r\n                        i++,\r\n                        ib++\r\n                );\r\n            } else {\r\n                delta = Array(na);\r\n                const offsetA = na - nb;\r\n                for (\r\n                    let i = 0;\r\n                    i < offsetA;\r\n                    delta[i] = b[i],\r\n                        expression += newTerm(na - i, delta[i], i, this.symbol),\r\n                        i++\r\n                );\r\n                for (\r\n                    let i = 0, ib = offsetA;\r\n                    i <= nb;\r\n                    delta[ib] = b[ib] + k * a[i],\r\n                        expression += newTerm(\r\n                            nb - i,\r\n                            delta[ib],\r\n                            ib,\r\n                            this.symbol\r\n                        ),\r\n                        i++,\r\n                        ib++\r\n                );\r\n            }\r\n            // const roots = new Equation(new Poly(delta)).roots();\r\n            const poles = new Equation(expression).solve();\r\n\r\n            await makeProgress(\r\n                progressBarObject,\r\n                (100 * progress) / progressLength\r\n            );\r\n\r\n            for (let i = 0; i < poles.length; i++) {\r\n                if (poles[i] instanceof Complex) {\r\n                    reals.push(poles[i].real());\r\n                    imaginaries.push(poles[i].imaginary());\r\n                } else {\r\n                    reals.push(poles[i]);\r\n                    imaginaries.push(0);\r\n                }\r\n            }\r\n        }\r\n        await makeProgress(progressBarObject, 100);\r\n        return [reals, imaginaries];\r\n    };\r\n\r\n    controlFeedback = (controller) => {\r\n        const cs_gs = this.multiply(controller);\r\n        return cs_gs\r\n            .numerator()\r\n            .devide(cs_gs.numerator().add(cs_gs.denominator()))\r\n            .toTransferFunction();\r\n    };\r\n\r\n    isIntegrator = () =>\r\n        !this.dot\r\n            ? (typeof this.a === \"number\" ||\r\n                  (this.a.length === 1 && typeof this.a[0] === \"number\")) &&\r\n              this.b[this.b.length - 1] === 0 &&\r\n              this.b.filter((bi) => bi !== 0).length === 1 &&\r\n              !this.plus &&\r\n              !this.previous\r\n            : this.copy().linkDot(null).multiply(this.dot).isIntegrator();\r\n\r\n    simplify = () => {\r\n        const [zeros, poles] = this.getSimplifiedRoots();\r\n        console.log(\"simpled: \", zeros,poles);\r\n        return TransferFunction.Shortcuts.$Roots(zeros, poles);\r\n    };\r\n}\r\n","import Algebra from \"math/algebra\";\r\nimport Complex from \"math/algebra/complex\";\r\nimport Exp from \"./exp\";\r\nimport Fraction from \"./fraction\";\r\n\r\nexport class Sin extends Algebra {\r\n    constructor(A, w, teta = 0, symbol = \"t\", params = {}) {\r\n        // Ae^wt\r\n        if (w === +w && w < 0) {\r\n            w *= -1;\r\n            A *= -1;\r\n        }\r\n        super(A, { symbol, type: \"sin\", b: w, teta, ...params });\r\n    }\r\n    copy = (\r\n        linkPrevious = false // deep copy; copy everything\r\n    ) =>\r\n        new Sin(this.a, this.b, this.teta, this.symbol, {\r\n            dot: this.dot,\r\n            plus: this.plus,\r\n            previous: linkPrevious ? this.previous : null,\r\n            input: this.input,\r\n        });\r\n    hardcopy = () =>\r\n        // shallow copy; copy signle term\r\n        new Sin(this.a, this.b, this.teta, this.symbol, {\r\n            dot: this.dot,\r\n            input: this.input,\r\n        });\r\n    toExp = () => {\r\n        const sin = this.copy();\r\n        const exp1 = new Exp(sin.a / 2, new Complex(0, -sin.b));\r\n        const exp2 = new Exp(-sin.a / 2, new Complex(0, sin.b));\r\n        return new Complex(0, exp1.add(exp2));\r\n    };\r\n\r\n    valueAt = (t) => {\r\n        const A = Algebra.valueOf(this.a, t);\r\n        const w = Algebra.valueOf(this.b, t);\r\n        const teta = Algebra.valueOf(this.teta, t);\r\n        return A * Math.sin(w * t + teta);\r\n    };\r\n}\r\n\r\nexport class Cos extends Algebra {\r\n    constructor(A, w, teta = 0, symbol = \"t\", params = {}) {\r\n        // Ae^wt\r\n        if (+w === w && w < 0) w *= -1; // cos(-w) = cos(w);\r\n        super(A, { symbol, type: \"cos\", b: w, teta, ...params });\r\n    }\r\n    copy = (linkPrevious = false) =>\r\n        new Cos(this.a, this.b, this.teta, this.symbol, {\r\n            dot: this.dot,\r\n            plus: this.plus,\r\n            previous: linkPrevious ? this.previous : null,\r\n            input: this.input,\r\n        });\r\n    hardcopy = () =>\r\n        // shallow copy; copy signle term\r\n        new Cos(this.a, this.b, this.teta, this.symbol, {\r\n            dot: this.dot,\r\n            input: this.input,\r\n        });\r\n    toExp = () => {\r\n        const cos = this.copy();\r\n        const exp1 = new Exp(cos.a / 2, new Complex(0, cos.b));\r\n        const exp2 = new Exp(cos.a / 2, new Complex(0, -cos.b));\r\n        return exp1.add(exp2);\r\n    };\r\n\r\n    valueAt = (t) => {\r\n        const A = Algebra.valueOf(this.a, t);\r\n        const w = Algebra.valueOf(this.b, t);\r\n        const teta = Algebra.valueOf(this.teta, t);\r\n        return A * Math.cos(w * t + teta);\r\n    };\r\n}\r\n\r\nexport class Tan extends Algebra {\r\n    constructor(A, w, teta = 0, symbol = \"t\", params = {}) {\r\n        // Ae^wt\r\n        super(A, { symbol, type: \"tan\", b: w, teta, ...params });\r\n    }\r\n    copy = (linkPrevious = false) =>\r\n        new Tan(this.a, this.b, this.teta, this.symbol, {\r\n            dot: this.dot,\r\n            plus: this.plus,\r\n            previous: linkPrevious ? this.previous : null,\r\n            input: this.input,\r\n        });\r\n    hardcopy = () =>\r\n        // shallow copy; copy signle term\r\n        new Tan(this.a, this.b, this.teta, this.symbol, {\r\n            dot: this.dot,\r\n            input: this.input,\r\n        });\r\n    toExp = () => {\r\n        const tan = this.copy();\r\n        const exp1 = new Exp(1, new Complex(0, -tan.b));\r\n        const numeratorExp2 = new Exp(-1, new Complex(0, tan.b));\r\n        const denominatorExp2 = new Exp(1, new Complex(0, tan.b));\r\n        return new Fraction(exp1.add(numeratorExp2), exp1.add(denominatorExp2));\r\n    };\r\n\r\n    valueAt = (t) => {\r\n        const A = Algebra.valueOf(this.a, t);\r\n        const w = Algebra.valueOf(this.b, t);\r\n        const teta = Algebra.valueOf(this.teta, t);\r\n        return A * Math.tan(w * t + teta);\r\n    };\r\n}\r\n\r\nexport class Cot extends Algebra {\r\n    constructor(A, w, teta = 0, symbol = \"t\", params = {}) {\r\n        // Ae^wt\r\n        super(A, { symbol, type: \"cot\", b: w, teta, ...params });\r\n    }\r\n    copy = (linkPrevious = false) =>\r\n        new Cot(this.a, this.b, this.teta, this.symbol, {\r\n            dot: this.dot,\r\n            plus: this.plus,\r\n            previous: linkPrevious ? this.previous : null,\r\n            input: this.input,\r\n        });\r\n    hardcopy = () =>\r\n        // shallow copy; copy signle term\r\n        new Cot(this.a, this.b, this.teta, this.symbol, {\r\n            dot: this.dot,\r\n            input: this.input,\r\n        });\r\n    toExp = () => {\r\n        const cot = this.copy();\r\n        const exp1 = new Exp(1, new Complex(0, -cot.b));\r\n        const numeratorExp2 = new Exp(-1, new Complex(0, cot.b));\r\n        const denominatorExp2 = new Exp(1, new Complex(0, cot.b));\r\n        return new Fraction(exp1.add(denominatorExp2), exp1.add(numeratorExp2));\r\n    };\r\n\r\n    valueAt = (t) => {\r\n        const A = Algebra.valueOf(this.a, t);\r\n        const w = Algebra.valueOf(this.b, t);\r\n        const teta = Algebra.valueOf(this.teta, t);\r\n        return A * Math.cot(w * t + teta);\r\n    };\r\n}\r\n","import { error_codes } from \"config\";\r\n\r\nexport default class NotScalarError extends Error {\r\n    \r\n    constructor(cause = null){ // the parameter with problem\r\n        super(cause ? `${cause} => این عبارت باید اسکالر باشد!!` : \"این خطا بدلیل استفاده از یک عبارت غیر اسکالر در مکان غیر مجاز رخ داده است!\")\r\n        this.name = \"NotNumberError\";\r\n        this.type = \"Numeric\";\r\n        this.code = error_codes.not_scalar;\r\n        this.cause = cause;\r\n    }\r\n\r\n    describe = () => {\r\n        console.log(this.message + (this.cause ? \"\\n\" + this.cause : \"\"));\r\n        return this.message + (this.cause ? \"\\n\" + this.cause.toString() : \"\");\r\n    }\r\n}","import NotScalarError from \"errors/algebra/NotScalarError\";\r\nimport StandardInputSignal from \"math/input-signals\";\r\nimport { round, strictPrecisionFormat } from \"../calculus\";\r\n\r\nclass Algebra {\r\n    // symbolic expressions\r\n    constructor(\r\n        a,\r\n        { symbol = \"t\", type = \"poly\", b, dot, plus, teta = 0, previous, input }\r\n    ) {\r\n        // dot is the interface between terms\r\n        // g(t) = a * f(t) * {dot: as Algebra}\r\n        // teta is the offset for wt + alpha in sin/cos/tan/..\r\n\r\n        this.symbol = symbol;\r\n        this.type = type.toLowerCase();\r\n        this.setA(a).setB(b).setTeta(teta);\r\n\r\n        this.input = input; // u(t), r(t), puls, ...\r\n        if (dot) {\r\n            this.dot = dot.copy();\r\n        } // multiply a Algebra from different type into 'this'\r\n\r\n        if (plus) {\r\n            this.plus = plus.copy();\r\n            this.removeZeros();\r\n        } // add another Algebra with different type to this one\r\n\r\n        this.previous = previous; // the previous term in the chained Algebra objects\r\n        // term.plus => next term, term.previous => previous term, term.dot => an algebra from another type that is multiplied to actual term\r\n        // F(u) = a.f(u).dot(u) + term.plus(u)\r\n        this.link();\r\n    }\r\n    static identify = (parameter) => {\r\n        if (parameter instanceof Array)\r\n            return parameter.map((pi) =>\r\n                pi instanceof Algebra || pi instanceof StandardInputSignal\r\n                    ? pi.copy()\r\n                    : round(pi)\r\n            );\r\n        else if (parameter instanceof Algebra) {\r\n            return parameter.copy();\r\n        } else if (typeof parameter === \"number\") return round(parameter);\r\n        else if (typeof parameter === \"string\") return parameter;\r\n        else if (!parameter) return 0;\r\n        throw new NotScalarError(parameter);\r\n    };\r\n    setA = (a) => {\r\n        this.a = Algebra.identify(a);\r\n        return this;\r\n    };\r\n    getA = () => this.a;\r\n    getSymbol = () => this.symbol;\r\n    setB = (b) => {\r\n        this.b = Algebra.identify(b);\r\n        return this;\r\n    };\r\n    getB = () => this.b;\r\n\r\n    setTeta = (teta) => {\r\n        this.teta = Algebra.identify(teta);\r\n        return this;\r\n    };\r\n    getTeta = () => this.teta;\r\n    getType = () => this.type;\r\n\r\n    linkPlus = (plus) => {\r\n        this.plus = plus;\r\n        return this;\r\n    };\r\n    linkDot = (dot) => {\r\n        this.dot = dot;\r\n        return this;\r\n    };\r\n\r\n    setInputSignal = (input) => {\r\n        this.input = input;\r\n        return this;\r\n    };\r\n    // CONNECT AND LINK METHODS, FIND FIRST TERM AND LAST TERM AND ...\r\n    end = () => {\r\n        // returns the end term in the algebratic chain\r\n        let last = this;\r\n        while (last.plus) last = last.plus;\r\n        return last;\r\n    };\r\n\r\n    first = () => {\r\n        // returns the first term in the algebratic chain\r\n        let fst = this;\r\n        while (fst.previous) fst = fst.previous;\r\n        return fst;\r\n    };\r\n\r\n    enddot = () => {\r\n        // returns the end term in the algebratic chain\r\n        let last = this;\r\n        while (last.dot) last = last.dot;\r\n        return last;\r\n    };\r\n\r\n    firstdot = () => {\r\n        // returns the first term in the algebratic chain\r\n        let fst = this;\r\n        // WRONG *****************************\r\n        //while (fst.previous) fst = fst.previous;\r\n        return fst;\r\n    };\r\n    link = () => {\r\n        // some times .previous links are broken; so i decided to write this method just to make sure everything is connected\r\n        let term = this.first();\r\n        if (!term) term = this; // in case this.first() returns wrong answer\r\n        while (term.plus) {\r\n            if (term.plus) term.plus.previous = term;\r\n            term = term.plus; // go to next term in the chain\r\n        }\r\n        return this;\r\n    };\r\n\r\n    copy = (linkPrevious = false) =>\r\n        new Algebra(this.a, {\r\n            type: this.type,\r\n            b: this.b,\r\n            dot: this.dot,\r\n            plus: this.plus,\r\n            symbol: this.symbol,\r\n            teta: this.teta,\r\n            input: this.input,\r\n            previous: linkPrevious ? this.previous : null,\r\n        });\r\n\r\n    // SORT THE MULTIPLIERD TERMS ( TERMS CONNECTED WITH this.dot) IN A SPECIFIC ORDER (FOR BETTER SHOW AND COMPARE AND ETC.)\r\n    // LOOK HERE IT STILL HAS BUGS\r\n    sort = () => {\r\n        // sort .dot in special order: poly - exp - frac - ...\r\n        const orders = [\"poly\", \"exp\", \"frac\"];\r\n        let position = this;\r\n        for (const order of orders) {\r\n            while (position) {\r\n                let func = position.dot;\r\n                while (func) {\r\n                    if (func.type === order && !position.isPrior(order)) {\r\n                        const temp = position.copy();\r\n                        position.a =\r\n                            func.a instanceof Array ? [...func.a] : func.a;\r\n                        position.type = func.type;\r\n                        position.symbol = func.symbol;\r\n                        if (func.b instanceof Array) position.b = [...func.b];\r\n                        else position.b = func.b;\r\n\r\n                        func.a = temp.a instanceof Array ? [...temp.a] : temp.a;\r\n                        func.type = temp.type;\r\n                        func.symbol = temp.symbol;\r\n                        if (temp.b instanceof Array) func.b = [...temp.b];\r\n                        else func.b = temp.b;\r\n                    }\r\n                    func = func.dot;\r\n                }\r\n                position = position.dot;\r\n            }\r\n        }\r\n    };\r\n\r\n    isPrior = (order) => {\r\n        const orders = [\"poly\", \"exp\", \"frac\"];\r\n        const thisValue = orders.findIndex((or) => or === this.type);\r\n        const orderValue = orders.findIndex((or) => or === order);\r\n        return thisValue <= orderValue;\r\n    };\r\n\r\n    // CHECK IF ONE TERMS CAN BE ADDED TO ANOTHER ONE (MEANING THEY HAVE SAME PARAMETRIC TERMS)\r\n    unifiable = (exp) => {\r\n        // check if this is unifiable with expression:exp\r\n        //this.sort();\r\n        //exp.sort();\r\n        if (exp && this.type === exp.type && this.symbol === exp.symbol) {\r\n            // check if this and exp are sumable\r\n            // check .dot s:\r\n            let isUnifiable = true;\r\n            if (this.dot || exp.dot)\r\n                isUnifiable = this.dot && this.dot.unifiable(exp.dot);\r\n\r\n            if (this.b instanceof Array && exp.b instanceof Array) {\r\n                if (this.b.length === exp.b.length) {\r\n                    const sameOnes = this.b.filter(\r\n                        (item, idx) => item === exp.b[idx]\r\n                    );\r\n                    return isUnifiable && this.b.length === sameOnes.length;\r\n                }\r\n            } else if (this.b instanceof Algebra)\r\n                return isUnifiable && this.b.equals(exp.b);\r\n            return isUnifiable && exp.b === this.b;\r\n        }\r\n        return false;\r\n    };\r\n\r\n    static valueOf = (x, t = 0) => {\r\n        if (x) {\r\n            let value = 0;\r\n            if (x instanceof Algebra || x instanceof StandardInputSignal)\r\n                value = x.$(t);\r\n            else if (x instanceof Array)\r\n                value = Algebra.polynomialValueAt(x, t);\r\n            else value = x;\r\n            return value;\r\n        }\r\n        return 0;\r\n    };\r\n\r\n    static polynomialValueAt = (arr, t) => {\r\n        let value = 0;\r\n        const n = arr.length - 1;\r\n        for (let i = 0; i <= n; i++) {\r\n            value += arr[i] * t ** (n - i);\r\n        }\r\n        return value;\r\n    };\r\n    // REMOVE REDUNDANT TERMS, SIGNS AND ETC.\r\n    removeZeros = () => {\r\n        let term = this.first();\r\n        while (term) {\r\n            if (term instanceof Algebra) {\r\n                if (\r\n                    term.a === 0 ||\r\n                    Algebra.polynomial(term.a, term.symbol) === 0\r\n                ) {\r\n                    if (term.previous) {\r\n                        term.previous.plus = term.plus;\r\n                    } else {\r\n                        // remove first term and transfer the second term to first one\r\n                        if (this === term) term.redundant = true;\r\n                        if (term.plus) {\r\n                            term = term.plus.copy(true);\r\n                            if (term.plus) {\r\n                                term.plus = term.plus.plus;\r\n                                if (term.plus) term.plus.previous = term;\r\n                            }\r\n                            term.previous = null;\r\n                        }\r\n                    }\r\n                    // }\r\n                }\r\n            }\r\n            term = term.plus;\r\n        }\r\n        return this;\r\n    };\r\n\r\n    $ = (t, params = { showSteps: false }) => {\r\n        // valueOf function in certain point\r\n        // I used character $ in many places as acronym for \"set\" in setters, so $ here means that set the t ( or x or whatever) with a certain point\r\n        // for each type just implement the method literally\r\n        if (params.showSteps) console.log(\"step: \", this);\r\n        let result = this.valueAt(t);\r\n        if (this.dot) result *= this.dot.$(t);\r\n        if (this.plus) result += this.plus.$(t);\r\n\r\n        return (!this.input ? 1 : this.input.$(t)) * result;\r\n    };\r\n\r\n    label = (name = undefined, index = undefined) =>\r\n        (name\r\n            ? name +\r\n              (index !== undefined ? \"_{\" + index + \"}\" : \"\") +\r\n              \"(\" +\r\n              this.symbol +\r\n              \") = \"\r\n            : \"\") + this.toString();\r\n\r\n    // RETURNS THE BEST AND SIMPLE AND SHORTEST WAY TO SHOW COEFFICIENTS\r\n    static coefy = (a_i, i, n) => {\r\n        if (a_i instanceof Algebra) {\r\n            let str = \"\";\r\n            let ai = a_i.copy();\r\n            if (i > 0) {\r\n                // write a method to edit all the + - occuring next to each other in toString()\r\n                if (ai.type === \"complex\" && +ai.a === ai.a) {\r\n                    if (ai.a < 0) {\r\n                        str += \" - \";\r\n                        ai.a *= -1;\r\n                    } else if (!ai.a) {\r\n                        ai.b = +ai.b;\r\n                        if (ai.b < 0) {\r\n                            str += \" - \";\r\n                            ai.b *= -1;\r\n                        } else str += \" + \";\r\n                    } else str += \" + \";\r\n                } else str += \" + \";\r\n            }\r\n            return str + ai.toString(i < n && a_i.hasMultiTerms());\r\n        }\r\n        if (a_i instanceof StandardInputSignal) {\r\n            //EDIT THIS PART TOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO\r\n            let str = i > 0 ? \" + \" : \"\";\r\n            return str + a_i.toString(i < n && a_i.hasMultiTerms());\r\n        } else {\r\n            if (n === 0) return strictPrecisionFormat(a_i);\r\n            if (a_i === 0) return \"\";\r\n            if (i !== 0) {\r\n                let s = \"\";\r\n                if (a_i < 0) {\r\n                    s += \" - \";\r\n                    a_i *= -1;\r\n                } else s += \" + \";\r\n\r\n                if (a_i === 1 && i < n) return s;\r\n                return s + strictPrecisionFormat(a_i);\r\n            }\r\n            if (a_i === 1) return \"\";\r\n            if (a_i === -1) return \"-\";\r\n\r\n            return strictPrecisionFormat(a_i);\r\n        }\r\n    };\r\n\r\n    // DECIPHER THE OBJECT TO ITS POLYNOMINAL FORM (IF IT IS ONE ACTUALLY)\r\n    static polynomial = (coefs, symbol) => {\r\n        if (coefs instanceof Array) {\r\n            const n = coefs.length - 1;\r\n            if(n < 0) return \"0\";\r\n            if (\r\n                !n ||\r\n                !coefs.slice(0, n).filter((ci) => ci.toString() !== \"0\").length\r\n            )\r\n                return coefs[n].toString();\r\n            return coefs\r\n                .map((a_i, i) =>\r\n                    a_i\r\n                        ? Algebra.coefy(a_i, i, n) +\r\n                          (i < n\r\n                              ? symbol +\r\n                                (i < n - 1\r\n                                    ? \"^{\" + (n - i).toString() + \"}\"\r\n                                    : \"\")\r\n                              : \"\")\r\n                        : \"\"\r\n                )\r\n                .join(\"\"); // joins all the coefficients, symbols, etc all together as for polynomal functions\r\n        }\r\n        return coefs.toString();\r\n    };\r\n\r\n    join = () => {\r\n        // connect this term to its next terms; considering the right use of + or -\r\n        if (this.plus) {\r\n            let operator = \"+\",\r\n                next = this.plus.copy();\r\n            if (next.a instanceof Array) {\r\n                if (next.a[0] < 0) {\r\n                    operator = \"-\";\r\n                    next.a[0] *= -1;\r\n                }\r\n            } else {\r\n                if (next.a < 0) {\r\n                    operator = \"-\";\r\n                    next.a *= -1;\r\n                }\r\n            }\r\n            return operator + next.toString();\r\n        }\r\n        return \"\";\r\n    };\r\n\r\n    hasMultiTerms = () => {\r\n        if (this.plus) return true;\r\n        if (this.a instanceof Array && this.type !== \"frac\")\r\n            return this.a.filter((ai) => ai !== 0).length > 1;\r\n        return false;\r\n    };\r\n    isTriangular = () =>\r\n        this.type === \"sin\" ||\r\n        this.type === \"cos\" ||\r\n        this.type === \"tan\" ||\r\n        this.type === \"cot\";\r\n\r\n    // MATHEMATICAL OPERATIONS\r\n    // static add = (expressions) => expressions.map((el) => el.toString()).join(\" + \");\r\n    add = (right) => {\r\n        // result = this + operand\r\n        let result = this.link().copy();\r\n        if (right instanceof Algebra) {\r\n            let operand = right.link().copy();\r\n\r\n            let x = result; // now we try to add each term with its unifiable term in y\r\n            while (x) {\r\n                let y = operand;\r\n                while (y) {\r\n                    if (x.unifiable(y)) {\r\n                        if (x.a instanceof Algebra) x.a = x.a.add(y.a);\r\n                        else if (y.a instanceof Algebra) x.a = y.a.add(x.a);\r\n                        // **************************************************\r\n                        // else if x.a || y.a instanceof StandardInputSignal\r\n                        // *********************************************\r\n                        else if (x.a instanceof Array) {\r\n                            if (y.a instanceof Array) {\r\n                                if (y.a.length > x.a.length) x.a = [...y.a];\r\n                                for (\r\n                                    let i = 1;\r\n                                    i <= y.a.length && i <= x.a.length;\r\n                                    i++\r\n                                )\r\n                                    x.a[x.a.length - i] += y.a[y.a.length - i];\r\n                            } else {\r\n                                x.a[x.a.length - 1] += y.a;\r\n                            }\r\n                        } else {\r\n                            x.a += y.a;\r\n                        }\r\n                        // remove the term in y that has been processed\r\n                        if (y.previous) {\r\n                            y.previous.plus = y.plus;\r\n                            if (y.plus) y.plus.previous = y.previous;\r\n                            y.a = 0;\r\n                        }\r\n\r\n                        // its the first term\r\n                        else operand = operand.plus;\r\n                        // after this the garbage collector will remove the term because it has no reference to it\r\n                    }\r\n                    y = y.plus;\r\n                }\r\n                // if(x.plus) x.plus.previous = x;\r\n                x = x.plus; // go to next term in the chain\r\n            }\r\n\r\n            if (operand) {\r\n                // if the above algorythm leaves operand with non-null value\r\n                /// it means there was terms in the operand's algebratic chain that are'nt unifiable with x terms\r\n                // so we must connect the leftovers to last terms of the result\r\n                if (Algebra.polynomial(result.a, result.symbol) !== \"0\") {\r\n                    if (\r\n                        Algebra.polynomial(operand.getA(), operand.symbol) !==\r\n                        \"0\"\r\n                    ) {\r\n                        let endTerm = result.end();\r\n                        endTerm.plus = operand;\r\n                        endTerm.plus.previous = result;\r\n                    }\r\n                } else result = operand.copy(); // connect to next term\r\n            }\r\n            return result.removeZeros();\r\n        } else if (right instanceof StandardInputSignal) {\r\n            const endTerm = result.end();\r\n            endTerm.plus = right.copy();\r\n            endTerm.plus.previous = endTerm;\r\n        }\r\n        return result;\r\n    };\r\n\r\n    arrangeDots = () => {\r\n        let term = this;\r\n        let input = null;\r\n        while (term.dot) {\r\n            // enhance the algo for cases that more than one input signal erxists in .dot chain\r\n            if (term.dot instanceof StandardInputSignal) {\r\n                input = term.dot;\r\n                term.dot = term.dot.dot;\r\n            }\r\n            if (term.dot) term = term.dot;\r\n        }\r\n        term.dot = input;\r\n    };\r\n    // INCOMPLETE ***********\r\n    multiply = (operand) => {\r\n        const y = this.copy().link();\r\n        if (operand instanceof Algebra) {\r\n            // operand algebra or complex\r\n            // ***** TODO:  ****************\r\n            if (operand.type === \"poly\") {\r\n                if (this.type === \"poly\" || this.type === \"frac\") {\r\n                    // NEEDS ERDITING for FRACTIONs\r\n                    if (this.symbol === operand.symbol) {\r\n                        const ao = operand.getA();\r\n                        const no = ao.length - 1;\r\n                        const As = [];\r\n                        for (let i = no; i >= 0; i--) {\r\n                            if (operand.a[i]) {\r\n                                const zeros = Array(no - i).fill(0);\r\n                                const a = [...y.a].map((yai) =>\r\n                                    yai instanceof Algebra\r\n                                        ? yai.multiply(operand.a[i])\r\n                                        : operand.a[i] instanceof Algebra\r\n                                        ? operand.a[i].multiply(yai)\r\n                                        : yai * operand.a[i]\r\n                                );\r\n                                a.push(...zeros);\r\n                                As.push(a);\r\n                            }\r\n                        }\r\n                        // now sum all the products\r\n                        let product = As.pop();\r\n                        for (let j = 0; j < As.length; j++)\r\n                            for (\r\n                                let i = 1;\r\n                                i <= As[j].length && i <= product.length;\r\n                                i++\r\n                            )\r\n                                if (\r\n                                    product[product.length - i] instanceof\r\n                                    Algebra\r\n                                )\r\n                                    product[product.length - i] = product[\r\n                                        product.length - i\r\n                                    ].add(As[j][As[j].length - i]);\r\n                                else if (\r\n                                    As[j][As[j].length - i] instanceof Algebra\r\n                                )\r\n                                    product[product.length - i] = As[j][\r\n                                        As[j].length - i\r\n                                    ].add(product[product.length - i]);\r\n                                else\r\n                                    product[product.length - i] +=\r\n                                        As[j][As[j].length - i];\r\n\r\n                        y.a = product;\r\n                        if (operand.dot) {\r\n                            // link dots ***IS THIS TRUE?>***\r\n                            const endDotTerm = y.enddot();\r\n                            endDotTerm.dot = operand.dot.copy(); // multiply\r\n                            endDotTerm.dot.previous = endDotTerm;\r\n                        }\r\n                    }\r\n                }\r\n            } else if (y.type !== operand.type && operand.plus) {\r\n                // like: exp(f(...)) * [Asin(...) * Bcos(...)]\r\n                // UPDATE SELF MULTIPLY AFTER SOLVING THIS ISSUE\r\n                y.plus = y.multiply(operand.plus.copy());\r\n                const lastyDot = y.enddot();\r\n                if (\r\n                    typeof y.a === \"number\" &&\r\n                    typeof operand.a === \"number\" &&\r\n                    operand.a !== 1\r\n                ) {\r\n                    y.a *= operand.a;\r\n                    operand.a = 1;\r\n                }\r\n                lastyDot.dot = operand.copy();\r\n                lastyDot.dot.previous = lastyDot;\r\n                // UPDATE SELF MULTIPLY AFTER SOLVING THIS ISSUE\r\n            } else {\r\n                const endDotTerm = y.enddot();\r\n                if (typeof y.a === \"number\" && typeof operand.a === \"number\") {\r\n                    y.a *= operand.a;\r\n                    operand.a = 1;\r\n                }\r\n                endDotTerm.dot = operand.copy(); // multiply\r\n                endDotTerm.dot.previous = endDotTerm;\r\n            }\r\n            if (y.plus) y.plus = y.plus.multiply(operand);\r\n            if (operand.plus) y.end().plus = y.multiply(operand.plus);\r\n            return y; // for now just to avoid crashes\r\n        } else if (operand instanceof StandardInputSignal) {\r\n            // const endDotTerm = y.enddot();\r\n            // endDotTerm.dot = operand.copy(); // multiply\r\n            // endDotTerm.dot.previous = endDotTerm;\r\n            y.input = operand.copy();\r\n            if (y.plus) y.plus = y.plus.multiply(operand);\r\n        } else {\r\n            // scalar multiply\r\n            if (operand instanceof Algebra) {\r\n            } else {\r\n                if (y.a instanceof Array) y.a = y.a.map((ai) => operand * ai);\r\n                else if (y.a instanceof Algebra) y.a = y.a.multiply(operand);\r\n                else y.a = y.a * operand;\r\n            }\r\n            if (y.plus) y.plus = y.plus.multiply(operand);\r\n        }\r\n        return y;\r\n    };\r\n\r\n    selfmultiply = (operand) => {\r\n        if (operand instanceof Algebra) {\r\n            // operand algebra or complex\r\n            // ***** TODO:  ****************\r\n            if (operand.type === \"poly\") {\r\n                if (this.type === \"poly\" || this.type === \"frac\") {\r\n                    // NEEDS ERDITING for FRACTIONs\r\n                    if (this.symbol === operand.symbol) {\r\n                        const ao = operand.getA();\r\n                        const no = ao.length - 1;\r\n                        const As = [];\r\n                        for (let i = no; i >= 0; i--) {\r\n                            if (ao[i]) {\r\n                                const zeros = Array(no - i).fill(0);\r\n                                const a = [...this.a].map(\r\n                                    (yai) => yai * operand[i]\r\n                                );\r\n                                a.push(...zeros);\r\n                                As.push(a);\r\n                            }\r\n                        }\r\n                        // now sum all the products\r\n                        const product = As.pop();\r\n                        for (let j = 0; j < As.length; j++)\r\n                            for (\r\n                                let i = 1;\r\n                                i <= As[j].length && i <= product.length;\r\n                                i++\r\n                            )\r\n                                product[product.length - i] +=\r\n                                    As[j][As[j].length - i];\r\n                        this.a = product;\r\n                        if (operand.dot) {\r\n                            // link dots ***IS THIS TRUE?>***\r\n                            const endDotTerm = this.enddot();\r\n                            endDotTerm.dot = operand.dot.copy(); // multiply\r\n                            endDotTerm.dot.previous = endDotTerm;\r\n                        }\r\n                    }\r\n                }\r\n            } else if (this.type !== operand.type && operand.plus) {\r\n                // like: exp(f(...)) * [Asin(...) * Bcos(...)]\r\n                // UPDATE SELF MULTIPLY AFTER SOLVING THIS ISSUE\r\n                this.plus = this.selfmultiply(operand.plus.copy());\r\n                const lastyDot = this.enddot();\r\n                if (\r\n                    typeof this.a === \"number\" &&\r\n                    typeof operand.a === \"number\" &&\r\n                    operand.a !== 1\r\n                ) {\r\n                    this.a *= operand.a;\r\n                    operand.a = 1;\r\n                }\r\n                lastyDot.dot = operand.copy();\r\n                lastyDot.dot.previous = lastyDot;\r\n                // UPDATE SELF MULTIPLY AFTER SOLVING THIS ISSUE\r\n            } else {\r\n                const endDotTerm = this.enddot();\r\n                if (\r\n                    typeof this.a === \"number\" &&\r\n                    typeof operand.a === \"number\"\r\n                ) {\r\n                    this.a *= operand.a;\r\n                    operand.a = 1;\r\n                }\r\n                endDotTerm.dot = operand.copy(); // multiply\r\n                endDotTerm.dot.previous = endDotTerm;\r\n            }\r\n            if (this.plus) this.plus.selfmultiply(operand);\r\n            // if (operand.plus) this.end().plus = this.selfmultiply(operand.plus);\r\n        } else if (operand instanceof StandardInputSignal) {\r\n            // this.dot = operand.copy(); // multiply\r\n            // this.dot.previous = this;\r\n            this.input = operand.copy();\r\n            if (this.plus) this.plus.selfmultiply(operand);\r\n            if (operand.plus) this.end().plus = this.multiply(operand.plus);\r\n        } else {\r\n            // scalar multiply\r\n            if (this.a instanceof Array)\r\n                this.a = this.a.map((ai) => operand * ai);\r\n            else this.a *= operand;\r\n\r\n            if (this.plus) this.plus.selfmultiply(operand);\r\n        }\r\n    };\r\n\r\n    raise = (degree = 1) => {\r\n        if (degree === 0) return new Algebra(1, { symbol: null });\r\n        let negative = false;\r\n        if (degree < 0) {\r\n            negative = true;\r\n            degree *= -1;\r\n        }\r\n        let result = this.copy();\r\n        for (let i = 1; i < degree; i++) result = result.multiply(this);\r\n        return !negative ? result : result.devideInverse(1);\r\n    };\r\n    negation = () => this.multiply(-1);\r\n\r\n    substract = (operand) => this.add(operand.negation());\r\n\r\n    devide = (operand) => {\r\n        if (operand === +operand)\r\n            // scaler\r\n            return this.multiply(1 / +operand);\r\n        // u need to handle Complex objects as Algebra using their type to recognize them\r\n        if (operand instanceof Algebra) {\r\n            if (operand.type === \"poly\" && this.symbol === operand.symbol) {\r\n                return new Algebra(this.getA(), {\r\n                    type: \"frac\",\r\n                    b: operand.getA(),\r\n                    symbol: this.symbol,\r\n                });\r\n            }\r\n            return this.copy(); // for now just to avoid crashes\r\n        }\r\n    };\r\n\r\n    devideInverse = (k) => {\r\n        if (k === +k) {\r\n            return new Algebra([k], {\r\n                symbol: this.symbol,\r\n                type: \"frac\",\r\n                b: [1],\r\n            });\r\n        } else if (k instanceof Algebra) return k.devide(this);\r\n    };\r\n\r\n    laplace = () => {};\r\n\r\n    static areTheSame = (el1, el2) => {\r\n        // checkes the sameness of parameters like .a .b .teta , etc.\r\n        if (el1 instanceof Algebra && el2 instanceof Algebra)\r\n            return el1.equals(el2);\r\n        else if (el1 instanceof Array && el2 instanceof Array) {\r\n            if (el1.length === el2.length) {\r\n                let i = 0;\r\n                for (i = 0; i < el1.length; i++) if (el1[i] !== el2[i]) break;\r\n                return i >= el1.length;\r\n            }\r\n        }\r\n        return typeof el1 === typeof el2 && el1 === el2;\r\n    };\r\n    equals = (operand) =>\r\n        operand instanceof Algebra &&\r\n        this.type === operand.type &&\r\n        this.symbol === operand.symbol &&\r\n        this.type === operand.type &&\r\n        this.symbol === operand.symbol &&\r\n        Algebra.areTheSame(this.a, operand.a) &&\r\n        Algebra.areTheSame(this.b, operand.b) &&\r\n        Algebra.areTheSame(this.teta, operand.teta) &&\r\n        (!this.dot || this.dot.equals(operand.dot)) &&\r\n        (!this.plus || this.plus.equals(operand.plus)) &&\r\n        (!this.previous || this.previous.equals(operand.previous));\r\n\r\n    static areTheseTwoEqual = (p1, p2) =>\r\n        p1 instanceof Algebra\r\n            ? p1.equals(p2)\r\n            : p2 instanceof Algebra\r\n            ? p2.equals(p1)\r\n            : p1 === p2;\r\n    // DECIPHERS THE CONNECT OBJECTS TO UNDERSTANDABLE MATHMATICALLY SHAPED TEXT\r\n    // IT IS FORMATTED COMPATIBLE FOR MathJax component\r\n    toString = (parenthesis = false) => {\r\n        // this.arrangeDots();\r\n        this.removeZeros(); // removeZeros current chain that's left from unknown number of operations\r\n        let formula = \"\";\r\n        // if ... + 0 || 0 + ... appears ===>>>>> see below !!\r\n        if (!this.a) return \"0\"; // what if **************************************** 0 / 0\r\n        if (parenthesis) formula += \"(\";\r\n        switch (this.type.toLowerCase()) {\r\n            case \"exp\": {\r\n                // if (this.a < 0) formula += \"(\";\r\n                let a0 = this.a;\r\n                if (a0 < 0) {\r\n                    formula += \"-\";\r\n                    a0 *= -1;\r\n                }\r\n                if (a0 !== 1)\r\n                    if (a0 instanceof Algebra)\r\n                        formula += a0.toString(\r\n                            a0 instanceof Algebra && a0.hasMultiTerms()\r\n                        );\r\n                    else if (a0 instanceof Array)\r\n                        // testTEST\r\n                        formula += Algebra.polynomial(a0, this.symbol);\r\n                    // FOR TEST\r\n                    else formula += strictPrecisionFormat(a0);\r\n                if (this.dot instanceof Algebra)\r\n                    formula += this.dot.toString(\r\n                        this.dot instanceof Algebra && this.dot.hasMultiTerms()\r\n                    );\r\n                if (this.b !== 0) {\r\n                    if (this.a !== 0) {\r\n                        formula += \"e^{\";\r\n                        let e0 = this.b;\r\n                        if (this.b instanceof Algebra)\r\n                            formula += this.b.toString(\r\n                                this.b instanceof Algebra &&\r\n                                    this.b.hasMultiTerms()\r\n                            );\r\n                        else if (this.b instanceof Array)\r\n                            formula += Algebra.polynomial(this.b, this.symbol);\r\n                        else {\r\n                            if (e0 < 0) {\r\n                                formula += \"-\";\r\n                                e0 *= -1;\r\n                            }\r\n                            if (e0 !== 1) formula += e0;\r\n                        }\r\n                        formula += this.symbol + \"}\";\r\n                    }\r\n                    if (this.input) formula += this.input.toString();\r\n                } else if (a0 !== 1 || !this.dot)\r\n                    formula +=\r\n                        this.a instanceof Algebra\r\n                            ? this.a.toString()\r\n                            : strictPrecisionFormat(this.a);\r\n\r\n                // if (this.a < 0) formula += \")\";\r\n                if (this.plus) formula += this.join(); // if there's a next term: casscade toString() calls\r\n                break;\r\n            }\r\n            case \"poly\":\r\n                if (\r\n                    !parenthesis &&\r\n                    this.input &&\r\n                    this.a.filter((ai) => ai).length > 1\r\n                ) {\r\n                    parenthesis = true;\r\n                    formula += \"(\";\r\n                }\r\n                formula += Algebra.polynomial(this.a, this.symbol);\r\n                if (this.dot instanceof Algebra)\r\n                    formula += this.dot.toString(\r\n                        this.dot instanceof Algebra && this.dot.hasMultiTerms()\r\n                    );\r\n                if (this.input && formula !== \"0\") {\r\n                    if (formula === \"1\")\r\n                        formula =\r\n                            (parenthesis ? \")\" : \"\") + this.input.toString();\r\n                    else if (formula === \"-1\")\r\n                        formula =\r\n                            \"- \" +\r\n                            (parenthesis ? \")\" : \"\") +\r\n                            this.input.toString();\r\n                    else {\r\n                        formula +=\r\n                            (parenthesis ? \")\" : \"\") + this.input.toString();\r\n                    }\r\n                    parenthesis = false;\r\n                }\r\n                if (this.plus) formula += this.join(); // if there's a next term: casscade toString() calls\r\n                break;\r\n            case \"frac\": {\r\n                if (this.dot instanceof Algebra)\r\n                    formula += this.dot.toString(\r\n                        this.dot instanceof Algebra && this.dot.hasMultiTerms()\r\n                    );\r\n                const numerator = Algebra.polynomial(this.a, this.symbol);\r\n                formula +=\r\n                    numerator !== \"0\"\r\n                        ? \"\\\\frac{\" +\r\n                          numerator +\r\n                          \"}{\" +\r\n                          Algebra.polynomial(this.b, this.symbol) +\r\n                          \"}\"\r\n                        : \"0\";\r\n                if (this.input) formula += this.input.toString();\r\n                if (this.plus) formula += this.join(); // if there's a next term: casscade toString() calls\r\n\r\n                break;\r\n            }\r\n            case \"sin\":\r\n            case \"asin\":\r\n            case \"cos\":\r\n            case \"tan\":\r\n            case \"cot\": {\r\n                // if (this.a < 0) formula += \"(\";\r\n                let a0 = this.a;\r\n                if (a0 < 0) {\r\n                    formula += \"-\";\r\n                    a0 *= -1;\r\n                }\r\n                if (a0 !== 1)\r\n                    if (a0 instanceof Algebra)\r\n                        formula += a0.toString(\r\n                            a0 instanceof Algebra && a0.hasMultiTerms()\r\n                        );\r\n                    else if (a0 instanceof Array)\r\n                        formula += Algebra.polynomial(a0, this.symbol);\r\n                    // FOR TEST\r\n                    else formula += strictPrecisionFormat(a0);\r\n                if (this.a !== 0) {\r\n                    if (this.dot && this.dot instanceof Algebra)\r\n                        formula += this.dot.toString(\r\n                            this.dot instanceof Algebra &&\r\n                                this.dot.hasMultiTerms()\r\n                        );\r\n                    if (this.b !== 0) {\r\n                        formula += this.type;\r\n                        if (this.b instanceof Algebra) {\r\n                            formula += this.b.toString(\r\n                                this.b instanceof Algebra &&\r\n                                    this.b.hasMultiTerms()\r\n                            );\r\n                        } else if (this.b instanceof Array)\r\n                            formula += Algebra.polynomial(this.b, this.symbol);\r\n                        // FOR TEST\r\n                        else {\r\n                            let w0 = this.b;\r\n                            formula += \"(\";\r\n                            if (w0 < 0) {\r\n                                formula += \"-\";\r\n                                w0 *= -1;\r\n                            }\r\n                            if (w0 !== 1) formula += strictPrecisionFormat(w0);\r\n                            formula += this.symbol;\r\n                            if (this.teta instanceof Algebra)\r\n                                formula += this.teta.toString();\r\n                            else if (this.teta) {\r\n                                let e0 = this.teta;\r\n                                if (e0 < 0) {\r\n                                    formula += \" - \";\r\n                                    e0 *= -1;\r\n                                } else formula += \" + \";\r\n                                formula += strictPrecisionFormat(e0);\r\n                            }\r\n                            formula += \")\";\r\n                        }\r\n                        if (this.input) formula += this.input.toString();\r\n                    }\r\n                    // simple num\r\n                } else {\r\n                    if (a0 !== 1 || !this.dot)\r\n                        formula += strictPrecisionFormat(this.a);\r\n                }\r\n                // if (this.a < 0) formula += \")\";\r\n                if (this.plus) formula += this.join(); // if there's a next term: casscade toString() calls\r\n                break;\r\n            }\r\n\r\n            default:\r\n                return null;\r\n        }\r\n        if (parenthesis) formula += \")\";\r\n\r\n        return formula;\r\n    };\r\n    toArray = () => {\r\n        let x = [];\r\n        const params = [\"a\", \"b\", \"teta\", \"symbol\", \"type\"],\r\n            linkers = [\"dot\", \"input\", \"plus\", \"previous\"];\r\n        for (const [key, value] of Object.entries(this)) {\r\n            if (typeof value !== \"function\") {\r\n                if (value) {\r\n                    // maximum toArray call happens\r\n                    if (params.filter((p) => p === key).length)\r\n                        x[key] =\r\n                            value instanceof Algebra ? value.toArray() : value;\r\n                    //)((value instanceof StandardInputSignal ? value.copy() : ));\r\n                    else if (linkers.filter((l) => l === key).length)\r\n                        x[key] =\r\n                            value instanceof StandardInputSignal\r\n                                ? value.copy()\r\n                                : value.toArray();\r\n                }\r\n            }\r\n        }\r\n        return x;\r\n    };\r\n\r\n    isIntegrator = () => false;\r\n}\r\n\r\nexport default Algebra;\r\n","import { round, strictPrecisionFormat } from \"../calculus\";\r\n\r\nexport default class StandardInputSignal {\r\n    constructor(amplitude = 1, type = \"u\", symbol = \"t\") {\r\n        this.symbol = symbol;\r\n        this.type = type;\r\n        this.amp = round(amplitude);\r\n    }\r\n\r\n    copy = () => new StandardInputSignal(this.amp, this.type, this.symbol);\r\n\r\n    toString = () => {\r\n        let str = \"\",\r\n            a = this.amp;\r\n        if (this.amp === -1) {\r\n            str += \"-\";\r\n            a *= -1;\r\n        }\r\n        if (a !== 1) str += strictPrecisionFormat(a);\r\n        return str + `${this.type}(${this.symbol})`;\r\n    };\r\n\r\n    ampiltude = () => this.amp;\r\n}\r\n"],"names":["Complex","preal","pimage","params","symbol","type","b","hasMultiTerms","plus","a","toString","parenthesis","showJ1","isZero","rl","formula","Algebra","round","im","getA","setA","join","real","imaginary","copy","linkPrevious","dot","previous","input","hardcopy","conjugate","negation","magnitude$2","magnitude","phase","definiteA","definiteB","Math","atan2","t","$","NaN","isReal","hasSameTypeWith","x","realify","add","operand","Re","Im","substract","equals","isConjugateWith","multiply","push","devide","denominator","result","isNaN","setB","raiseTo","power","floor","i","devideInverse","k","actual","ToCouples","arrComplex","n","length","reals","Array","fill","imaginaries","extract","strNumber","replace","isDigit","Number","slice","sign","img","MultiplyFactors","factors","s","factor","term","value","order","Exp","toSin","exp","cos","Cos","sin","Sin","amplitude","w","jw","pb","valueAt","numericT","Fraction","num","den","lim","numerator","Poly","setNumerator","setDenominator","y","toFormula","toTransferFunction","TransferFunction","getB","isIntegrator","degree","powerTerm","derivative","against","da","expression","filter","ci","map","a_i","atn","aArray","Symbolic","halfTermsVisible","coef","inline","res","Step","amp","StandardInputSignal","Algebrite","require","Equation","solve","nroots","replaceAll","split","xi","separatorIndex","terms","approximate","method","Methods","newton","N","boundary","allRoots","isUnique","newRoot","findIndex","rt","isUniqueComplex","a0","an","abs","x0","algebra","rx","durandKerner","guess","f","random","roots","_","iter","xiN","sndTermDen","j","xjN","sndTerm","r","this","GetAlgebriteTerm","undefined","zeroPrecision","precision","termDegree","index","intExpI","symbolicPart","run","algebraf","df","xs","dfx0","fx","middlePoint","expectedRate","poles","xa","xb","rate","max","p","Set","nerdamer","Formula","mathPhrase","expressions","diff","iL","timeSymbol","L","frequencySymbol","knownVariables","evaluate","toDecimal","solveFor","ri","includes","toTeX","toAlgebra","GetTerm","RepetitiveFactors","fullRoots","root","knowns","fi","Zero","str","linkPlus","teta","getTeta","getSymbol","getType","zeros","overshoot","t_rise","logMp","log10","zeta","PI","w_d","w_n","wn2","OmegaZetaPoles","getSimplifiedRoots","temp","pi","zi","getSimplifiedOrderedRoots","orderedPoles","orderedZeros","minOrder","min","find","ai","bi","setRoots","sort","p1","p2","z1","z2","RootOrders","updateRoots","getDampingSystemCharasteristics","getOrder","setOrder","getPoles","setPoles","getZeros","setZeros","poleOrder","pole","rplus","g","laplace","laplaceInverse","f_s","simplify","console","log","denCoef","$s","$t","setInputSignal","coefs","otherPoles","splice","dF","Shortcuts","$Roots","z","factoriel","q","g_s","c_t","$DelayedIntegrator","ap","stepify","lstep","step","m","nreal","a2","ka2b2","t_settle","timeConstant","s0","sp","sMinPower","Infinity","errors","sGs","s2Gs","Ks","Kr","Ka","numPhase","denPhase","Function","nyquist","PolarToComplex","bode","rootLocus","k_min","k_max","progressBarObject","dk","na","nb","progressLength","newTerm","progress","delta","offsetB","ib","offsetA","makeProgress","rootsByAlgebriteLocus","controlFeedback","controller","cs_gs","linkDot","dampingCharasteristics","$1","$2","aplusb","ab","$WnZ","$design","$PID","Kp","Ti","Td","delay","raise","Roots","orders","alpha","beta","A","phi","toExp","exp1","exp2","NotScalarError","cause","describe","message","name","code","error_codes","Error","identify","setTeta","end","last","first","fst","enddot","firstdot","link","position","func","isPrior","or","unifiable","isUnifiable","sameOnes","item","idx","removeZeros","polynomial","redundant","showSteps","label","operator","next","isTriangular","right","endTerm","arrangeDots","no","As","yai","product","pop","endDotTerm","lastyDot","selfmultiply","ao","negative","areTheSame","toLowerCase","strictPrecisionFormat","e0","w0","toArray","linkers","key","l","Object","entries","parameter","valueOf","polynomialValueAt","arr","coefy","el1","el2","areTheseTwoEqual","ampiltude"],"sourceRoot":""}