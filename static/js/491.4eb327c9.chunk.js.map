{"version":3,"file":"static/js/491.4eb327c9.chunk.js","mappings":"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","sources":["math/algebra/functions/exp.js","math/algebra/functions/fraction.js","math/algebra/functions/poly.js","math/input-signals/signals.js","math/solvers/formula.js","math/algebra/functions/zero.js","math/algebra/functions/transfer.js","math/algebra/functions/trigonometric.js","math/solvers/equation.js"],"sourcesContent":["import Algebra from \"math/algebra\";\r\nimport Complex from \"math/algebra//complex\";\r\nimport { Cos, Sin } from \"./trigonometric\";\r\n\r\nexport default class Exp extends Algebra {\r\n    constructor(a, b, symbol = \"t\", params = {}) {\r\n        // ae^bt\r\n        super(a, { symbol, type: \"exp\", b, ...params });\r\n    }\r\n\r\n    copy = (\r\n        linkPrevious = false // copy everything\r\n    ) =>\r\n        new Exp(this.a, this.b, this.symbol, {\r\n            dot: this.dot,\r\n            plus: this.plus,\r\n            previous: linkPrevious ? this.previous : null,\r\n            input: this.input,\r\n        });\r\n\r\n    hardcopy = () =>\r\n        // shallow copy just for single term copy\r\n        new Exp(this.a, this.b, this.symbol, {\r\n            dot: this.dot,\r\n            input: this.input,\r\n        });\r\n    toSin = () => {\r\n        const exp = this.copy();\r\n        if (\r\n            exp.type === \"exp\" &&\r\n            exp.b instanceof Complex &&\r\n            exp.b.isComplex()\r\n        ) {\r\n            if (exp.b instanceof Complex) {\r\n                if (exp.b.real() === 0 || exp.b.toString() === \"0\") {\r\n                    const b = exp.b.imaginary();\r\n                    const cos = new Cos(exp.a, b, 0, this.symbol, {\r\n                        input: this.input,\r\n                        plus: this.plus,\r\n                        previous: this.previous,\r\n                        dot: this.dot,\r\n                    });\r\n                    const sin =\r\n                        b >= 0\r\n                            ? new Sin(exp.a, b, 0, this.symbol, {\r\n                                  dot: this.dot,\r\n                              })\r\n                            : new Sin(\r\n                                  exp.a instanceof Algebra\r\n                                      ? exp.a.negation()\r\n                                      : -exp.a,\r\n                                  -b,\r\n                                  0,\r\n                                  this.symbol,\r\n                                  { dot: this.dot }\r\n                              );\r\n                    return new Complex(cos, sin);\r\n                } else\r\n                    return new Exp(\r\n                        new Exp(\r\n                            exp.a,\r\n                            Complex.jX(exp.b.imaginary()),\r\n                            exp.symbol\r\n                        ).toSin(),\r\n                        exp.b.real(),\r\n                        exp.symbol,\r\n                        {\r\n                            dot: this.dot,\r\n                            input: this.input,\r\n                            plus: this.plus,\r\n                            previous: this.previous,\r\n                        }\r\n                    );\r\n            }\r\n        }\r\n        return exp; // if doesnt math the condition then just return exponential function itself\r\n    };\r\n\r\n    amplitude = (t) => {\r\n        // NOT SURE\r\n        // if (this.b instanceof Complex || t instanceof Complex) {\r\n        //     if (this.a === +this.a) return this.a;\r\n        //     else if (this.a instanceof Algebra && this.symbol === this.a.symbol)\r\n        //         return this.a.$(t);\r\n        // } else return this.valueAt(t);\r\n    };\r\n    phase = (w) => {\r\n        const jw = Complex.jX(w);\r\n        let pb = +this.b;\r\n        if (this.b === pb) return pb * w;\r\n        if (this.b instanceof Algebra) {\r\n            pb = this.b.$(jw);\r\n            return jw.multiply(pb).imaginary();\r\n        }\r\n    };\r\n\r\n    decomposition = () => {\r\n        if (this.b instanceof Complex)\r\n            return new Exp(\r\n                new Exp(this.a, Complex.jX(this.b.imaginary()), this.symbol),\r\n                this.b.real(),\r\n                this.symbol\r\n            );\r\n        return this.copy();\r\n    };\r\n\r\n    valueAt = (t) => {\r\n        const numericT = +t;\r\n        if (numericT === t) {\r\n            const a = Algebra.valueOf(this.a, numericT),\r\n                b = Algebra.valueOf(this.b, numericT);\r\n            return a * Math.exp(b * numericT);\r\n        } else if (t instanceof Complex) {\r\n            if (!t.real()) {\r\n                return new Exp(\r\n                    this.a,\r\n                    Complex.jX(this.b * t.imaginary()),\r\n                    this.symbol\r\n                ).toSin();\r\n            } else if (t.imaginary()) {\r\n                // edit this\r\n                return (\r\n                    new Exp(this.a, this.b, this.symbol).valueAt(t.real()) *\r\n                    new Exp(\r\n                        1,\r\n                        Complex.jX(this.b * t.imaginary()),\r\n                        this.symbol\r\n                    ).toSin()\r\n                );\r\n            }\r\n            // t is real\r\n            else return this.valueAt(t.real());\r\n        }\r\n    };\r\n\r\n    static ConvertToMe = (algebra) =>\r\n        new Exp(\r\n            algebra.getA(),\r\n            algebra.getB() ? algebra.getB() : 0,\r\n            algebra.symbol,\r\n            {\r\n                dot: this.dot,\r\n                plus: this.plus,\r\n                previous: this.previous,\r\n                input: this.input,\r\n            }\r\n        );\r\n    toAlgebra = () =>\r\n        new Algebra(this.a, {\r\n            type: \"exp\",\r\n            symbol: this.symbol,\r\n            b: this.b,\r\n            dot: this.dot,\r\n            plus: this.plus,\r\n            previous: this.previous,\r\n            input: this.input,\r\n        });\r\n}\r\n","import Algebra from \"math/algebra\";\r\nimport Complex from \"../complex\";\r\nimport Poly from \"./poly\";\r\nimport TransferFunction from 'math/algebra/functions/transfer';\r\n\r\nexport default class Fraction extends Algebra {\r\n    constructor(num, den = [1], symbol = \"t\", params = {}) {\r\n        // ke^ct\r\n        if (!(num instanceof Algebra)) {\r\n            if (!(num instanceof Array)) num = [num];\r\n            // this.a\r\n            else if (num.length === 0) num = [0];\r\n        }\r\n        if (!(den instanceof Algebra)) {\r\n            if (!(den instanceof Array)) den = [den];\r\n            // this.b\r\n            else if (den.length === 0) den = [1];\r\n        }\r\n        super(num, {\r\n            symbol,\r\n            type: \"frac\",\r\n            b:\r\n                den instanceof Array\r\n                    ? den.map((di) =>\r\n                          di instanceof Complex ? di.actual() : di\r\n                      )\r\n                    : den,\r\n            ...params,\r\n        });\r\n    }\r\n\r\n    copy = (\r\n        linkPrevious = false // copy everything\r\n    ) =>\r\n        new Fraction(this.a, this.b, this.symbol, {\r\n            dot: this.dot,\r\n            plus: this.plus,\r\n            previous: linkPrevious ? this.previous : null,\r\n            input: this.input,\r\n        });\r\n\r\n    hardcopy = () =>\r\n        // shallow copy just for copying single term\r\n        new Fraction(this.a, this.b, this.symbol, {\r\n            dot: this.dot,\r\n            input: this.input,\r\n        });\r\n    lim = () => {\r\n        // for all fractions with all kind of numerator and denominator\r\n    };\r\n\r\n    numerator = () =>\r\n        this.a instanceof Algebra\r\n            ? this.a.copy(true)\r\n            : new Poly(this.a, this.symbol);\r\n    denominator = () =>\r\n        this.b instanceof Algebra\r\n            ? this.b.copy(true)\r\n            : new Poly(this.b, this.symbol);\r\n\r\n    setNumerator = (num) => {\r\n        if (!(num instanceof Algebra)) {\r\n            if (!(num instanceof Array)) num = [num];\r\n            // this.a\r\n            else if (num.length === 0) num = [0];\r\n        }\r\n        return this.setA(num);\r\n    };\r\n\r\n    setDenominator = (den) => {\r\n        if (!(den instanceof Algebra)) {\r\n            if (!(den instanceof Array)) den = [den];\r\n            // this.b\r\n            else if (den.length === 0) den = [1];\r\n        }\r\n        return this.setB(den);\r\n    };\r\n    valueAt = (t) => {\r\n        const num = this.numerator().$(t);\r\n        const den = this.denominator().$(t);\r\n\r\n        if (num instanceof Algebra) return num.devide(den);\r\n        if (den instanceof Algebra) return den.devideInverse(num);\r\n        if (den) return num / den;\r\n        // THROW zero denominator ERROR\r\n        return undefined;\r\n    };\r\n\r\n    multiply = (operand) => {\r\n        let y = this.copy(true);\r\n        if (operand instanceof Fraction) {\r\n            const num = this.numerator().multiply(operand.numerator()),\r\n                den = this.denominator().multiply(operand.denominator());\r\n            y = num.devide(den);\r\n        } else {\r\n            const num = this.numerator().multiply(operand);\r\n            y = num.devide(this.denominator());\r\n        }\r\n        if (this.plus) y.plus = this.plus.multiply(operand);\r\n        return this instanceof TransferFunction ? y.toTransferFunction() : y;\r\n    };\r\n    toFormula = () =>\r\n        \"(\" +\r\n        this.numerator().toFormula() +\r\n        \")/(\" +\r\n        this.denominator().toFormula() +\r\n        \")\";\r\n\r\n    isIntegrator = () => this.toTransferFunction().isIntegrator();\r\n\r\n    add2gether = (operand) => {};\r\n\r\n    toAlgebra = () =>\r\n        new Algebra(this.a, {\r\n            type: \"frac\",\r\n            symbol: this.symbol,\r\n            b: this.b,\r\n            dot: this.dot,\r\n            plus: this.plus,\r\n            previous: this.previous,\r\n            input: this.input,\r\n        });\r\n\r\n    toTransferFunction = () => new TransferFunction(this.a, this.b);\r\n    \r\n    static ConvertToMe = (algebra) =>\r\n        new Fraction(\r\n            algebra.getA(),\r\n            algebra.getB() ? algebra.getB() : [1],\r\n            algebra.symbol,\r\n            {\r\n                dot: this.dot,\r\n                plus: this.plus,\r\n                previous: this.previous,\r\n                input: this.input,\r\n            }\r\n        );\r\n}\r\n","import Algebra from \"math/algebra\";\r\nimport Complex from \"../complex\";\r\nimport Fraction from \"./fraction\";\r\nexport default class Poly extends Algebra {\r\n    static atn = (a, n, symbol = \"t\") => {\r\n        const aArray = Array(n + 1).fill(0);\r\n        aArray[0] = a;\r\n        return new Poly(aArray, symbol);\r\n    };\r\n    constructor(a, symbol = \"t\", params = {}) {\r\n        // ke^ct\r\n        if (typeof a === \"number\") a = [a];\r\n        super(a, { symbol, type: \"poly\", ...params });\r\n    }\r\n\r\n    copy = (\r\n        linkPrevious = false // copy everything\r\n    ) =>\r\n        new Poly(this.a, this.symbol, {\r\n            dot: this.dot,\r\n            plus: this.plus,\r\n            previous: linkPrevious ? this.previous : null,\r\n            input: this.input,\r\n        });\r\n    hardcopy = () =>\r\n        // shallow copy; signle term copy\r\n        new Poly(this.a, this.symbol, {\r\n            dot: this.dot,\r\n            input: this.input,\r\n        });\r\n    degree = () => this.a.length - 1;\r\n\r\n    valueAt = (t) => {\r\n        if (typeof t === \"number\") return Algebra.polynomialValueAt(this.a, t);\r\n        else if (t instanceof Complex) {\r\n            const n = this.a.length - 1;\r\n            if (n >= 0) {\r\n                let powerTerm = 1,\r\n                    result =\r\n                        this.a[n] instanceof Complex\r\n                        ? this.a[n].copy()\r\n                            : new Complex(this.a[n], 0);\r\n                for (let i = n - 1; i >= 0; i--) {\r\n                    powerTerm = t.multiply(powerTerm);\r\n                    result = result.add(powerTerm.multiply(this.a[i]));\r\n                }\r\n                return result;\r\n            }\r\n            return 0;\r\n        }\r\n        return NaN;\r\n    };\r\n\r\n    static Symbolic = (\r\n        degree,\r\n        symbol = \"t\",\r\n        halfTermsVisible = 2,\r\n        coef = \"a\",\r\n        inline = false\r\n    ) => {\r\n        let res = inline ? \"\" : \"$$\";\r\n        if (degree === \"n\") {\r\n            res += `${coef}_n ${symbol}^n + `;\r\n            for (let i = 1; i < halfTermsVisible; i++)\r\n                res += `${coef}_{n - ${i}}${symbol}^{n - ${i}} + `;\r\n            res += \" ... \";\r\n            for (let i = halfTermsVisible - 1; i > 0; i--)\r\n                res += ` + ${coef}_{${i}}${symbol}^{${i}}`;\r\n            res += ` + ${coef}_0`;\r\n        } else if (typeof degree === \"number\") {\r\n            for (; degree >= 0; degree--) {\r\n                res += `${coef}_{${degree}}`;\r\n                if (degree > 0) res += `${symbol}^{${degree}} + `;\r\n            }\r\n        }\r\n        return res + (inline ? \"\" : \" $$\");\r\n    };\r\n    derivative = (against = this.symbol) => {\r\n        const result = this.copy(true);\r\n        if (against === this.symbol) {\r\n            if (!result.dot) {\r\n                const n = result.a.length - 1;\r\n                const da = Array(n).fill(0);\r\n                for (let i = n; i >= 1; i--) da[n - i] = i * result.a[n - i];\r\n                result.a = [...da];\r\n            }\r\n            if (result.plus) result.plus = result.plus.derivative();\r\n        }\r\n        return result;\r\n    };\r\n\r\n    expression = () => {\r\n        if (this.a instanceof Array) {\r\n            const n = this.a.length - 1;\r\n            if (\r\n                !n ||\r\n                !this.a.slice(0, n).filter((ci) => ci.toString() !== \"0\").length\r\n            )\r\n                return this.a[n].toString();\r\n            return this.a\r\n                .map((a_i, i) =>\r\n                    a_i\r\n                        ? Algebra.coefy(a_i, i, n) +\r\n                          (i < n\r\n                              ? this.symbol +\r\n                                (i < n - 1 ? \"^\" + (n - i).toString() : \"\")\r\n                              : \"\")\r\n                        : \"\"\r\n                )\r\n                .join(\"\"); // joins all the coefficients, symbols, etc all together as for polynomal functions\r\n        }\r\n        return this.a.toString();\r\n    };\r\n\r\n    // edit this function to remove unnecessary white spaces\r\n    toFormula = () => {\r\n        if (this.a instanceof Array) {\r\n            const n = this.a.length - 1;\r\n            if (\r\n                !n ||\r\n                !this.a.slice(0, n).filter((ci) => ci.toString() !== \"0\").length\r\n            )\r\n                return this.a[n].toString();\r\n            return this.a\r\n                .map((a_i, i) =>\r\n                    a_i\r\n                        ? Algebra.coefy(a_i, i, n) +\r\n                          (i < n\r\n                              ? this.symbol +\r\n                                (i < n - 1 ? \"^\" + (n - i).toString() : \"\")\r\n                              : \"\")\r\n                        : \"\"\r\n                )\r\n                .join(\"\"); // joins all the coefficients, symbols, etc all together as for polynomal functions\r\n        }\r\n        return this.a.toString();\r\n    };\r\n\r\n    mostSignificantCoefficient = () => {\r\n        const an = this.a.filter((bi) => bi !== 0)[0];\r\n        return an instanceof Complex ? (!an.isUnit() ? an : 1) : an;\r\n    };\r\n\r\n    devide = (operand) => {\r\n        if (operand instanceof Poly && this.symbol === operand.symbol)\r\n            return new Fraction(this.getA(), operand.getA(), this.symbol);\r\n\r\n        if (operand === +operand) return this.multiply(1 / +operand);\r\n        else if (operand instanceof Algebra)\r\n            return new Fraction(this.getA(), operand, this.symbol);\r\n        return this.toAlgebra().devide(operand); // if none of the conditions are met use the parent class devide function\r\n        // is it true??\r\n        // return super.devide();\r\n    };\r\n    toAlgebra = () =>\r\n        new Algebra(this.a, {\r\n            type: \"poly\",\r\n            symbol: this.symbol,\r\n            dot: this.dot,\r\n            plus: this.plus,\r\n            previous: this.previous,\r\n            input: this.input,\r\n        });\r\n}\r\n","import StandardInputSignal from \"math/input-signals\";\r\nimport Poly from \"math/algebra/functions/poly\";\r\n\r\nexport class Step extends StandardInputSignal {\r\n    constructor(amplitude = 1, symbol = \"t\") {\r\n        super(amplitude, \"u\", symbol); // \\\\delta is the equivalent of small delta in mathjax\r\n    }\r\n    copy = () => new Step(this.amp, this.symbol);\r\n\r\n    $ = (t) => (t >= 0) * this.amp;\r\n}\r\n\r\nexport class Puls extends StandardInputSignal {\r\n    constructor(Delta = 1, amplitude = 1, symbol = \"t\") {\r\n        super(amplitude, \"\\\\sqcap\", symbol);\r\n        this.Delta = Delta;\r\n    }\r\n    copy = () => new Puls(this.Delta, this.amp, this.symbol);\r\n    $ = (t) => (t >= 0 && t <= this.Delta) * this.amp / this.Delta;\r\n}\r\n\r\nexport class Impact extends StandardInputSignal {\r\n    constructor(amplitude = 1, symbol = \"t\") {\r\n        super(amplitude, \"\\\\delta\", symbol); // \\\\delta is the equivalent of small delta in mathjax\r\n    }\r\n    copy = () => new Impact(this.amp, this.symbol);\r\n\r\n    $ = (t) => this.amp * (t === 0);\r\n}\r\n\r\nexport class Ramp extends Poly {\r\n    constructor(amplitude, symbol = \"t\") {\r\n        super([amplitude, 0], symbol);\r\n        this.amplitude = amplitude; // just for calculating the value of this\r\n        this.selfmultiply(Step());\r\n    }\r\n    copy = () => new Ramp(this.amplitude, this.symbol);\r\n\r\n    $ = (t) => (t >= 0) * t * this.amplitude;\r\n}\r\n\r\n\r\nexport class Parabolic extends Poly { //EDIT\r\n    constructor(amplitude, symbol = \"t\") {\r\n        super([amplitude, 0, 0], symbol);\r\n        this.amplitude = amplitude; // just for calculating the value of this\r\n        this.selfmultiply(Step());\r\n    }\r\n    copy = () => new Parabolic(this.amplitude, this.symbol);\r\n    $ = (t) => (t >= 0 ? t * this.amplitude : 0);\r\n}\r\n","import Algebra from \"math/algebra\";\r\nimport { isDigit } from \"math/calculus\";\r\nimport Complex from \"math/algebra/complex\";\r\nconst nerdamer = require(\"nerdamer/all.min\");\r\n\r\nexport default class Formula {\r\n    constructor(mathPhrase, symbol = null, expressions = null) {\r\n        /// all type of parameters must be converted to an string mathPhrases (f)\r\n        if (mathPhrase instanceof Algebra) {\r\n            this.f = mathPhrase.toFormula();\r\n            this.symbol = mathPhrase.symbol;\r\n        } else if (typeof mathPhrase === \"string\") {\r\n            this.f = mathPhrase;\r\n            this.symbol = symbol;\r\n        }\r\n        this.expressions = expressions ? expressions : nerdamer(this.f); // normally its the nerdamer expressions\r\n    }\r\n\r\n    // differentiate function\r\n    df = (against = this.symbol) => {\r\n        const expressions = nerdamer.diff(this.f, against);\r\n        return new Formula(expressions.toString(), this.symbol, expressions);\r\n    };\r\n    iL = (timeSymbol = \"t\") => {\r\n        // inverse laplace transform\r\n        const expressions = nerdamer(\r\n            `ilt(${this.f}, ${this.symbol}, ${timeSymbol})`\r\n        );\r\n        return new Formula(expressions.toString(), timeSymbol, expressions);\r\n    };\r\n\r\n    L = (frequencySymbol = \"s\") => {\r\n        // laplace\r\n        const expressions = nerdamer(\r\n            `laplace(${this.f}, ${this.symbol}, ${frequencySymbol})`\r\n        );\r\n        return new Formula(\r\n            expressions.toString(),\r\n            frequencySymbol,\r\n            expressions\r\n        );\r\n    };\r\n\r\n    $ = (t = undefined) => {\r\n        // returns the containing f as a normal funtion or single value in a certain point\r\n        // get value at certain point\r\n        const knownVariables = [];\r\n        knownVariables[this.symbol] = t;\r\n        return t\r\n            ? nerdamer(this.f, { ...knownVariables })\r\n                  .evaluate()\r\n                  .toDecimal()\r\n            : nerdamer(this.f).toDecimal();\r\n    };\r\n\r\n    // solve equations\r\n    x = () => {\r\n        // nerdamer.solveEquations(this.f, this.symbol);\r\n\r\n        let roots = nerdamer(this.f)\r\n            .solveFor(this.symbol)\r\n            .map((ri) =>\r\n                (!ri.toString().includes(\"sqrt\")\r\n                    ? ri\r\n                    : ri.evaluate()\r\n                ).toDecimal()\r\n            );\r\n            \r\n        //roots = roots.split(\",\").filter((ri) => ri && ri !== \"\"); // now x is converted from a string to the array of x answers (as +s);\r\n        // edit string to array\r\n        return roots.map((ri, i) => {\r\n            // let [real, image] = ri.split(/\\+|-/).filter((ri) => ri && ri !== \"\");\r\n            let separatorIndex = 1;\r\n            for (; separatorIndex < ri.length; separatorIndex++)\r\n                if (\r\n                    (ri[separatorIndex] === \"+\" ||\r\n                        ri[separatorIndex] === \"-\") &&\r\n                    (isDigit(ri[separatorIndex - 1]) ||\r\n                        ri[separatorIndex - 1] === \"i\") &&\r\n                    (isDigit(ri[separatorIndex + 1]) ||\r\n                        ri[separatorIndex + 1] === \"i\")\r\n                )\r\n                    break;\r\n\r\n            let terms = [];\r\n            terms.push(ri.slice(0, separatorIndex));\r\n            if (separatorIndex < ri.length)\r\n                terms.push(ri.slice(separatorIndex, ri.length));\r\n\r\n            if (terms.length === 1) {\r\n                const magnitude = terms[0].replace(\"*i\", \"\").replace(\"i\", \"1\");\r\n                return magnitude === terms[0]\r\n                    ? new Complex(+magnitude)\r\n                    : Complex.jX(+magnitude);\r\n            } else {\r\n                let b = terms[1].replace(\"*i\", \"\").replace(\"i\", \"1\");\r\n                if (b !== terms[1]) return new Complex(+terms[0], +b);\r\n                // if not, means the first term was image\r\n                b = terms[0].replace(\"*i\", \"\").replace(\"i\", \"1\");\r\n                return new Complex(+terms[1], +b);\r\n            }\r\n        });\r\n    };\r\n    toString = () => nerdamer(this.f).toTeX();\r\n\r\n    toAlgebra = () => {\r\n        if (this.expressions instanceof Algebra) return this.expressions.copy();\r\n    };\r\n    static GetTerm = (termDegree, coef, symbol) => {\r\n        if (coef === +coef) {\r\n            // means that coef is not a string\r\n            const symbolicPart =\r\n                termDegree > 0 ? `*${symbol}^${termDegree}` : \"\";\r\n            return (coef >= 0 ? \"+\" : \"\") + `${coef}${symbolicPart}`;\r\n        }\r\n        // here it means coef is a string like '11/2' or '1/4', ...\r\n        return `${coef}${symbol}^${termDegree}`;\r\n    };\r\n\r\n    static RepetitiveFactors = (f, roots, symbol) => {\r\n        const fullRoots = [];\r\n        roots = roots.sort(\r\n            (p1, p2) =>\r\n                p1.isZero() ||\r\n                p2.isZero() ||\r\n                p1.real() - p2.real() ||\r\n                p2.imaginary() - p1.imaginary()\r\n        );\r\n        for (const root of roots) {\r\n            const knowns = [];\r\n            knowns[symbol] = root.toString(false, true).replace(\"j\", \"i*\");\r\n            let order = 0;\r\n            for (\r\n                let fi = f;\r\n                !+nerdamer(fi, { ...knowns }).toDecimal();\r\n                fullRoots.push(root.copy()), fi = nerdamer.diff(fi), order++\r\n            );\r\n            if (root && root.isZero()) {\r\n                // zero factors cause problem in determining other factors order\r\n                while (order >= 0) {\r\n                    f = nerdamer(`${f} / s`);\r\n                    order--;\r\n                }\r\n            }\r\n        }\r\n        return fullRoots;\r\n    };\r\n}\r\n","import Algebra from \"math/algebra\";\n\nexport default class Zero extends Algebra {\n    constructor(params) {\n        // ke^ct\n        super(0, { symbol: null, type: \"poly\"});\n    }\n\n    degree = () => 0;\n\n    valueAt = (t) => 0;\n\n    toString = () => {\n        let str = \"0\";\n        if (this.plus) str = this.plus.toString();\n\n        return str;\n    };\n    devide = (operand) => new Zero();\n\n    add = (operand) => operand.hardcopy().linkPlus(this.plus);\n\n    multiply = (operand) => new Zero();\n\n    replace = (operand) => {\n        this.a = operand.getA();\n        this.b = operand.getB();\n        this.teta = operand.getTeta();\n        this.symbol = operand.getSymbol();\n        this.type = operand.getType();\n        this.dot = operand.dot.copy();\n    };\n}\n","import Algebra from \"../index\";\r\nimport Complex from \"../complex\";\r\nimport Exp from \"./exp\";\r\nimport Fraction from \"./fraction\";\r\nimport { Step } from \"math/input-signals/signals\";\r\nimport Poly from \"./poly\";\r\nimport { Cos, Sin } from \"./trigonometric\";\r\nimport { round } from \"math/calculus\";\r\nimport Equation from \"math/solvers/equation\";\r\nimport { makeProgress } from \"toolshed\";\r\nimport Formula from \"math/solvers/formula\";\r\nimport Zero from \"./zero\";\r\nimport { min } from \"../../calculus\";\r\n\r\nexport default class TransferFunction extends Fraction {\r\n    static Shortcuts = {\r\n        $1: (k, a) =>\r\n            new TransferFunction([k], [1, a]).setRoots([], [-a]).setOrder(1),\r\n        $2: (k, a, b = a instanceof Complex ? a.conjugate : a) => {\r\n            // k / (s + a)(s + b) => must be converted to => k / (s2 + 2(a+b)s + ab)\r\n            let aplusb =\r\n                a instanceof Algebra\r\n                    ? a.add(b)\r\n                    : b instanceof Algebra\r\n                    ? b.add(a)\r\n                    : b + a;\r\n            let ab =\r\n                a instanceof Algebra\r\n                    ? a.multiply(b)\r\n                    : b instanceof Algebra\r\n                    ? b.multiply(a)\r\n                    : b * a;\r\n            if (aplusb instanceof Complex && aplusb.isReal())\r\n                aplusb = aplusb.real();\r\n            if (ab instanceof Complex && ab.isReal()) ab = ab.real();\r\n\r\n            return new TransferFunction(\r\n                [k],\r\n                [1, aplusb instanceof Algebra ? aplusb.negation() : -aplusb, ab]\r\n            )\r\n                .setRoots([], [a, b])\r\n                .setOrder(2);\r\n        },\r\n        $WnZ: (w_n, zeta) => new TransferFunction(null, null, { w_n, zeta }),\r\n        $design: (t_rise, overshoot) =>\r\n            new TransferFunction(null, null, { overshoot, t_rise }),\r\n\r\n        $PID: (Kp, Ti, Td) =>\r\n            Ti !== 0\r\n                ? new TransferFunction([Kp * Ti * Td, Kp * Ti, Kp], [Ti, 0])\r\n                : new TransferFunction([Kp * Td, Kp], [1]),\r\n        $Roots: (zeros, poles, numeratorGain = 1, denominatorGain = 1) => {\r\n            let num = new Poly([numeratorGain], \"s\"),\r\n                den = new Poly([denominatorGain], \"s\");\r\n            for (let i = 0; i < zeros.length; i++) {\r\n                if (zeros[i] instanceof Complex)\r\n                    num = num.multiply(new Poly([1, zeros[i].negation()], \"s\"));\r\n                else {\r\n                    num = num.multiply(new Poly([1, -zeros[i]], \"s\"));\r\n                    zeros[i] = new Complex(zeros[i], 0);\r\n                }\r\n            }\r\n            for (let i = 0; i < poles.length; i++) {\r\n                if (poles[i] instanceof Complex)\r\n                    den = den.multiply(new Poly([1, poles[i].negation()], \"s\"));\r\n                else {\r\n                    den = den.multiply(new Poly([1, -poles[i]], \"s\"));\r\n                    poles[i] = new Complex(poles[i], 0);\r\n                }\r\n            }\r\n            return num.devide(den).toTransferFunction().setRoots(zeros, poles);\r\n        },\r\n        $DelayedIntegrator: (amplitude, delay, degree) =>\r\n            // k / (s + a) ^ n : k =amplitude, a = delay, n = degree\r\n\r\n            new TransferFunction(1, [1, delay])\r\n                .raise(degree)\r\n                .multiply(amplitude)\r\n                .toTransferFunction(),\r\n    };\r\n\r\n    static ConvertToMe = (algebra) =>\r\n        new TransferFunction(\r\n            algebra.getA(),\r\n            algebra.getB() ? algebra.getB() : [1],\r\n            {\r\n                dot: this.dot,\r\n                plus: this.plus,\r\n                previous: this.previous,\r\n                input: this.input,\r\n            }\r\n        );\r\n    static RootOrders = (Roots) => {\r\n        Roots = Roots.sort((p1, p2) => p1.real() - p2.real());\r\n        const orders = [];\r\n        for (let i = 0; i < Roots.length; i++) {\r\n            let j = i + 1,\r\n                order = 1;\r\n            for (; j < Roots.length && Roots[i].equals(Roots[j]); j++, order++);\r\n            orders.push({ value: Roots[i], order });\r\n            i = j - 1;\r\n        }\r\n        return orders;\r\n    };\r\n\r\n    parentMultiply = (operand) =>\r\n        TransferFunction.ConvertToMe(this.toAlgebra().multiply(operand));\r\n\r\n    // raise = (degree) =>\r\n    //     TransferFunction.ConvertToMe(this.toAlgebra().raise(degree));\r\n\r\n    getSimplifiedRoots = () => {\r\n        let temp = this.copy();\r\n        for (let i = 0; i < temp.zeros.length; i++) {\r\n            temp.zeros[i] =\r\n                temp.zeros[i] instanceof Complex\r\n                    ? temp.zeros[i]\r\n                    : new Complex(temp.zeros[i], 0);\r\n            const pi = temp.poles.findIndex((p) => temp.zeros[i].equals(p));\r\n            if (pi !== -1) {\r\n                // temp.zeros.splice(i, 1);\r\n                // temp.poles.splice(pi, 1);\r\n                temp.zeros[i] = null;\r\n                temp.poles[pi] = null;\r\n            }\r\n        }\r\n        return [temp.zeros.filter((zi) => zi), temp.poles.filter((pi) => pi)];\r\n    };\r\n\r\n    getSimplifiedOrderedRoots = () => {\r\n        let temp = this.copy();\r\n        for (let i = 0; i < temp.orderedZeros.length; i++) {\r\n            const pi = temp.orderedPoles.findIndex((p) =>\r\n                p.value.equals(temp.orderedZeros[i].value)\r\n            );\r\n            if (pi !== -1) {\r\n                const minOrder = min(temp.orderedZeros[i].order, pi.order);\r\n                temp.orderedZeros[i].order -= minOrder;\r\n                temp.orderedPoles[pi].order -= minOrder;\r\n            }\r\n        }\r\n        return [\r\n            temp.orderedZeros.filter((zi) => zi.order),\r\n            temp.orderedPoles.filter((pi) => pi.order),\r\n        ];\r\n    };\r\n\r\n    static OmegaZetaPoles = (w_n, zeta) => {\r\n        if (Math.abs(zeta) >= 1) {\r\n            const alpha = -zeta * w_n;\r\n            const beta = w_n * (zeta * zeta - 1) ** 0.5;\r\n            return [alpha + beta, alpha - beta];\r\n        }\r\n        const alpha = -zeta * w_n;\r\n        const beta = w_n * (1 - zeta * zeta) ** 0.5;\r\n        return [new Complex(alpha, beta), new Complex(alpha, -beta)];\r\n    };\r\n    constructor(numerator, denominator, params = {}) {\r\n        let zeros = [],\r\n            poles = [];\r\n        if (params) {\r\n            if (params.overshoot && params.t_rise) {\r\n                params.overshoot = Number(params.overshoot);\r\n                params.t_rise = Number(params.t_rise);\r\n                const logMp = Math.log10(params.overshoot);\r\n                params.zeta =\r\n                    -logMp / (Math.PI * Math.PI + logMp * logMp) ** 0.5;\r\n                params.w_d = Math.PI / params.t_rise;\r\n                params.w_n =\r\n                    params.w_d / (1 - params.zeta * params.zeta) ** 0.5;\r\n            }\r\n\r\n            if (params.w_n) {\r\n                params.w_n = Number(params.w_n);\r\n                params.zeta = Number(params.zeta);\r\n                // if the user sends w_n params it will override the given zero/pole list\r\n                const { w_n, zeta } = params;\r\n                const wn2 = w_n * w_n;\r\n                numerator = wn2;\r\n                denominator = [1, 2 * zeta * w_n, wn2];\r\n                poles = TransferFunction.OmegaZetaPoles(w_n, zeta);\r\n                zeros = [];\r\n            }\r\n        }\r\n        super(numerator, denominator, \"s\", params);\r\n        // SIMPL;IFY\r\n        this.poles = [...poles]; //edit solve equations\r\n        this.zeros = [...zeros];\r\n        if (!this.a instanceof Array) this.a = [this.a];\r\n        if (this.a.length === 1 && !this.w_n) {\r\n            if (\r\n                this.b.length === 3 &&\r\n                this.b[this.b.length - 1] === this.a[0] &&\r\n                this.a[0] ** 2 === this.b[2]\r\n            ) {\r\n                this.w_n = this.a[0];\r\n                this.zeta = this.b[1] / (2 * this.w_n);\r\n                this.timeConstant = round(1 / (this.zeta * this.w_n));\r\n                this.t_settle = 4 * this.timeConstant;\r\n                if (params && params.w_d) this.w_d = params.w_d;\r\n                else if (this.zeta >= -1 && this.zeta <= 1)\r\n                    this.w_d = this.w_n * (1 - this.zeta ** 2) ** 0.5;\r\n                this.order = 2;\r\n                this.setRoots(\r\n                    [],\r\n                    TransferFunction.OmegaZetaPoles(this.w_n, this.zeta)\r\n                );\r\n            }\r\n        }\r\n        if (!this.order)\r\n            this.order =\r\n                denominator instanceof Array ? denominator.length - 1 : 1;\r\n        if (params.overshoot && params.t_rise) {\r\n            [this.overshoot, this.t_rise] = [params.overshoot, params.t_rise];\r\n        } else {\r\n            const dampingCharasteristics =\r\n                this.getDampingSystemCharasteristics();\r\n            if (dampingCharasteristics) {\r\n                this.overshoot = dampingCharasteristics.overshoot;\r\n                this.t_rise = dampingCharasteristics.t_rise;\r\n            }\r\n        }\r\n        if (\r\n            (!this.zeros || !this.zeros.length) &&\r\n            (!this.poles || !this.poles.length)\r\n        )\r\n            this.updateRoots();\r\n    }\r\n\r\n    getRootsByNerdamer = () => [\r\n        this.a.length > 1\r\n            ? new Formula(this.numerator().toFormula(), this.symbol).x()\r\n            : [],\r\n        this.b.length > 1\r\n            ? new Formula(this.denominator().toFormula(), this.symbol).x()\r\n            : [],\r\n    ];\r\n    roots = (useNerdamer = false) => {\r\n        // roots hasnt been decided by user\r\n        let zeros = [],\r\n            poles = [];\r\n        if (\r\n            this.a instanceof Array &&\r\n            this.b instanceof Array && // if all elements of numerator and denominator are actual numbers\r\n            !this.a.find((ai) => ai !== +ai) &&\r\n            !this.b.find((bi) => bi !== +bi)\r\n        ) {\r\n            // CONSTANT COEFFICIENT POLYNOMIAL EQUATIONS\r\n            if (!useNerdamer) {\r\n                try {\r\n                    zeros =\r\n                        this.a.length > 1\r\n                            ? new Equation(this.a, this.symbol).solve()\r\n                            : [];\r\n                    poles =\r\n                        this.b.length > 1\r\n                            ? new Equation(this.b, this.symbol).solve()\r\n                            : [];\r\n                } catch (ex) {\r\n                    [zeros, poles] = this.getRootsByNerdamer();\r\n                }\r\n            } else [zeros, poles] = this.getRootsByNerdamer();\r\n\r\n            if (zeros.length < this.a.length - 1) {\r\n                zeros = Formula.RepetitiveFactors(\r\n                    this.numerator().toFormula(),\r\n                    zeros,\r\n                    this.symbol\r\n                );\r\n            }\r\n            if (poles.length < this.b.length - 1) {\r\n                poles = Formula.RepetitiveFactors(\r\n                    this.denominator().toFormula(),\r\n                    poles,\r\n                    this.symbol\r\n                );\r\n            }\r\n        } else {\r\n            // if the equation isnt a simple constant coefficient polynomial\r\n        }\r\n\r\n        return [zeros, poles];\r\n    };\r\n\r\n    setRoots = (zeros, poles) => {\r\n        this.poles = poles\r\n            .map((pi) =>\r\n                pi instanceof Complex ? pi.copy() : new Complex(pi, 0)\r\n            )\r\n            .sort((p1, p2) => p1.real() - p2.real());\r\n        this.zeros = zeros\r\n            .map((zi) =>\r\n                zi instanceof Complex ? zi.copy() : new Complex(zi, 0)\r\n            )\r\n            .sort((z1, z2) => z1.real() - z2.real());\r\n        this.orderedZeros = TransferFunction.RootOrders(this.zeros);\r\n        this.orderedPoles = TransferFunction.RootOrders(this.poles);\r\n        return this;\r\n    };\r\n\r\n    characteristicEquation = (k = 1) =>\r\n        this.denominator().add(\r\n            k !== 1 ? this.numerator() : this.numerator().multiply(k)\r\n        );\r\n\r\n    updateRoots = () => {\r\n        const [zeros, poles] = this.roots();\r\n\r\n        return this.setRoots(zeros, poles);\r\n    };\r\n    getDampingSystemCharasteristics = () =>\r\n        this.w_d\r\n            ? {\r\n                  t_rise: round(Math.PI / this.w_d),\r\n                  // WHAT IF W_D === 0?\r\n                  overshoot:\r\n                      this.zeta >= -1 && this.zeta <= 1\r\n                          ? round(\r\n                                100 *\r\n                                    Math.exp(\r\n                                        -(this.zeta * Math.PI) /\r\n                                            (1 - this.zeta ** 2) ** 0.5\r\n                                    )\r\n                            )\r\n                          : null,\r\n              }\r\n            : null;\r\n\r\n    getOrder = () => this.order;\r\n    setOrder = (order) => {\r\n        this.order = order;\r\n        return this;\r\n    };\r\n    getPoles = () => this.poles;\r\n    setPoles = (poles) => {\r\n        this.poles = TransferFunction.map((pi) =>\r\n            pi instanceof Complex ? pi.copy() : new Complex(pi, 0)\r\n        );\r\n        return this;\r\n    };\r\n    getZeros = () => this.zeros;\r\n    setZeros = (zeros) => {\r\n        this.zeros = zeros.map((zi) =>\r\n            zi instanceof Complex ? zi.copy() : new Complex(zi, 0)\r\n        );\r\n        return this;\r\n    };\r\n\r\n    poleOrder = (pole) =>\r\n        this.poles.filter((pi) => Algebra.areTheseTwoEqual(pole, pi)).length;\r\n\r\n    derivative = (against = this.symbol) => {\r\n        let result = this.copy(true);\r\n        if (against === this.symbol) {\r\n            const rplus = result.plus;\r\n            if (!result.dot) {\r\n                if (!result.isIntegrator()) {\r\n                    const f = result.numerator(),\r\n                        g = result.denominator();\r\n                    const num = f\r\n                        .derivative()\r\n                        .multiply(g)\r\n                        .substract(g.derivative().multiply(f));\r\n                    result = num.devide(g.multiply(g)).toTransferFunction();\r\n                } else {\r\n                    if (typeof result.a === \"number\") result.a = [result.a];\r\n                    const n = this.b.length - 1;\r\n                    result.a *= -n;\r\n                    result.b.push(0);\r\n                }\r\n            }\r\n            if (rplus) result.plus = rplus.derivative();\r\n        }\r\n\r\n        return result;\r\n    };\r\n    laplace = () => this.copy(true); // actually it has no laplace, this is for disfunctioning the laplace method in the parent class Algebra\r\n    laplaceInverse = () => {\r\n        this.updateRoots();\r\n\r\n        const f_s = this.simplify();\r\n        if (f_s.isIntegrator()) {\r\n            const denCoef = f_s.b.filter((bi) => bi !== 0)[0];\r\n            return {\r\n                $s: f_s.copy(),\r\n                $t: Poly.atn(\r\n                    (f_s.a instanceof Array ? f_s.a[0] : f_s.a) / denCoef,\r\n                    f_s.denominator().degree() - 1\r\n                ).setInputSignal(new Step()),\r\n            };\r\n        }\r\n        const coefs = [];\r\n        const zeros = f_s.orderedZeros,\r\n            poles = f_s.orderedPoles; // shortcuts\r\n\r\n        for (let i = 0; i < poles.length; i++) {\r\n            // for(let j  = 0; j < poles[i].order; i++)\r\n            const s = poles[i].value;\r\n            const otherPoles = [...poles];\r\n            otherPoles.splice(i, 1);\r\n            const num =\r\n                    zeros.length > 0\r\n                        ? Complex.MultiplyFactors(\r\n                              zeros,\r\n                              s,\r\n                              f_s.numerator().mostSignificantCoefficient()\r\n                          )\r\n                        : new Complex(\r\n                              f_s.numerator().mostSignificantCoefficient(),\r\n                              0\r\n                          ),\r\n                den = Complex.MultiplyFactors(\r\n                    otherPoles,\r\n                    s,\r\n                    f_s.denominator().mostSignificantCoefficient()\r\n                );\r\n            coefs.push(num.devide(den));\r\n            if (poles[i].order > 1) {\r\n                coefs[i] = [coefs[i]];\r\n\r\n                let dF = TransferFunction.Shortcuts.$Roots(\r\n                    zeros.map((z) => z.value),\r\n                    otherPoles.map((p) => p.value)\r\n                );\r\n\r\n                let factoriel = 1;\r\n                for (let q = 1; q < poles[i].order; q++) {\r\n                    dF = dF.derivative();\r\n                    let coef = dF.$(s);\r\n                    coef =\r\n                        coef instanceof Complex ? coef : new Complex(coef, 0);\r\n                    factoriel *= q;\r\n                    coefs[i].push(coef.devide(factoriel));\r\n                }\r\n            }\r\n        }\r\n        // edit THIIIIIIIIIIIIIS\r\n        let g_s = new Zero(),\r\n            c_t = new Zero();\r\n        for (let i = 0; i < coefs.length; i++) {\r\n            if (coefs[i] instanceof Array && poles[i].order > 1) {\r\n                const n = poles[i].order;\r\n                for (let q = 0; q < n; q++) {\r\n                    g_s = g_s.add(\r\n                        TransferFunction.Shortcuts.$DelayedIntegrator(\r\n                            coefs[i][q].actual(),\r\n                            poles[i].value.negation().actual(),\r\n                            n - q\r\n                        )\r\n                    );\r\n\r\n                    const ap = Poly.atn(\r\n                        coefs[i][q].actual(),\r\n                        poles[i].order - q - 1\r\n                    );\r\n                    c_t = !poles[i].value.isZero()\r\n                        ? c_t.add(\r\n                              new Exp(ap, poles[i].value.actual(), \"t\", {\r\n                                  input: new Step(),\r\n                              })\r\n                          )\r\n                        : c_t.add(ap).multiply(new Step());\r\n                }\r\n            } else {\r\n                g_s = g_s.add(\r\n                    new TransferFunction(coefs[i].actual(), [\r\n                        1,\r\n                        poles[i].value.negation().actual(),\r\n                    ])\r\n                );\r\n                c_t = c_t.add(\r\n                    !poles[i].value.isZero()\r\n                        ? new Exp(\r\n                              coefs[i].actual(),\r\n                              poles[i].value.actual(),\r\n                              \"t\",\r\n                              { input: new Step() }\r\n                          ).toSin()\r\n                        : new Poly(coefs[i].actual(), \"t\", {\r\n                              input: new Step(),\r\n                          })\r\n                );\r\n            }\r\n        }\r\n        return { $s: g_s, $t: c_t.simplify() };\r\n    };\r\n\r\n    stepify = () => {\r\n        const lstep = this.copy();\r\n        lstep.b.push(0); //update denominator\r\n        lstep.poles.push(Complex.jX(0));\r\n        return lstep;\r\n    };\r\n    step = () => {\r\n        // normally will automatically return the time domain answer\r\n        // unless inLaplaceDomain is true\r\n        // PUT INPUT SIGNAL AT THE END\r\n        const m = this.zeros.length; // number of zeros\r\n        const n = this.poles.length; // number of poles\r\n        const nreal = this.poles.filter(\r\n            (pi) => !(pi instanceof Complex) || pi.isReal()\r\n        ).length; // number of real poles; can be eig   her 2 or 0\r\n        if (m === 0) {\r\n            const k = this.numerator();\r\n            if (n === 0) {\r\n                // return u(t)\r\n                // DEFINE U(T) IN ALGEBRA\r\n            }\r\n            if (n === 1) {\r\n            } else if (n === 2) {\r\n                const a = -this.poles[0],\r\n                    b = -this.poles[1];\r\n                if (nreal === 2) {\r\n                    // if (a > 0 && b > 0) {\r\n                    if (a !== b)\r\n                        // two independent polesdddd\r\n                        // two negative independent poles\r\n                        return new Exp(1 / a, -a)\r\n                            .add(new Exp(-1 / b, -b))\r\n                            .multiply(k / (a - b))\r\n                            .multiply(new Step())\r\n                            .add(new Step(k / (a * b)));\r\n                    else {\r\n                        const a2 = a * a;\r\n                        return new Exp(-k / a2, -a)\r\n                            .multiply(new Poly([a, 1]))\r\n                            .multiply(new Step())\r\n                            .add(new Step(k / a2));\r\n                    }\r\n                    // } else {\r\n                    //     // repetetive poles\r\n                    // }\r\n                } else if (nreal === 0) {\r\n                    // two conjugated complex poles\r\n                    //UNDERSHOOT BUG FIXLAYS HERE\r\n                    const a = -this.poles[0].real(),\r\n                        b = this.poles[0].imaginary();\r\n                    const ka2b2 = k / (a ** 2 + b ** 2);\r\n                    // FIND BUUUUUUG\r\n                    // return new Exp(-ka2b2, -a)\r\n                    //     .multiply(new Cos(1, b).add(new Sin(a / b, b)))\r\n                    //     .multiply(new Step())\r\n                    //     .add(new Step(ka2b2));\r\n                    return new Exp(-ka2b2, -a)\r\n                        .multiply(new Cos(1, b))\r\n                        .add(new Exp(-ka2b2, -a).multiply(new Sin(a / b, b)))\r\n                        .multiply(new Step())\r\n                        .add(new Step(ka2b2));\r\n                }\r\n                // else if( nreal == 1) // this cant happen, but what if sth went wrong?\r\n            }\r\n        }\r\n        // if its not in special mode:\r\n        return new Formula(this.stepify().toFormula(), this.symbol).iL();\r\n    };\r\n    copy = (\r\n        linkPrevious = false // copy everything\r\n    ) =>\r\n        new TransferFunction(this.a, this.b, {\r\n            overshoot: this.overshoot,\r\n            t_rise: this.t_rise,\r\n            t_settle: this.t_settle,\r\n            w_d: this.w_d,\r\n            timeConstant: this.timeConstant,\r\n            w_n: this.w_n,\r\n            zeta: this.zeta,\r\n            dot: this.dot,\r\n            plus: this.plus,\r\n            previous: linkPrevious ? this.previous : null,\r\n            input: this.input,\r\n        }).setRoots(this.zeros, this.poles);\r\n\r\n    hardcopy = () =>\r\n        // shallow-singleterm copy\r\n        new TransferFunction(this.a, this.b, {\r\n            dot: this.dot,\r\n            input: this.input,\r\n        });\r\n    lim = (s0) => {\r\n        let num, den;\r\n        // for simple polynomial numerator and denominator fractions\r\n        // IMPLEMENT HOPITAL AS WELL?\r\n        if (!s0) {\r\n            // s -> 0)\r\n\r\n            num = { a: 0, sp: this.a.length - 1 };\r\n            den = { b: 1, sp: this.b.length - 1 };\r\n            for (; num.sp > 0 && this.a[num.sp] === 0; num.sp--);\r\n            num.a = this.a[num.sp];\r\n            for (; den.sp > 0 && this.b[den.sp] === 0; den.sp--);\r\n            den.b = this.b[den.sp];\r\n            num.sp = this.a.length - num.sp - 1;\r\n            den.sp = this.b.length - den.sp - 1;\r\n            if (num.sp === den.sp) return num.a / den.b;\r\n            else {\r\n                const sMinPower = Math.min(den.sp, num.sp);\r\n                if (sMinPower) {\r\n                    num.sp -= sMinPower;\r\n                    den.sp -= sMinPower;\r\n                }\r\n                // now one of num.sp or den.sp is zero\r\n                if (den.sp)\r\n                    // zero on denominator\r\n                    return Infinity;\r\n                // if den.sp == 0 and num.sp != 0\r\n                return 0;\r\n            }\r\n        } else if (s0 === Infinity) {\r\n            // s -> infinity\r\n            num = { a: 0, sp: 0 };\r\n            den = { b: 1, sp: 0 };\r\n            for (; num.sp < this.a.length && this.a[num.sp] === 0; num.sp++);\r\n            num.a = this.a[num.sp];\r\n            for (; den.sp < this.b.length && this.b[den.sp] === 0; den.sp++);\r\n            den.b = this.b[den.sp];\r\n            num.sp = this.a.length - num.sp - 1;\r\n            den.sp = this.b.length - den.sp - 1;\r\n            if (num.sp === den.sp) return num.a / den.b;\r\n            // else\r\n            const sMinPower = Math.min(den.sp, num.sp);\r\n            if (sMinPower) {\r\n                num.sp -= sMinPower;\r\n                den.sp -= sMinPower;\r\n            }\r\n            // now one of num.sp or den.sp is zero\r\n            if (den.sp)\r\n                // zero on denominator\r\n                return 0;\r\n            // if den.sp == 0 and num.sp != 0\r\n            return Infinity;\r\n        } else {\r\n            // if s0 is just a no-zero limited number\r\n            num = this.numerator().$(s0);\r\n            den = this.denominator().$(s0);\r\n            if (den)\r\n                // simple non zero denominator limit\r\n                return num / den;\r\n            // if den == 0\r\n            // use Hopital or other limit methods\r\n            //return (num.a * (s0 ** num.sp)) / (den.b * (s0 ** den.sp));\r\n        }\r\n    };\r\n    errors = () => {\r\n        const sGs = this.multiply(new Poly([1, 0], \"s\"));\r\n        const s2Gs = sGs.multiply(new Poly([1, 0], \"s\"));\r\n        return {\r\n            Ks: round(this.lim(0)),\r\n            Kr: round(sGs.lim(0)),\r\n            Ka: round(s2Gs.lim(0)),\r\n        };\r\n    };\r\n    // $ = (t) => this.laplaceInverse().$(t); // valueOf function in certain point; I used character $ in many places as,\r\n    // acronym for \"set\" in setters, so $ here means that set the t ( or x or whatever) with a certain point\r\n\r\n    amplitude = (w) => {\r\n        // w === omega\r\n        const jw = Complex.jX(w);\r\n        const num = this.numerator(),\r\n            den = this.denominator();\r\n        const numAmp = !(num instanceof Exp)\r\n                ? num.$(jw).magnitude()\r\n                : Math.abs(num.getA()),\r\n            denAmp = !(den instanceof Exp)\r\n                ? den.$(jw).magnitude()\r\n                : Math.abs(den.getB());\r\n        return numAmp / denAmp;\r\n        // this is for find exact match of the devide function\r\n        // but im sure num and den are Complex so i directly stated the result\r\n\r\n        // if(num instanceof Complex)\r\n        //     return num.magnitude() / (den instanceof Complex ? den.magnitude : den).magnitude();\r\n        // if(den instanceof Complex)\r\n        //     return num instanceof Algebra ? num.devide(den.magnitude()) : num / den.magnitude();\r\n        // if(num instanceof Algebra)\r\n        //     return num.devide(den);\r\n        // if(den instanceof Algebra)\r\n        //     return den.devideInverse(num);\r\n        // // signal input?\r\n        // if(den)\r\n        //     return num / den;\r\n        // return NaN;\r\n    };\r\n\r\n    phase = (w) => {\r\n        const jw = Complex.jX(w);\r\n        let num = this.numerator(),\r\n            den = this.denominator();\r\n        const numPhase = !(num instanceof Exp)\r\n                ? num.$(jw).phase()\r\n                : num.phase(w), //exponentials have their own shortcut for phase()\r\n            denPhase = !(den instanceof Exp) ? den.$(jw).phase() : den.phase(w);\r\n        if (+denPhase === denPhase && +numPhase === numPhase)\r\n            return numPhase - denPhase;\r\n        // for now Complex.phase() returns numbers or functions:\r\n        // numPhase or denPhase instanceof Function then:\r\n        return (\r\n            (numPhase instanceof Function ? numPhase(w) : numPhase) -\r\n            (denPhase instanceof Function ? denPhase(w) : denPhase)\r\n        );\r\n        // else if(numPhase instanceof Algebra)\r\n        //     return numPhase.$(w) - den.phase();\r\n        // return NaN;\r\n    };\r\n\r\n    static PolarToCartesian = (A, phi) =>\r\n        new Complex(A * Math.cos(phi), A * Math.sin(phi));\r\n    nyquist = (w, method = \"cartesian\") =>\r\n        method === \"cartesian\"\r\n            ? this.$(Complex.jX(w))\r\n            : TransferFunction.PolarToCartesian(\r\n                  this.amplitude(w),\r\n                  this.phase(w)\r\n              );\r\n\r\n    bode = (w) => 20 * Math.log10(this.amplitude(w));\r\n\r\n    toFormula = () => {\r\n        // const [zeros, poles] = this.repetitiveRoots();\r\n        const num =\r\n            this.zeros.length > 0\r\n                ? this.zeros\r\n                      .map(\r\n                          (zi) =>\r\n                              \"(\" +\r\n                              this.symbol +\r\n                              \" - \" +\r\n                              zi.toString(false, true).replace(\"j\", \"i*\") +\r\n                              \")\"\r\n                      )\r\n                      .join(\"*\")\r\n                : \"1\";\r\n        const den =\r\n            this.poles.length > 0\r\n                ? this.poles\r\n                      .map(\r\n                          (pi) =>\r\n                              \"(\" +\r\n                              this.symbol +\r\n                              \" - \" +\r\n                              pi.toString(false, true).replace(\"j\", \"i*\") +\r\n                              \")\"\r\n                      )\r\n                      .join(\"*\")\r\n                : \"1\";\r\n        return `(${num})/(${den})`;\r\n    };\r\n\r\n    // ****************************************************** //\r\n    rootLocus = async (k_min, k_max, progressBarObject, N = 1000) => {\r\n        // return root locus values for plotting\r\n\r\n        // TEMPORARY:\r\n        let dk = (k_max - k_min) / N;\r\n        const a = this.getA(), // numerator\r\n            b = this.getB(); // denominator => a / b\r\n        const na = a.length - 1,\r\n            nb = b.length - 1;\r\n        const reals = [],\r\n            imaginaries = [];\r\n        const progressLength = k_max - k_min;\r\n        const newTerm = Formula.GetTerm; // Equation.GetAlgebriteTerm;\r\n        for (let k = k_min, progress = 0; k <= k_max; k += dk, progress += dk) {\r\n            // in this piece: using short form codes and using objects is set to minimum\r\n            // because root locus is time consuming and putting all the codes in one main loop is better\r\n            // const delta = b.add(a.multiply(k));\r\n            let delta = null,\r\n                expression = \"\";\r\n            // USE ARRAY DIRECT PROCESS FOR FASTER RESPONSE\r\n            // NUM + K * DEN\r\n            if (na <= nb) {\r\n                delta = Array(nb);\r\n                const offsetB = nb - na;\r\n                for (\r\n                    let i = 0;\r\n                    i < offsetB;\r\n                    delta[i] = b[i],\r\n                        expression += newTerm(nb - i, delta[i], this.symbol),\r\n                        i++\r\n                );\r\n                for (\r\n                    let i = 0, ib = offsetB;\r\n                    i <= na;\r\n                    delta[ib] = b[ib] + k * a[i],\r\n                        expression += newTerm(na - i, delta[ib], this.symbol),\r\n                        i++,\r\n                        ib++\r\n                );\r\n            } else {\r\n                delta = Array(na);\r\n                const offsetA = na - nb;\r\n                for (\r\n                    let i = 0;\r\n                    i < offsetA;\r\n                    delta[i] = b[i],\r\n                        expression += newTerm(na - i, delta[i], this.symbol),\r\n                        i++\r\n                );\r\n                for (\r\n                    let i = 0, ib = offsetA;\r\n                    i <= nb;\r\n                    delta[ib] = b[ib] + k * a[i],\r\n                        expression += newTerm(nb - i, delta[ib], this.symbol),\r\n                        i++,\r\n                        ib++\r\n                );\r\n            }\r\n            const poles = new Formula(expression, this.symbol).x();\r\n            await makeProgress(\r\n                progressBarObject,\r\n                (100 * progress) / progressLength\r\n            );\r\n\r\n            for (let i = 0; i < poles.length; i++) {\r\n                if (poles[i] instanceof Complex) {\r\n                    reals.push(poles[i].real());\r\n                    imaginaries.push(poles[i].imaginary());\r\n                } else {\r\n                    reals.push(poles[i]);\r\n                    imaginaries.push(0);\r\n                }\r\n            }\r\n        }\r\n        await makeProgress(progressBarObject, 100);\r\n        return [reals, imaginaries];\r\n    };\r\n\r\n    rootsByAlgebriteLocus = async (\r\n        k_min,\r\n        k_max,\r\n        progressBarObject,\r\n        N = 1000\r\n    ) => {\r\n        // return root locus values for plotting\r\n\r\n        // TEMPORARY:\r\n        let dk = (k_max - k_min) / N;\r\n        const a = this.getA(), // numerator\r\n            b = this.getB(); // denominator => a / b\r\n        const na = a.length - 1,\r\n            nb = b.length - 1;\r\n        const reals = [],\r\n            imaginaries = [];\r\n        const progressLength = k_max - k_min;\r\n        const newTerm = Equation.GetAlgebriteTerm;\r\n        for (let k = k_min, progress = 0; k <= k_max; k += dk, progress += dk) {\r\n            // in this piece: using short form codes and using objects is set to minimum\r\n            // because root locus is time consuming and putting all the codes in one main loop is better\r\n            // const delta = b.add(a.multiply(k));\r\n            let delta = null,\r\n                expression = \"\";\r\n            // USE ARRAY DIRECT PROCESS FOR FASTER RESPONSE\r\n            // NUM + K * DEN\r\n            if (na <= nb) {\r\n                delta = Array(nb);\r\n                const offsetB = nb - na;\r\n                for (\r\n                    let i = 0;\r\n                    i < offsetB;\r\n                    delta[i] = b[i],\r\n                        expression += newTerm(nb - i, delta[i], i, this.symbol),\r\n                        i++\r\n                );\r\n                for (\r\n                    let i = 0, ib = offsetB;\r\n                    i <= na;\r\n                    delta[ib] = b[ib] + k * a[i],\r\n                        expression += newTerm(\r\n                            na - i,\r\n                            delta[ib],\r\n                            ib,\r\n                            this.symbol\r\n                        ),\r\n                        i++,\r\n                        ib++\r\n                );\r\n            } else {\r\n                delta = Array(na);\r\n                const offsetA = na - nb;\r\n                for (\r\n                    let i = 0;\r\n                    i < offsetA;\r\n                    delta[i] = b[i],\r\n                        expression += newTerm(na - i, delta[i], i, this.symbol),\r\n                        i++\r\n                );\r\n                for (\r\n                    let i = 0, ib = offsetA;\r\n                    i <= nb;\r\n                    delta[ib] = b[ib] + k * a[i],\r\n                        expression += newTerm(\r\n                            nb - i,\r\n                            delta[ib],\r\n                            ib,\r\n                            this.symbol\r\n                        ),\r\n                        i++,\r\n                        ib++\r\n                );\r\n            }\r\n            // const roots = new Equation(new Poly(delta)).roots();\r\n            const poles = new Equation(expression).solve();\r\n\r\n            await makeProgress(\r\n                progressBarObject,\r\n                (100 * progress) / progressLength\r\n            );\r\n\r\n            for (let i = 0; i < poles.length; i++) {\r\n                if (poles[i] instanceof Complex) {\r\n                    reals.push(poles[i].real());\r\n                    imaginaries.push(poles[i].imaginary());\r\n                } else {\r\n                    reals.push(poles[i]);\r\n                    imaginaries.push(0);\r\n                }\r\n            }\r\n        }\r\n        await makeProgress(progressBarObject, 100);\r\n        return [reals, imaginaries];\r\n    };\r\n\r\n    controlFeedback = (controller) => {\r\n        const cs_gs = this.multiply(controller);\r\n        return cs_gs\r\n            .numerator()\r\n            .devide(cs_gs.numerator().add(cs_gs.denominator()))\r\n            .toTransferFunction();\r\n    };\r\n\r\n    isIntegrator = () =>\r\n        !this.dot\r\n            ? (typeof this.a === \"number\" ||\r\n                  (this.a.length === 1 && typeof this.a[0] === \"number\")) &&\r\n              this.b[this.b.length - 1] === 0 &&\r\n              this.b.filter((bi) => (bi instanceof Complex ? !bi.isZero() : bi))\r\n                  .length === 1 &&\r\n              !this.plus &&\r\n              !this.previous\r\n            : this.copy().linkDot(null).multiply(this.dot).isIntegrator();\r\n\r\n    simplify = () => {\r\n        const [zeros, poles] = this.getSimplifiedRoots();\r\n        return TransferFunction.Shortcuts.$Roots(\r\n            zeros,\r\n            poles,\r\n            this.numerator().mostSignificantCoefficient(),\r\n            this.denominator().mostSignificantCoefficient()\r\n        );\r\n    };\r\n}\r\n","import Algebra from \"math/algebra\";\r\nimport Complex from \"math/algebra/complex\";\r\nimport Exp from \"./exp\";\r\nimport Fraction from \"./fraction\";\r\n\r\nexport class Sin extends Algebra {\r\n    constructor(A, w, teta = 0, symbol = \"t\", params = {}) {\r\n        // Ae^wt\r\n        if (w === +w && w < 0) {\r\n            w *= -1;\r\n            A *= -1;\r\n        }\r\n        super(A, { symbol, type: \"sin\", b: w, teta, ...params });\r\n    }\r\n    copy = (\r\n        linkPrevious = false // deep copy; copy everything\r\n    ) =>\r\n        new Sin(this.a, this.b, this.teta, this.symbol, {\r\n            dot: this.dot,\r\n            plus: this.plus,\r\n            previous: linkPrevious ? this.previous : null,\r\n            input: this.input,\r\n        });\r\n    hardcopy = () =>\r\n        // shallow copy; copy signle term\r\n        new Sin(this.a, this.b, this.teta, this.symbol, {\r\n            dot: this.dot,\r\n            input: this.input,\r\n        });\r\n    toExp = () => {\r\n        const sin = this.copy();\r\n        const exp1 = new Exp(sin.a / 2, Complex.jX(-sin.b));\r\n        const exp2 = new Exp(-sin.a / 2, Complex.jX(sin.b));\r\n        return Complex.jX(exp1.add(exp2));\r\n    };\r\n\r\n    valueAt = (t) => {\r\n        const A = Algebra.valueOf(this.a, t);\r\n        const w = Algebra.valueOf(this.b, t);\r\n        const teta = Algebra.valueOf(this.teta, t);\r\n        return A * Math.sin(w * t + teta);\r\n    };\r\n    static ConvertToMe = (algebra) =>\r\n        new Sin(\r\n            algebra.getA(),\r\n            algebra.getB() ? algebra.getB() : 0,\r\n            algebra.symbol,\r\n            {\r\n                dot: this.dot,\r\n                plus: this.plus,\r\n                previous: this.previous,\r\n                input: this.input,\r\n            }\r\n        );\r\n}\r\n\r\nexport class Cos extends Algebra {\r\n    constructor(A, w, teta = 0, symbol = \"t\", params = {}) {\r\n        // Ae^wt\r\n        if (+w === w && w < 0) w *= -1; // cos(-w) = cos(w);\r\n        super(A, { symbol, type: \"cos\", b: w, teta, ...params });\r\n    }\r\n    copy = (linkPrevious = false) =>\r\n        new Cos(this.a, this.b, this.teta, this.symbol, {\r\n            dot: this.dot,\r\n            plus: this.plus,\r\n            previous: linkPrevious ? this.previous : null,\r\n            input: this.input,\r\n        });\r\n    hardcopy = () =>\r\n        // shallow copy; copy signle term\r\n        new Cos(this.a, this.b, this.teta, this.symbol, {\r\n            dot: this.dot,\r\n            input: this.input,\r\n        });\r\n    toExp = () => {\r\n        const cos = this.copy();\r\n        const exp1 = new Exp(cos.a / 2, Complex.jX(cos.b));\r\n        const exp2 = new Exp(cos.a / 2, Complex.jX(-cos.b));\r\n        return exp1.add(exp2);\r\n    };\r\n\r\n    valueAt = (t) => {\r\n        const A = Algebra.valueOf(this.a, t);\r\n        const w = Algebra.valueOf(this.b, t);\r\n        const teta = Algebra.valueOf(this.teta, t);\r\n        return A * Math.cos(w * t + teta);\r\n    };\r\n    static ConvertToMe = (algebra) =>\r\n        new Cos(\r\n            algebra.getA(),\r\n            algebra.getB() ? algebra.getB() : 0,\r\n            algebra.symbol,\r\n            {\r\n                dot: this.dot,\r\n                plus: this.plus,\r\n                previous: this.previous,\r\n                input: this.input,\r\n            }\r\n        );\r\n}\r\n\r\nexport class Tan extends Algebra {\r\n    constructor(A, w, teta = 0, symbol = \"t\", params = {}) {\r\n        // Ae^wt\r\n        super(A, { symbol, type: \"tan\", b: w, teta, ...params });\r\n    }\r\n    copy = (linkPrevious = false) =>\r\n        new Tan(this.a, this.b, this.teta, this.symbol, {\r\n            dot: this.dot,\r\n            plus: this.plus,\r\n            previous: linkPrevious ? this.previous : null,\r\n            input: this.input,\r\n        });\r\n    hardcopy = () =>\r\n        // shallow copy; copy signle term\r\n        new Tan(this.a, this.b, this.teta, this.symbol, {\r\n            dot: this.dot,\r\n            input: this.input,\r\n        });\r\n    toExp = () => {\r\n        const tan = this.copy();\r\n        const exp1 = new Exp(1, Complex.jX(-tan.b));\r\n        const numeratorExp2 = new Exp(-1, Complex.jX(tan.b));\r\n        const denominatorExp2 = new Exp(1, Complex.jX(tan.b));\r\n        return new Fraction(exp1.add(numeratorExp2), exp1.add(denominatorExp2));\r\n    };\r\n\r\n    valueAt = (t) => {\r\n        const A = Algebra.valueOf(this.a, t);\r\n        const w = Algebra.valueOf(this.b, t);\r\n        const teta = Algebra.valueOf(this.teta, t);\r\n        return A * Math.tan(w * t + teta);\r\n    };\r\n    static ConvertToMe = (algebra) =>\r\n        new Tan(\r\n            algebra.getA(),\r\n            algebra.getB() ? algebra.getB() : 0,\r\n            algebra.symbol,\r\n            {\r\n                dot: this.dot,\r\n                plus: this.plus,\r\n                previous: this.previous,\r\n                input: this.input,\r\n            }\r\n        );\r\n}\r\n\r\nexport class Cot extends Algebra {\r\n    constructor(A, w, teta = 0, symbol = \"t\", params = {}) {\r\n        // Ae^wt\r\n        super(A, { symbol, type: \"cot\", b: w, teta, ...params });\r\n    }\r\n    copy = (linkPrevious = false) =>\r\n        new Cot(this.a, this.b, this.teta, this.symbol, {\r\n            dot: this.dot,\r\n            plus: this.plus,\r\n            previous: linkPrevious ? this.previous : null,\r\n            input: this.input,\r\n        });\r\n    hardcopy = () =>\r\n        // shallow copy; copy signle term\r\n        new Cot(this.a, this.b, this.teta, this.symbol, {\r\n            dot: this.dot,\r\n            input: this.input,\r\n        });\r\n    toExp = () => {\r\n        const cot = this.copy();\r\n        const exp1 = new Exp(1, Complex.jX(-cot.b));\r\n        const numeratorExp2 = new Exp(-1, Complex.jX(cot.b));\r\n        const denominatorExp2 = new Exp(1, Complex.jX(cot.b));\r\n        return new Fraction(exp1.add(denominatorExp2), exp1.add(numeratorExp2));\r\n    };\r\n\r\n    valueAt = (t) => {\r\n        const A = Algebra.valueOf(this.a, t);\r\n        const w = Algebra.valueOf(this.b, t);\r\n        const teta = Algebra.valueOf(this.teta, t);\r\n        return A * Math.cot(w * t + teta);\r\n    };\r\n    static ConvertToMe = (algebra) =>\r\n        new Cot(\r\n            algebra.getA(),\r\n            algebra.getB() ? algebra.getB() : 0,\r\n            algebra.symbol,\r\n            {\r\n                dot: this.dot,\r\n                plus: this.plus,\r\n                previous: this.previous,\r\n                input: this.input,\r\n            }\r\n        );\r\n}\r\n","import Algebra from \"../algebra/index\";\r\nimport { isDigit, precision, round } from \"math/calculus\";\r\nimport Complex from \"math/algebra/complex\";\r\nimport Poly from \"../algebra/functions/poly\";\r\nconst Algebrite = require(\"algebrite\");\r\n\r\nexport default class Equation {\r\n    static zeroPrecision = round(10 ** -precision.get());\r\n    constructor(exp, symbol = \"x\") {\r\n        if (exp instanceof Array) {\r\n            this.symbol = symbol;\r\n            this.algebra = new Poly(exp, this.symbol);\r\n            this.expression = \"\";\r\n            const n = exp.length - 1;\r\n            this.degree = n;\r\n            for (\r\n                let i = 0;\r\n                i < exp.length;\r\n                this.expression += Equation.GetAlgebriteTerm(\r\n                    n - i,\r\n                    exp[i],\r\n                    i,\r\n                    symbol\r\n                ),\r\n                    i++\r\n            );\r\n        } else if (typeof exp === \"string\") {\r\n            this.expression = exp;\r\n            this.algebra = null;\r\n            this.symbol = symbol;\r\n        } else if (exp instanceof Poly) {\r\n            this.expression = \"\";\r\n            this.algebra = exp.copy();\r\n            this.symbol = this.algebra.symbol;\r\n            const expression = this.algebra.getA();\r\n            const n = expression.length - 1;\r\n            this.degree = n; // unknown\r\n            for (\r\n                let i = 0;\r\n                i < expression.length;\r\n                this.expression += Equation.GetAlgebriteTerm(\r\n                    n - i,\r\n                    expression[i],\r\n                    i,\r\n                    symbol\r\n                ),\r\n                    i++\r\n            );\r\n        } else if (exp instanceof Algebra) {\r\n            // THIS IS TEMPORARY\r\n            this.expression = exp.toString(); // wrong EDIT THIS LATER\r\n            this.algebra = exp.copy();\r\n            this.symbol = this.exp.symbol;\r\n            this.degree = undefined; // unknown\r\n        }\r\n        this.symbol = symbol;\r\n    }\r\n\r\n    static GetAlgebriteTerm = (termDegree, coef, index, symbol) => {\r\n        if (!coef) return \"\";\r\n        if (coef === +coef) {\r\n            // means that coef is not a string\r\n            const intExpI = coef | 0;\r\n            const symbolicPart =\r\n                termDegree > 0 ? `*${symbol}^${termDegree}` : \"\";\r\n            if (intExpI !== coef) {\r\n                // means that coef is a float number\r\n                Algebrite.run(`a${index} = ${coef}`);\r\n                return (coef >= 0 ? \"+\" : \"\") + `a${index}${symbolicPart}`;\r\n            } else\r\n                return (intExpI >= 0 ? \"+\" : \"\") + `${intExpI}${symbolicPart}`;\r\n        }\r\n        // here it means coef is a string like '11/2' or '1/4', ...\r\n        return `${coef}${symbol}^${termDegree}`;\r\n    };\r\n    solve = () => {\r\n        // for factorable equations use: algebrite.roots\r\n        if (this.algebra && this.algebra.toString() === this.symbol)\r\n            return [Complex.jX(0)];\r\n        let x = Algebrite.nroots(this.expression)\r\n            .toString()\r\n            .replaceAll(\"...\", \"\");\r\n        x = x.slice(1, x.length - 1);\r\n        x = x.split(\",\").filter((xi) => xi && xi !== \"\"); // now x is converted from a string to the array of x answers (as Numbers);\r\n        // edit string to array\r\n        return x.map((xi, i) => {\r\n            // let [real, image] = xi.split(/\\+|-/).filter((xi) => xi && xi !== \"\");\r\n            let separatorIndex = 1;\r\n            for (; separatorIndex < xi.length; separatorIndex++)\r\n                if (\r\n                    (xi[separatorIndex] === \"+\" ||\r\n                        xi[separatorIndex] === \"-\") &&\r\n                    isDigit(xi[separatorIndex - 1]) &&\r\n                    isDigit(xi[separatorIndex + 1])\r\n                )\r\n                    break;\r\n\r\n            let terms = [];\r\n            terms.push(xi.slice(0, separatorIndex));\r\n            if (separatorIndex < xi.length)\r\n                terms.push(xi.slice(separatorIndex, xi.length - 2));\r\n\r\n            if (terms.length === 1) {\r\n                const magnitude = terms[0].replace(\"*i\", \"\");\r\n                return magnitude === terms[0]\r\n                    ? new Complex(Number(magnitude))\r\n                    : Complex.jX(Number(magnitude));\r\n            } else return new Complex(Number(terms[0]), Number(terms[1]));\r\n        });\r\n    };\r\n\r\n    // AlgebraRoots = () => {\r\n    //     // convert roots returning string to\r\n    //     if (!this.roots || this.roots.length === 0) this.solve();\r\n    // };\r\n\r\n    approximate = (\r\n        method = Equation.Methods.newton,\r\n        N = 10,\r\n        boundary = 1000\r\n    ) => {\r\n        const allRoots = [];\r\n        // newton reaches to approx fast\r\n        // so N = 10 is enough (?????)\r\n        const isUnique = (newRoot) =>\r\n            !isNaN(newRoot) &&\r\n            allRoots.findIndex((rt) =>\r\n                !(rt instanceof Complex) ? rt === newRoot : rt.equals(newRoot)\r\n            ) === -1;\r\n        const isUniqueComplex = (newRoot) =>\r\n            newRoot instanceof Complex &&\r\n            allRoots.findIndex((rt) => newRoot.equals(rt)) === -1;\r\n\r\n        if (this.expression instanceof Algebra) {\r\n            let a0 = 0;\r\n            for (let i = this.expression.a.length - 1; i >= 0; i--)\r\n                if (this.expression.a[i]) {\r\n                    a0 = this.expression.a[i];\r\n                    break;\r\n                }\r\n            const an = this.expression.a[0];\r\n\r\n            if (a0 && an !== 0) boundary = Math.abs(a0 / an);\r\n\r\n            for (let x0 = -boundary; x0 <= boundary; x0++) {\r\n                let x = method(this.algebra, x0, N);\r\n                if (!isNaN(x)) {\r\n                    const rx = round(x);\r\n                    if (isUnique(rx)) allRoots.push(rx);\r\n                }\r\n                x = method(this.algebra, Complex.jX(x0), N);\r\n                if (isUniqueComplex(x)) allRoots.push(x);\r\n            }\r\n        }\r\n        return allRoots;\r\n    };\r\n    // approximation methods\r\n    durandKerner = (N = 20) => {\r\n        if (this.algebra instanceof Algebra) {\r\n            const f = this.algebra.$;\r\n            const n = this.algebra.degree();\r\n            let guess;\r\n            do {\r\n                guess = new Complex(Math.random(), Math.random());\r\n            } while (guess.isReal());\r\n            const roots = Array(n)\r\n                .fill(0)\r\n                .map((_) => []);\r\n\r\n            roots[0].push(new Complex(1, 0));\r\n            for (let i = 1; i < n; i++)\r\n                roots[i][0] = guess.multiply(roots[i - 1][0]);\r\n            for (let iter = 0; iter < N; iter++) {\r\n                for (let i = 0; i < n; i++) {\r\n                    const xiN = roots[i][iter].copy();\r\n                    let sndTermDen = new Complex(1, 0);\r\n                    for (let j = 0; j < n; j++) {\r\n                        if (i !== j) {\r\n                            const xjN = roots[j][roots[j].length - 1];\r\n                            sndTermDen = sndTermDen.multiply(\r\n                                xiN.substract(xjN)\r\n                            );\r\n                        }\r\n                    }\r\n                    let sndTerm = f(xiN).devide(sndTermDen);\r\n                    // USING PUSH MAY SLOW DOWN THE ALGORITHM\r\n                    roots[i].push(xiN.substract(sndTerm));\r\n                }\r\n            }\r\n            return roots.map((r) => r[r.length - 1]);\r\n        }\r\n    };\r\n\r\n    static Methods = {\r\n        // needs work!\r\n        newton: (algebraf, x0 = 0, N = 20) => {\r\n            const f = algebraf.$;\r\n            const df = algebraf.derivative().$;\r\n            const xs = Array(N + 1).fill(0);\r\n            const dfx0 = df(x0);\r\n            if (dfx0 && (!(dfx0 instanceof Complex) || !dfx0.isZero())) {\r\n                if (x0 instanceof Complex) {\r\n                    xs[0] = x0;\r\n                    for (let i = 0; i < N; i++) {\r\n                        // const dfxsi = df(xs[i]);\r\n                        xs[i + 1] = xs[i].substract(f(xs[i]).devide(df(xs[i])));\r\n                    }\r\n\r\n                    const fx = f(xs[N]);\r\n                    if (\r\n                        Math.abs(fx.real()) > Equation.zeroPrecision ||\r\n                        Math.abs(fx.imaginary()) > Equation.zeroPrecision\r\n                    )\r\n                        return NaN;\r\n                } else {\r\n                    xs[0] = x0;\r\n\r\n                    for (let i = 0; i < N; i++) {\r\n                        xs[i + 1] = xs[i] - f(xs[i]) / df(xs[i]);\r\n                    }\r\n\r\n                    if (f(xs[N]) > Equation.zeroPrecision) return NaN;\r\n                }\r\n                //integrity check!\r\n                return xs[xs.length - 1];\r\n            }\r\n            return NaN;\r\n        },\r\n        // needs work!\r\n        middlePoint: (\r\n            f,\r\n            boundary = 1000\r\n            // decimalPrecision = precision.get()\r\n        ) => {\r\n            // NOTE: works fine for some equations\r\n            // and wronge for some others like:  x ** 2 - 4*x  - 5\r\n            boundary = Math.abs(boundary);\r\n            const expectedRate = Equation.zeroPrecision;\r\n            const poles = [];\r\n            let xa = 0,\r\n                xb = 1;\r\n            for (let i = 0; i < boundary; i++) {\r\n                xa = -boundary + i;\r\n                xb = boundary - i;\r\n\r\n                let rate =\r\n                    (xb - xa) / (2 * Math.max(Math.abs(xa), Math.abs(xb)));\r\n                let p = null;\r\n                while (rate >= expectedRate) {\r\n                    p = (xa + xb) / 2;\r\n                    if (!f(p)) break;\r\n                    else if (f(p) * f(xa) < 0) xb = p;\r\n                    else {\r\n                        xa = p;\r\n                        rate =\r\n                            (xb - xa) /\r\n                            (2 * Math.max(Math.abs(xa), Math.abs(xb)));\r\n                    }\r\n                }\r\n                if (!f(p)) poles.push(round(p));\r\n            }\r\n            return new Set(poles);\r\n        },\r\n    };\r\n}\r\n"],"names":["Exp","a","b","symbol","params","type","copy","linkPrevious","dot","plus","previous","input","hardcopy","toSin","exp","Complex","isComplex","real","toString","imaginary","cos","Cos","sin","Sin","Algebra","negation","amplitude","t","phase","w","jw","pb","$","multiply","decomposition","valueAt","numericT","Math","toAlgebra","ConvertToMe","algebra","getA","getB","Fraction","num","den","Array","length","map","di","actual","lim","numerator","Poly","denominator","setNumerator","setA","setDenominator","setB","devide","devideInverse","operand","y","TransferFunction","toTransferFunction","toFormula","isIntegrator","add2gether","degree","n","powerTerm","result","i","add","NaN","derivative","against","da","fill","expression","slice","filter","ci","a_i","join","mostSignificantCoefficient","an","bi","isUnit","atn","aArray","Symbolic","halfTermsVisible","coef","inline","res","Step","amp","StandardInputSignal","nerdamer","require","Formula","mathPhrase","expressions","df","diff","f","iL","timeSymbol","L","frequencySymbol","undefined","knownVariables","evaluate","toDecimal","x","solveFor","ri","includes","separatorIndex","isDigit","terms","push","magnitude","replace","toTeX","this","GetTerm","termDegree","symbolicPart","RepetitiveFactors","roots","fullRoots","sort","p1","p2","isZero","root","knowns","order","fi","Zero","str","linkPlus","teta","getTeta","getSymbol","getType","zeros","poles","overshoot","t_rise","Number","logMp","log10","zeta","PI","w_d","w_n","wn2","OmegaZetaPoles","parentMultiply","getSimplifiedRoots","temp","pi","findIndex","p","equals","zi","getSimplifiedOrderedRoots","orderedPoles","value","orderedZeros","minOrder","min","getRootsByNerdamer","useNerdamer","find","ai","Equation","solve","ex","setRoots","z1","z2","RootOrders","characteristicEquation","k","updateRoots","getDampingSystemCharasteristics","round","getOrder","setOrder","getPoles","setPoles","getZeros","setZeros","poleOrder","pole","rplus","g","substract","laplace","laplaceInverse","f_s","simplify","denCoef","$s","$t","setInputSignal","coefs","s","otherPoles","splice","dF","Shortcuts","$Roots","z","factoriel","q","g_s","c_t","$DelayedIntegrator","ap","stepify","lstep","step","m","nreal","isReal","a2","ka2b2","t_settle","timeConstant","s0","sp","sMinPower","Infinity","errors","sGs","s2Gs","Ks","Kr","Ka","abs","numPhase","denPhase","Function","nyquist","method","PolarToCartesian","bode","rootLocus","k_min","k_max","progressBarObject","N","dk","na","nb","reals","imaginaries","progressLength","newTerm","progress","delta","offsetB","ib","offsetA","makeProgress","rootsByAlgebriteLocus","controlFeedback","controller","cs_gs","linkDot","dampingCharasteristics","$1","$2","conjugate","aplusb","ab","$WnZ","$design","$PID","Kp","Ti","Td","numeratorGain","denominatorGain","delay","raise","Roots","orders","j","alpha","beta","A","phi","toExp","exp1","exp2","Tan","tan","numeratorExp2","denominatorExp2","Cot","cot","Algebrite","nroots","replaceAll","split","xi","approximate","Methods","newton","boundary","allRoots","isUnique","newRoot","isNaN","rt","isUniqueComplex","a0","x0","rx","durandKerner","guess","random","_","iter","xiN","sndTermDen","xjN","sndTerm","r","GetAlgebriteTerm","zeroPrecision","precision","index","intExpI","run","algebraf","xs","dfx0","fx","middlePoint","expectedRate","xa","xb","rate","max","Set"],"sourceRoot":""}