{"version":3,"file":"static/js/138.9f79ae8b.chunk.js","mappings":"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","sources":["math/algebra/functions/poly.js","errors/algebra/NotScalarError.js","math/algebra/index.js","math/input-signals/index.js"],"sourcesContent":["import Algebra from \"math/algebra\";\n\nexport default class Poly extends Algebra {\n    static atn = (a, n, symbol = \"t\") => {\n        const aArray = Array(n + 1).fill(0);\n        aArray[0] = a;\n        return new Poly(aArray, symbol);\n    };\n    constructor(a, symbol = \"t\", params = {}) {\n        // ke^ct\n        super(a, { symbol, type: \"poly\", ...params });\n    }\n\n    copy = (linkPrevious = false) =>\n        new Poly(this.a, this.symbol, {\n            dot: this.dot,\n            plus: this.plus,\n            previous: linkPrevious ? this.previous : null,\n            input: this.input,\n        });\n\n    valueAt = (t) => Algebra.polynomialValueAt(this.a, t);\n\n    static Symbolic = (degree, symbol = \"t\",  halfTermsVisible = 2, coef = \"a\", inline = false) => {\n        let res = inline ? \"\" : \"$$\";\n        if (degree === \"n\") {\n            res += `${coef}_n ${symbol}^n + `;\n            for (let i = 1; i < halfTermsVisible; i++) \n                res += `${coef}_{n - ${i}}${symbol}^{n - ${i}} + `;\n            res += \" ... \";\n            for(let i = halfTermsVisible - 1;i > 0; i--)\n                res += ` + ${coef}_{${i}}${symbol}^{${i}}`;\n            res += ` + ${coef}_0`;\n        } else if (typeof degree === \"number\") {\n            for (; degree >= 0; degree--) {\n                res += `${coef}_{${degree}}`;\n                if(degree > 0)\n                    res += `${symbol}^{${degree}} + `;\n            }\n            \n        }\n        return res + (inline ? \"\" : \" $$\");\n    };\n    derivative = () => {\n        const result = this.copy(true);\n        if (!result.dot) {\n            const n = result.a.length - 1;\n            const da = Array(n).fill(0);\n            for (let i = n; i >= 1; i--) da[n - i] = i * result.a[n - i];\n            result.a = [...da];\n        }\n        if (result.plus) result.plus = result.plus.derivative();\n        return result;\n    };\n}\n","import { error_codes } from \"config\";\n\nexport default class NotScalarError extends Error {\n    \n    constructor(cause = null){ // the parameter with problem\n        super(cause ? `${cause} => این عبارت باید اسکالر باشد!!` : \"این خطا بدلیل استفاده از یک عبارت غیر اسکالر در مکان غیر مجاز رخ داده است!\")\n        this.name = \"NotNumberError\";\n        this.type = \"Numeric\";\n        this.code = error_codes.not_scalar;\n        this.cause = cause;\n    }\n\n    describe = () => {\n        console.log(this.message + (this.cause ? \"\\n\" + this.cause : \"\"));\n        return this.message + (this.cause ? \"\\n\" + this.cause.toString() : \"\");\n    }\n}","import { CollectionsOutlined } from \"@mui/icons-material\";\nimport NotScalarError from \"errors/algebra/NotScalarError\";\nimport StandardInputSignal from \"math/input-signals\";\nimport { round, strictPrecisionFormat } from \"../calculus\";\n\nclass Algebra {\n    // symbolic expressions\n    constructor(\n        a,\n        { symbol = \"t\", type = \"poly\", b, dot, plus, teta = 0, previous, input }\n    ) {\n        // dot is the interface between terms\n        // g(t) = a * f(t) * {dot: as Algebra}\n        // teta is the offset for wt + alpha in sin/cos/tan/..\n\n        this.symbol = symbol;\n        this.type = type.toLowerCase();\n        this.setA(a).setB(b).setTeta(teta);\n\n        this.input = input; // u(t), r(t), puls, ...\n        if (dot) {\n            this.dot = dot.copy();\n        } // multiply a Algebra from different type into 'this'\n\n        if (plus) {\n            this.plus = plus.copy();\n            this.simplify();\n        } // add another Algebra with different type to this one\n\n        this.previous = previous; // the previous term in the chained Algebra objects\n        // term.plus => next term, term.previous => previous term, term.dot => an algebra from another type that is multiplied to actual term\n        // F(u) = a.f(u).dot(u) + term.plus(u)\n        this.link();\n    }\n    static identify = (parameter) => {\n        if (parameter instanceof Array)\n            return parameter.map((pi) =>\n                pi instanceof Algebra || pi instanceof StandardInputSignal\n                    ? pi.copy()\n                    : round(pi)\n            );\n        else if (parameter instanceof Algebra) {\n            return parameter.copy();\n        } else if (typeof parameter === \"number\") return round(parameter);\n        else if (!parameter) return 0;\n        console.log(parameter);\n        throw new NotScalarError(parameter);\n    };\n    setA = (a) => {\n        this.a = Algebra.identify(a);\n        return this;\n    };\n    getA = () => this.a;\n\n    setB = (b) => {\n        this.b = Algebra.identify(b);\n        return this;\n    };\n    getB = () => this.b;\n\n    setTeta = (teta) => {\n        this.teta = Algebra.identify(teta);\n        return this;\n    };\n    getTeta = () => this.teta;\n    // CONNECT AND LINK METHODS, FIND FIRST TERM AND LAST TERM AND ...\n    end = () => {\n        // returns the end term in the algebratic chain\n        let last = this;\n        while (last.plus) last = last.plus;\n        return last;\n    };\n\n    first = () => {\n        // returns the first term in the algebratic chain\n        let fst = this;\n        while (fst.previous) fst = fst.previous;\n        return fst;\n    };\n\n    enddot = () => {\n        // returns the end term in the algebratic chain\n        let last = this;\n        while (last.dot) last = last.dot;\n        return last;\n    };\n\n    firstdot = () => {\n        // returns the first term in the algebratic chain\n        let fst = this;\n        // WRONG *****************************\n        //while (fst.previous) fst = fst.previous;\n        return fst;\n    };\n    link = () => {\n        // some times .previous links are broken; so i decided to write this method just to make sure everything is connected\n        let term = this.first();\n        if (!term) term = this; // in case this.first() returns wrong answer\n        while (term.plus) {\n            if (term.plus) term.plus.previous = term;\n            term = term.plus; // go to next term in the chain\n        }\n        return this;\n    };\n\n    copy = (linkPrevious = false) =>\n        new Algebra(this.a, {\n            type: this.type,\n            b: this.b,\n            dot: this.dot,\n            plus: this.plus,\n            symbol: this.symbol,\n            teta: this.teta,\n            input: this.input,\n            previous: linkPrevious ? this.previous : null,\n        });\n\n    // SORT THE MULTIPLIERD TERMS ( TERMS CONNECTED WITH this.dot) IN A SPECIFIC ORDER (FOR BETTER SHOW AND COMPARE AND ETC.)\n    // LOOK HERE IT STILL HAS BUGS\n    sort = () => {\n        // sort .dot in special order: poly - exp - frac - ...\n        const orders = [\"poly\", \"exp\", \"frac\"];\n        let position = this;\n        for (const order of orders) {\n            while (position) {\n                let func = position.dot;\n                while (func) {\n                    if (func.type === order && !position.isPrior(order)) {\n                        const temp = position.copy();\n                        position.a =\n                            func.a instanceof Array ? [...func.a] : func.a;\n                        position.type = func.type;\n                        position.symbol = func.symbol;\n                        if (func.b instanceof Array) position.b = [...func.b];\n                        else position.b = func.b;\n\n                        func.a = temp.a instanceof Array ? [...temp.a] : temp.a;\n                        func.type = temp.type;\n                        func.symbol = temp.symbol;\n                        if (temp.b instanceof Array) func.b = [...temp.b];\n                        else func.b = temp.b;\n                    }\n                    func = func.dot;\n                }\n                position = position.dot;\n            }\n        }\n    };\n\n    isPrior = (order) => {\n        const orders = [\"poly\", \"exp\", \"frac\"];\n        const thisValue = orders.findIndex((or) => or === this.type);\n        const orderValue = orders.findIndex((or) => or === order);\n        return thisValue <= orderValue;\n    };\n\n    // CHECK IF ONE TERMS CAN BE ADDED TO ANOTHER ONE (MEANING THEY HAVE SAME PARAMETRIC TERMS)\n    unifiable = (exp) => {\n        // check if this is unifiable with expression:exp\n        //this.sort();\n        //exp.sort();\n        if (exp && this.type === exp.type && this.symbol === exp.symbol) {\n            // check if this and exp are sumable\n            // check .dot s:\n            if (this.dot || exp.dot)\n                return this.dot && this.dot.unifiable(exp.dot);\n\n            if (this.b instanceof Array && exp.b instanceof Array) {\n                if (this.b.length === exp.b.length) {\n                    const sameOnes = this.b.filter(\n                        (item, idx) => item === exp.b[idx]\n                    );\n                    return this.b.length === sameOnes.length;\n                }\n            }\n            return exp.b === this.b;\n        }\n        return false;\n    };\n\n    static valueOf = (x, t = 0) => {\n        if (x) {\n            let value = 0;\n            if (x instanceof Algebra || x instanceof StandardInputSignal)\n                value = x.$(t);\n            else if (x instanceof Array)\n                value = Algebra.polynomialValueAt(x, t);\n            else value = x;\n            return value;\n        }\n        return 0;\n    };\n\n    static polynomialValueAt = (arr, t) => {\n        let value = 0;\n        const n = arr.length - 1;\n        for (let i = 0; i <= n; i++) {\n            value += arr[i] * t ** (n - i);\n        }\n        return value;\n    };\n    // REMOVE REDUNDANT TERMS, SIGNS AND ETC.\n    simplify = () => {\n        let term = this.first();\n        while (term) {\n            if (term instanceof Algebra) {\n                if (\n                    term.a === 0 ||\n                    Algebra.polynomial(term.a, term.symbol) === 0\n                ) {\n                    if (term.previous) {\n                        term.previous.plus = term.plus;\n                    } else {\n                        // remove first term and transfer the second term to first one\n                        if (this === term) term.redundant = true;\n                        if (term.plus) {\n                            term = term.plus.copy(true);\n                            if (term.plus) {\n                                term.plus = term.plus.plus;\n                                if (term.plus) term.plus.previous = term;\n                            }\n                            term.previous = null;\n                        }\n                    }\n                    // }\n                }\n            }\n            term = term.plus;\n        }\n        return this;\n    };\n\n    $ = (t) => {\n        // valueOf function in certain point\n        // I used character $ in many places as acronym for \"set\" in setters, so $ here means that set the t ( or x or whatever) with a certain point\n        // for each type just implement the method literally\n        let result = this.valueAt(t);\n        if (this.dot) result *= this.dot.$(t);\n        if (this.plus) result += this.plus.$(t);\n\n        return result;\n    };\n\n    label = (name = undefined, index = undefined) =>\n        (name\n            ? name +\n              (index !== undefined ? \"_{\" + index + \"}\" : \"\") +\n              \"(\" +\n              this.symbol +\n              \") = \"\n            : \"\") + this.toString();\n\n    // RETURNS THE BEST AND SIMPLE AND SHORTEST WAY TO SHOW COEFFICIENTS\n    static coefy = (a_i, i, n) => {\n        if (a_i instanceof Algebra) {\n            let str = \"\";\n            let ai = a_i.copy();\n            if (i > 0) {\n                // write a method to edit all the + - occuring next to each other in toString()\n                if (ai.type === \"complex\" && typeof ai.a === \"number\") {\n                    if (ai.a < 0) {\n                        str += \" - \";\n                        ai.a *= -1;\n                    } else if (!ai.a && typeof ai.b === \"number\" && ai.b < 0) {\n                        str += \" - \";\n                        ai.b *= -1;\n                    }\n                } else str += \" + \";\n            }\n            return str + ai.toString(i < n && a_i.hasMultiTerms());\n        }\n        if (a_i instanceof StandardInputSignal) {\n            //EDIT THIS PART TOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO\n            let str = i > 0 ? \" + \" : \"\";\n            return str + a_i.toString(i < n && a_i.hasMultiTerms());\n        } else {\n            if (n === 0) return strictPrecisionFormat(a_i);\n            if (a_i === 0) return \"\";\n            if (i !== 0) {\n                let s = \"\";\n                if (a_i < 0) {\n                    s += \" - \";\n                    a_i *= -1;\n                } else s += \" + \";\n\n                if (a_i === 1 && i < n) return s;\n                return s + strictPrecisionFormat(a_i);\n            }\n            if (a_i === 1) return \"\";\n            if (a_i === -1) return \"-\";\n\n            return strictPrecisionFormat(a_i);\n        }\n    };\n\n    // DECIPHER THE OBJECT TO ITS POLYNOMINAL FORM (IF IT IS ONE ACTUALLY)\n    static polynomial = (coefs, symbol) => {\n        if (coefs instanceof Array) {\n            const n = coefs.length - 1;\n            if (\n                !n ||\n                !coefs.slice(0, n).filter((ci) => ci.toString() !== \"0\").length\n            )\n                return coefs[n].toString();\n            return coefs\n                .map((a_i, i) =>\n                    a_i\n                        ? Algebra.coefy(a_i, i, n) +\n                          (i < n\n                              ? symbol +\n                                (i < n - 1\n                                    ? \"^{\" + (n - i).toString() + \"}\"\n                                    : \"\")\n                              : \"\")\n                        : \"\"\n                )\n                .join(\"\"); // joins all the coefficients, symbols, etc all together as for polynomal functions\n        }\n        return coefs.toString();\n    };\n\n    join = () => {\n        // connect this term to its next terms; considering the right use of + or -\n        if (this.plus) {\n            let operator = \"+\",\n                next = this.plus.copy();\n            if (next.a instanceof Array) {\n                if (next.a[0] < 0) {\n                    operator = \"-\";\n                    next.a[0] *= -1;\n                }\n            } else {\n                if (next.a < 0) {\n                    operator = \"-\";\n                    next.a *= -1;\n                }\n            }\n            return operator + next.toString();\n        }\n        return \"\";\n    };\n\n    hasMultiTerms = () => {\n        if (this.plus) return true;\n        if (this.a instanceof Array && this.type !== \"frac\")\n            return this.a.filter((ai) => ai !== 0).length > 1;\n        return false;\n    };\n    isTriangular = () =>\n        this.type === \"sin\" ||\n        this.type === \"cos\" ||\n        this.type === \"tan\" ||\n        this.type === \"cot\";\n\n    // MATHEMATICAL OPERATIONS\n    // static add = (expressions) => expressions.map((el) => el.toString()).join(\" + \");\n    add = (right) => {\n        // result = this + operand\n        let result = this.link().copy();\n        if (right instanceof Algebra) {\n            let operand = right.link().copy();\n\n            let x = result; // now we try to add each term with its unifiable term in y\n            while (x) {\n                let y = operand;\n                while (y) {\n                    if (x.unifiable(y)) {\n                        if (x.a instanceof Algebra) x.a = x.a.add(y.a);\n                        else if (y.a instanceof Algebra) x.a = y.a.add(x.a);\n                        // **************************************************\n                        // else if x.a || y.a instanceof StandardInputSignal\n                        // *********************************************\n                        else if (x.a instanceof Array) {\n                            if (y.a instanceof Array) {\n                                if (y.a.length > x.a.length) x.a = [...y.a];\n                                for (\n                                    let i = 1;\n                                    i <= y.a.length && i <= x.a.length;\n                                    i++\n                                )\n                                    x.a[x.a.length - i] += y.a[y.a.length - i];\n                            } else {\n                                x.a[x.a.length - 1] += y.a;\n                            }\n                        } else {\n                            x.a += y.a;\n                        }\n                        // remove the term in y that has been processed\n                        if (y.previous) {\n                            y.previous.plus = y.plus;\n                            if (y.plus) y.plus.previous = y.previous;\n                            y.a = 0;\n                        }\n\n                        // its the first term\n                        else operand = operand.plus;\n                        // after this the garbage collector will remove the term because it has no reference to it\n                    }\n                    y = y.plus;\n                }\n                // if(x.plus) x.plus.previous = x;\n                x = x.plus; // go to next term in the chain\n            }\n\n            if (operand) {\n                // if the above algorythm leaves operand with non-null value\n                /// it means there was terms in the operand's algebratic chain that are'nt unifiable with x terms\n                // so we must connect the leftovers to last terms of the result\n                if (Algebra.polynomial(result.a, result.symbol) !== \"0\") {\n                    if (\n                        Algebra.polynomial(operand.getA(), operand.symbol) !==\n                        \"0\"\n                    ) {\n                        let endTerm = result.end();\n                        endTerm.plus = operand;\n                        endTerm.plus.previous = result;\n                    }\n                } else result = operand.copy(); // connect to next term\n            }\n            return result.simplify();\n        } else if (right instanceof StandardInputSignal) {\n            const endTerm = result.end();\n            endTerm.plus = right.copy();\n            endTerm.plus.previous = endTerm;\n        }\n        return result;\n    };\n\n    arrangeDots = () => {\n        let term = this;\n        let input = null;\n        while (term.dot) {\n            // enhance the algo for cases that more than one input signal erxists in .dot chain\n            if (term.dot instanceof StandardInputSignal) {\n                input = term.dot;\n                term.dot = term.dot.dot;\n            }\n            if (term.dot) term = term.dot;\n        }\n        term.dot = input;\n    };\n    // INCOMPLETE ***********\n    multiply = (operand) => {\n        const y = this.copy().link();\n        if (operand instanceof Algebra) {\n            // operand algebra or complex\n            // ***** TODO:  ****************\n            if (operand.type === \"poly\") {\n                if (this.type === \"poly\" || this.type === \"frac\") {\n                    // NEEDS ERDITING for FRACTIONs\n                    if (this.symbol === operand.symbol) {\n                        const ao = operand.getA();\n                        const no = ao.length - 1;\n                        const As = [];\n                        for (let i = no; i >= 0; i--) {\n                            if (operand.a[i]) {\n                                const zeros = Array(no - i).fill(0);\n                                const a = [...y.a].map(\n                                    (yai) => yai * operand.a[i]\n                                );\n                                a.push(...zeros);\n                                As.push(a);\n                            }\n                        }\n                        // now sum all the products\n                        console.table(As);\n                        let product = As.pop();\n                        for (let j = 0; j < As.length; j++)\n                            for (\n                                let i = 1;\n                                i <= As[j].length && i <= product.length;\n                                i++\n                            )\n                                product[product.length - i] +=\n                                    As[j][As[j].length - i];\n\n                        y.a = product;\n                        if (operand.dot) {\n                            // link dots ***IS THIS TRUE?>***\n                            const endDotTerm = y.enddot();\n                            endDotTerm.dot = operand.dot.copy(); // multiply\n                            endDotTerm.dot.previous = endDotTerm;\n                        }\n                    }\n                }\n            } else if (y.type !== operand.type && operand.plus) {\n                // like: exp(f(...)) * [Asin(...) * Bcos(...)]\n                // UPDATE SELF MULTIPLY AFTER SOLVING THIS ISSUE\n                y.plus = y.multiply(operand.plus.copy());\n                const lastyDot = y.enddot();\n                if(typeof y.a === 'number' && typeof operand.a === 'number' && operand.a !== 1){\n                    y.a *= operand.a;\n                    operand.a = 1;\n                }\n                lastyDot.dot = operand.copy();\n                lastyDot.dot.previous = lastyDot;\n                // UPDATE SELF MULTIPLY AFTER SOLVING THIS ISSUE\n\n            } else {\n                const endDotTerm = y.enddot();\n                if (typeof y.a === \"number\" && typeof operand.a === \"number\") {\n                    y.a *= operand.a;\n                    operand.a = 1;\n                }\n                endDotTerm.dot = operand.copy(); // multiply\n                endDotTerm.dot.previous = endDotTerm;\n            }\n            if (y.plus) y.plus = y.plus.multiply(operand);\n            if (operand.plus) y.end().plus = y.multiply(operand.plus);\n            return y; // for now just to avoid crashes\n        } else if (operand instanceof StandardInputSignal) {\n            // const endDotTerm = y.enddot();\n            // endDotTerm.dot = operand.copy(); // multiply\n            // endDotTerm.dot.previous = endDotTerm;\n            y.input = operand.copy();\n            if (y.plus) y.plus = y.plus.multiply(operand);\n        } else {\n            // scalar multiply\n            if (operand instanceof Algebra) {\n            } else {\n                if (y.a instanceof Array) y.a = y.a.map((ai) => operand * ai);\n                else if (y.a instanceof Algebra) y.a = y.a.multiply(operand);\n                else y.a = y.a * operand;\n            }\n            if (y.plus) y.plus = y.plus.multiply(operand);\n        }\n        // console.log(\"y = \", y, \"operand = \", operand)\n        return y;\n    };\n\n    selfmultiply = (operand) => {\n        if (operand instanceof Algebra) {\n            // operand algebra or complex\n            // ***** TODO:  ****************\n            if (operand.type === \"poly\") {\n                if (this.type === \"poly\" || this.type === \"frac\") {\n                    // NEEDS ERDITING for FRACTIONs\n                    if (this.symbol === operand.symbol) {\n                        const ao = operand.getA();\n                        const no = ao.length - 1;\n                        const As = [];\n                        for (let i = no; i >= 0; i--) {\n                            if (ao[i]) {\n                                const zeros = Array(no - i).fill(0);\n                                const a = [...this.a].map(\n                                    (yai) => yai * operand[i]\n                                );\n                                a.push(...zeros);\n                                As.push(a);\n                            }\n                        }\n                        // now sum all the products\n                        const product = As.pop();\n                        for (let i = 0; i < product.length; i++) {\n                            for (let j = 0; j < As.length; j++) {\n                                if (i < As[j].length) product[i] += As[j][i];\n                            }\n                        }\n                        this.a = product;\n                        if (operand.dot) {\n                            // link dots ***IS THIS TRUE?>***\n                            const endDotTerm = this.enddot();\n                            endDotTerm.dot = operand.dot.copy(); // multiply\n                            endDotTerm.dot.previous = endDotTerm;\n                        }\n                    }\n                }\n            } else {\n                const endDotTerm = this.enddot();\n                endDotTerm.dot = operand.copy(); // multiply\n                endDotTerm.dot.previous = endDotTerm;\n                if (this.plus) this.plus = this.plus.multiply(operand);\n            }\n        } else if (operand instanceof StandardInputSignal) {\n            // this.dot = operand.copy(); // multiply\n            // this.dot.previous = this;\n            this.input = operand.copy();\n            if (this.plus) this.plus.selfmultiply(operand);\n            if (operand.plus) this.end().plus = this.multiply(operand.plus);\n        } else {\n            // scalar multiply\n            if (this.a instanceof Array)\n                this.a = this.a.map((ai) => operand * ai);\n            else this.a *= operand;\n\n            if (this.plus) this.plus.selfmultiply(operand);\n        }\n    };\n\n    negation = () => this.multiply(-1);\n\n    substract = (operand) => this.add(operand.negation());\n\n    devide = (operand) => {\n        // u need to handle Complex objects as Algebra using their type to recognize them\n        if (operand instanceof Algebra) {\n            // operand algebra or complex\n            // ***** TODO:  ****************\n            // first u must do everything to simplify\n            // second at the simplest state of the terms,\n            // construct a new Algebra of \"frac\" type\n            return this.copy(); // for now just to avoid crashes\n        } else {\n            // scaler\n            return this.multiply(1 / operand);\n        }\n    };\n\n    laplace = () => {};\n\n    static areTheSame = (el1, el2) => {\n        // checkes the sameness of parameters like .a .b .teta , etc.\n        if(el1 instanceof Algebra && el2 instanceof Algebra)\n            return el1.equals(el2);\n        else if(el1 instanceof Array && el2 instanceof Array){\n            if(el1.length === el2.length){\n                let i = 0;\n                for(i = 0; i < el1.length; i++)\n                    if(el1[i] !== el2[i]) break;\n                return i >= el1.length;\n                \n            }\n        }\n        return typeof el1 === typeof el2 && el1 === el2;\n    }\n    equals = (operand) => operand instanceof Algebra && \n                            this.type === operand.type && \n                            this.symbol === operand.symbol &&\n                            this.type === operand.type &&\n                            this.symbol === operand.symbol &&\n                            Algebra.areTheSame(this.a, operand.a) &&\n                            Algebra.areTheSame(this.b, operand.b) &&\n                            Algebra.areTheSame(this.teta, operand.teta) &&\n                            (!this.dot || this.dot.equals(operand.dot)) &&\n                            (!this.plus || this.plus.equals(operand.plus)) &&\n                            (!this.previous || this.previous.equals(operand.previous));\n\n\n    static areTheseTwoEqual = (p1, p2) =>\n        p1 instanceof Algebra\n            ? p1.equals(p2)\n            : p2 instanceof Algebra\n            ? p2.equals(p1)\n            : p1 === p2;\n    // DECIPHERS THE CONNECT OBJECTS TO UNDERSTANDABLE MATHMATICALLY SHAPED TEXT\n    // IT IS FORMATTED COMPATIBLE FOR MathJax component\n    toString = (parenthesis = false) => {\n        // this.arrangeDots();\n        this.simplify(); // simplify current chain that's left from unknown number of operations\n        let formula = \"\";\n        // if ... + 0 || 0 + ... appears ===>>>>> see below !!\n        if (!this.a) return \"0\"; // what if **************************************** 0 / 0\n        if (parenthesis) formula += \"(\";\n        switch (this.type.toLowerCase()) {\n            case \"exp\": {\n                // if (this.a < 0) formula += \"(\";\n                let a0 = this.a;\n                if (a0 < 0) {\n                    formula += \"-\";\n                    a0 *= -1;\n                }\n                if (a0 !== 1)\n                    if (a0 instanceof Algebra)\n                        formula += a0.toString(\n                            a0 instanceof Algebra && a0.hasMultiTerms()\n                        );\n                    else if (a0 instanceof Array)\n                        // testTEST\n                        formula += Algebra.polynomial(a0, this.symbol);\n                    // FOR TEST\n                    else formula += strictPrecisionFormat(a0);\n                if (this.dot instanceof Algebra)\n                    formula += this.dot.toString(\n                        this.dot instanceof Algebra && this.dot.hasMultiTerms()\n                    );\n                if (this.b !== 0) {\n                    if (this.a !== 0) {\n                        formula += \"e^{\";\n                        let e0 = this.b;\n                        if (this.b instanceof Algebra)\n                            formula += this.b.toString(\n                                this.b instanceof Algebra &&\n                                    this.b.hasMultiTerms()\n                            );\n                        else if (this.b instanceof Array)\n                            formula += Algebra.polynomial(this.b, this.symbol);\n                        else {\n                            if (e0 < 0) {\n                                formula += \"-\";\n                                e0 *= -1;\n                            }\n                            if (e0 !== 1) formula += e0;\n                        }\n                        formula += this.symbol + \"}\";\n                    }\n                    if (this.input) formula += this.input.toString();\n                } else {\n                    if (a0 !== 1 || !this.dot)\n                        formula += strictPrecisionFormat(this.a);\n                }\n                // if (this.a < 0) formula += \")\";\n                if (this.plus) formula += this.join(); // if there's a next term: casscade toString() calls\n                break;\n            }\n            case \"poly\":\n                formula += Algebra.polynomial(this.a, this.symbol);\n                if (this.dot instanceof Algebra)\n                    formula += this.dot.toString(\n                        this.dot instanceof Algebra && this.dot.hasMultiTerms()\n                    );\n                if (this.input) {\n                    formula += (parenthesis ? \")\" : \"\") + this.input.toString();\n                    parenthesis = false;\n                }\n                if (this.plus) formula += this.join(); // if there's a next term: casscade toString() calls\n                break;\n            case \"frac\": {\n                if (this.dot instanceof Algebra)\n                    formula += this.dot.toString(\n                        this.dot instanceof Algebra && this.dot.hasMultiTerms()\n                    );\n                const numerator = Algebra.polynomial(this.a, this.symbol);\n                formula +=\n                    numerator !== \"0\"\n                        ? \"\\\\frac{\" +\n                          numerator +\n                          \"}{\" +\n                          Algebra.polynomial(this.b, this.symbol) +\n                          \"}\"\n                        : \"0\";\n                if (this.input) formula += this.input.toString();\n                if (this.plus) formula += this.join(); // if there's a next term: casscade toString() calls\n\n                break;\n            }\n            case \"sin\":\n            case \"asin\":\n            case \"cos\":\n            case \"tan\":\n            case \"cot\": {\n                // if (this.a < 0) formula += \"(\";\n                let a0 = this.a;\n                if (a0 < 0) {\n                    formula += \"-\";\n                    a0 *= -1;\n                }\n                if (a0 !== 1)\n                    if (a0 instanceof Algebra)\n                        formula += a0.toString(\n                            a0 instanceof Algebra && a0.hasMultiTerms()\n                        );\n                    else if (a0 instanceof Array)\n                        formula += Algebra.polynomial(a0, this.symbol);\n                    // FOR TEST\n                    else formula += strictPrecisionFormat(a0);\n                if (this.a !== 0) {\n                    if (this.dot && this.dot instanceof Algebra)\n                        formula += this.dot.toString(\n                            this.dot instanceof Algebra &&\n                                this.dot.hasMultiTerms()\n                        );\n                    if (this.b !== 0) {\n                        formula += this.type;\n                        if (this.b instanceof Algebra) {\n                            formula += this.b.toString(\n                                this.b instanceof Algebra &&\n                                    this.b.hasMultiTerms()\n                            );\n                        } else if (this.b instanceof Array)\n                            formula += Algebra.polynomial(this.b, this.symbol);\n                        // FOR TEST\n                        else {\n                            let w0 = this.b;\n                            formula += \"(\";\n                            if (w0 < 0) {\n                                formula += \"-\";\n                                w0 *= -1;\n                            }\n                            if (w0 !== 1) formula += strictPrecisionFormat(w0);\n                            formula += this.symbol;\n                            if (this.teta instanceof Algebra)\n                                formula += this.teta.toString();\n                            else if (this.teta) {\n                                let e0 = this.teta;\n                                if (e0 < 0) {\n                                    formula += \" - \";\n                                    e0 *= -1;\n                                } else formula += \" + \";\n                                formula += strictPrecisionFormat(e0);\n                            }\n                            formula += \")\";\n                        }\n                        if (this.input) formula += this.input.toString();\n                    }\n                    // simple num\n                } else {\n                    if (a0 !== 1 || !this.dot)\n                        formula += strictPrecisionFormat(this.a);\n                }\n                // if (this.a < 0) formula += \")\";\n                if (this.plus) formula += this.join(); // if there's a next term: casscade toString() calls\n                break;\n            }\n\n            default:\n                return null;\n        }\n        if (parenthesis) formula += \")\";\n\n        return formula;\n    };\n    toArray = () => {\n        let x = [];\n        const params = [\"a\", \"b\", \"teta\", \"symbol\", \"type\"],\n            linkers = [\"dot\", \"input\", \"plus\", \"previous\"];\n        for (const [key, value] of Object.entries(this)) {\n            if (typeof value !== \"function\") {\n                if (value) {\n                    // maximum toArray call happens\n                    if (params.filter((p) => p === key).length)\n                        x[key] =\n                            value instanceof Algebra ? value.toArray() : value;\n                    //)((value instanceof StandardInputSignal ? value.copy() : ));\n                    else if (linkers.filter((l) => l === key).length)\n                        x[key] =\n                            value instanceof StandardInputSignal\n                                ? value.copy()\n                                : value.toArray();\n                }\n            }\n        }\n        return x;\n    };\n}\n\nexport default Algebra;\n","import { round, strictPrecisionFormat } from \"../calculus\";\n\nexport default class StandardInputSignal {\n    constructor(amplitude = 1, type = \"u\", symbol = \"t\") {\n        this.symbol = symbol;\n        this.type = type;\n        this.amp = round(amplitude);\n    }\n\n    copy = () => new StandardInputSignal(this.amp, this.type, this.symbol);\n\n    toString = () => {\n        let str = \"\",\n            a = this.amp;\n        if (this.amp === -1) {\n            str += \"-\";\n            a *= -1;\n        }\n        if (a !== 1) str += strictPrecisionFormat(a);\n        return str + `${this.type}(${this.symbol})`;\n    };\n\n    ampiltude = () => this.amp;\n}\n"],"names":["Poly","a","symbol","params","type","copy","linkPrevious","dot","plus","previous","input","valueAt","t","Algebra","derivative","result","n","length","da","Array","fill","i","atn","aArray","Symbolic","degree","halfTermsVisible","coef","inline","res","NotScalarError","cause","describe","console","log","message","toString","name","code","error_codes","Error","b","teta","setA","identify","getA","setB","getB","setTeta","getTeta","end","last","first","fst","enddot","firstdot","link","term","sort","position","order","func","isPrior","temp","orders","findIndex","or","unifiable","exp","sameOnes","filter","item","idx","simplify","polynomial","redundant","$","label","undefined","index","join","operator","next","hasMultiTerms","ai","isTriangular","add","right","operand","x","y","endTerm","StandardInputSignal","arrangeDots","multiply","no","As","zeros","map","yai","push","table","product","pop","j","endDotTerm","lastyDot","selfmultiply","ao","negation","substract","devide","laplace","equals","areTheSame","parenthesis","formula","toLowerCase","a0","strictPrecisionFormat","e0","numerator","w0","toArray","linkers","key","value","p","l","Object","entries","this","parameter","pi","round","valueOf","polynomialValueAt","arr","coefy","a_i","str","s","coefs","slice","ci","el1","el2","areTheseTwoEqual","p1","p2","amplitude","amp","ampiltude"],"sourceRoot":""}