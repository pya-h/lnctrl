{"version":3,"file":"static/js/573.d8d4345f.chunk.js","mappings":"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","sources":["math/algebra/complex.js","math/algebra/functions/exp.js","math/algebra/functions/fraction.js","math/input-signals/signals.js","math/algebra/functions/transferFunction.js","math/algebra/functions/trigonometric.js"],"sourcesContent":["import Algebra from \".\";\nimport { round, isDigit } from \"../calculus\";\n\nclass Complex extends Algebra {\n    constructor(preal, pimage, params = {}) {\n        super(preal, { symbol: \"j\", type: \"complex\", b: pimage, ...params });\n    }\n\n    hasMultiTerms = () =>\n        this.plus || (this.a.toString() !== \"0\" && this.b.toString() !== \"0\");\n\n    toString = (parenthesis = false) => {\n        const rl = this.a;\n        let formula = parenthesis && this.hasMultiTerms() ? \"(\" : \"\";\n        if (rl !== 0)\n            formula +=\n                rl instanceof Algebra\n                    ? rl.toString(rl.hasMultiTerms())\n                    : round(rl);\n        let im = this.b;\n        if (im !== 0) {\n            //if (im < 0 || (im instanceof Algebra)) { im = im.negation()\n            if (im < 0) {\n                im *= -1;\n                formula += \" - \";\n            } else if (rl !== 0) formula += \" + \";\n\n            formula += this.symbol;\n            if (im !== 1)\n                formula +=\n                    im instanceof Algebra\n                        ? im.toString(im.hasMultiTerms())\n                        : round(im);\n        }\n        if (this.plus) formula += this.join(); // if there's a next term: casscade toString() calls\n\n        return parenthesis ? formula + \")\" : formula;\n    }; // a + jb\n\n    real = () => this.a;\n    imaginary = () => this.b;\n\n    copy = (linkPrevious = false) =>\n        new Complex(this.a, this.b, {\n            dot: this.dot,\n            plus: this.plus,\n            previous: linkPrevious ? this.previous : null,\n            input: this.input\n\n        });\n\n    conjugate = () =>\n        new Complex(\n            this.a,\n            this.b instanceof Algebra ? this.b.negation() : -this.b\n        );\n\n    negation = () =>\n        new Complex(\n            this.a instanceof Algebra ? this.a.negation() : -this.a,\n            this.b instanceof Algebra ? this.b.negation() : -this.b\n        );\n\n    magnitude$2 = () => this.a ** 2 + this.b ** 2;\n\n    magnitude = () => (this.a ** 2 + this.b ** 2) ** 0.5;\n\n    isReal = () => this.b === 0;\n\n    hasSameTypeWith = x => (this.isReal() && x.isReal()) || (!this.isReal() && !x.isReal()); // both full imaginray or both real\n    realify = () => new Complex(this.a, 0); // return a simple real value in Complex object format (for methods that only accept Complex values)\n\n    add = (operand) => {\n        let Re = null,\n            Im = null;\n        if (operand instanceof Complex) {\n            if (this.a instanceof Algebra) Re = this.a.add(operand.real());\n            else if (operand.real() instanceof Algebra)\n                Re = operand.real().add(this.a);\n            else Re = this.a + operand.real();\n\n            if (this.b instanceof Algebra) Im = this.b.add(operand.imaginary());\n            else if (operand.imaginary() instanceof Algebra)\n                Im = operand.imaginary().add(this.b);\n            else Im = this.b + operand.imaginary();\n        } else {\n            if (this.a instanceof Algebra) Re = this.a.add(operand);\n            else if (operand instanceof Algebra) Re = operand.add(this.a);\n            else Re = this.a + operand;\n\n            Im = this.b;\n        }\n        return new Complex(Re, Im);\n    };\n\n    substract = (operand) => this.add(operand.negation());\n\n    equals = (operand) => {\n        if (operand instanceof Complex) {\n            // two complex number are equal to eachother if both thier real parts are the same, and their imaginary parts are the same\n            let realPartsEqual = false;\n            if (this.a instanceof Algebra)\n                realPartsEqual = this.a.equals(operand.real());\n            else if (operand.real() instanceof Algebra)\n                realPartsEqual = operand.real().equals(this.a);\n            else realPartsEqual = this.a === operand.real();\n            if (!realPartsEqual) return false;\n\n            if (this.b instanceof Algebra)\n                return this.b.equals(operand.imaginary());\n            else if (operand.imaginary() instanceof Algebra)\n                return operand.imaginary().equals(this.b);\n            return this.b === operand.imaginary();\n        }\n\n        // if operand is not a complex number then the only way it can be equal with this object of Complex,\n        // is for this object to have a zero imaginary part:\n        return (\n            this.isReal() &&\n            (operand instanceof Algebra\n                ? operand.equals(this.a)\n                : operand === this.a)\n        );\n    };\n\n    isConjugateWith = (operand) => this.conjugate().equals(operand);\n    multiply = (operand) => {\n        let Re = [],\n            Im = [];\n        if (operand instanceof Complex) {\n            // first term\n            if (this.a instanceof Algebra) {\n                Re.push(this.a.multiply(operand.real()));\n                Im.push(this.a.multiply(operand.imaginary()));\n            } else {\n                Re.push(\n                    operand.a instanceof Algebra\n                        ? operand.a.multiply(this.a)\n                        : operand.a * this.a\n                );\n\n                Im.push(\n                    operand.b instanceof Algebra\n                        ? operand.b.multiply(this.a)\n                        : this.a * operand.b\n                );\n            }\n\n            // second term\n            if (this.b instanceof Algebra) {\n                Re.push(this.b.multiply(operand.imaginary()));\n                Im.push(this.b.multiply(operand.real()));\n            } else {\n                Re.push(\n                    operand.b instanceof Algebra\n                        ? operand.b.multiply(this.b)\n                        : operand.b * this.b\n                );\n\n                Im.push(\n                    operand.a instanceof Algebra\n                        ? operand.a.multiply(this.b)\n                        : this.b * operand.a\n                );\n            }\n            return new Complex(Re[0] - Re[1], Im[0] + Im[1]);\n        } else {\n            Re =\n                this.a instanceof Algebra\n                    ? this.a.multiply(operand)\n                    : operand instanceof Algebra\n                    ? operand.multiply(this.a)\n                    : this.a * operand;\n\n            Im =\n                this.b instanceof Algebra\n                    ? this.b.multiply(operand)\n                    : operand instanceof Algebra\n                    ? operand.multiply(this.b)\n                    : this.b * operand;\n        }\n        return new Complex(Re, Im);\n    };\n\n    devide = (denominator) => {\n        if (denominator instanceof Complex)\n            return this.multiply(denominator.conjugate()).devide(\n                denominator.magnitude$2()\n            );\n        else if (denominator instanceof Algebra) {\n            // USE super().devide ?\n            return this.copy(); // for now to avoid craches\n        } else return this.multiply(1 / denominator); // number\n    };\n\n    devideInverse = (k) =>\n        (k instanceof Algebra ? k : new Complex(k, 0)).devide(this);\n\n    static extract = (strNumber) => {\n        // extract a string to a complex object\n\n        strNumber = strNumber.replace(/\\s/g, \"\");\n        let i = strNumber[0] === \"-\" || strNumber[0] === \"+\" ? 1 : 0;\n        let real = 0;\n        if (strNumber[i] !== \"j\") {\n            for (; i < strNumber.length && isDigit(strNumber[i]); i++);\n            real = Number(strNumber.slice(0, i) || 0);\n        }\n\n        let sign = 1;\n        for (\n            ;\n            i < strNumber.length &&\n            (strNumber[i] === \"j\" ||\n                strNumber[i] === \"+\" ||\n                strNumber[i] === \"-\");\n            i++\n        )\n            if (strNumber[i] === \"-\") sign = -1;\n\n        const img = Number(strNumber.slice(i, strNumber.length) || 0);\n        return new Complex(real, sign * img);\n    };\n}\n\nexport default Complex;\n","import Algebra from \"math/algebra\";\nimport Complex from \"math/algebra//complex\";\nimport { Cos, Sin } from \"./trigonometric\";\n\nexport default class Exp extends Algebra {\n    constructor(a, b, symbol = \"t\", params = {}) {\n        // ae^bt\n        super(a, { symbol, type: \"exp\", b, ...params });\n    }\n\n    copy = (linkPrevious = false) =>\n        new Exp(this.a, this.b, this.symbol, {\n            dot: this.dot,\n            plus: this.plus,\n            previous: linkPrevious ? this.previous : null,\n            input: this.input\n        });\n\n    toSin = () => {\n        const exp = this.copy();\n        if (exp.type === \"exp\" && exp.b instanceof Complex) {\n            if (exp.b instanceof Complex && exp.b.real() === 0) {\n                const cos = new Cos(exp.a, exp.b.imaginary());\n                const sin = new Sin(exp.a, -exp.b.imaginary());\n                return new Complex(cos, sin);\n            }\n        }\n        return exp; // if doesnt math the condition then just return exponential function itself\n    };\n\n    valueAt = (t) => {\n        const a = Algebra.valueOf(this.a, t),\n            b = Algebra.valueOf(this.b, t);\n        return a * Math.exp(b * t);\n    }\n}\n","import Algebra from \"math/algebra\";\nimport Poly from \"./poly\";\n\nexport default class Fraction extends Algebra {\n    constructor(num, den = [1], symbol = \"t\", params = {}) {\n        // ke^ct\n        if (!(num instanceof Algebra)) {\n            if (!(num instanceof Array)) num = [num];\n            // this.a\n            else if (num.length === 0) num = [0];\n        }\n        if (!(den instanceof Algebra)) {\n            if (!(den instanceof Array)) den = [den];\n            // this.b\n            else if (den.length === 0) den = [1];\n        }\n        super(num, { symbol, type: \"frac\", b: den, ...params });\n    }\n\n    copy = (linkPrevious = false) =>\n        new Fraction(this.a, this.b, this.symbol, {\n            dot: this.dot,\n            plus: this.plus,\n            previous: linkPrevious ? this.previous : null,\n            input: this.input\n        });\n\n    lim = () => {\n        // for all fractions with all kind of numerator and denominator\n    }\n    \n    numerator = () => (this.a.length > 1 ? Poly(this.a) : this.a[0]);\n    denominator = () => new Poly(this.b);\n\n    setNumerator = (num) => {\n        if (!(num instanceof Algebra)) {\n            if (!(num instanceof Array)) num = [num];\n            // this.a\n            else if (num.length === 0) num = [0];\n        }\n        return this.setA(num);\n    }\n\n    setDenominator = (den) => {\n        if (!(den instanceof Algebra)) {\n            if (!(den instanceof Array)) den = [den];\n            // this.b\n            else if (den.length === 0) den = [1];\n        }\n        return this.setB(den);\n    }\n    valueAt = (t) => {\n        const num = Algebra.valueOf(this.a, t);\n        const den = Algebra.valueOf(this.b, t);\n        return num / den;\n    }\n\n}\n","import StandardInputSignal from \"math/input-signals\";\nimport Poly from \"math/algebra/functions/poly\";\n\nexport class Step extends StandardInputSignal {\n    constructor(amplitude = 1, symbol = \"t\") {\n        super(amplitude, \"u\", symbol); // \\\\delta is the equivalent of small delta in mathjax\n    }\n    copy = () => new Step(this.amp, this.symbol);\n\n    $ = (t) => (t >= 0) * this.amp;\n}\n\nexport class Puls extends StandardInputSignal {\n    constructor(Delta = 1, amplitude = 1, symbol = \"t\") {\n        super(amplitude, \"\\\\sqcap\", symbol);\n        this.Delta = Delta;\n    }\n    copy = () => new Puls(this.Delta, this.amp, this.symbol);\n    $ = (t) => (t >= 0 && t <= this.Delta) * this.amp / this.Delta;\n}\n\nexport class Impact extends StandardInputSignal {\n    constructor(amplitude = 1, symbol = \"t\") {\n        super(amplitude, \"\\\\delta\", symbol); // \\\\delta is the equivalent of small delta in mathjax\n    }\n    copy = () => new Impact(this.amp, this.symbol);\n\n    $ = (t) => this.amp * (t === 0);\n}\n\nexport class Ramp extends Poly {\n    constructor(amplitude, symbol = \"t\") {\n        super([amplitude, 0], symbol);\n        this.amplitude = amplitude; // just for calculating the value of this\n        this.selfmultiply(Step());\n    }\n    copy = () => new Ramp(this.amplitude, this.symbol);\n\n    $ = (t) => (t >= 0) * t * this.amplitude;\n}\n\n\nexport class Parabolic extends Poly { //EDIT\n    constructor(amplitude, symbol = \"t\") {\n        super([amplitude, 0, 0], symbol);\n        this.amplitude = amplitude; // just for calculating the value of this\n        this.selfmultiply(Step());\n    }\n    copy = () => new Parabolic(this.amplitude, this.symbol);\n    $ = (t) => (t >= 0 ? t * this.amplitude : 0);\n}\n","import Algebra from \"../index\";\nimport Complex from \"../complex\";\nimport Exp from \"./exp\";\nimport Fraction from \"./fraction\";\nimport { Step } from \"math/input-signals/signals\";\nimport Poly from \"./poly\";\nimport { Cos, Sin } from \"./trigonometric\";\nimport { round } from \"math/calculus/index\";\n\nexport default class TransferFunction extends Fraction {\n    static Specials = {\n        $1: (k, a) =>\n            new TransferFunction([k], [1, -a]).setRoots([], [a]).setOrder(1),\n        $2: (k, a, b = a instanceof Complex ? a.conjugate : a) => {\n            // k / (s + a)(s + b) => must be converted to => k / (s2 + 2(a+b)s + ab)\n            let aplusb =\n                a instanceof Algebra\n                    ? a.add(b)\n                    : b instanceof Algebra\n                    ? b.add(a)\n                    : b + a;\n            let ab =\n                a instanceof Algebra\n                    ? a.multiply(b)\n                    : b instanceof Algebra\n                    ? b.multiply(a)\n                    : b * a;\n            if (aplusb instanceof Complex && aplusb.isReal())\n                aplusb = aplusb.real();\n            if (ab instanceof Complex && ab.isReal()) ab = ab.real();\n\n            return new TransferFunction(\n                [k],\n                [1, aplusb instanceof Algebra ? aplusb.negation() : -aplusb, ab]\n            )\n                .setRoots([], [a, b])\n                .setOrder(2);\n        },\n        $WnZ: (w_n, zeta) => new TransferFunction(null, null, { w_n, zeta }),\n        $design: (t_rise, overshoot) =>\n            new TransferFunction(null, null, { overshoot, t_rise }),\n    };\n\n    static omegaZetaPoles = (w_n, zeta) => {\n        if (Math.abs(zeta) >= 1) {\n            const alpha = -zeta * w_n;\n            const beta = w_n * (zeta * zeta - 1) ** 0.5;\n            return [alpha + beta, alpha - beta];\n        }\n        const alpha = -zeta * w_n;\n        const beta = w_n * (1 - zeta * zeta) ** 0.5;\n        return [new Complex(alpha, beta), new Complex(alpha, -beta)];\n    };\n    constructor(numerator, denominator, params = {}) {\n        let zeros = [],\n            poles = [];\n        if (params) {\n            if (params.overshoot && params.t_rise) {\n                params.overshoot = Number(params.overshoot);\n                params.t_rise = Number(params.t_rise);\n                const logMp = Math.log(params.overshoot);\n                params.zeta =\n                    -logMp / (Math.PI * Math.PI + logMp * logMp) ** 0.5;\n                params.w_d = Math.PI / params.t_rise;\n                params.w_n =\n                    params.w_d / (1 - params.zeta * params.zeta) ** 0.5;\n            }\n\n            if (params.w_n) {\n                params.w_n = Number(params.w_n);\n                params.zeta = Number(params.zeta);\n                // if the user sends w_n params it will override the given zero/pole list\n                const { w_n, zeta } = params;\n                const wn2 = w_n * w_n;\n                numerator = wn2;\n                denominator = [1, 2 * zeta * w_n, wn2];\n                poles = TransferFunction.omegaZetaPoles(w_n, zeta);\n                zeros = [];\n            }\n        }\n        super(numerator, denominator, \"s\", params);\n        // SIMPL;IFY\n        this.poles = [...poles]; //edit solve equations\n        this.zeros = [...zeros];\n        if (!this.a instanceof Array) this.a = [this.a];\n        if (this.a.length === 1 && !this.w_n) {\n            if (\n                this.b.length === 3 &&\n                this.b[this.b.length - 1] === this.a[0]\n            ) {\n                this.w_n = this.a[0];\n                this.zeta = this.b[1] / (2 * this.w_n);\n                this.timeConstant = round(1 / (this.zeta * this.w_n));\n                this.t_settle = 4 * this.timeConstant;\n                if (params && params.w_d) this.w_d = params.w_d;\n                else if (this.zeta >= -1 && this.zeta <= 1)\n                    this.w_d = this.w_n * (1 - this.zeta ** 2) ** 0.5;\n                this.order = 2;\n                this.setRoots(\n                    [],\n                    TransferFunction.omegaZetaPoles(this.w_n, this.zeta)\n                );\n            }\n        }\n        if (!this.order)\n            this.order =\n                denominator instanceof Array ? denominator.length - 1 : 1;\n        if (params.overshoot && params.t_rise) {\n            [this.overshoot, this.t_rise] = [params.overshoot, params.t_rise];\n        } else {\n            const dampingCharasteristics =\n                this.getDampingSystemCharasteristics();\n            if (dampingCharasteristics) {\n                this.overshoot = dampingCharasteristics.overshoot;\n                this.t_rise = dampingCharasteristics.t_rise;\n            }\n        }\n    }\n    static sortRoots = (rt) =>\n        rt.sort((ri, rj) =>\n            ri instanceof Algebra\n                ? ri.substract(rj)\n                : rj instanceof Algebra\n                ? rj.substract(ri)\n                : Math.abs(ri) - Math.abs(rj)\n        );\n    roots = () => [this.zeros, this.poles];\n    setRoots = (zeros, poles) => {\n        this.poles = poles.map((pi) =>\n            pi instanceof Complex && pi.isReal() ? pi.real() : pi\n        );\n        this.zeros = zeros.map((zi) =>\n            zi instanceof Complex && zi.isReal() ? zi.real() : zi\n        );\n        return this;\n    };\n\n    getDampingSystemCharasteristics = () =>\n        this.w_d\n            ? {\n                  t_rise: round(Math.PI / this.w_d),\n                  // WHAT IF W_D === 0?\n                  overshoot:\n                      this.zeta >= -1 && this.zeta <= 1\n                          ? round(\n                                100 *\n                                    Math.exp(\n                                        -(this.zeta * Math.PI) /\n                                            (1 - this.zeta ** 2) ** 0.5\n                                    )\n                            )\n                          : null,\n              }\n            : null;\n\n    getOrder = () => this.order;\n    setOrder = (order) => {\n        this.order = order;\n        return this;\n    };\n    getPoles = () => this.poles;\n    setPoles = (poles) => {\n        this.poles = TransferFunction.sortRoots(poles).map((pi) =>\n            pi instanceof Complex && pi.isReal() ? pi.real() : pi\n        );\n        return this;\n    };\n    getZeros = () => this.zeros;\n    setZeros = (zeros) => {\n        this.zeros = zeros.map((pi) =>\n            pi instanceof Complex && pi.isReal() ? pi.real() : pi\n        );\n        return this;\n    };\n\n    poleOrder = (pole) =>\n        this.poles.filter((pi) => Algebra.areTheseTwoEqual(pole, pi)).length;\n\n    laplace = () => this.copy(); // actually it has no laplace, this is for disfunctioning the laplace method in the parent class Algebra\n    laplaceInverse = () => {\n        const m = this.zeros.length - 1; // number of zeros\n        const n = this.poles.length - 1; // number of poles\n\n        if (m === 0) {\n            switch (n) {\n                case 2:\n                    return null;\n                case 1:\n                    return new Algebra(1, { type: \"exp\" }); //EDITTTTTTTTTTTTTTTT\n                case 0:\n                    return null; //u(t)\n                default:\n                    return null; //DEFINE AN UNKNOWN FUNCTION FOR CASE LIKE THIS\n            }\n        }\n    };\n    step = (inTimeDomain = true) => {\n        // normally will automatically return the time domain answer\n        // unless inLaplaceDomain is true\n        if (inTimeDomain) {\n            const m = this.zeros.length; // number of zeros\n            const n = this.poles.length; // number of poles\n            const nreal = this.poles.filter(\n                (pi) => !(pi instanceof Complex)\n            ).length; // number of real poles; can be eigher 2 or 0\n            if (m === 0) {\n                const k = this.numerator();\n                if (n === 0) {\n                    // return u(t)\n                    // DEFINE U(T) IN ALGEBRA\n                }\n                if (n === 1) {\n                } else if (n === 2) {\n                    const a = -this.poles[0],\n                        b = -this.poles[1];\n                    if (nreal === 2) {\n                        // if (a > 0 && b > 0) {\n                        if (a !== b)\n                            // two independent polesdddd\n                            // two negative independent poles\n                            return new Exp(1 / a, -a)\n                                .add(new Exp(-1 / b, -b))\n                                .multiply(k / (a - b))\n                                .multiply(new Step())\n                                .add(new Step(k / (a * b)));\n                        else {\n                            const a2 = a * a;\n                            return new Exp(-k / a2, -a)\n                                .multiply(new Poly([a, 1]))\n                                .multiply(new Step())\n                                .add(new Step(k / a2));\n                        }\n                        // } else {\n                        //     // repetetive poles\n                        // }\n                    } else if (nreal === 0) {\n                        // two conjugated complex poles\n                        //UNDERSHOOT BUG FIXLAYS HERE\n                        const a = -this.poles[0].real(),\n                            b = this.poles[0].imaginary();\n                        const ka2b2 = k / (a ** 2 + b ** 2);\n                        // FIND BUUUUUUG\n                        // return new Exp(-ka2b2, -a)\n                        //     .multiply(new Cos(1, b).add(new Sin(a / b, b)))\n                        //     .multiply(new Step())\n                        //     .add(new Step(ka2b2));\n                        return new Exp(-ka2b2, -a)\n                            .multiply(new Cos(1, b))\n                            .add(\n                                new Exp(-ka2b2, -a).multiply(new Sin(a / b, b))\n                            )\n                            .multiply(new Step())\n                            .add(new Step(ka2b2));\n                    }\n                    // else if( nreal == 1) // this cant happen, but what if sth went wrong?\n                }\n            }\n        } else {\n            const lstep = this.copy();\n            const poles = lstep.getPoles();\n            poles.push(0);\n            lstep.getB().push(0); //update denominator\n            lstep.setPoles(poles).setDenominator(lstep.getB());\n            return lstep;\n        }\n    };\n    copy = (linkPrevious = false) =>\n        new TransferFunction(this.a, this.b, {\n            overshoot: this.overshoot,\n            t_rise: this.t_rise,\n            t_settle: this.t_settle,\n            w_d: this.w_d,\n            timeConstant: this.timeConstant,\n            w_n: this.w_n,\n            zeta: this.zeta,\n            dot: this.dot,\n            plus: this.plus,\n            previous: linkPrevious ? this.previous : null,\n            input: this.input,\n        }).setRoots(this.zeros, this.poles);\n\n    lim = (s0) => {\n        let num, den;\n        // for simple polynomial numerator and denominator fractions\n        // IMPLEMENT HOPITAL AS WELL?\n        if (!s0) {\n            // s -> 0)\n\n            num = { a: 0, sp: this.a.length - 1 };\n            den = { b: 1, sp: this.b.length - 1 };\n            for (; num.sp > 0 && this.a[num.sp] === 0; num.sp--);\n            num.a = this.a[num.sp];\n            for (; den.sp > 0 && this.b[den.sp] === 0; den.sp--);\n            den.b = this.b[den.sp];\n            num.sp = this.a.length - num.sp - 1;\n            den.sp = this.b.length - den.sp - 1;\n            if (num.sp === den.sp) return num.a / den.b;\n            else {\n                const sMinPower = Math.min(den.sp, num.sp);\n                if (sMinPower) {\n                    num.sp -= sMinPower;\n                    den.sp -= sMinPower;\n                }\n                // now one of num.sp or den.sp is zero\n                if (den.sp)\n                    // zero on denominator\n                    return Infinity;\n                // if den.sp == 0 and num.sp != 0\n                return 0;\n            }\n        } else if (s0 === Infinity) {\n            // s -> infinity\n            num = { a: 0, sp: 0 };\n            den = { b: 1, sp: 0 };\n            for (; num.sp < this.a.length && this.a[num.sp] === 0; num.sp++);\n            num.a = this.a[num.sp];\n            for (; den.sp < this.b.length && this.b[den.sp] === 0; den.sp++);\n            den.b = this.b[den.sp];\n            num.sp = this.a.length - num.sp - 1;\n            den.sp = this.b.length - den.sp - 1;\n            if (num.sp === den.sp) return num.a / den.b;\n            // else\n            const sMinPower = Math.min(den.sp, num.sp);\n            if (sMinPower) {\n                num.sp -= sMinPower;\n                den.sp -= sMinPower;\n            }\n            // now one of num.sp or den.sp is zero\n            if (den.sp)\n                // zero on denominator\n                return 0;\n            // if den.sp == 0 and num.sp != 0\n            return Infinity;\n        } else {\n            // if s0 is just a no-zero limited number\n            num = this.numerator().$(s0);\n            den = this.denominator().$(s0);\n            if (den)\n                // simple non zero denominator limit\n                return num / den;\n            // if den == 0\n            // use Hopital or other limit methods\n            //return (num.a * (s0 ** num.sp)) / (den.b * (s0 ** den.sp));\n        }\n    };\n    errors = () => {\n        const sGs = this.multiply(new Poly([1, 0], \"s\"));\n        const s2Gs = sGs.multiply(new Poly([1, 0], \"s\"));\n        console.log(sGs);\n        return {\n            Ks: round(this.lim(0)),\n            Kr: round(sGs.lim(0)),\n            Ka: round(s2Gs.lim(0)),\n        };\n    };\n    $ = (t) => this.laplaceInverse().$(t); // valueOf function in certain point; I used character $ in many places as,\n    // acronym for \"set\" in setters, so $ here means that set the t ( or x or whatever) with a certain point\n\n    rootLocus = (k_min, k_max, N = 100) => {\n        // return root locus values for plotting\n        let dt = (k_max - k_min) / N; //time step size\n        while (dt >= 1) {\n            N *= 10;\n            dt = (k_max - k_min) / N; //time step size\n        }\n\n        \n    }\n}\n","import Algebra from \"math/algebra\";\nimport Complex from \"math/algebra/complex\";\nimport Exp from \"./exp\";\nimport Fraction from \"./fraction\";\n\nexport class Sin extends Algebra {\n    constructor(A, w, teta = 0, symbol = \"t\", params = {}) {\n        // Ae^wt\n        super(A, { symbol, type: \"sin\", b: w, teta, ...params });\n    }\n    copy = (linkPrevious = false) =>\n        new Sin(this.a, this.b, this.teta, this.symbol, {\n            dot: this.dot,\n            plus: this.plus,\n            previous: linkPrevious ? this.previous : null,\n            input: this.input,\n        });\n\n    toExp = () => {\n        const sin = this.copy();\n        const exp1 = new Exp(sin.a / 2, new Complex(0, -sin.b));\n        const exp2 = new Exp(-sin.a / 2, new Complex(0, sin.b));\n        return new Complex(0, exp1.add(exp2));\n    };\n\n    valueAt = (t) => {\n        const A = Algebra.valueOf(this.a, t);\n        const w = Algebra.valueOf(this.b, t);\n        const teta = Algebra.valueOf(this.teta, t);\n        return A * Math.sin(w * t + teta)\n    }\n}\n\nexport class Cos extends Algebra {\n    constructor(A, w, teta = 0, symbol = \"t\", params = {}) {\n        // Ae^wt\n        super(A, { symbol, type: \"cos\", b: w, teta, ...params });\n    }\n    copy = (linkPrevious = false) =>\n        new Cos(this.a, this.b, this.teta, this.symbol, {\n            dot: this.dot,\n            plus: this.plus,\n            previous: linkPrevious ? this.previous : null,\n            input: this.input,\n        });\n\n    toExp = () => {\n        const cos = this.copy();\n        const exp1 = new Exp(cos.a / 2, new Complex(0, cos.b));\n        const exp2 = new Exp(cos.a / 2, new Complex(0, -cos.b));\n        return exp1.add(exp2);\n    };\n\n\n    valueAt = (t) => {\n        const A = Algebra.valueOf(this.a, t);\n        const w = Algebra.valueOf(this.b, t);\n        const teta = Algebra.valueOf(this.teta, t);\n        return A * Math.cos(w * t + teta)\n    }\n}\n\nexport class Tan extends Algebra {\n    constructor(A, w, teta = 0, symbol = \"t\", params = {}) {\n        // Ae^wt\n        super(A, { symbol, type: \"tan\", b: w, teta, ...params });\n    }\n    copy = (linkPrevious = false) =>\n        new Tan(this.a, this.b, this.teta, this.symbol, {\n            dot: this.dot,\n            plus: this.plus,\n            previous: linkPrevious ? this.previous : null,\n            input: this.input,\n        });\n\n    toExp = () => {\n        const tan = this.copy();\n        const exp1 = new Exp(1, new Complex(0, -tan.b));\n        const numeratorExp2 = new Exp(-1, new Complex(0, tan.b));\n        const denominatorExp2 = new Exp(1, new Complex(0, tan.b));\n        return new Fraction(exp1.add(numeratorExp2), exp1.add(denominatorExp2));\n    };\n\n    valueAt = (t) => {\n        const A = Algebra.valueOf(this.a, t);\n        const w = Algebra.valueOf(this.b, t);\n        const teta = Algebra.valueOf(this.teta, t);\n        return A * Math.tan(w * t + teta)\n    }\n}\n\nexport class Cot extends Algebra {\n    constructor(A, w, teta = 0, symbol = \"t\", params = {}) {\n        // Ae^wt\n        super(A, { symbol, type: \"cot\", b: w, teta, ...params });\n    }\n    copy = (linkPrevious = false) =>\n        new Cot(this.a, this.b, this.teta, this.symbol, {\n            dot: this.dot,\n            plus: this.plus,\n            previous: linkPrevious ? this.previous : null,\n            input: this.input,\n        });\n    toExp = () => {\n        const cot = this.copy();\n        const exp1 = new Exp(1, new Complex(0, -cot.b));\n        const numeratorExp2 = new Exp(-1, new Complex(0, cot.b));\n        const denominatorExp2 = new Exp(1, new Complex(0, cot.b));\n        return new Fraction(exp1.add(denominatorExp2), exp1.add(numeratorExp2));\n    };\n\n\n    valueAt = (t) => {\n        const A = Algebra.valueOf(this.a, t);\n        const w = Algebra.valueOf(this.b, t);\n        const teta = Algebra.valueOf(this.teta, t);\n        return A * Math.cot(w * t + teta)\n    }\n}\n"],"names":["Complex","preal","pimage","params","symbol","type","b","hasMultiTerms","plus","a","toString","parenthesis","rl","formula","Algebra","round","im","join","real","imaginary","copy","linkPrevious","dot","previous","input","conjugate","negation","magnitude$2","magnitude","isReal","hasSameTypeWith","x","realify","add","operand","Re","Im","substract","equals","isConjugateWith","multiply","push","devide","denominator","devideInverse","k","extract","strNumber","i","replace","length","isDigit","Number","slice","sign","img","Exp","toSin","exp","cos","Cos","sin","Sin","valueAt","t","Math","Fraction","num","den","Array","lim","numerator","Poly","setNumerator","setA","setDenominator","setB","Step","amplitude","amp","$","StandardInputSignal","TransferFunction","zeros","poles","overshoot","t_rise","logMp","log","zeta","PI","w_d","w_n","wn2","omegaZetaPoles","roots","setRoots","map","pi","zi","getDampingSystemCharasteristics","getOrder","order","setOrder","getPoles","setPoles","sortRoots","getZeros","setZeros","poleOrder","pole","filter","laplace","laplaceInverse","m","n","step","inTimeDomain","lstep","getB","nreal","a2","ka2b2","t_settle","timeConstant","s0","sp","sMinPower","min","Infinity","errors","sGs","s2Gs","console","Ks","Kr","Ka","rootLocus","k_min","k_max","N","dt","dampingCharasteristics","Specials","$1","$2","aplusb","ab","$WnZ","$design","abs","alpha","beta","rt","sort","ri","rj","A","w","teta","toExp","exp1","exp2"],"sourceRoot":""}